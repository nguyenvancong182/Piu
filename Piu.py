# -*- coding: utf-8 -*-
# üî∞ PIU

# ==========================
# PH·∫¶N 1: IMPORT TH∆Ø VI·ªÜN
# ==========================
import customtkinter as ctk
import os
import atexit
import re
import sys
import ctypes
import shutil
import psutil # Th∆∞ vi·ªán ƒë·ªÉ qu·∫£n l√Ω ti·∫øn tr√¨nh v√† CPU
import subprocess
import platform
import tempfile
import threading
import time
import textwrap
import json
import webbrowser
import requests
import uuid
from datetime import date, datetime, timedelta
import logging
from tkinter import filedialog, messagebox, TclError # Import TclError ƒë·ªÉ x·ª≠ l√Ω icon khay h·ªá th·ªëng
from unidecode import unidecode
from PIL import Image
from packaging import version # ƒê·ªÉ so s√°nh phi√™n b·∫£n
from pathlib import Path # ƒê·ªÉ x·ª≠ l√Ω ƒë∆∞·ªùng d·∫´n m·ªôt c√°ch m·∫°nh m·∫Ω
# Th√™m c√°c import c·∫ßn thi·∫øt cho t√≠nh nƒÉng Dubbing t·ª´ DubApp
from mutagen.mp3 import MP3
from mutagen.wave import WAVE
from mutagen.flac import FLAC
from mutagen.oggopus import OggOpus
from mutagen.aac import AAC
from gtts import gTTS
from gtts.tts import gTTSError
import base64
import pysubs2 #(c·∫ßn c√†i ƒë·∫∑t: pip install pysubs2)
from tkinter import colorchooser
import tkinter as tk
from tkinter import font as tkfont # Import c·ª• th·ªÉ ƒë·ªÉ d·ªÖ d√πng
from matplotlib import font_manager
from logging.handlers import RotatingFileHandler
import csv
import torch
import torchaudio
from contextlib import contextmanager
from selenium.common.exceptions import NoSuchElementException

# Import helper utilities
from utils.helpers import get_default_downloads_folder, safe_int, parse_timecode, ms_to_tc, open_file_with_default_app, resource_path, create_safe_filename, remove_vietnamese_diacritics, strip_series_chapter_prefix, get_dpi_scaling_factor, get_work_area, sanitize_youtube_text, play_sound_async, parse_color_string_to_tuple, format_timestamp, normalize_string_for_comparison, get_identifier_from_source, parse_ai_response, validate_volume_input, sanitize_script_for_ai
from utils.ffmpeg_utils import find_ffmpeg, find_ffprobe, create_ffmpeg_concat_file_list, ffmpeg_split_media, get_video_duration_s
from utils.file_utils import prepare_batch_queue
from utils.keep_awake import KeepAwakeManager
from utils.system_utils import run_system_command, shutdown_system, cancel_shutdown_system, is_cuda_available, cleanup_stale_chrome_processes, normalize_hwid_string, is_plausible_hwid, ensure_single_instance, release_mutex
from utils.srt_utils import parse_srt_for_slideshow_timing, format_srt_data_to_string, extract_dialogue_from_srt_string, write_srt, write_vtt
from exceptions.app_exceptions import SingleInstanceException
from config.settings import get_config_path, get_font_cache_path, get_google_voices_cache_path, load_config, save_config
from config.ui_constants import get_theme_colors
from ui.widgets.tooltip import Tooltip
from ui.widgets.menu_utils import textbox_right_click_menu, clear_all_links
from ui.widgets.splash_screen import SplashScreen
from ui.widgets.custom_font_dropdown import CustomFontDropdown
from ui.widgets.custom_voice_dropdown import CustomVoiceDropdown
from ui.popups.api_settings import APISettingsWindow
from ui.popups.branding_settings import BrandingSettingsWindow
from ui.popups.imagen_settings import ImagenSettingsWindow
from ui.popups.dalle_settings import DalleSettingsWindow
from ui.popups.metadata_manager import MetadataManagerWindow
from ui.popups.subtitle_style_settings import SubtitleStyleSettingsWindow
from ui.tabs.ai_editor_tab import AIEditorTab
from ui.tabs.download_tab import DownloadTab
from ui.tabs.subtitle_tab import SubtitleTab
from ui.tabs.dubbing_tab import DubbingTab
from ui.tabs.youtube_upload_tab import YouTubeUploadTab
from utils.logging_utils import setup_logging, log_failed_task
from ui.utils.ui_helpers import is_ui_alive, safe_after, update_path_label, norm_no_diacritics, is_readyish, locked_msg_for_view, ready_msg_for_view
from services.youtube_upload_service import upload_youtube_thumbnail, get_playlist_id_by_name, add_video_to_playlist
from services.youtube_upload_api_service import upload_video_to_youtube
from services.youtube_browser_upload_service import click_with_fallback, init_chrome_driver, YOUTUBE_LOCATORS
from services.google_api_service import get_google_api_service
from services.licensing_service import verify_status as licensing_verify_status, activate as licensing_activate, start_trial as licensing_start_trial
from services.ffmpeg_service import run_ffmpeg_command as ffmpeg_run_command
from services.download_service import stream_process_output as ytdlp_stream_output
from services.update_service import is_newer as is_newer_version

# --- Th√™m c√°c import cho Google Sheets API ---
import os.path # D√πng ƒë·ªÉ l√†m vi·ªác v·ªõi ƒë∆∞·ªùng d·∫´n file token/credentials
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google.api_core import exceptions as google_api_exceptions
from googleapiclient.http import MediaFileUpload

# --- Import t√πy ch·ªçn (Ki·ªÉm tra l√∫c ch·∫°y) ---
try:
    import pystray
    PYSTRAY_AVAILABLE = True
except ImportError:
    PYSTRAY_AVAILABLE = False

try:
    import appdirs
    APPDIRS_AVAILABLE = True
except ImportError:
    APPDIRS_AVAILABLE = False

try:
    from playsound import playsound # Th·ª≠ import
    PLAYSOUND_AVAILABLE = True
except ImportError:
    # Th√¥ng b√°o n·∫øu thi·∫øu th∆∞ vi·ªán, nh∆∞ng kh√¥ng d·ª´ng ch∆∞∆°ng tr√¨nh
    logging.warning("Th∆∞ vi·ªán 'playsound' ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t ho·∫∑c c√≥ l·ªói. Ch·ª©c nƒÉng ph√°t nh·∫°c khi t·∫£i xong s·∫Ω kh√¥ng ho·∫°t ƒë·ªông. C√†i ƒë·∫∑t: pip install playsound==1.2.2")
    PLAYSOUND_AVAILABLE = False # ƒê·∫∑t c·ªù l√† False
    playsound = None # ƒê·∫∑t bi·∫øn playsound th√†nh None ƒë·ªÉ tr√°nh l·ªói n·∫øu g·ªçi tr·ª±c ti·∫øp

try:
    from google.cloud import translate_v2 as google_translate
    from google.oauth2 import service_account # ƒê·ªÉ load credentials t·ª´ file JSON
    HAS_GOOGLE_CLOUD_TRANSLATE = True
    logging.info("Th∆∞ vi·ªán Google Cloud Translate ƒë√£ ƒë∆∞·ª£c import th√†nh c√¥ng.")
except ImportError:
    HAS_GOOGLE_CLOUD_TRANSLATE = False
    # Gi·ªØ l·∫°i logging warning ƒë·ªÉ th√¥ng b√°o n·∫øu thi·∫øu
    logging.warning("Th∆∞ vi·ªán Google Cloud Translate ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t ho·∫∑c c√≥ l·ªói. Ch·ª©c nƒÉng d·ªãch Google Cloud API s·∫Ω kh√¥ng ho·∫°t ƒë·ªông. C√†i ƒë·∫∑t: pip install google-cloud-translate google-auth")
    google_translate = None
    service_account = None

# --- Imports cho OpenAI ---
try:
    from openai import OpenAI, RateLimitError, AuthenticationError, APIConnectionError, APIStatusError, APITimeoutError # Th√™m c√°c Exception
    HAS_OPENAI = True
    logging.info("Th∆∞ vi·ªán OpenAI v√† c√°c Exception ƒë√£ ƒë∆∞·ª£c import th√†nh c√¥ng.")
except ImportError:
    HAS_OPENAI = False
    logging.warning("Th∆∞ vi·ªán OpenAI ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t ho·∫∑c c√≥ l·ªói. Ch·ª©c nƒÉng d·ªãch ChatGPT API v√† ki·ªÉm tra key s·∫Ω kh√¥ng ho·∫°t ƒë·ªông. C√†i ƒë·∫∑t: pip install openai")
    # ƒê·∫∑t c√°c bi·∫øn n√†y th√†nh None ƒë·ªÉ tr√°nh l·ªói n·∫øu kh√¥ng import ƒë∆∞·ª£c
    OpenAI = None
    RateLimitError = None
    AuthenticationError = None
    APIConnectionError = None
    APIStatusError = None
    APITimeoutError = None
    
# import whisper
try:
    import whisper
    HAS_WHISPER = True
except ImportError:
    HAS_WHISPER = False
    logging.error("Th∆∞ vi·ªán 'whisper' ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t. Ch·ª©c nƒÉng t·∫°o sub s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.")

# import UNDERTHESEA

try:
    from underthesea import sent_tokenize # Ch·ªâ import h√†m c·∫ßn thi·∫øt
    HAS_UNDERTHESEA = True
    logging.info("Th∆∞ vi·ªán Underthesea (sent_tokenize) ƒë√£ ƒë∆∞·ª£c import th√†nh c√¥ng.")
except ImportError:
    HAS_UNDERTHESEA = False
    logging.warning("Th∆∞ vi·ªán 'underthesea' ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t ho·∫∑c c√≥ l·ªói. Ch·ª©c nƒÉng chia c√¢u ti·∫øng Vi·ªát n√¢ng cao s·∫Ω kh√¥ng ho·∫°t ƒë·ªông. C√†i ƒë·∫∑t: pip install underthesea")
    sent_tokenize = None # ƒê·ªÉ tr√°nh l·ªói n·∫øu g·ªçi tr·ª±c ti·∫øp sau n√†y m√† kh√¥ng ki·ªÉm tra HAS_UNDERTHESEA

try:
    import pyttsx3 # Th∆∞ vi·ªán cho Gi·ªçng ƒë·ªçc H·ªá th·ªëng
    HAS_PYTTSX3 = True
    logging.info("Th∆∞ vi·ªán pyttsx3 ƒë√£ ƒë∆∞·ª£c import th√†nh c√¥ng.")
except ImportError:
    HAS_PYTTSX3 = False
    logging.warning("Th∆∞ vi·ªán 'pyttsx3' ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t ho·∫∑c c√≥ l·ªói. Ch·ª©c nƒÉng 'Gi·ªçng ƒë·ªçc H·ªá th·ªëng' s·∫Ω kh√¥ng ho·∫°t ƒë·ªông. C√†i ƒë·∫∑t: pip install pyttsx3")
    pyttsx3 = None # ƒê·ªÉ tr√°nh l·ªói n·∫øu g·ªçi tr·ª±c ti·∫øp sau n√†y m√† kh√¥ng ki·ªÉm tra HAS_PYTTSX3

# Th√™m c√°c import n√†y cho single-instance check
if sys.platform == "win32": # Ch·ªâ th·ª±c hi·ªán tr√™n Windows
    try:
        import win32event
        import win32api
        import win32gui      # C·∫ßn cho vi·ªác t√¨m v√† k√≠ch ho·∫°t c·ª≠a s·ªï
        import win32con      # Ch·ª©a c√°c h·∫±ng s·ªë cho h√†m Windows
        from winerror import ERROR_ALREADY_EXISTS # M√£ l·ªói c·ª• th·ªÉ
        PYWIN32_AVAILABLE = True
    except ImportError:
        PYWIN32_AVAILABLE = False
        print("WARNING: Th∆∞ vi·ªán pywin32 ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t ho·∫∑c import l·ªói.")
        print("Ch·ª©c nƒÉng single-instance v√† k√≠ch ho·∫°t c·ª≠a s·ªï s·∫Ω kh√¥ng ho·∫°t ƒë·ªông ƒë·∫ßy ƒë·ªß.")
        print("H√£y th·ª≠ c√†i ƒë·∫∑t b·∫±ng l·ªánh: pip install pywin32")
else:
    PYWIN32_AVAILABLE = False # ƒê·∫∑t l√† False n·∫øu kh√¥ng ph·∫£i Windows


# --- Th√™m c√°c import cho Selenium ---
try:
    from selenium import webdriver
    from selenium.webdriver.chrome.service import Service
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.common.action_chains import ActionChains
    from webdriver_manager.chrome import ChromeDriverManager

    # Exceptions: g·ªôp ƒë·ªß c√°c lo·∫°i b·∫°n ƒëang d√πng trong code
    from selenium.common.exceptions import (
        TimeoutException,
        ElementClickInterceptedException,
        StaleElementReferenceException,
        NoSuchWindowException,      # <<< B·ªî SUNG (ƒë√£ g√¢y NameError)
        WebDriverException,         # <<< Khuy·∫øn ngh·ªã th√™m
        NoSuchElementException,     # <<< B·∫°n ƒë√£ d√πng ·ªü ch·ªó alt popup
    )

    HAS_SELENIUM = True
    logging.info("Th∆∞ vi·ªán Selenium v√† c√°c Exception ƒë√£ ƒë∆∞·ª£c import th√†nh c√¥ng.")
except ImportError:
    HAS_SELENIUM = False
    logging.warning("Th∆∞ vi·ªán Selenium ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t. Ch·ª©c nƒÉng upload s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.")


# ==========================
# KEEP-AWAKE (CH·ªêNG SLEEP)
# ==========================
# MOVED to utils/keep_awake.py - imported above

# Create global instance and register cleanup
KEEP_AWAKE = KeepAwakeManager()
atexit.register(KEEP_AWAKE.force_off)

@contextmanager
def keep_awake(reason: str = "Processing"):
    """Context manager: gi·ªØ m√°y kh√¥ng Sleep trong kh·ªëi l·ªánh."""
    tk = KEEP_AWAKE.acquire(reason)
    try:
        yield
    finally:
        KEEP_AWAKE.release(tk)

# Keep context manager in Piu.py since it uses global KEEP_AWAKE instance

# ==========================
# PH·∫¶N 2: H·∫∞NG S·ªê & C·∫§U H√åNH C∆† B·∫¢N
# ==========================

# Import constants from config module
from config.constants import (
    APP_NAME, APP_AUTHOR, CURRENT_VERSION,
    CONFIG_FILENAME, FONT_CACHE_FILENAME, LOG_FILENAME,
    CREDENTIALS_FILENAME, TOKEN_FILENAME,
    APPS_SCRIPT_URL,
    UPDATE_CHECK_INTERVAL_SECONDS, LICENSE_REVALIDATION_INTERVAL_SECONDS,
    DEFAULT_REFERENCE_VIDEO_HEIGHT_FOR_FONT_SCALING,
    YOUTUBE_API_SERVICE_NAME, YOUTUBE_API_VERSION,
    
    # C√°c h·∫±ng s·ªë v·ª´a ƒë∆∞·ª£c di chuy·ªÉn
    APP_MUTEX_NAME,
    LANGUAGE_MAP_VI,
    SCOPES,
    WHISPER_VRAM_REQ_MB,
    YOUTUBE_CATEGORIES,
    YOUTUBE_CATEGORY_NAVIGATION_ORDER,
    API_PRICING_USD
)

# SingleInstanceException - MOVED to exceptions/app_exceptions.py - imported above
# SENSITIVE_WORD_MAPPING - MOVED to config/constants.py
# APP_MUTEX_NAME - MOVED to config/constants.py
# LANGUAGE_MAP_VI - MOVED to config/constants.py

# --- X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n yt-dlp --- START BLOCK TO REPLACE ---
_YTDLP_DEFAULT_COMMAND = "yt-dlp.exe" if sys.platform == "win32" else "yt-dlp"
# ƒê·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh l√† t√™n l·ªánh (s·∫Ω t√¨m trong PATH)
YTDLP_PATH = _YTDLP_DEFAULT_COMMAND

# KI·ªÇM TRA QUAN TR·ªåNG: N·∫øu ƒëang ch·∫°y t·ª´ b·∫£n ƒë√≥ng g√≥i (Nuitka/PyInstaller)
if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS') is False: # Th√™m ki·ªÉm tra _MEIPASS ƒë·ªÉ ch·∫Øc ch·∫Øn kh√¥ng ph·∫£i PyInstaller one-file ƒëang gi·∫£i n√©n
    try:
        # L·∫•y ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c ch·ª©a file .exe
        application_path = os.path.dirname(sys.executable)

        # T·∫°o ƒë∆∞·ªùng d·∫´n ƒë·∫øn file yt-dlp n·∫±m c√πng c·∫•p file .exe
        bundled_ytdlp_path = os.path.join(application_path, _YTDLP_DEFAULT_COMMAND)

        # Ki·ªÉm tra xem file ƒëi k√®m c√≥ t·ªìn t·∫°i kh√¥ng
        if os.path.exists(bundled_ytdlp_path):
            YTDLP_PATH = bundled_ytdlp_path # N·∫øu c√≥, s·ª≠ d·ª•ng ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß n√†y
            logging.info(f"T√¨m th·∫•y v√† s·∫Ω s·ª≠ d·ª•ng yt-dlp ƒëi k√®m: {YTDLP_PATH}")
        else:
            logging.warning(f"ƒêang ch·∫°y t·ª´ b·∫£n ƒë√≥ng g√≥i nh∆∞ng kh√¥ng t√¨m th·∫•y '{_YTDLP_DEFAULT_COMMAND}' t·∫°i '{bundled_ytdlp_path}'. S·∫Ω th·ª≠ t√¨m trong PATH.")
            # (N·∫øu kh√¥ng th·∫•y ƒëi k√®m) Th·ª≠ t√¨m trong PATH nh∆∞ ph∆∞∆°ng √°n cu·ªëi
            system_ytdlp = shutil.which(_YTDLP_DEFAULT_COMMAND)
            if system_ytdlp:
                YTDLP_PATH = system_ytdlp
                logging.info(f"T√¨m th·∫•y yt-dlp trong PATH h·ªá th·ªëng: {YTDLP_PATH}")
            else:
                # R·∫•t t·ªá, kh√¥ng t√¨m th·∫•y ·ªü ƒë√¢u c·∫£
                logging.error(f"L·ªñI NGHI√äM TR·ªåNG: Kh√¥ng t√¨m th·∫•y '{_YTDLP_DEFAULT_COMMAND}' ƒëi k√®m ho·∫∑c trong PATH h·ªá th·ªëng!")
                # Gi·ªØ nguy√™n YTDLP_PATH l√† t√™n l·ªánh ƒë·ªÉ g√¢y l·ªói r√µ r√†ng khi th·ª±c thi
    except Exception as e:
        logging.error(f"L·ªói b·∫•t ng·ªù khi x√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n yt-dlp ƒëi k√®m: {e}")

# Tr∆∞·ªùng h·ª£p kh√¥ng ch·∫°y t·ª´ b·∫£n ƒë√≥ng g√≥i (ch·∫°y tr·ª±c ti·∫øp b·∫±ng python)
else:
    system_ytdlp = shutil.which(_YTDLP_DEFAULT_COMMAND)
    if system_ytdlp:
        YTDLP_PATH = system_ytdlp # G√°n ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß t·ª´ PATH
        logging.info(f"Ch·∫°y t·ª´ source, t√¨m th·∫•y yt-dlp trong PATH: {YTDLP_PATH}")
    else:
        logging.warning(f"Ch·∫°y t·ª´ source, kh√¥ng t√¨m th·∫•y '{_YTDLP_DEFAULT_COMMAND}' trong PATH. T√≠nh nƒÉng t·∫£i c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông.")

# --- Thi·∫øt l·∫≠p Logging (IDEMPOTENT, KH√îNG NH√ÇN ƒê√îI) ---
import logging, sys, os
from logging.handlers import RotatingFileHandler

# Logging setup ƒë√£ ƒë∆∞·ª£c t√°ch ra utils/logging_utils.py
# G·ªçi ƒë√∫ng 1 l·∫ßn khi app kh·ªüi ƒë·ªông
setup_logging()

# SCOPES - MOVED to config/constants.py
# WHISPER_VRAM_REQ_MB - MOVED to config/constants.py  
# YOUTUBE_CATEGORIES - MOVED to config/constants.py
# YOUTUBE_CATEGORY_NAVIGATION_ORDER - MOVED to config/constants.py
# API_PRICING_USD - MOVED to config/constants.py


# ============================================================
# H√ÄM get_google_api_service ƒê√É ƒê∆Ø·ª¢C DI CHUY·ªÇN ƒê·∫æN services/google_api_service.py
# ============================================================

# =======================================================================================================================================================================
# L·ªöP M√ÄN H√åNH CH·ªú (SPLASH SCREEN)
# =======================================================================================================================================================================

# SplashScreen class has been moved to ui/widgets/splash_screen.py

# =======================================================================================================================================================================

# ==========================
# PH·∫¶N 4: L·ªöP ·ª®NG D·ª§NG CH√çNH (SubtitleApp)
# ==========================

class SubtitleApp(ctk.CTk):
    """
    L·ªõp ch√≠nh c·ªßa ·ª©ng d·ª•ng Piu, qu·∫£n l√Ω giao di·ªán ng∆∞·ªùi d√πng,
    c√°c lu·ªìng x·ª≠ l√Ω v√† tr·∫°ng th√°i c·ªßa ·ª©ng d·ª•ng.
    """

    # --------------------
    # 4.1 Kh·ªüi t·∫°o & Bi·∫øn C·ªët l√µi
    # --------------------

    # H√†m kh·ªüi t·∫°o: Thi·∫øt l·∫≠p c√°c thu·ªôc t√≠nh v√† tr·∫°ng th√°i ban ƒë·∫ßu c·ªßa ·ª©ng d·ª•ng
    def __init__(self):
        # --- SINGLE INSTANCE CHECK (WINDOWS ONLY) ---
        self.mutex = None
        self.mutex_error_occurred = False # C·ªù theo d√µi l·ªói li√™n quan ƒë·∫øn mutex

        if sys.platform == "win32":
            try:
                self.mutex = ensure_single_instance(APP_MUTEX_NAME)
                logging.info(f"Mutex '{APP_MUTEX_NAME}' ƒë∆∞·ª£c t·∫°o/m·ªü th√†nh c√¥ng. ƒê√¢y l√† instance ch√≠nh.")
            except SingleInstanceException:
                activated_existing = self._activate_existing_window() if hasattr(self, '_activate_existing_window') else False
                if activated_existing:
                    logging.info("ƒê√£ k√≠ch ho·∫°t c·ª≠a s·ªï c·ªßa instance ƒëang ch·∫°y. Instance m·ªõi s·∫Ω tho√°t.")
                else:
                    logging.warning("Kh√¥ng th·ªÉ t·ª± ƒë·ªông k√≠ch ho·∫°t c·ª≠a s·ªï c·ªßa instance ƒëang ch·∫°y.")
                raise
            except Exception as e_mutex_create:
                logging.error(f"L·ªói nghi√™m tr·ªçng khi t·∫°o/ki·ªÉm tra Mutex: {e_mutex_create}", exc_info=True)
                self.mutex_error_occurred = True
        # --- END SINGLE INSTANCE CHECK ---
        
        super().__init__()
        self.title(APP_NAME)

        # 1. L·∫•y m·ªôt logger c√≥ t√™n l√† "Piu" (t·ª´ bi·∫øn APP_NAME c·ªßa b·∫°n)
        self.logger = logging.getLogger(APP_NAME)
        # 2. Ra l·ªánh cho logger n√†y kh√¥ng b√°o c√°o l√™n cho root logger n·ªØa
        self.logger.propagate = False

        # === B·∫ÆT ƒê·∫¶U CODE M·ªöI CHO VI·ªÜC PH·ª§C H·ªíI ===
        
        # M·∫∑c ƒë·ªãnh, kh√¥ng ph·ª•c h·ªìi
        self._initial_geometry = None
        self._initial_view = None

        try:
            # X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n file restore_state.json
            config_path = get_config_path()
            restore_file_path = os.path.join(os.path.dirname(config_path), "restore_state.json")

            if os.path.exists(restore_file_path):
                logging.info(f"[AppRestore] T√¨m th·∫•y file ph·ª•c h·ªìi: {restore_file_path}. ƒêang ƒë·ªçc...")
                with open(restore_file_path, "r", encoding="utf-8") as f:
                    restore_data = json.load(f)
                
                # L·∫•y c√°c gi√° tr·ªã ƒë√£ l∆∞u
                self._initial_geometry = restore_data.get("window_geometry")
                self._initial_view = restore_data.get("current_view")

                logging.info(f"[AppRestore] D·ªØ li·ªáu ph·ª•c h·ªìi: Geometry='{self._initial_geometry}', View='{self._initial_view}'")
                
                # Quan tr·ªçng: X√≥a file sau khi ƒë√£ ƒë·ªçc ƒë·ªÉ kh√¥ng b·ªã ph·ª•c h·ªìi ·ªü l·∫ßn m·ªü sau
                os.remove(restore_file_path)
                logging.info(f"[AppRestore] ƒê√£ x√≥a file ph·ª•c h·ªìi.")

        except Exception as e_restore:
            logging.error(f"[AppRestore] L·ªói trong qu√° tr√¨nh ƒë·ªçc v√† x·ª≠ l√Ω file ph·ª•c h·ªìi: {e_restore}")
            # Reset c√°c bi·∫øn v·ªÅ None n·∫øu c√≥ l·ªói
            self._initial_geometry = None
            self._initial_view = None

        # 1. T·∫Øt c∆° ch·∫ø scaling t·ª± ƒë·ªông c·ªßa CustomTkinter
        ctk.deactivate_automatic_dpi_awareness()

        # 2. T·ª± l·∫•y t·ªâ l·ªá scaling v√† ch·ªß ƒë·ªông ƒë·∫∑t l·∫°i cho to√†n b·ªô ·ª©ng d·ª•ng
        #    H√†m get_dpi_scaling_factor c·ªßa b·∫°n r·∫•t t·ªët, h√£y d√πng n√≥!
        scaling_factor = get_dpi_scaling_factor(self) 
        ctk.set_widget_scaling(scaling_factor)
        ctk.set_window_scaling(scaling_factor)
        
        self.withdraw()  # ·∫®n c·ª≠a s·ªï ch√≠nh ƒëi ngay l·∫≠p t·ª©c
        self.splash = SplashScreen(self)  # T·∫°o v√† hi·ªÉn th·ªã m√†n h√¨nh ch·ªù
        self.update_idletasks()  # ƒê·∫£m b·∫£o c√°c thay ƒë·ªïi giao di·ªán ƒë∆∞·ª£c th·ª±c hi·ªán

        # H√†ng ch·ªù c√°c t√°c v·ª• kh·ªüi ƒë·ªông tu·∫ßn t·ª±. ƒê√¢y ch√≠nh l√† "k·ªãch b·∫£n" c·ªßa ch√∫ng ta.
        self.startup_task_queue = [
            {
                "name": "dependencies",
                "message": "‚ö°Ô∏è ƒêang ki·ªÉm tra m√¥i tr∆∞·ªùng v√† c√¥ng c·ª•...",
                "function": self.check_dependencies,
                "min_display_time_ms": 1200
            },
            {
                "name": "activation",
                "message": "üîë ƒêang x√°c minh b·∫£n quy·ªÅn c·ªßa b·∫°n...",
                "function": self.check_activation_status,
                "min_display_time_ms": 1500
            },
            {
                "name": "system_fonts",
                "message": "üî§ ƒêang t·∫£i danh s√°ch font h·ªá th·ªëng...",
                "function": self._load_system_fonts_in_background,
                "min_display_time_ms": 1000
            },
            {
                "name": "cuda_check",
                "message": "üöÄ ƒêang ki·ªÉm tra card ƒë·ªì h·ªça (GPU)...",
                "function": self.check_cuda_status_thread,
                "min_display_time_ms": 1200
            }
            #{
                #"name": "ai_model",
                #"message": "üß† ƒêang chu·∫©n b·ªã m√¥ h√¨nh Tr√≠ tu·ªá nh√¢n t·∫°o...",
                #"function": self.load_whisper_model_if_needed,
                #"min_display_time_ms": 2000
            #}
        ]
   
        self.is_app_initializing = True
        logging.info("ƒêang kh·ªüi t·∫°o SubtitleApp...")

        self.iconbitmap(resource_path("logo_Piu.ico"))
        self.title("Piu - ƒêang ki·ªÉm tra b·∫£n quy·ªÅn...")

        ctk.set_default_color_theme("dark-blue")
        self.initial_ui_setup_complete = False

        # --- Tr·∫°ng th√°i C·ªët l√µi c·ªßa ·ª®ng d·ª•ng ---
        self.api_stats_var = ctk.StringVar(value="üìä API Th√°ng N√†y: ƒêang t·∫£i...")
        self.final_activation_state = None
        self.is_subbing = False
        self.is_downloading = False
        self.is_gpt_processing_script = False # C·ªù m·ªõi cho vi·ªác GPT x·ª≠ l√Ω k·ªãch b·∫£n
        self.is_gemini_processing = False # C·ªù m·ªõi cho Gemini
        self.is_imagen_processing = False # C·ªù m·ªõi V·∫Ω ·∫£nh Imagen
        self.stop_event = threading.Event()
        self.dub_stop_event = threading.Event()
        self.is_creating_slideshow = False
        self.chain_download_sub_dub_active = False 
        self.files_for_chained_dubbing = []      # (ƒë·ªÉ l∆∞u k·∫øt qu·∫£ sub)

        self._after_id_save_config_on_shutdown = None
        self._after_id_quit_on_shutdown = None

        self.youtube_final_guard_seconds = 3600  # 1h

        # --- C√ÅC BI·∫æN M·ªöI CHO H√ÄNG CH·ªú GH√âP SUB TH·ª¶ C√îNG ---
        self.manual_sub_queue = [] # H√†ng ch·ªù ch√≠nh cho c√°c t√°c v·ª• gh√©p th·ªß c√¥ng
        self.is_manual_sub_processing = False # C·ªù b√°o hi·ªáu ƒëang x·ª≠ l√Ω h√†ng ch·ªù th·ªß c√¥ng
        self.manual_sub_original_media_source_path = None
        self.is_chain_handoff = False # c·ªù "Chuy·ªÉn giao" (Handoff Flag)
        # ----------------------------------------------------        

        # BI·∫æN CHO QUY TR√åNH AI T·ª∞ ƒê·ªòNG H√ÄNG LO·∫†T
        self.is_ai_batch_processing = False  # C·ªù b√°o hi·ªáu m·ªôt l√¥ AI ƒëang ch·∫°y
        self.ai_batch_queue = []             # H√†ng ch·ªù ch·ª©a ƒë∆∞·ªùng d·∫´n c√°c file k·ªãch b·∫£n
        self.ai_batch_current_prompt = ""    # L∆∞u prompt chung cho c·∫£ l√¥
        self.ai_batch_current_file = None    # L∆∞u ƒë∆∞·ªùng d·∫´n file k·ªãch b·∫£n m√† l√¥ AI ƒëang x·ª≠ l√Ω
        self.ai_batch_trigger_dubbing = False

        self.pending_auto_dub_after_current_sub_batch = False
        self.is_dalle_processing = False
        self._is_restoring_task_config = False
        self.start_time = None
        self._dub_trigger_initiated_for_current_batch = False 
        self.processing_thread = None
        self.download_thread = None
        self.current_process = None # L∆∞u ti·∫øn tr√¨nh con
        self.dub_current_ffmpeg_process = None
        self.download_urls_list = [] # L∆∞u danh s√°ch URL ch·ªù
        self.current_download_url = None # L∆∞u URL ƒëang t·∫£i
        self.is_performing_single_task = False # C·ªù chung reset Tab Swicher
        self.is_manual_update_checking = False # C·ªù m·ªõi cho ki·ªÉm tra c·∫≠p nh·∫≠t th·ªß c√¥ng
        self.current_single_task_status = "" # Bi·∫øn m·ªõi ƒë·ªÉ l∆∞u status cho h√†ng ch·ªù

        # --- C·∫•u h√¨nh ---
        self.cfg = load_config()

        # Ch·ªß ƒë·ªông l·∫•y v√† l∆∞u HWID ngay l·∫≠p t·ª©c ƒë·ªÉ tr√°nh race condition.
        try:
            if not self.cfg.get('hardware_id'):
                logging.info("L·∫ßn ƒë·∫ßu kh·ªüi ƒë·ªông ho·∫∑c thi·∫øu HWID, ƒëang t·∫°o v√† l∆∞u...")
                current_hwid = self.get_hardware_id() # H√†m n√†y s·∫Ω t·ª± c·∫≠p nh·∫≠t self.cfg['hardware_id']
                
                # CH·ªà L∆ØU FILE CONFIG V·ªöI DUY NH·∫§T HWID ƒê√É ƒê∆Ø·ª¢C TH√äM V√ÄO
                if current_hwid != "UNKNOWN_HWID":
                    save_config(self.cfg) # <--- S·ª¨A TH√ÄNH L·ªÜNH G·ªåI N√ÄY
                    logging.info(f"ƒê√£ l∆∞u th√†nh c√¥ng HWID: {current_hwid} v√†o config.")
                else:
                    logging.error("V·∫´n kh√¥ng th·ªÉ l·∫•y HWID ngay c·∫£ khi kh·ªüi ƒë·ªông. C√≥ th·ªÉ c√≥ v·∫•n ƒë·ªÅ v·ªõi h·ªá th·ªëng.")
        except Exception as e_init_hwid:
            logging.error(f"L·ªói kh√¥ng mong mu·ªën khi kh·ªüi t·∫°o HWID: {e_init_hwid}", exc_info=True)

        self.master_metadata_cache = {} 
        self.after(1000, self._load_master_metadata_cache) 
        
        ctk.set_appearance_mode(self.cfg.get("appearance_mode", "dark"))

        # Bi·∫øn ƒëi·ªÅu khi·ªÉn v√† theo d√µi cho n√∫t gi·∫£m ∆∞u ti√™n CPU
        self.limit_cpu_var = ctk.BooleanVar(value=self.cfg.get("limit_cpu_usage", True))
        # Khi gi√° tr·ªã c·ªßa bi·∫øn n√†y thay ƒë·ªïi, c√°c h√†m callback s·∫Ω ƒë∆∞·ª£c g·ªçi t·ª± ƒë·ªông:
        # 1. G·ªçi h√†m logic ƒë·ªÉ thay ƒë·ªïi ƒë·ªô ∆∞u ti√™n th·ª±c t·∫ø.
        self.limit_cpu_var.trace_add("write", lambda *args: self._set_cpu_priority(self.limit_cpu_var.get()))
        # 2. G·ªçi h√†m "nh·∫°c tr∆∞·ªüng" ƒë·ªÉ c·∫≠p nh·∫≠t l·∫°i giao di·ªán c·ªßa t·∫•t c·∫£ c√°c n√∫t icon.
        self.limit_cpu_var.trace_add("write", lambda *args: self._update_footer_icon_buttons_visuals())

        self.cuda_status = "UNKNOWN" # Th√™m d√≤ng n√†y: Tr·∫°ng th√°i CUDA ban ƒë·∫ßu
        self.cuda_status_label = None # Th√™m d√≤ng n√†y: Placeholder cho label hi·ªÉn th·ªã
        self.gpu_vram_mb = 0
        self.loaded_model_device = None # Th√™m d√≤ng n√†y: L∆∞u device c·ªßa model ƒë√£ load (cuda/cpu)

        # === BI·∫æN CHO UNDO V√Ä REWRITE GEMINI EDIT ===
        self.gemini_undo_buffer = {}
        self.last_gemini_parameters_used = {}
        self.last_imagen_parameters_used = {}

        # === BI·∫æN CHO UNDO V√Ä REWRITE GPT EDIT ===
        self.gpt_undo_buffer = {} 
        # C·∫•u tr√∫c d·ª± ki·∫øn: 
        # self.gpt_undo_buffer = {
        #    "subtitle": {"original_text": "...", "target_widget": self.subtitle_textbox},
        #    "dubbing":  {"original_text": "...", "target_widget": self.dub_script_textbox}
        # }

        self.last_gpt_parameters_used = {}
        # C·∫•u tr√∫c d·ª± ki·∫øn:
        # self.last_gpt_parameters_used = {
        #    "subtitle": {"prompt": "...", "model": "...", "original_input_script": "..."},
        #    "dubbing":  {"prompt": "...", "model": "...", "original_input_script": "..."}
        # }
        # original_input_script l√† n·ªôi dung TR∆Ø·ªöC KHI prompt n√†y ƒë∆∞·ª£c √°p d·ª•ng l·∫ßn ƒë·∫ßu.
        # ==========================================
        

        # --- Th√†nh ph·∫ßn Giao di·ªán cho Chuy·ªÉn ƒë·ªïi Ch·∫ø ƒë·ªô xem ---
        self.view_switcher = None
        self.main_content_frame = None
        self.subtitle_view_frame = None
        self.download_view_frame = None
        self.dubbing_view_frame = None
        self.current_view = None
        self.shutdown_scheduled = False # C·ªù theo d√µi h·∫πn gi·ªù t·∫Øt m√°y
        self.shutdown_requested_by_task = False # L∆∞u y√™u c·∫ßu t·∫Øt m√°y t·ª´ t√°c v·ª•
        self._is_automated_quit = False # C·ªù b√°o hi·ªáu tho√°t t·ª± ƒë·ªông ƒë·ªÉ kh√¥ng hi·ªán popup h·ªßy t·∫Øt m√°y
        self._is_shutting_down = False
        self.dub_audio_path_for_queue_temp = ""  # ƒê∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß ƒë·∫øn file audio ƒëang ƒë∆∞·ª£c ch·ªçn (cho 1 t√°c v·ª•)
        self.dub_current_audio_for_queue_display = ctk.StringVar(value="") # ƒê·ªÉ hi·ªÉn th·ªã t√™n file audio ƒëang ch·ªçn        

        # KI·ªÇM TRA C·∫¨P NH·∫¨T
        if 'last_update_check_timestamp' not in self.cfg:
            self.cfg['last_update_check_timestamp'] = 0 # Kh·ªüi t·∫°o l√† 0 ƒë·ªÉ ki·ªÉm tra ngay l·∫ßn ƒë·∫ßu
            logging.info("Kh·ªüi t·∫°o 'last_update_check_timestamp' trong config l√† 0.")

        # KI·ªÇM TRA B·∫¢N QUY·ªÄN
        if 'last_license_revalidation_timestamp' not in self.cfg:
            self.cfg['last_license_revalidation_timestamp'] = 0 # Kh·ªüi t·∫°o l√† 0 ƒë·ªÉ ki·ªÉm tra ngay l·∫ßn ƒë·∫ßu (n·∫øu offline pass)
            logging.info("Kh·ªüi t·∫°o 'last_license_revalidation_timestamp' trong config l√† 0.")
        
        logging.info(f"DEBUG INIT: ƒê√£ t·∫£i download_rename_enabled = {self.cfg.get('download_rename_enabled', 'Kh√¥ng t√¨m th·∫•y trong c·∫•u h√¨nh')}")
        logging.info(f"C·∫•u h√¨nh ƒë√£ t·∫£i: {self.cfg}")

        # Ki·ªÉm tra xem kh√≥a "disable_auto_sheet_check" c√≥ trong self.cfg kh√¥ng
        if "disable_auto_sheet_check" not in self.cfg:
            default_for_disable_sheet_check = True
            self.cfg["disable_auto_sheet_check"] = True
            logging.info("L·∫ßn ƒë·∫ßu kh·ªüi ƒë·ªông (ho·∫∑c thi·∫øu key 'disable_auto_sheet_check' trong config): ƒê·∫∑t m·∫∑c ƒë·ªãnh 'T·∫Øt ki·ªÉm tra Sheet' l√† True.")
        else:
            # N·∫øu ƒë√£ c√≥ trong config, s·ª≠ d·ª•ng gi√° tr·ªã ƒë√£ l∆∞u
            default_for_disable_sheet_check = self.cfg.get("disable_auto_sheet_check")
            logging.info(f"ƒê√£ t√¨m th·∫•y key 'disable_auto_sheet_check' trong config: {default_for_disable_sheet_check}")

        self.disable_auto_sheet_check_var = ctk.BooleanVar(value=default_for_disable_sheet_check)     

        # --- Th∆∞ m·ª•c T·∫°m ---
        try:
            self._temp_dir_context = tempfile.TemporaryDirectory(prefix="PiuSubtitle_")
            self.temp_folder = self._temp_dir_context.name
            logging.info(f"Th∆∞ m·ª•c t·∫°m ƒë√£ t·∫°o: {self.temp_folder}")
        except Exception as e:
            logging.error(f"Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c t·∫°m: {e}")
            messagebox.showerror("L·ªói Kh·ªüi t·∫°o", f"Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c t·∫°m.\nL·ªói: {e}\n\n·ª®ng d·ª•ng c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông ƒë√∫ng.")
            self.temp_folder = "."

        # === C·∫§U H√åNH CHO GPT S·ª¨A K·ªäCH B·∫¢N ===
        # Danh s√°ch c√°c model GPT h·ªó tr·ª£ cho vi·ªác ch·ªânh s·ª≠a k·ªãch b·∫£n
        self.AVAILABLE_GPT_MODELS_FOR_SCRIPT_EDITING = ["gpt-3.5-turbo", "gpt-4", "gpt-4-turbo", "gpt-4o"]

        # C·∫≠p nh·∫≠t danh s√°ch c√°c m√¥ h√¨nh Gemini ·ªïn ƒë·ªãnh m·ªõi nh·∫•t
        self.AVAILABLE_GEMINI_MODELS_FOR_SCRIPT_EDITING = [
            "gemini-2.5-pro",          # M√¥ h√¨nh m·∫°nh m·∫Ω nh·∫•t
            "gemini-2.5-flash",        # Hi·ªáu su·∫•t t·ªët, c√¢n b·∫±ng
            "gemini-2.5-flash-lite",   # M√¥ h√¨nh ti·∫øt ki·ªám chi ph√≠ nh·∫•t, h·ªó tr·ª£ th√¥ng l∆∞·ª£ng cao
            "gemini-2.0-flash",        # Nhanh, th·ªùi gian th·ª±c
            "gemini-2.0-flash-lite",   # Ti·∫øt ki·ªám, ƒë·ªô tr·ªÖ th·∫•p
            "gemini-1.5-pro-latest",   # Phi√™n b·∫£n 1.5 Pro
            "gemini-1.5-flash-latest"    # Phi√™n b·∫£n 1.5 Flash
        ]
        self.gemini_model_for_script_editing_var = ctk.StringVar(
            value=self.cfg.get("gemini_model_for_script_editing", "gemini-2.5-flash") # ƒê·∫∑t flash 2.5 l√†m m·∫∑c ƒë·ªãnh m·ªõi
        )        
        
        # L·∫•y model ƒë√£ l∆∞u t·ª´ config, n·∫øu kh√¥ng c√≥ th√¨ d√πng model ƒë·∫ßu ti√™n trong danh s√°ch l√†m m·∫∑c ƒë·ªãnh
        default_gpt_model_for_edit = self.cfg.get(
            "gpt_model_for_script_editing", 
            self.AVAILABLE_GPT_MODELS_FOR_SCRIPT_EDITING[0] 
        )
        # ƒê·∫£m b·∫£o model ƒë√£ l∆∞u (ho·∫∑c m·∫∑c ƒë·ªãnh) n·∫±m trong danh s√°ch kh·∫£ d·ª•ng hi·ªán t·∫°i
        if default_gpt_model_for_edit not in self.AVAILABLE_GPT_MODELS_FOR_SCRIPT_EDITING:
            default_gpt_model_for_edit = self.AVAILABLE_GPT_MODELS_FOR_SCRIPT_EDITING[0]
            logging.warning(
                f"Model GPT cho s·ª≠a script ƒë√£ l∆∞u '{self.cfg.get('gpt_model_for_script_editing')}' kh√¥ng h·ª£p l·ªá. "
                f"ƒê·∫∑t l·∫°i v·ªÅ m·∫∑c ƒë·ªãnh: '{default_gpt_model_for_edit}'"
            )
        
        self.gpt_model_for_script_editing_var = ctk.StringVar(value=default_gpt_model_for_edit)
        # =======================================

        # --- Th√™m c√°c bi·∫øn cho API Keys v√† Engine D·ªãch ---
        self.google_key_path_var = ctk.StringVar(value=self.cfg.get("google_service_account_path", "")) # L·∫•y t·ª´ config, m·∫∑c ƒë·ªãnh l√† chu·ªói r·ªóng
        self.openai_key_var = ctk.StringVar(value=self.cfg.get("openai_api_key", ""))              # L·∫•y t·ª´ config, m·∫∑c ƒë·ªãnh l√† chu·ªói r·ªóng
        self.gemini_key_var = ctk.StringVar(value=self.cfg.get("gemini_api_key", "")) 
        self.translation_engine_var = ctk.StringVar(value=self.cfg.get("translation_engine", "Googletrans (Free)")) # L·∫•y t·ª´ config, m·∫∑c ƒë·ªãnh l√† Googletrans

        # === PHONG C√ÅCH D·ªäCH OPENAI ===
        self.OPENAI_TRANSLATION_STYLES = [
            "M·∫∑c ƒë·ªãnh (trung t√≠nh)", 
            "Trang tr·ªçng (formal)",
            "Th√¢n m·∫≠t (informal)",
            "C·ªï trang (historical/ancient)",
            "H√†i h∆∞·ªõc (humorous)",
            "K·ªπ thu·∫≠t (technical)",
            "VƒÉn h·ªçc (literary)",
            "T√≥m t·∫Øt (summary-style)"
        ]
        # L·∫•y gi√° tr·ªã ƒë√£ l∆∞u ho·∫∑c d√πng gi√° tr·ªã ƒë·∫ßu ti√™n trong list l√†m m·∫∑c ƒë·ªãnh
        default_openai_style = self.cfg.get("openai_translation_style", self.OPENAI_TRANSLATION_STYLES[0])
        # ƒê·∫£m b·∫£o gi√° tr·ªã m·∫∑c ƒë·ªãnh c√≥ trong danh s√°ch, n·∫øu kh√¥ng th√¨ d√πng c√°i ƒë·∫ßu ti√™n
        if default_openai_style not in self.OPENAI_TRANSLATION_STYLES:
            default_openai_style = self.OPENAI_TRANSLATION_STYLES[0]
            logging.warning(f"Phong c√°ch d·ªãch OpenAI ƒë√£ l∆∞u '{self.cfg.get('openai_translation_style')}' kh√¥ng h·ª£p l·ªá, ƒë·∫∑t l·∫°i v·ªÅ m·∫∑c ƒë·ªãnh: '{default_openai_style}'")
            
        self.openai_translation_style_var = ctk.StringVar(value=default_openai_style)
        # ======================================================

        # --------------------
        # Bi·∫øn c·∫•u h√¨nh PH·ª§ ƒê·ªÄ
        # --------------------        

        # --- Bi·∫øn & C·∫•u h√¨nh C·ª• th·ªÉ cho Ph·ª• ƒë·ªÅ ---
        self.whisper_model = None
        self.loaded_model_name = None
        self.is_loading_model = False
        self.is_loading_model_for_timer = False
        self.file_queue = []
        self.current_file = None
        self.current_srt_path = None
        self.last_loaded_script_path = None
        self.allow_edit_sub = True
        self.sub_pause_selected_media_path = None
        self.source_lang_var = ctk.StringVar(value=self.cfg.get("language", "auto"))
        self.merge_sub_var = ctk.StringVar(value=self.cfg.get("merge_mode", "Kh√¥ng g·ªôp"))
        self.bilingual_var = ctk.BooleanVar(value=self.cfg.get("bilingual", False))
        self.target_lang_var = ctk.StringVar(value=self.cfg.get("target_lang", "vi"))
        self.enable_split_var = ctk.BooleanVar(value=self.cfg.get("split", True))
        self.max_chars_var = ctk.StringVar(value=str(self.cfg.get("max_chars", 90)))
        self.max_lines_var = ctk.StringVar(value=str(self.cfg.get("max_lines", 1)))
        self.sub_cps_for_timing_var = ctk.StringVar(value=str(self.cfg.get("sub_cps_for_timing", 17))) # M·∫∑c ƒë·ªãnh l√† 17
        self.is_actively_paused_for_edit = False
        self.HAS_UNDERTHEESEA_LIB = globals().get('HAS_UNDERTHEESEA', False) 

        # --- Bi·∫øn C·∫•u h√¨nh FFmpeg cho Slideshow ---
        self.ffmpeg_encoder_var = ctk.StringVar(value=self.cfg.get("ffmpeg_encoder", "libx264"))
        self.ffmpeg_preset_var = ctk.StringVar(value=self.cfg.get("ffmpeg_preset", "veryfast"))
        self.ffmpeg_crf_var = ctk.StringVar(value=str(self.cfg.get("ffmpeg_crf", "23")))

        # --- BI·∫æN M·ªöI CHO FONT CACHING ---
        self.system_fonts_cache = [] # S·∫Ω ch·ª©a danh s√°ch font h·ªá th·ªëng sau khi t·∫£i
        self.fonts_are_loading = False # C·ªù ƒë·ªÉ bi·∫øt lu·ªìng t·∫£i font c√≥ ƒëang ch·∫°y kh√¥ng

        # =======================================================
        # Gi√∫p c√°c c√¢u tho·∫°i ng·∫Øn, m·∫°nh c√≥ ƒë·ªß th·ªùi gian ƒë·ªÉ th·ªÉ hi·ªán
        self.min_duration_per_segment_ms = 999 # (ms) Th·ªùi l∆∞·ª£ng t·ªëi thi·ªÉu cho m·ªói d√≤ng sub
        
        # === C·∫§U H√åNH NH·ªäP ƒêI·ªÜU V√Ä T·ªêC ƒê·ªò ƒê·ªåC (N√ÇNG CAO) ===
        self.sub_pacing_pause_medium_ms_var = ctk.StringVar(
            value=str(self.cfg.get("sub_pacing_pause_medium_ms", 150))
        )
        self.sub_pacing_pause_period_ms_var = ctk.StringVar(
            value=str(self.cfg.get("sub_pacing_pause_period_ms", 300))
        )
        self.sub_pacing_pause_question_ms_var = ctk.StringVar(
            value=str(self.cfg.get("sub_pacing_pause_question_ms", 450))
        )
        self.sub_pacing_long_sentence_threshold_var = ctk.StringVar(
            value=str(self.cfg.get("sub_pacing_long_sentence_threshold", 55))
        )
        self.sub_pacing_fast_cps_multiplier_var = ctk.StringVar(
            value=str(self.cfg.get("sub_pacing_fast_cps_multiplier", 1.1))
        )
        # =============================================================        

        # C·ªù cho l·ªói API khi d·ªãch ph·ª• ƒë·ªÅ h√†ng lo·∫°t
        self.translate_batch_first_api_error_msg_shown = False
        self.translate_batch_accumulated_api_error_details = None

        self.optimize_whisper_tts_voice_var = ctk.BooleanVar(
            value=self.cfg.get("optimize_whisper_tts_voice", False) # M·∫∑c ƒë·ªãnh l√† False, ƒë·ªçc t·ª´ config n·∫øu c√≥
        )

        # ƒêo·∫°n code m·ªõi ƒë·ªÉ kh·ªüi t·∫°o self.split_mode_var
        _initial_split_modes = ["sentence", "char"]
        if HAS_UNDERTHESEA:
            _initial_split_modes.append("underthesea (Ti·∫øng Vi·ªát)")
        
        saved_split_mode_on_init = self.cfg.get("split_mode", _initial_split_modes[0]) # L·∫•y t·ª´ config, fallback v·ªÅ t√πy ch·ªçn ƒë·∫ßu ti√™n
        
        if saved_split_mode_on_init not in _initial_split_modes:
            logging.warning(f"Split mode ƒë√£ l∆∞u trong config '{saved_split_mode_on_init}' kh√¥ng kh·∫£ d·ª•ng khi kh·ªüi t·∫°o. ƒê·∫∑t l·∫°i v·ªÅ '{_initial_split_modes[0]}'.")
            self.split_mode_var = ctk.StringVar(value=_initial_split_modes[0])
        else:
            self.split_mode_var = ctk.StringVar(value=saved_split_mode_on_init)

        # --- Khai b√°o bi·∫øn cho T√ôY CH·ªåN G·ªòP KH·ªêI PH·ª§ ƒê·ªÄ ---
        # ƒê·ªçc gi√° tr·ªã t·ª´ config ƒë√£ l∆∞u (self.cfg), n·∫øu ch∆∞a c√≥ th√¨ d√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh.

        # Bi·∫øn cho checkbox B·∫≠t/T·∫Øt t√≠nh nƒÉng g·ªôp kh·ªëi
        self.enable_block_merging_var = ctk.BooleanVar(
            value=self.cfg.get("enable_block_merging", False)  # M·∫∑c ƒë·ªãnh: T·∫Øt (False)
        )

        # Bi·∫øn cho √¥ nh·∫≠p "Th·ªùi gian ngh·ªâ t·ªëi ƒëa ƒë·ªÉ g·ªôp (ms)"
        self.merge_max_time_gap_var = ctk.StringVar(
            value=str(self.cfg.get("merge_max_time_gap_ms", 369)) # M·∫∑c ƒë·ªãnh: 350ms
        )

        # Bi·∫øn cho √¥ nh·∫≠p "ƒê·ªô d√†i kh·ªëi t·ªëi ƒëa ƒë·ªÉ ti·∫øp t·ª•c g·ªôp (k√Ω t·ª±)"
        # ƒê√¢y l√† ng∆∞·ª°ng MERGE_CURRENT_BLOCK_MAX_LEN_NORMAL
        self.merge_curr_max_len_normal_var = ctk.StringVar(
            value=str(self.cfg.get("merge_curr_max_len_normal", 36)) # M·∫∑c ƒë·ªãnh: 60 k√Ω t·ª±
        )

        # --- Bi·∫øn cho t√≠nh nƒÉng T·∫°m d·ª´ng ƒë·ªÉ s·ª≠a ---
        self.pause_for_edit_var = ctk.BooleanVar(value=self.cfg.get("pause_for_edit", False)) # L∆∞u tr·∫°ng th√°i checkbox
        self.continue_merge_event = threading.Event() # Event ƒë·ªÉ b√°o hi·ªáu cho lu·ªìng ti·∫øp t·ª•c

        self.manual_merge_mode_var = ctk.BooleanVar(value=self.cfg.get("manual_merge_mode", False))
        self.manual_merge_mode_var.trace_add("write", lambda *args: self._on_toggle_manual_merge_mode())

        # >>> BI·∫æN CHIA D√íNG TEXBOX CHO TAB SUB <<<
        self.auto_format_plain_text_to_srt_var = ctk.BooleanVar(value=self.cfg.get("auto_format_plain_text_to_srt", False))
        # Bi·∫øn cho checkbox t·ª± ƒë·ªông th√™m t√°c v·ª• slideshow th·ªß c√¥ng v√†o h√†ng ch·ªù
        self.auto_add_manual_sub_task_var = ctk.BooleanVar(
            value=self.cfg.get("auto_add_manual_sub_task", True) 
        )

        # Bi·∫øn cho checkbox "L∆∞u v√†o th∆∞ m·ª•c c·ªßa media"
        self.save_in_media_folder_var = ctk.BooleanVar(
            value=self.cfg.get("save_in_media_folder", False) # M·∫∑c ƒë·ªãnh l√† T·∫Øt
        )
        
        # Bi·∫øn placeholder
        self.subtitle_textbox_placeholder = "[N·ªôi dung ph·ª• ƒë·ªÅ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y sau khi ƒë∆∞·ª£c t·∫°o ho·∫∑c t·∫£i.\n·ªû ch·∫ø ƒë·ªô 'Gh√©p Sub Th·ªß C√¥ng', b·∫°n c√≥ th·ªÉ 'üìÇ M·ªü Sub...' ho·∫∑c 'üìù S·ª≠a Sub' ƒë·ªÉ nh·∫≠p/d√°n tr·ª±c ti·∫øp.]"
        self.dub_script_textbox_placeholder = "[N·ªôi dung k·ªãch b·∫£n s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y.\nVui l√≤ng ch·ªçn file SRT b·∫±ng n√∫t 'üìú Ch·ªçn Script...' ho·∫∑c nh·∫•n '‚úç S·ª≠a Script' ƒë·ªÉ nh·∫≠p/d√°n vƒÉn b·∫£n.]"
        self.download_log_placeholder = "[Log v√† tr·∫°ng th√°i t·∫£i xu·ªëng s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y... C√°m ∆°n m·ªçi ng∆∞·ªùi ƒë√£ s·ª≠ d·ª•ng ph·∫ßn m·ªÅm Piu.]"
        self.download_url_placeholder = "Vui l√≤ng k√≠ch ho·∫°t b·∫£n quy·ªÅn ƒë·ªÉ s·ª≠ d·ª•ng ph·∫ßn m·ªÅm 'Piu' v√† m·ªü kh√≥a t√≠nh nƒÉng t·∫£i xu·ªëng."

        # L·∫•y ƒë∆∞·ªùng d·∫´n Output cho Ph·ª• ƒë·ªÅ
        self.output_path_var = ctk.StringVar(value=self.cfg.get("output_path", get_default_downloads_folder()))
        self.model_var = ctk.StringVar(value=self.cfg.get("model", "medium"))
        self.format_var = ctk.StringVar(value=self.cfg.get("format", "srt"))

        self.manual_sub_then_dub_active = False  # C·ªù b√°o hi·ªáu ƒëang trong chu·ªói Sub(Manual) & Dub
        self.current_manual_merge_srt_path = None # L∆∞u ƒë∆∞·ªùng d·∫´n SRT ƒë√£ d√πng cho manual merge ƒë·ªÉ dub c√≥ th·ªÉ l·∫•y        

        # --------------------
        # Bi·∫øn c·∫•u h√¨nh c·ªßa ƒêOWNLOAD
        # --------------------

        # --- Bi·∫øn & C·∫•u h√¨nh C·ª• th·ªÉ cho T·∫£i xu·ªëng ---
        self.download_playlist_var = ctk.BooleanVar(value=self.cfg.get("download_playlist", False))
        # S·ª≠ d·ª•ng get_default_downloads_folder n·∫øu ch∆∞a c√≥ trong config
        self.disable_auto_sheet_check_var = ctk.BooleanVar(value=self.cfg.get("disable_auto_sheet_check", False))
        self.download_path_var = ctk.StringVar(value=self.cfg.get("download_path", get_default_downloads_folder()))
        self.download_mode_var = ctk.StringVar(value=self.cfg.get("download_mode", "video"))
        self.download_video_quality_var = ctk.StringVar(value=self.cfg.get("download_video_quality", "1080p"))
        self.download_audio_quality_var = ctk.StringVar(value=self.cfg.get("download_audio_quality", "320k"))
        self.download_sound_var = ctk.BooleanVar(value=self.cfg.get("download_sound_enabled", False))
        self.download_sound_path_var = ctk.StringVar(value=self.cfg.get("download_sound_path", ""))
        self.download_shutdown_var = ctk.BooleanVar(value=self.cfg.get("download_shutdown_enabled", False))
        self.download_rename_var = ctk.BooleanVar(value=self.cfg.get("download_rename_enabled", False))
        self.download_rename_box_var = ctk.StringVar(value=self.cfg.get("download_rename_base_name", ""))
        self.download_stop_on_error_var = ctk.BooleanVar(value=self.cfg.get("download_stop_on_error", False))
        self.sheet_id_var = ctk.StringVar(value=self.cfg.get("sheet_id", ""))
        self.sheet_range_var = ctk.StringVar(value=self.cfg.get("sheet_range", "Sheet1!B2:B"))
        self.download_auto_dub_after_sub_var = ctk.BooleanVar(value=self.cfg.get("download_auto_dub_after_sub", False))
        self.auto_upload_after_download_var = ctk.BooleanVar(value=self.cfg.get("auto_upload_after_download", False))
        self.download_use_cookies_var = ctk.BooleanVar(value=self.cfg.get("download_use_cookies", False))
        self.download_cookies_path_var = ctk.StringVar(value=self.cfg.get("download_cookies_path", ""))

        # --- Bi·∫øn c·∫•u h√¨nh c·ªßa UPLOAD YOUTUBE --- # <-- D√íNG B·∫†N S·∫º TH√äM
        self.youtube_video_path_var = ctk.StringVar(value="") # ƒê∆∞·ªùng d·∫´n video ƒë√£ ch·ªçn ƒë·ªÉ upload
        self.youtube_title_var = ctk.StringVar(value=self.cfg.get("youtube_last_title", ""))      # Ti√™u ƒë·ªÅ video
        self.youtube_description_var = ctk.StringVar(value="") # M√¥ t·∫£ video
        self.youtube_tags_var = ctk.StringVar(value=self.cfg.get("youtube_last_tags", ""))       # Th·∫ª tag (c√°ch nhau b·ªüi d·∫•u ph·∫©y)
        self.youtube_playlist_var = ctk.StringVar(value=self.cfg.get("youtube_playlist_name", "")) # Bi·∫øn m·ªõi cho t√™n danh s√°ch ph√°t

        self.youtube_upload_queue = [] # H√†ng ch·ªù cho c√°c t√°c v·ª• upload
        self.youtube_currently_processing_task_id = None # Theo d√µi ID c·ªßa t√°c v·ª• ƒëang ch·∫°y
        self.youtube_autofill_var = ctk.BooleanVar(value=self.cfg.get("youtube_autofill_enabled", False))
        self.metadata_auto_increment_thumb_var = ctk.BooleanVar(value=self.cfg.get("metadata_auto_increment_thumb", True))
        
        # Tr·∫°ng th√°i ri√™ng t∆∞: 'public', 'private', 'unlisted'
        self.youtube_privacy_status_var = ctk.StringVar(value=self.cfg.get("youtube_default_privacy", "private"))
        # M·∫∑c ƒë·ªãnh l√† '24' (Gi·∫£i tr√≠) ho·∫∑c '1' (Phim & Ho·∫°t ·∫£nh)
        self.youtube_category_id_var = ctk.StringVar(value=self.cfg.get("youtube_default_category_id", '2'))         
        self.is_uploading_youtube = False # C·ªù theo d√µi tr·∫°ng th√°i upload YouTube

        # Bi·∫øn cho checkbox "Upload l√™n YouTube sau khi ho√†n t·∫•t chu·ªói t·ª± ƒë·ªông"
        self.auto_upload_to_youtube_var = ctk.BooleanVar(value=self.cfg.get("auto_upload_to_youtube", False))
        self.youtube_thumbnail_path_var = ctk.StringVar(value="") # ƒê∆∞·ªùng d·∫´n file thumbnail
        self.youtube_fetch_metadata_var = ctk.BooleanVar(value=self.cfg.get("youtube_fetch_metadata_enabled", False))

        # Th√™m c√°c bi·∫øn M·ªöI cho ph∆∞∆°ng ph√°p upload tr√¨nh duy·ªát
        self.youtube_upload_method_var = ctk.StringVar(value=self.cfg.get("youtube_upload_method", "api")) # "api" ho·∫∑c "browser"
        self.chrome_portable_path_var = ctk.StringVar(value=self.cfg.get("chrome_portable_path", ""))
        self.chromedriver_path_var = ctk.StringVar(value=self.cfg.get("chromedriver_path", ""))
        self.youtube_headless_var = ctk.BooleanVar(value=self.cfg.get("youtube_run_headless", True)) # M·∫∑c ƒë·ªãnh l√† True (·∫©n)
        # BI·∫æN M·ªöI CHO M√ÄN H√åNH K·∫æT TH√öC V√Ä TH·∫∫
        self.youtube_add_end_screen_var = ctk.BooleanVar(value=self.cfg.get("youtube_add_end_screen", False))
        self.youtube_add_cards_var = ctk.BooleanVar(value=self.cfg.get("youtube_add_cards", False))
        
        self.download_retry_counts = {} 
        self.globally_completed_urls = set() 

        # --- T·ªëi ∆∞u L∆∞u C·∫•u H√¨nh: X√≥a/Comment c√°c d√≤ng trace_add g·ªçi save_current_config ---
        self.model_var.trace_add("write", self.on_model_change)

        # --------------------
        # Bi·∫øn c·∫•u h√¨nh c·ªßa DUB
        # --------------------
        
        # --- BI·∫æN V√Ä C·∫§U H√åNH C·ª§ TH·ªÇ CHO TAB THUY·∫æT MINH (DUBBING) ---

        self.dub_processing_queue = []  # Danh s√°ch ch√≠nh l∆∞u c√°c t√°c v·ª• trong h√†ng ch·ªù thuy·∫øt minh
                                        # M·ªói t√°c v·ª• s·∫Ω l√† m·ªôt dictionary ch·ª©a ƒë·∫ßy ƒë·ªß th√¥ng tin c·∫ßn thi·∫øt.

        # Bi·∫øn t·∫°m ƒë·ªÉ l∆∞u tr·ªØ th√¥ng tin video v√† script ƒëang ƒë∆∞·ª£c ng∆∞·ªùi d√πng ch·ªçn tr√™n UI
        # TR∆Ø·ªöC KHI th√™m v√†o h√†ng ch·ªù x·ª≠ l√Ω h√†ng lo·∫°t.
        self.dub_current_video_for_queue_display = ctk.StringVar(value="") # ƒê·ªÉ hi·ªÉn th·ªã t√™n file video ƒëang ch·ªçn
        self.dub_current_script_for_queue_display = ctk.StringVar(value="")# ƒê·ªÉ hi·ªÉn th·ªã t√™n file script ƒëang ch·ªçn
        
        # C√°c bi·∫øn n√†y s·∫Ω l∆∞u ƒë∆∞·ªùng d·∫´n th·ª±c t·∫ø v√† d·ªØ li·ªáu ƒë√£ ph√¢n t√≠ch c·ªßa script ƒëang ƒë∆∞·ª£c ch·ªçn,
        # kh√¥ng ph·∫£i l√† StringVar ƒë·ªÉ tr√°nh c√°c v·∫•n ƒë·ªÅ kh√¥ng c·∫ßn thi·∫øt khi truy·ªÅn qua l·∫°i.
        self.dub_current_video_path_for_queue_temp = ""  # ƒê∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß ƒë·∫øn file video ƒëang ƒë∆∞·ª£c ch·ªçn
        self.dub_current_script_path_for_queue_temp = "" # ƒê∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß ƒë·∫øn file script ƒëang ƒë∆∞·ª£c ch·ªçn
        self.dub_temp_srt_data_for_queue = []            # D·ªØ li·ªáu SRT ƒë√£ parse t·ª´ script ƒëang ƒë∆∞·ª£c ch·ªçn

        # ID c·ªßa t√°c v·ª• ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω t·ª´ h√†ng ch·ªù (s·∫Ω d√πng ƒë·ªÉ theo d√µi)
        self.dub_currently_processing_task_id = None
        # =================================================

        # C·ªù reset l·ªói api
        self.dub_batch_first_api_error_msg_shown = False
        self.dub_batch_accumulated_api_error_details = None # ƒê·ªÉ l∆∞u chi ti·∫øt l·ªói ƒë·∫ßu ti√™n
        
        # [Paths v√† File t·∫°m cho Dubbing]
        # S·ª≠ d·ª•ng self.temp_folder chung c·ªßa PiuApp cho c√°c file preview.
        # C√°c file n√†y s·∫Ω ƒë∆∞·ª£c t·∫°o v√† x√≥a trong qu√° tr√¨nh preview.
        self.dub_piper_output_wav_filename = os.path.join(self.temp_folder, "dub_piper_preview.wav")
        self.dub_openai_output_mp3_filename = os.path.join(self.temp_folder, "dub_openai_preview.mp3")
        self.dub_google_output_mp3_filename = os.path.join(self.temp_folder, "dub_google_preview.mp3")
        self.dub_gtts_output_mp3_filename = os.path.join(self.temp_folder, "dub_gtts_preview.mp3")

        # [Tr·∫°ng th√°i x·ª≠ l√Ω v√† D·ªØ li·ªáu Dubbing]
        self.dub_srt_data = []  # L∆∞u tr·ªØ d·ªØ li·ªáu SRT ƒë√£ parse cho k·ªãch b·∫£n thuy·∫øt minh
        self.dub_is_processing = False  # C·ªù b√°o hi·ªáu ƒëang trong qu√° tr√¨nh t·∫°o video thuy·∫øt minh
        self.dub_video_path = None      # ƒê∆∞·ªùng d·∫´n ƒë·∫øn file video g·ªëc ƒëang l√†m vi·ªác
        self.dub_is_stopping = False    # C·ªù b√°o hi·ªáu ng∆∞·ªùi d√πng y√™u c·∫ßu d·ª´ng qu√° tr√¨nh thuy·∫øt minh

        # [C·∫•u h√¨nh ƒê∆∞·ªùng d·∫´n Output cho Dubbing]
        # S·ª≠ d·ª•ng get_default_downloads_folder() n·∫øu ch∆∞a c√≥ trong config
        self.dub_output_path_var = ctk.StringVar(value=self.cfg.get("dub_output_path", get_default_downloads_folder()))

        # [Bi·∫øn cho UI hi·ªÉn th·ªã th√¥ng tin file ƒëang x·ª≠ l√Ω]
        self.dub_current_processing_video_label_var = ctk.StringVar(value="Video: Ch∆∞a ch·ªçn")
        self.dub_current_processing_srt_label_var = ctk.StringVar(value="Script: Ch∆∞a ch·ªçn")

        # [C·∫•u h√¨nh Engine v√† Gi·ªçng ƒë·ªçc TTS cho Dubbing]
        # Danh s√°ch c√°c engine TTS v√† c√°c gi·ªçng ƒë·ªçc t∆∞∆°ng ·ª©ng
        self.dub_tts_voice_options = {
            "Google Translate (gTTS)": {"default_gtts": "M·∫∑c ƒë·ªãnh Ti·∫øng Vi·ªát"},
            "Google Cloud TTS": {
                # --- GI·ªåNG TI·∫æNG VI·ªÜT ---
                "vi-VN-Standard-A": "[VN] N·ªØ - Mi·ªÅn Nam (Standard-A)",
                "vi-VN-Wavenet-A":  "[VN] N·ªØ - Mi·ªÅn Nam (Wavenet-A)",
                "vi-VN-Neural2-A": "[VN] N·ªØ - Mi·ªÅn Nam (Neural2-A)",
                "vi-VN-Standard-B": "[VN] Nam - Mi·ªÅn Nam (Standard-B)",
                "vi-VN-Wavenet-B":  "[VN] Nam - Mi·ªÅn Nam (Wavenet-B)",
                "vi-VN-Standard-C": "[VN] N·ªØ - Mi·ªÅn B·∫Øc (Standard-C)",
                "vi-VN-Wavenet-C":  "[VN] N·ªØ - Mi·ªÅn B·∫Øc (Wavenet-C)",
                "vi-VN-Standard-D": "[VN] Nam - Mi·ªÅn B·∫Øc (Standard-D)",
                "vi-VN-Wavenet-D":  "[VN] Nam - Mi·ªÅn B·∫Øc (Wavenet-D)",
                "vi-VN-Neural2-D": "[VN] Nam - Mi·ªÅn B·∫Øc (Neural2-D)",
                
                # --- GI·ªåNG TI·∫æNG ANH (M·ª∏) ---
                "en-US-Wavenet-A": "[EN-US] Nam (Wavenet-A)",
                "en-US-Wavenet-F": "[EN-US] N·ªØ (Wavenet-F)",
                "en-US-Neural2-C": "[EN-US] N·ªØ - Th√¢n thi·ªán (Neural2-C)",
                "en-US-Neural2-J": "[EN-US] Nam - Th√¢n thi·ªán (Neural2-J)",
                "en-US-Standard-E": "[EN-US] N·ªØ (Standard-E)",

                # --- GI·ªåNG TI·∫æNG ANH (ANH) ---
                "en-GB-Wavenet-A": "[EN-GB] N·ªØ (Wavenet-A)",
                "en-GB-Standard-B": "[EN-GB] Nam (Standard-B)",
                "en-GB-Neural2-C": "[EN-GB] N·ªØ (Neural2-C)",
            },

            "OpenAI TTS": {
                "alloy": "Alloy", "echo": "Echo", "fable": "Fable",
                "nova": "Nova", "onyx": "Onyx", "shimmer": "Shimmer"
            },
            "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)": {
                "default_system_voice": "M·∫∑c ƒë·ªãnh H·ªá th·ªëng" 
            }
        }

        # X√°c ƒë·ªãnh engine TTS ban ƒë·∫ßu
        default_dub_tts_engine_fallback = "Google Translate (gTTS)" # Engine fallback cu·ªëi c√πng
        saved_tts_engine = self.cfg.get("dub_tts_engine")
        current_engine_name = default_dub_tts_engine_fallback # M·∫∑c ƒë·ªãnh an to√†n

        if saved_tts_engine and saved_tts_engine in self.dub_tts_voice_options.keys():
            current_engine_name = saved_tts_engine
            logging.debug(f"Kh√¥i ph·ª•c Engine TTS t·ª´ config: '{current_engine_name}'")
        elif saved_tts_engine: # N·∫øu c√≥ l∆∞u nh∆∞ng kh√¥ng h·ª£p l·ªá
            logging.warning(f"Engine TTS ƒë√£ l∆∞u '{saved_tts_engine}' kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng fallback '{default_dub_tts_engine_fallback}'.")
        else: # N·∫øu kh√¥ng c√≥ trong config
            logging.debug(f"Kh√¥ng c√≥ Engine TTS trong config. S·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh '{default_dub_tts_engine_fallback}'.")
        
        self.dub_selected_tts_engine_var = ctk.StringVar(value=current_engine_name)

        # Kh·ªüi t·∫°o c√°c StringVar cho gi·ªçng ƒë·ªçc
        self.dub_selected_voice_id_var = ctk.StringVar()
        self.dub_selected_voice_display_name_var = ctk.StringVar()
        self.dub_current_engine_voice_display_to_id_map = {} 

        # KH·ªûI T·∫†O B·ªò NH·ªö ƒê·ªÜM CHO GOOGLE TTS (S·∫Ω ƒë∆∞·ª£c ƒëi·ªÅn sau khi app kh·ªüi ƒë·ªông)
        self.google_tts_voices_cache = {} # Kh·ªüi t·∫°o cache r·ªóng

        # <<< --- B·∫ÆT ƒê·∫¶U KH·ªêI CODE M·ªöI THAY TH·∫æ --- >>>
        # KH·ªûI T·∫†O B·ªò NH·ªö ƒê·ªÜM CHO GOOGLE TTS (S·∫Ω ƒë∆∞·ª£c ƒëi·ªÅn sau khi app kh·ªüi ƒë·ªông)
        self.google_tts_voices_cache = {} # Kh·ªüi t·∫°o cache r·ªóng

        # --- LOGIC KH√îI PH·ª§C GI·ªåNG ƒê·ªåC ƒê√É L∆ØU (PHI√äN B·∫¢N CACHE ƒê·ªòNG) ---
        # 1. T·∫£i danh s√°ch gi·ªçng ƒë·ªçc Google t·ª´ file cache n·∫øu c√≥
        google_voices_cache_path = get_google_voices_cache_path()
        if os.path.exists(google_voices_cache_path):
            try:
                with open(google_voices_cache_path, "r", encoding="utf-8") as f:
                    self.google_tts_voices_cache = json.load(f)
                logging.info(f"ƒê√£ t·∫£i th√†nh c√¥ng {len(self.google_tts_voices_cache)} gi·ªçng Google t·ª´ file cache.")
            except (json.JSONDecodeError, IOError) as e:
                logging.warning(f"L·ªói khi ƒë·ªçc file cache gi·ªçng Google: {e}. S·∫Ω d√πng danh s√°ch tƒ©nh.")

        saved_voice_id_from_cfg = self.cfg.get("dub_selected_voice_id")
        logging.debug(f"ID gi·ªçng ƒë·ªçc ƒë√£ l∆∞u t·ª´ config: '{saved_voice_id_from_cfg}' cho engine '{current_engine_name}'")

        voices_for_current_engine_map = {} # Map {voice_id: display_name}

        if current_engine_name == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)":
            if HAS_PYTTSX3 and pyttsx3:
                try:
                    temp_engine_init = pyttsx3.init()
                    if temp_engine_init:
                        system_voices_init = temp_engine_init.getProperty('voices')
                        temp_engine_init.stop()
                        for voice_init in system_voices_init:
                            langs_decoded_init = []
                            if hasattr(voice_init, 'languages') and voice_init.languages:
                                for lang_raw_init in voice_init.languages:
                                    decoded_init = lang_raw_init.decode('utf-8', 'ignore').lower() if isinstance(lang_raw_init, bytes) else str(lang_raw_init).lower()
                                    langs_decoded_init.append(decoded_init)
                            lang_suffix_init = f" ({', '.join(langs_decoded_init)})" if langs_decoded_init else ""
                            display_name_init = f"{voice_init.name}{lang_suffix_init}"
                            voices_for_current_engine_map[voice_init.id] = display_name_init
                        logging.debug(f"Gi·ªçng h·ªá th·ªëng l·∫•y ƒë∆∞·ª£c khi init: {voices_for_current_engine_map}")
                    else:
                        logging.warning("pyttsx3.init() tr·∫£ v·ªÅ None khi kh√¥i ph·ª•c gi·ªçng ƒë·ªçc h·ªá th·ªëng.")
                except Exception as e_init_voices:
                    logging.error(f"L·ªói l·∫•y gi·ªçng h·ªá th·ªëng khi kh·ªüi t·∫°o: {e_init_voices}")
        
        elif current_engine_name == "Google Cloud TTS":
            # 2. ∆Øu ti√™n d√πng cache ƒë·ªông ƒë√£ t·∫£i t·ª´ file
            if self.google_tts_voices_cache:
                voices_for_current_engine_map = self.google_tts_voices_cache
            else:
                # 3. N·∫øu cache r·ªóng (l·∫ßn ƒë·∫ßu ch·∫°y), d√πng danh s√°ch tƒ©nh l√†m d·ª± ph√≤ng
                logging.warning("Cache gi·ªçng Google r·ªóng, d√πng danh s√°ch tƒ©nh l√†m d·ª± ph√≤ng ƒë·ªÉ kh·ªüi ƒë·ªông.")
                voices_for_current_engine_map = self.dub_tts_voice_options.get(current_engine_name, {})
        else: # C√°c engine kh√°c
            engine_specific_options = self.dub_tts_voice_options.get(current_engine_name, {})
            voices_for_current_engine_map = engine_specific_options
            logging.debug(f"Gi·ªçng cho engine API '{current_engine_name}': {voices_for_current_engine_map}")

        # <<< --- B·∫ÆT ƒê·∫¶U KH·ªêI S·ª¨A L·ªñI L·∫¶N CU·ªêI --- >>>
        initial_display_name_to_set = ""
        actual_voice_id_to_set = ""

        # B∆∞·ªõc 1: T√¨m ki·∫øm ch√≠nh x√°c gi·ªçng ƒë·ªçc ƒë√£ l∆∞u
        if saved_voice_id_from_cfg and voices_for_current_engine_map:
            # T√¨m ng∆∞·ª£c l·∫°i display_name t·ª´ voice_id ƒë√£ l∆∞u
            # Duy·ªát qua c·∫∑p (key, value) t·ª©c l√† (voice_id, display_name)
            for v_id, d_name in voices_for_current_engine_map.items():
                if v_id == saved_voice_id_from_cfg:
                    initial_display_name_to_set = d_name
                    actual_voice_id_to_set = v_id
                    logging.debug(f"T√¨m th·∫•y ID gi·ªçng ƒë√£ l∆∞u '{saved_voice_id_from_cfg}' cho engine '{current_engine_name}'. T√™n hi·ªÉn th·ªã: '{initial_display_name_to_set}'")
                    break # Tho√°t v√≤ng l·∫∑p ngay khi t√¨m th·∫•y
        
        # B∆∞·ªõc 2: N·∫øu kh√¥ng t√¨m th·∫•y, ch·ªçn m·ªôt gi·ªçng m·∫∑c ƒë·ªãnh
        if not actual_voice_id_to_set and voices_for_current_engine_map:
            logging.warning(f"ID gi·ªçng ƒë√£ l∆∞u '{saved_voice_id_from_cfg}' kh√¥ng t√¨m th·∫•y trong danh s√°ch gi·ªçng c·ªßa engine '{current_engine_name}'. S·∫Ω d√πng gi·ªçng m·∫∑c ƒë·ªãnh.")
            
            # L·∫•y gi·ªçng ƒë·∫ßu ti√™n l√†m m·∫∑c ƒë·ªãnh
            # S·ª≠ d·ª•ng iter() ƒë·ªÉ l·∫•y an to√†n c·∫∑p key-value ƒë·∫ßu ti√™n
            try:
                first_display_name = next(iter(voices_for_current_engine_map.keys()))
                first_voice_id = voices_for_current_engine_map[first_display_name]
                
                initial_display_name_to_set = first_display_name
                actual_voice_id_to_set = first_voice_id
                logging.debug(f"Ch·ªçn gi·ªçng m·∫∑c ƒë·ªãnh ƒë·∫ßu ti√™n: '{initial_display_name_to_set}' (ID: {actual_voice_id_to_set})")
            except StopIteration:
                logging.error("Kh√¥ng th·ªÉ l·∫•y gi·ªçng m·∫∑c ƒë·ªãnh v√¨ voice map r·ªóng.")
        
        elif not voices_for_current_engine_map:
            logging.warning(f"Kh√¥ng c√≥ gi·ªçng n√†o ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ho·∫∑c l·∫•y ƒë∆∞·ª£c cho engine '{current_engine_name}'.")

        # B∆∞·ªõc 3: G√°n gi√° tr·ªã cu·ªëi c√πng
        self.dub_selected_voice_display_name_var.set(initial_display_name_to_set if initial_display_name_to_set else "N/A")
        self.dub_selected_voice_id_var.set(actual_voice_id_to_set if actual_voice_id_to_set else "")

        logging.info(f"Ho√†n t·∫•t kh√¥i ph·ª•c gi·ªçng ƒë·ªçc trong __init__: Engine='{self.dub_selected_tts_engine_var.get()}', DisplayName='{self.dub_selected_voice_display_name_var.get()}', VoiceID='{self.dub_selected_voice_id_var.get()}'")

        # [C·∫•u h√¨nh Chi ti·∫øt cho t·ª´ng Engine (n·∫øu c√≥)]
        # Google Cloud TTS
        self.dub_google_tts_language_code = self.cfg.get("dub_google_tts_language_code", "vi-VN") # M√£ ng√¥n ng·ªØ cho Google Cloud TTS
        self.dub_use_google_ssml_var = ctk.BooleanVar(value=self.cfg.get("dub_use_google_ssml", False)) # C√≥ s·ª≠ d·ª•ng SSML c∆° b·∫£n cho Google TTS kh√¥ng

        # OpenAI TTS
        self.dub_openai_tts_model = self.cfg.get("dub_openai_tts_model", "tts-1") # Model cho OpenAI TTS (v√≠ d·ª•: "tts-1", "tts-1-hd")

        # --- TH√äM C√ÅC BI·∫æN M·ªöI CHO T√ôY CH·ªåN T·ªêI ∆ØU LU·ªíNG ƒê·ªåC THUY·∫æT MINH ---
        self.optimize_dub_flow_var = ctk.BooleanVar(value=self.cfg.get("optimize_dub_flow_enabled", False)) # M·∫∑c ƒë·ªãnh l√† T·∫Øt

        self.dub_force_recalculate_timing_var = ctk.BooleanVar(
            value=self.cfg.get("dub_force_recalculate_timing", False) # M·∫∑c ƒë·ªãnh l√† T·∫Øt
        )        

        # Bi·∫øn ∆∞·ªõc l∆∞·ª£ng th·ªùi gian chia k·ªãch b·∫£n
        self.dub_cps_for_timing_var = ctk.StringVar(
            value=str(self.cfg.get("dub_cps_for_timing", 17)) # ƒê·ªçc t·ª´ config, m·∫∑c ƒë·ªãnh l√† 17
        )
        # Bi·∫øn hi·ªán t·ªëi ∆∞u ngay l·∫≠p t·ª©c
        self.dub_auto_optimize_on_paste_var = ctk.BooleanVar(
            value=self.cfg.get("dub_auto_optimize_on_paste", False) # M·∫∑c ƒë·ªãnh l√† T·∫Øt
        )
        
        # C√°c bi·∫øn c·∫•u h√¨nh chia c√¢u/ƒëo·∫°n d√†nh ri√™ng cho Thuy·∫øt Minh
        self.dub_split_enabled_for_flow_var = ctk.BooleanVar(value=self.cfg.get("dub_split_enabled_for_flow", True)) # M·∫∑c ƒë·ªãnh B·∫≠t n·∫øu optimize_dub_flow ƒë∆∞·ª£c b·∫≠t
        self.dub_max_chars_for_flow_var = ctk.StringVar(value=str(self.cfg.get("dub_max_chars_for_flow", 999))) # M·∫∑c ƒë·ªãnh r·∫•t l·ªõn ƒë·ªÉ ∆∞u ti√™n ng·∫Øt t·ª± nhi√™n
        self.dub_max_lines_for_flow_var = ctk.StringVar(value=str(self.cfg.get("dub_max_lines_for_flow", 1)))    # Th∆∞·ªùng th√¨ thuy·∫øt minh m·ªói c√¢u/ƒëo·∫°n l√† 1 kh·ªëi
        
        _initial_dub_split_modes = ["underthesea (Ti·∫øng Vi·ªát)"] # ∆Øu ti√™n underthesea cho thuy·∫øt minh
        if not HAS_UNDERTHESEA: # N·∫øu kh√¥ng c√≥ underthesea, th√™m c√°c l·ª±a ch·ªçn kh√°c
            _initial_dub_split_modes.extend(["sentence", "char"])
        else: # N·∫øu c√≥ underthesea, c√≥ th·ªÉ th√™m c√°c l·ª±a ch·ªçn kh√°c n·∫øu mu·ªën
            if "sentence" not in _initial_dub_split_modes: _initial_dub_split_modes.append("sentence")
            if "char" not in _initial_dub_split_modes: _initial_dub_split_modes.append("char")

        saved_dub_split_mode = self.cfg.get("dub_split_mode_for_flow", _initial_dub_split_modes[0])
        if saved_dub_split_mode not in _initial_dub_split_modes:
            saved_dub_split_mode = _initial_dub_split_modes[0]
        self.dub_split_mode_for_flow_var = ctk.StringVar(value=saved_dub_split_mode)
        # ----------------------------------------------------------------------

        # --- BI·∫æN M·ªöI ƒê·ªÇ KI·ªÇM SO√ÅT HI·ªÇN TH·ªä T√ôY CH·ªàNH N√ÇNG CAO AUDIO ---
        self.dub_show_advanced_audio_settings_var = ctk.BooleanVar(
            value=self.cfg.get("dub_show_advanced_audio_settings", False) # M·∫∑c ƒë·ªãnh l√† ·∫©n
        )
        # [Tham s·ªë ƒê·ªìng b·ªô h√≥a Audio v√† SRT]
        self.dub_sync_tolerance_ms_var = ctk.StringVar(
            value=str(self.cfg.get("dub_sync_tolerance_ms", 20)) # ƒê·ªçc t·ª´ config, m·∫∑c ƒë·ªãnh 50ms
        )

        self.dub_sync_max_speed_up_var = ctk.StringVar(
            value=str(self.cfg.get("dub_sync_max_speed_up", "1.50")) # ƒê·ªçc t·ª´ config, m·∫∑c ƒë·ªãnh 1.50
        )
        
        default_min_speed_down_str = str(self.cfg.get("dub_sync_min_speed_down_val", "1.0"))
        self.dub_sync_min_speed_down_var = ctk.StringVar(value=default_min_speed_down_str) # ƒê√£ c√≥ t·ª´ B∆∞·ªõc 1

        self.dub_sync_force_cut_if_over_srt_duration_var = ctk.BooleanVar(
            value=self.cfg.get("dub_sync_force_cut_if_over_srt_duration", True) # Key config m·ªõi
        )

        self.dub_sync_min_srt_duration_for_adjust_ms_var = ctk.StringVar(
            value=str(self.cfg.get("dub_sync_min_srt_duration_for_adjust_ms", 200)) # Key config m·ªõi
        )
        
        self.dub_sync_pad_short_tts_var = ctk.BooleanVar(
            value=self.cfg.get("dub_sync_pad_short_tts", True)
        ) # ƒê√£ c√≥ t·ª´ B∆∞·ªõc 1
        
        self.dub_min_gap_between_segments_ms_var = ctk.StringVar(
            value=str(self.cfg.get("dub_min_gap_between_segments_ms", 0))
        ) # ƒê√£ c√≥ t·ª´ B∆∞·ªõc 1

        # [Tham s·ªë X·ª≠ l√Ω Audio (Fade, Silence)] - (C√°c d√≤ng hi·ªán c√≥ c·ªßa b·∫°n)
        self.dub_audio_fade_in_duration_s_var = ctk.StringVar(
            value=str(self.cfg.get("dub_audio_fade_in_duration_s", "0.05"))
        )

        self.dub_audio_fade_out_duration_s_var = ctk.StringVar(
            value=str(self.cfg.get("dub_audio_fade_out_duration_s", "0.03"))
        )

        # Bi·∫øn x·ª≠ l√Ω √¢m thanh
        self.CFG_ALLOW_OVERFLOW_MS = 100  # V√≠ d·ª•: cho ph√©p n√≥i l·ªë 0.1 gi√¢y
        self.CFG_MIN_SILENCE_AFTER_OVERFLOW_MS = 0 # V√≠ d·ª•: kho·∫£ng l·∫∑ng t·ªëi thi·ªÉu 10ms sau c√¢u n√≥i l·ªë

        # [T√πy ch·ªçn X·ª≠ l√Ω √Çm thanh N·ªÅn c·ªßa Video G·ªëc]
        self.dub_background_audio_options = ["Tr·ªôn v·ªõi √¢m thanh g·ªëc (m·ª©c nh·ªè)", "Thay th·∫ø √¢m thanh g·ªëc", "T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh (Audio Ducking)"] # C√°c l·ª±a ch·ªçn cho ng∆∞·ªùi d√πng
        default_dub_bg_audio_option = self.cfg.get("dub_background_audio_option", self.dub_background_audio_options[0])
        self.dub_background_audio_option_var = ctk.StringVar(value=default_dub_bg_audio_option)
        self.dub_background_mix_level_var = ctk.DoubleVar(value=self.cfg.get("dub_background_mix_level", 0.30)) # M·ª©c √¢m l∆∞·ª£ng g·ªëc khi tr·ªôn (0.0 - 1.0)

        # [T√πy ch·ªçn Nh·∫°c n·ªÅn T√πy ch·ªânh]
        self.dub_use_custom_bg_music_var = ctk.BooleanVar(value=self.cfg.get("dub_use_custom_bg_music", False)) # C√≥ s·ª≠ d·ª•ng nh·∫°c n·ªÅn t√πy ch·ªânh kh√¥ng
        self.dub_custom_bg_music_path_var = ctk.StringVar(value=self.cfg.get("dub_custom_bg_music_path", "")) # ƒê∆∞·ªùng d·∫´n file nh·∫°c n·ªÅn

        # --- TH√äM M·ªöI CHO T√çNH NƒÇNG CH·ªåN TH∆Ø M·ª§C NH·∫†C N·ªÄN ---
        self.dub_custom_bg_music_folder_path_var = ctk.StringVar(value=self.cfg.get("dub_custom_bg_music_folder_path", "")) # L∆∞u ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c nh·∫°c
        self.dub_randomize_bg_music_var = ctk.BooleanVar(value=self.cfg.get("dub_randomize_bg_music", False)) # L∆∞u tr·∫°ng th√°i checkbox "Ng·∫´u nhi√™n"
        # --- K·∫æT TH√öC TH√äM M·ªöI ---
        
        self.dub_custom_bg_music_volume_var = ctk.DoubleVar(value=self.cfg.get("dub_custom_bg_music_volume", 0.25)) # √Çm l∆∞·ª£ng nh·∫°c n·ªÅn t√πy ch·ªânh
        default_dub_bg_vol_float = self.cfg.get("dub_custom_bg_volume", 0.25) # Gi√° tr·ªã l√† float (0.0 ƒë·∫øn 1.0)
        default_dub_bg_vol_percent_str = str(int(default_dub_bg_vol_float * 100))
        self.dub_custom_bg_music_volume_percent_str_var = ctk.StringVar(value=default_dub_bg_vol_percent_str)
        #self.dub_custom_bg_music_volume_percent_str_var.trace_add("write", lambda *args: self.save_current_config())

        # [C·∫•u h√¨nh FFmpeg cho Dubbing - C√°c gi√° tr·ªã n√†y th∆∞·ªùng l√† h·∫±ng s·ªë c·ªßa ·ª©ng d·ª•ng]
        self.dub_FFMPEG_PATH = None  # S·∫Ω ƒë∆∞·ª£c ƒë·∫∑t khi c·∫ßn b·∫±ng find_ffmpeg()
        self.dub_DEFAULT_VIDEO_CODEC = "copy"  # Gi·ªØ codec video g·ªëc khi gh√©p
        self.dub_DEFAULT_AUDIO_CODEC_AAC = "aac"  # Codec AAC cho track audio thuy·∫øt minh trong video output
        self.dub_DEFAULT_AUDIO_BITRATE_AAC = "256k" # Bitrate cho AAC
        self.dub_DEFAULT_MP3_QUALITY = "2"  # Ch·∫•t l∆∞·ª£ng cho MP3 (VBR, 0-9, c√†ng th·∫•p c√†ng t·ªët, "4" l√† kh√° t·ªët)
        self.dub_DEFAULT_WAV_CODEC = "pcm_s16le" # Codec cho c√°c file WAV trung gian (lossless, 16-bit signed little-endian)
        self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE = 44100 # T·∫ßn s·ªë l·∫•y m·∫´u m·ª•c ti√™u cho x·ª≠ l√Ω audio
        self.dub_TARGET_AUDIO_PROCESSING_CHANNELS = 2      # S·ªë k√™nh audio m·ª•c ti√™u (1 = mono)

        # [T√πy ch·ªçn Slideshow t·ª´ Th∆∞ m·ª•c ·∫¢nh]
        self.dub_use_image_folder_var = ctk.BooleanVar(value=self.cfg.get("dub_use_image_folder", False))
        self.dub_selected_image_folder_path_var = ctk.StringVar(value=self.cfg.get("dub_slideshow_image_folder", ""))
        # C√°c widget UI ƒë∆∞·ª£c t·∫°o trong DubbingTab (ui/tabs/dubbing_tab.py)
        self.dub_slideshow_folder_frame = None
        self.dub_chk_use_image_folder = None
        self.dub_btn_browse_image_folder = None
        self.dub_lbl_image_folder_path = None

        # --- C√ÄI ƒê·∫∂T CHO T√çNH NƒÇNG BRANDING (LOGO, INTRO, OUTRO) ---
        logging.info("Kh·ªüi t·∫°o bi·∫øn cho t√≠nh nƒÉng Branding...")

        # Bi·∫øn cho Intro Video
        self.branding_intro_enabled_var = ctk.BooleanVar(
            value=self.cfg.get("branding_intro_enabled", False)
        )
        self.branding_intro_path_var = ctk.StringVar(
            value=self.cfg.get("branding_intro_path", "")
        )

        # ### TH√äM M·ªöI: BI·∫æN CHO INTRO T·ª™ ·∫¢NH ###
        self.branding_intro_from_image_enabled_var = ctk.BooleanVar(value=self.cfg.get("branding_intro_from_image_enabled", False))
        self.branding_intro_image_path_var = ctk.StringVar(value=self.cfg.get("branding_intro_image_path", ""))
        self.branding_intro_image_duration_var = ctk.StringVar(value=str(self.cfg.get("branding_intro_image_duration_s", 5.0))) # L∆∞u d∆∞·ªõi d·∫°ng string

        # Bi·∫øn cho Outro Video
        self.branding_outro_enabled_var = ctk.BooleanVar(
            value=self.cfg.get("branding_outro_enabled", False)
        )
        self.branding_outro_path_var = ctk.StringVar(
            value=self.cfg.get("branding_outro_path", "")
        )

        # ### TH√äM M·ªöI: BI·∫æN CHO OUTRO T·ª™ ·∫¢NH ###
        self.branding_outro_from_image_enabled_var = ctk.BooleanVar(value=self.cfg.get("branding_outro_from_image_enabled", False))
        self.branding_outro_image_path_var = ctk.StringVar(value=self.cfg.get("branding_outro_image_path", ""))
        self.branding_outro_image_duration_var = ctk.StringVar(value=str(self.cfg.get("branding_outro_image_duration_s", 5.0))) # L∆∞u d∆∞·ªõi d·∫°ng string

        # Bi·∫øn cho Logo (Watermark)
        self.branding_logo_enabled_var = ctk.BooleanVar(
            value=self.cfg.get("branding_logo_enabled", False)
        )
        self.branding_logo_path_var = ctk.StringVar(
            value=self.cfg.get("branding_logo_path", "")
        )
        
        # C√†i ƒë·∫∑t chi ti·∫øt cho Logo
        # V·ªã tr√≠ logo: d√πng StringVar ƒë·ªÉ d·ªÖ d√†ng l∆∞u c√°c gi√° tr·ªã text nh∆∞ "top_left", "bottom_right"
        # Ho·∫∑c b·∫°n c√≥ th·ªÉ d√πng IntVar n·∫øu mu·ªën √°nh x·∫° sang c√°c gi√° tr·ªã s·ªë sau n√†y.
        # C√°c gi√° tr·ªã v√≠ d·ª•: "top_left", "top_right", "bottom_left", "bottom_right", "center"
        self.branding_logo_position_var = ctk.StringVar(
            value=self.cfg.get("branding_logo_position", "bottom_right") # M·∫∑c ƒë·ªãnh g√≥c d∆∞·ªõi ph·∫£i
        )
        # ƒê·ªô m·ªù logo (0=trong su·ªët ho√†n to√†n, 100=kh√¥ng m·ªù)
        self.branding_logo_opacity_var = ctk.IntVar( # D√πng IntVar cho slider ho·∫∑c entry s·ªë
            value=self.cfg.get("branding_logo_opacity_percent", 80) # M·∫∑c ƒë·ªãnh 80%
        )
        # K√≠ch th∆∞·ªõc logo (v√≠ d·ª•: % chi·ªÅu r·ªông video)
        self.branding_logo_size_percent_var = ctk.IntVar( # D√πng IntVar
            value=self.cfg.get("branding_logo_size_percent", 10) # M·∫∑c ƒë·ªãnh 10% chi·ªÅu r·ªông video
        )
        # Kho·∫£ng c√°ch l·ªÅ c·ªßa logo so v·ªõi c·∫°nh video (t√≠nh b·∫±ng pixel)
        self.branding_logo_margin_px_var = ctk.IntVar(
            value=self.cfg.get("branding_logo_margin_px", 10) # M·∫∑c ƒë·ªãnh 10 pixels
        )
        # --- K·∫æT TH√öC C√ÄI ƒê·∫∂T BRANDING ---

        # Bi·∫øn c·∫•u h√¨nh cho gi·ªõi h·∫°n th·ªùi l∆∞·ª£ng t·ªëi thi·ªÉu c·ªßa c·∫£nh (Imagen)
        self.imagen_min_scene_duration_var = ctk.StringVar(
            value=self.cfg.get("imagen_min_scene_duration", "Kh√¥ng gi·ªõi h·∫°n")
        )
        # Bi·∫øn t·∫≠p trung cho Imagen Motion
        self.imagen_motion_effect_var = ctk.StringVar(
            value=self.cfg.get("imagen_motion_effect", "Kh√¥ng c√≥")
        )
        self.imagen_motion_speed_var = ctk.StringVar(
            value=self.cfg.get("imagen_motion_speed", "V·ª´a")
        )
        # --- Bi·∫øn C·∫•u h√¨nh Style Ph·ª• ƒë·ªÅ (Cho UI t√πy ch·ªânh) ---
        logging.info("Kh·ªüi t·∫°o bi·∫øn cho C√†i ƒë·∫∑t Style Ph·ª• ƒë·ªÅ...")
        self.sub_style_font_name_var = ctk.StringVar(value=self.cfg.get("sub_style_font_name", "Arial"))
        self.sub_style_font_size_var = ctk.IntVar(value=self.cfg.get("sub_style_font_size", 60)) # TƒÉng m·∫∑c ƒë·ªãnh l√™n ch√∫t n·∫øu PlayResY l√† 720
        self.sub_style_font_bold_var = ctk.BooleanVar(value=self.cfg.get("sub_style_font_bold", True))

        self.sub_style_text_color_rgb_str_var = ctk.StringVar(value=self.cfg.get("sub_style_text_color_rgb_str", "255,255,255"))
        self.sub_style_text_opacity_percent_var = ctk.IntVar(value=self.cfg.get("sub_style_text_opacity_percent", 100))

        # M·∫∑c ƒë·ªãnh cho box n·ªÅn l√† t·∫Øt (opacity 0%)
        self.sub_style_background_mode_var = ctk.StringVar(value=self.cfg.get("sub_style_background_mode", "ƒê·ªï B√≥ng"))
        self.sub_style_bg_color_rgb_str_var = ctk.StringVar(value=self.cfg.get("sub_style_bg_color_rgb_str", "0,0,0"))
        self.sub_style_bg_box_actual_opacity_percent_var = ctk.IntVar(value=self.cfg.get("sub_style_bg_box_actual_opacity_percent", 75)) # Gi·ªØ l·∫°i, nh∆∞ng s·∫Ω b·ªã v√¥ hi·ªáu h√≥a n·∫øu box_enabled l√† False

        self.sub_style_outline_enabled_var = ctk.BooleanVar(value=self.cfg.get("sub_style_outline_enabled", False))
        self.sub_style_outline_size_var = ctk.DoubleVar(value=self.cfg.get("sub_style_outline_size", 2.0)) # TƒÉng m·∫∑c ƒë·ªãnh l√™n ch√∫t
        self.sub_style_outline_color_rgb_str_var = ctk.StringVar(value=self.cfg.get("sub_style_outline_color_rgb_str", "0,0,0"))
        self.sub_style_outline_opacity_percent_var = ctk.IntVar(value=self.cfg.get("sub_style_outline_opacity_percent", 100))

        self.sub_style_marginv_var = ctk.IntVar(value=self.cfg.get("margin_v", 60))
        # --- K·∫øt th√∫c bi·∫øn C·∫•u h√¨nh Style Ph·ª• ƒë·ªÅ ---

        self.protocol("WM_DELETE_WINDOW", self.on_close) 
        self.bind("<<QuitApp>>", lambda e: self.on_close(from_event=True))
        
        # --- Icon Khay H·ªá th·ªëng ---
        self.tray_icon = None
        self.tray_thread = None
        self._is_quitting = False

        # --- Kh·ªüi t·∫°o Giao di·ªán ---
        self.tab_view = None
        # subtitle_textbox gi·ªù n·∫±m trong SubtitleTab (self.subtitle_view_frame)
        # Gi·ªØ l·∫°i self.subtitle_textbox = None ƒë·ªÉ t∆∞∆°ng th√≠ch, nh∆∞ng s·∫Ω truy c·∫≠p qua property
        self._subtitle_textbox_ref = None
        self.status_label = None
        self.queue_section = None # H√†ng ch·ªù Ph·ª• ƒë·ªÅ
        self.output_display_label = None # Hi·ªÉn th·ªã ƒë∆∞·ªùng d·∫´n output Ph·ª• ƒë·ªÅ
        self.stop_button = None
        self.add_button = None
        # ƒêƒÉng k√Ω l·ªánh x√°c th·ª±c cho √¥ nh·∫≠p li·ªáu
        self.volume_vcmd = (self.register(validate_volume_input), '%P')


       # Hi·ªÉn th·ªã c·∫£nh b√°o n·∫øu c√≥ l·ªói mutex (kh√¥ng ph·∫£i l·ªói "ƒë√£ t·ªìn t·∫°i")
        if self.mutex_error_occurred and sys.platform == "win32":
            self.after(150, lambda: messagebox.showwarning("C·∫£nh b√°o Mutex", 
                                                           "Kh√¥ng th·ªÉ thi·∫øt l·∫≠p c∆° ch·∫ø instance duy nh·∫•t do l·ªói.\n"
                                                           "·ª®ng d·ª•ng v·∫´n s·∫Ω ch·∫°y nh∆∞ng c√≥ th·ªÉ b·∫°n s·∫Ω m·ªü ƒë∆∞·ª£c nhi·ªÅu c·ª≠a s·ªï.", 
                                                           parent=self))


        # Kh·ªüi t·∫°o l·∫°i dictionary tr·∫°ng th√°i cho c√°c t√°c v·ª• m·ªõi
        self.startup_tasks_status = {
            "dependencies": False, "activation": False, "system_fonts": False, 
            "cuda_check": False, "ai_model": False, "update": False
        }
        self._auto_update_check_done = False
        
        # ƒê√¢y l√† n√∫t "kh·ªüi ƒë·ªông" cho to√†n b·ªô chu·ªói tu·∫ßn t·ª± c·ªßa ch√∫ng ta
        #self.after(500, self._run_startup_tasks_sequentially)
        pass

        # 1) Kh√≥a scale (ƒë·ª´ng set geometry ·ªü ƒë√¢y)
        self._apply_dpi_neutral_scaling()

        # 2) D·ª±ng giao di·ªán
        self.init_ui()

        # 3) Sau khi layout xong m·ªõi ƒë·∫∑t size + cƒÉn gi·ªØa
        self.after_idle(lambda: self._center_window_and_size(margin=(12, 12, 28, 88)))

        # 4) B·∫≠t watcher ƒë·ªÉ khi ƒë·ªïi DPI/m√†n h√¨nh th√¨ scale + center l·∫°i
        self._start_dpi_watcher()
       
        # √Åp d·ª•ng tr·∫°ng th√°i ∆∞u ti√™n CPU ngay khi kh·ªüi ƒë·ªông
        self._set_cpu_priority(self.limit_cpu_var.get())
        
        # 2. G·ªçi c√°c h√†m thi·∫øt l·∫≠p ph·ª• thu·ªôc v√†o UI 
        if PYSTRAY_AVAILABLE:
            self.setup_tray_icon()
        else:
            logging.warning("B·ªè qua thi·∫øt l·∫≠p icon khay h·ªá th·ªëng (pystray kh√¥ng kh·∫£ d·ª•ng).")
        
        self.update_queue_display()
        self.update_download_queue_display()
        self.update_status("‚è± ƒêang ki·ªÉm tra m√¥i tr∆∞·ªùng...")

        self.after(150, self._toggle_block_merge_options_state)
        self.after(200, self.dub_update_image_folder_controls_visibility)
        self.after(250, self._update_manual_mode_ui_elements) 
        self.after(300, self._toggle_dub_flow_options_visibility) 
        self.after(350, lambda: self._set_subtitle_tab_ui_state(subbing_active=False))
        self.after(400, self._on_toggle_manual_merge_mode)
        self.after(2000, self._update_api_stats_display) # T·∫£i v√† hi·ªÉn th·ªã th·ªëng k√™ l·∫ßn ƒë·∫ßu
        # ==========================================
        
        logging.info("Kh·ªüi t·∫°o SubtitleApp ho√†n t·∫•t.")

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # 4.2 T·∫°o Giao di·ªán (init_ui v√† c√°c ph∆∞∆°ng th·ª©c t·∫°o tab)
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    def _apply_dpi_neutral_scaling(self):
        try:
            ctk.set_widget_scaling(1.0)
            ctk.set_window_scaling(1.0)
            if hasattr(ctk, "set_spacing_scaling"):
                ctk.set_spacing_scaling(1.0)
        except Exception as e:
            logging.warning(f"CTk scaling error: {e}")
        try:
            # Gi·ªØ font theo chu·∫©n ~96dpi (·ªïn ƒë·ªãnh gi·ªØa 100%/125%/150%)
            self.tk.call('tk', 'scaling', 96/72.0)
        except Exception:
            pass

    def _center_window_and_size(self, margin=(12, 12, 28, 88)):
        """ƒê·∫∑t k√≠ch th∆∞·ªõc chu·∫©n v√† cƒÉn gi·ªØa, ch·ª´a margin (L,T,R,B) kh·ªèi vi·ªÅn/taskbar."""
        design_w, design_h = 1425, 920

        # L·∫•y v√πng l√†m vi·ªác (ƒë√£ tr·ª´ taskbar). N·∫øu l·ªói, d√πng full screen.
        try:
            wa = self._get_work_area()  # (l, t, r, b, dpi)
            l, t, r, b = wa[0], wa[1], wa[2], wa[3]
        except Exception:
            l, t, r, b = 0, 0, self.winfo_screenwidth(), self.winfo_screenheight()

        ml, mt, mr, mb = margin
        eff_l, eff_t = l + ml, t + mt
        eff_r, eff_b = r - mr, b - mb
        eff_w, eff_h = max(0, eff_r - eff_l), max(0, eff_b - eff_t)

        # N·∫øu m√†n h√¨nh nh·ªè, t·ª± co l·∫°i ƒë·ªÉ v·∫´n ch·ª´a ƒë∆∞·ª£c margin
        w = min(design_w, eff_w)
        h = min(design_h, eff_h)

        x = eff_l + (eff_w - w) // 2
        y = eff_t + (eff_h - h) // 2

        self.geometry(f"{w}x{h}+{x}+{y}")

    def _start_dpi_watcher(self):
        self._last_sig = None
        def _tick():
            try:
                try:
                    sig = self._work_area_signature(self._get_work_area())
                except Exception:
                    sig = None
                if sig != self._last_sig:
                    self._last_sig = sig
                    self._apply_dpi_neutral_scaling()
                    self._center_window_and_size(margin=(12, 12, 28, 88))
            finally:
                self.after(1000, _tick)
        _tick()


# H√†m "nh·∫°c tr∆∞·ªüng" th·ª±c thi tu·∫ßn t·ª± c√°c t√°c v·ª• trong self.startup_task_queue.
    def _run_startup_tasks_sequentially(self):
        """
        Th·ª±c thi tu·∫ßn t·ª± c√°c t√°c v·ª• v√† sau ƒë√≥ ho√†n t·∫•t qu√° tr√¨nh kh·ªüi ƒë·ªông.
        """
        # N·∫øu m√†n h√¨nh ch·ªù ƒë√£ ƒë√≥ng th√¨ d·ª´ng l·∫°i
        if not (hasattr(self, 'splash') and self.splash and self.splash.winfo_exists()):
            return

        # N·∫øu c√≤n t√°c v·ª• trong h√†ng ch·ªù, th·ª±c hi·ªán t√°c v·ª• ti·∫øp theo
        if self.startup_task_queue:
            task = self.startup_task_queue.pop(0)
            logging.info(f"--- B·∫Øt ƒë·∫ßu t√°c v·ª• kh·ªüi ƒë·ªông: {task['name']} ---")
            self.splash.update_status(task["message"])
            
            # H√†m n√†y s·∫Ω ch·∫°y t√°c v·ª• th·ª±c t·∫ø sau m·ªôt kho·∫£ng ch·ªù
            def execute_task():
                task["function"](callback=self._run_startup_tasks_sequentially)

            self.after(task["min_display_time_ms"], execute_task)
        
        else:
            # N·∫øu h√†ng ch·ªù ƒë√£ tr·ªëng, B·∫ÆT ƒê·∫¶U QU√Å TR√åNH K·∫æT TH√öC
            logging.info(">>> T·∫•t c·∫£ t√°c v·ª• trong h√†ng ch·ªù ƒë√£ ch·∫°y xong. B·∫Øt ƒë·∫ßu c√°c b∆∞·ªõc cu·ªëi c√πng.")
            self.after(100, self.check_if_fully_ready) # G·ªçi h√†m ho√†n t·∫•t cu·ªëi c√πng


# H√†m "nh·∫°c tr∆∞·ªüng" duy nh·∫•t ƒë·ªÉ c·∫≠p nh·∫≠t giao di·ªán cho T·∫§T C·∫¢ c√°c n√∫t icon ·ªü footer (Theme v√† CPU) d·ª±a tr√™n tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa ·ª©ng d·ª•ng.       
    def _update_footer_icon_buttons_visuals(self):
        """
        H√†m "nh·∫°c tr∆∞·ªüng" duy nh·∫•t ƒë·ªÉ c·∫≠p nh·∫≠t giao di·ªán cho T·∫§T C·∫¢
        c√°c n√∫t icon ·ªü footer (Theme v√† CPU) d·ª±a tr√™n tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa ·ª©ng d·ª•ng.
        """
        if not self.initial_ui_setup_complete:
            return # Kh√¥ng l√†m g√¨ n·∫øu UI ch∆∞a kh·ªüi t·∫°o xong

        logging.debug("[UI_Update] C·∫≠p nh·∫≠t giao di·ªán t·∫•t c·∫£ c√°c n√∫t icon ·ªü footer.")

        # ƒê·ªãnh nghƒ©a m√†u s·∫Øc v√† font
        selected_color = ("#3B8ED0", "#63B4FF")  # M√†u xanh khi ƒë∆∞·ª£c ch·ªçn
        unselected_color = ("#7F7F7F", "#A0A0A0") # M√†u x√°m khi kh√¥ng ch·ªçn
        
        # --- C·∫≠p nh·∫≠t c√°c n√∫t Theme ---
        current_mode = self.cfg.get("appearance_mode", "dark")
        
        # Helper function n·ªôi b·ªô ƒë·ªÉ tr√°nh l·∫∑p code
        def _update_single_button(button, is_selected):
            if button and button.winfo_exists():
                font_to_use = self.icon_font_selected if is_selected else self.icon_font_normal
                color_to_use = selected_color if is_selected else unselected_color
                button.configure(text_color=color_to_use, font=font_to_use)

        _update_single_button(getattr(self, 'light_mode_button', None), current_mode == "Light")
        _update_single_button(getattr(self, 'dark_mode_button', None), current_mode == "Dark")
        _update_single_button(getattr(self, 'system_mode_button', None), current_mode == "System")
        
        # --- C·∫≠p nh·∫≠t n√∫t CPU ---
        is_cpu_limited = self.limit_cpu_var.get()
        _update_single_button(getattr(self, 'cpu_limit_icon_button', None), is_cpu_limited)


# H√†m ƒë·∫£o ng∆∞·ª£c tr·∫°ng th√°i c·ªßa bi·∫øn limit_cpu_var
    def _toggle_cpu_priority(self):
        """ƒê·∫£o ng∆∞·ª£c tr·∫°ng th√°i c·ªßa bi·∫øn limit_cpu_var."""
        if hasattr(self, 'limit_cpu_var'):
            new_state = not self.limit_cpu_var.get()
            self.limit_cpu_var.set(new_state)
            logging.info(f"ƒê√£ toggle CPU Priority sang: {'ON' if new_state else 'OFF'}")


# DARK MODE
    def change_appearance_mode_event(self, new_appearance_mode: str):
        """Thay ƒë·ªïi giao di·ªán v√† g·ªçi h√†m c·∫≠p nh·∫≠t giao di·ªán c√°c n√∫t icon."""
        ctk.set_appearance_mode(new_appearance_mode)
        logging.info(f"Giao di·ªán ƒë√£ ƒë∆∞·ª£c ƒë·ªïi th√†nh: {new_appearance_mode}")

        self.cfg["appearance_mode"] = new_appearance_mode
        self.save_current_config()

        self.after(20, self._update_footer_icon_buttons_visuals)


#-------------------------------------------
# Nh√≥m H√†m reset H·ªèi ng∆∞·ªùi d√πng x√°c nh·∫≠n v√† b·∫Øt ƒë·∫ßu qu√° tr√¨nh l∆∞u tr·∫°ng th√°i
    def _request_app_reset(self):
        """
        H·ªèi ng∆∞·ªùi d√πng x√°c nh·∫≠n v√† b·∫Øt ƒë·∫ßu qu√° tr√¨nh l∆∞u tr·∫°ng th√°i, kh·ªüi ƒë·ªông l·∫°i.
        """
        logging.info("[AppReset] Ng∆∞·ªùi d√πng y√™u c·∫ßu reset ·ª©ng d·ª•ng.")
        answer = messagebox.askyesno(
            "X√°c nh·∫≠n Kh·ªüi ƒë·ªông l·∫°i",
            "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën l∆∞u c√°c c√†i ƒë·∫∑t hi·ªán t·∫°i v√† kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng kh√¥ng?\n\n"
            "T·∫•t c·∫£ c√°c t√°c v·ª• v√† h√†ng ch·ªù ƒëang x·ª≠ l√Ω s·∫Ω b·ªã h·ªßy.",
            icon='warning',
            parent=self
        )

        if answer:
            logging.info("[AppReset] Ng∆∞·ªùi d√πng ƒë√£ x√°c nh·∫≠n. B·∫Øt ƒë·∫ßu qu√° tr√¨nh reset...")
            self._save_state_for_restart()
            self._restart_application()

# H√†m Thu th·∫≠p v√† l∆∞u tr·∫°ng th√°i c·∫ßn thi·∫øt (c√†i ƒë·∫∑t, v·ªã tr√≠ c·ª≠a s·ªï) v√†o file t·∫°m.
    def _save_state_for_restart(self):
        """
        Thu th·∫≠p v√† l∆∞u tr·∫°ng th√°i c·∫ßn thi·∫øt (c√†i ƒë·∫∑t, v·ªã tr√≠ c·ª≠a s·ªï) v√†o file t·∫°m.
        """
        try:
            # 1. G·ªçi h√†m save_current_config() m√† b·∫°n ƒë√£ c√≥ ƒë·ªÉ l∆∞u t·∫•t c·∫£ c√†i ƒë·∫∑t
            # ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o t·∫•t c·∫£ c√°c t√πy ch·ªçn trong UI ƒë·ªÅu ƒë∆∞·ª£c l∆∞u.
            self.save_current_config()
            logging.info("[AppReset] ƒê√£ g·ªçi save_current_config() th√†nh c√¥ng.")

            # 2. L·∫•y th√™m th√¥ng tin v·ªÅ c·ª≠a s·ªï (v·ªã tr√≠, k√≠ch th∆∞·ªõc)
            window_geometry = self.geometry()
            logging.info(f"[AppReset] L·∫•y geometry c·ª≠a s·ªï: {window_geometry}")

            # 3. T·∫°o m·ªôt dictionary ch·ª©a t·∫•t c·∫£ th√¥ng tin c·∫ßn ph·ª•c h·ªìi
            restore_data = {
                "was_reset": True,
                "window_geometry": window_geometry,
                "current_view": self.view_switcher.get() if hasattr(self, 'view_switcher') else "‚Üì T·∫£i Xu·ªëng"
                # B·∫°n c√≥ th·ªÉ th√™m c√°c th√¥ng tin kh√°c ·ªü ƒë√¢y n·∫øu c·∫ßn,
                # nh∆∞ng h·∫ßu h·∫øt ƒë√£ ƒë∆∞·ª£c l∆∞u trong config.json b·ªüi save_current_config()
            }

            # 4. L∆∞u v√†o file restore_state.json
            # File n√†y s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t c√πng c·∫•p v·ªõi file config.json
            config_path = get_config_path() # D√πng h√†m get_config_path b·∫°n ƒë√£ c√≥
            restore_file_path = os.path.join(os.path.dirname(config_path), "restore_state.json")

            with open(restore_file_path, "w", encoding="utf-8") as f:
                json.dump(restore_data, f, indent=2)

            logging.info(f"[AppReset] ƒê√£ l∆∞u th√†nh c√¥ng tr·∫°ng th√°i ph·ª•c h·ªìi v√†o: {restore_file_path}")

        except Exception as e:
            logging.error(f"[AppReset] L·ªói nghi√™m tr·ªçng khi l∆∞u tr·∫°ng th√°i ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i: {e}", exc_info=True)
            messagebox.showerror("L·ªói L∆∞u Tr·∫°ng Th√°i",
                                 f"Kh√¥ng th·ªÉ l∆∞u tr·∫°ng th√°i ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i:\n{e}\n\n"
                                 "·ª®ng d·ª•ng s·∫Ω th·ª≠ kh·ªüi ƒë·ªông l·∫°i m√† kh√¥ng ph·ª•c h·ªìi.",
                                 parent=self)


# H√†mTho√°t kh·ªèi c√°c b∆∞·ªõc d·ªçn d·∫πp hi·ªán t·∫°i v√† kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng.
    def _restart_application(self):
        """
        (PHI√äN B·∫¢N S·ª¨A L·ªñI)
        Kh·ªüi ƒë·ªông m·ªôt instance m·ªõi c·ªßa ·ª©ng d·ª•ng b·∫±ng subprocess.Popen
        v√† sau ƒë√≥ tho√°t instance hi·ªán t·∫°i m·ªôt c√°ch an to√†n.
        """
        logging.info("[AppReset] ƒêang th·ª±c hi·ªán kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng (s·ª≠ d·ª•ng Popen)...")
        try:
            # L·∫•y c√°c tham s·ªë c·∫ßn thi·∫øt ƒë·ªÉ kh·ªüi ƒë·ªông l·∫°i
            args = [sys.executable] + sys.argv
            logging.info(f"[AppReset] L·ªánh kh·ªüi ƒë·ªông l·∫°i: {args}")

            # THAY ƒê·ªîI: D√πng subprocess.Popen thay v√¨ os.execv
            # Popen s·∫Ω t·∫°o m·ªôt ti·∫øn tr√¨nh m·ªõi v√† kh√¥ng ch·∫∑n ti·∫øn tr√¨nh hi·ªán t·∫°i.
            subprocess.Popen(args)
            
            logging.info("[AppReset] Ti·∫øn tr√¨nh m·ªõi ƒë√£ ƒë∆∞·ª£c kh·ªüi ch·∫°y. B·∫Øt ƒë·∫ßu tho√°t ti·∫øn tr√¨nh hi·ªán t·∫°i...")

            # QUAN TR·ªåNG: G·ªçi h√†m tho√°t ho√†n to√†n ngay sau khi kh·ªüi ch·∫°y ti·∫øn tr√¨nh m·ªõi.
            # H√†m n√†y s·∫Ω x·ª≠ l√Ω vi·ªác d·ª´ng thread, gi·∫£i ph√≥ng Mutex, v√† ƒë√≥ng c·ª≠a s·ªï.
            self._perform_full_quit()

        except Exception as e:
            logging.critical(f"[AppReset] L·ªói nghi√™m tr·ªçng khi th·ª±c thi l·ªánh kh·ªüi ƒë·ªông l·∫°i: {e}", exc_info=True)
            messagebox.showerror("L·ªói Kh·ªüi ƒê·ªông L·∫°i",
                                 f"Kh√¥ng th·ªÉ t·ª± ƒë·ªông kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng:\n{e}\n\n"
                                 "Vui l√≤ng ƒë√≥ng v√† m·ªü l·∫°i ·ª©ng d·ª•ng th·ªß c√¥ng.",
                                 parent=self)
            self.destroy()

        
#===========================================================================================================================================================================
# H√ÄM D·ª∞NG GIAO DI·ªÜN: B·ªê TR√ç V√Ä KH·ªûI T·∫†O C√ÅC TH√ÄNH PH·∫¶N GIAO DI·ªÜN
    def init_ui(self):
        """ Kh·ªüi t·∫°o c·∫•u tr√∫c UI ch√≠nh v·ªõi thanh ƒëi·ªÅu h∆∞·ªõng tab ·ªü tr√™n v√† code t·ªëi ∆∞u. """
        logging.debug("ƒêang kh·ªüi t·∫°o UI (tab ·ªü tr√™n, code t·ªëi ∆∞u)...")

        # --- 1. Khung Header (Logo & Ti√™u ƒë·ªÅ) ---
        header = ctk.CTkFrame(self, fg_color="transparent")
        header.pack(pady=(10, 0), fill="x", padx=10)

        # C·∫•u h√¨nh grid cho header: 1 c·ªôt duy nh·∫•t s·∫Ω gi√£n ra ƒë·ªÉ l·∫•p ƒë·∫ßy kh√¥ng gian
        header.grid_columnconfigure(0, weight=1)

        # --- Frame cho logo v√† ti√™u ƒë·ªÅ (s·∫Ω t·ª± ƒë·ªông cƒÉn gi·ªØa trong grid) ---
        logo_title_frame = ctk.CTkFrame(header, fg_color="transparent")
        # ƒê·∫∑t logo_title_frame v√†o c√πng m·ªôt √¥ grid, n√≥ s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c cƒÉn gi·ªØa
        logo_title_frame.grid(row=0, column=0, sticky="") # sticky="" l√† m·∫∑c ƒë·ªãnh (cƒÉn gi·ªØa)
        
        try:
            logo_path_resized = resource_path("logo_Piu_resized.png")
            logo_img = ctk.CTkImage(light_image=Image.open(logo_path_resized), dark_image=Image.open(logo_path_resized), size=(51, 51))
            ctk.CTkLabel(logo_title_frame, image=logo_img, text="").pack(side="left", pady=(14, 0))
        except Exception as e:
            logging.error(f"L·ªói khi t·∫£i logo: {e}")
        ctk.CTkLabel(logo_title_frame, text=" Piu", font=("Consolas", 60, "bold")).pack(side="left", pady=(10, 0), padx=(0,10))       

        # 3. Kh·ªëi ƒêi·ªÅu h∆∞·ªõng Tab
        top_nav_frame = ctk.CTkFrame(self)
        top_nav_frame.pack(fill="x", padx=0, pady=(15, 5))

        self.view_switcher = ctk.CTkSegmentedButton(
            top_nav_frame,
            values=["‚Üì T·∫£i Xu·ªëng", "‚â° T·∫°o Ph·ª• ƒê·ªÅ", "‚ô™ Thuy·∫øt Minh", "üì§ Upload YT", "‚úç AI Bi√™n T·∫≠p"],
            command=self.switch_view,
            font=("Segoe UI", 13, "bold"),
            height=35,
            corner_radius=8,
            selected_color="#0078D4",
            selected_hover_color="#005A9E"
        )
        self.view_switcher.pack(expand=True, fill="x", padx=25, pady=5)

        # === KHUNG CH·ª®A TH·ªêNG K√ä API ===
        # Frame container ngo√†i c√πng, trong su·ªët, ch·ªâ ƒë·ªÉ cƒÉn ch·ªânh v·ªã tr√≠
        stats_container_frame = ctk.CTkFrame(self, fg_color="transparent")
        stats_container_frame.pack(fill="x", padx=25, pady=(5, 0))

        # Frame con b√™n trong, C√ì M√ÄU N·ªÄN, bao quanh label
        stats_frame_with_bg = ctk.CTkFrame(stats_container_frame, corner_radius=6)
        stats_frame_with_bg.pack(side="right") # ƒê·∫∑t box n√†y ·ªü ph√≠a b√™n ph·∫£i

        # ƒê·∫∑t label th·ªëng k√™ v√†o B√äN TRONG frame c√≥ m√†u n·ªÅn
        self.api_stats_label = ctk.CTkLabel(
            stats_frame_with_bg, # Parent m·ªõi l√† frame c√≥ n·ªÅn
            textvariable=self.api_stats_var,
            font=("Segoe UI", 11, "italic"),
            text_color="gray"
        )
        self.api_stats_label.pack(padx=8, pady=4) # Th√™m padding ƒë·ªÉ text kh√¥ng b·ªã d√≠nh v√†o vi·ªÅn

        # --- 3. Khung N·ªôi dung Ch√≠nh (Ch·ª©a c√°c Panel) ---
        self.main_content_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.main_content_frame.pack(expand=True, fill="both", padx=10, pady=(0, 10))

        # Khai b√°o c√°c frame cho t·ª´ng tab
        self.subtitle_view_frame = SubtitleTab(master=self.main_content_frame, master_app=self)
        self.download_view_frame = DownloadTab(master=self.main_content_frame, master_app=self)
        self.dubbing_view_frame = DubbingTab(master=self.main_content_frame, master_app=self)
        self.youtube_upload_view_frame = YouTubeUploadTab(master=self.main_content_frame, master_app=self)
        
        self.ai_editor_view_frame = AIEditorTab(master=self.main_content_frame, master_app=self)
        
        # --- 4. THANH FOOTER (PHI√äN B·∫¢N T·ªêI ∆ØU V√Ä HO√ÄN CH·ªàNH) ---
        footer_frame = ctk.CTkFrame(self, height=35)
        footer_frame.pack(side="bottom", fill="x", padx=0, pady=(0, 15))

        # --- C·∫•u h√¨nh layout Grid v·ªõi 3 c·ªôt ---
        footer_frame.grid_columnconfigure(0, weight=0)  # C·ªôt 0: Status (c·ªë ƒë·ªãnh)
        footer_frame.grid_columnconfigure(1, weight=1)  # C·ªôt 1: Copyright (gi√£n ra ·ªü gi·ªØa)
        footer_frame.grid_columnconfigure(2, weight=0)  # C·ªôt 2: C√°c n√∫t (c·ªë ƒë·ªãnh)

        # C·ªôt 0: Status Label
        self.status_label = ctk.CTkLabel(footer_frame, text="...", font=("Poppins", 13), anchor='w')
        self.status_label.grid(row=0, column=0, padx=(15, 5), pady=5, sticky="w")

        # C·ªôt 1: Copyright Label (s·∫Ω n·∫±m gi·ªØa)
        ctk.CTkLabel(footer_frame, text=f"¬© {date.today().year} C√¥ng B·∫°c & Piu ‚Äì All rights reserved.", text_color="#888", font=("Poppins", 10)).grid(row=0, column=1, pady=5, sticky="ew")

        # C·ªôt 2: Frame ch·ª©a t·∫•t c·∫£ c√°c n√∫t icon
        buttons_icon_frame = ctk.CTkFrame(footer_frame, fg_color="transparent")
        buttons_icon_frame.grid(row=0, column=2, padx=(5, 10), pady=0, sticky="e")
        
        self.icon_font_normal = ctk.CTkFont(size=16, weight="normal")
        self.icon_font_selected = ctk.CTkFont(size=16, weight="bold")
        
        # --- T·∫°o c√°c n√∫t ---
        # C√°c n√∫t ƒë·ªïi giao di·ªán S√°ng/T·ªëi (s·∫Ω ƒë∆∞·ª£c pack t·ª´ ph·∫£i sang tr√°i, n√™n ch√∫ng s·∫Ω ·ªü b√™n tr√°i)
        theme_buttons_data = [
            ("üíª", "System", "system_mode_button"),
            ("üåô", "Dark", "dark_mode_button"),            
            ("üîÜ", "Light", "light_mode_button")
        ]
        
        # V√≤ng l·∫∑p ƒë·ªÉ t·∫°o c√°c n√∫t theme
        for icon, mode, attr_name in reversed(theme_buttons_data): # ƒê·∫£o ng∆∞·ª£c ƒë·ªÉ pack ƒë√∫ng th·ª© t·ª±
            button = ctk.CTkButton(
                buttons_icon_frame,
                text=icon,
                width=23,
                height=23,
                font=self.icon_font_normal,
                fg_color="transparent",
                text_color=("#7F7F7F", "#A0A0A0"),
                command=lambda m=mode: self.change_appearance_mode_event(m)
            )
            button.pack(side="left", padx=2)
            setattr(self, attr_name, button)

        # D·∫•u g·∫°ch ƒë·ª©ng ƒë·ªÉ ph√¢n c√°ch
        ctk.CTkLabel(buttons_icon_frame, text="|", font=("Segoe UI", 16), text_color="gray50").pack(side="left", padx=5)

        # === N√öT L∆ØU C·∫§U H√åNH D·ª∞ √ÅN ===
        self.save_preset_button = ctk.CTkButton(
            buttons_icon_frame,
            text="üìö",
            width=23,
            height=23,
            font=self.icon_font_normal,
            fg_color="transparent",
            text_color=("#7F7F7F", "#A0A0A0"), 
            command=self._save_project_preset
        )
        self.save_preset_button.pack(side="left", padx=2)
        Tooltip(self.save_preset_button, "L∆∞u c√†i ƒë·∫∑t hi·ªán t·∫°i th√†nh m·ªôt Preset cho d·ª± √°n")

        # === N√öT T·∫¢I C·∫§U H√åNH D·ª∞ √ÅN ===
        self.load_preset_button = ctk.CTkButton(
            buttons_icon_frame,
            text="üìñ",
            width=23,
            height=23,
            font=self.icon_font_normal,
            fg_color="transparent",
            text_color=("#7F7F7F", "#A0A0A0"),
            command=self._load_project_preset
        )
        self.load_preset_button.pack(side="left", padx=2)
        Tooltip(self.load_preset_button, "T·∫£i c√†i ƒë·∫∑t t·ª´ m·ªôt Preset d·ª± √°n ƒë√£ l∆∞u")

        # === N√öT L∆ØU NHANH C·∫§U H√åNH (M·ªöI) ===
        self.quick_save_button = ctk.CTkButton(
            buttons_icon_frame,
            text="üíΩ",  # Icon ƒëƒ©a m·ªÅm
            width=23,
            height=23,
            font=self.icon_font_normal,
            fg_color="transparent",
            text_color=("#7F7F7F", "#A0A0A0"), 
            command=self._quick_save_config # H√†m m·ªõi s·∫Ω t·∫°o ·ªü B∆∞·ªõc 2
        )
        self.quick_save_button.pack(side="left", padx=2)
        Tooltip(self.quick_save_button, "L∆∞u nhanh t·∫•t c·∫£ c√†i ƒë·∫∑t hi·ªán t·∫°i v√†o config.json")
        # === K·∫æT TH√öC TH√äM M·ªöI ===

        # === N√öT RESET ===
        self.reset_app_button = ctk.CTkButton(
            buttons_icon_frame,
            text="ÔªøüíÄ",  # Icon reset
            width=23,
            height=23,
            font=self.icon_font_normal,
            fg_color="transparent",
            text_color=("#C00000", "#FF6347"),  # (M√†u cho Light Mode, Dark Mode) - ƒê·ªè ƒë·∫≠m / ƒê·ªè c√† chua
            hover_color=("#FFCC66", "#FFFF66"),            
            command=self._request_app_reset # H√†m s·∫Ω x·ª≠ l√Ω khi nh·∫•n n√∫t
        )
        self.reset_app_button.pack(side="left", padx=2)
        Tooltip(self.reset_app_button, "L∆∞u c√†i ƒë·∫∑t v√† kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng")

        # N√∫t Gi·∫£m ∆∞u ti√™n CPU (s·∫Ω ƒë∆∞·ª£c pack v√†o b√™n ph·∫£i c√πng)
        self.cpu_limit_icon_button = ctk.CTkButton(
            buttons_icon_frame,
            text="ü™´",  # Icon h√¨nh C·ª•c pin, b·∫°n c√≥ th·ªÉ ƒë·ªïi th√†nh "üê¢" (r√πa) ho·∫∑c icon kh√°c
            width=23,
            height=23,
            font=self.icon_font_normal,
            fg_color="transparent",
            #hover_color=("#D3E5F5", "#2A3B4D"),
            command=self._toggle_cpu_priority # H√†m n√†y s·∫Ω ch·ªâ ƒë·∫£o ng∆∞·ª£c gi√° tr·ªã bi·∫øn
        )
        self.cpu_limit_icon_button.pack(side="left", padx=2)
        Tooltip(self.cpu_limit_icon_button, "Gi·∫£m ∆∞u ti√™n CPU ƒë·ªÉ m√°y ch·∫°y m∆∞·ª£t h∆°n khi x·ª≠ l√Ω t√°c v·ª• n·∫∑ng")

        # --- 5. ƒê·∫∑t View m·∫∑c ƒë·ªãnh ho·∫∑c ph·ª•c h·ªìi ---
        # ∆Øu ti√™n view ƒë√£ ƒë∆∞·ª£c ph·ª•c h·ªìi t·ª´ l·∫ßn reset tr∆∞·ªõc, n·∫øu kh√¥ng th√¨ d√πng m·∫∑c ƒë·ªãnh.
        final_view_to_set = self._initial_view if hasattr(self, '_initial_view') and self._initial_view else "‚â° T·∫°o Ph·ª• ƒê·ªÅ"

        # --- D√≤ng code m·ªõi s·∫Ω n·∫±m ·ªü ƒë√¢y ---
        # N·∫øu final_view_to_set l√† "üì§ Upload YouTube", th√¨ ch√∫ng ta c·∫ßn th√™m m·ªôt bi·∫øn t·∫°m ƒë·ªÉ ƒë·∫£m b·∫£o
        # c√°c bi·∫øn c·∫ßn thi·∫øt cho tab upload ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o tr∆∞·ªõc khi g·ªçi _update_youtube_ui_state
        if final_view_to_set == "üì§ Upload YT":
            # ƒê·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh cho c√°c bi·∫øn n·∫øu ch√∫ng ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë√∫ng c√°ch
            if not hasattr(self, 'youtube_video_path_var'):
                self.youtube_video_path_var = ctk.StringVar(value="")
            if not hasattr(self, 'youtube_title_var'):
                self.youtube_title_var = ctk.StringVar(value="")
            # ... (ki·ªÉm tra v√† kh·ªüi t·∫°o c√°c bi·∫øn kh√°c t∆∞∆°ng t·ª± n·∫øu c·∫ßn, v√≠ d·ª•: youtube_description_var, youtube_tags_var)
            # D√≤ng n√†y ƒë√£ c√≥ ·ªü B∆∞·ªõc 3, ch·ªâ l√† nh·∫Øc l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o b·∫°n ƒë√£ th√™m ƒë·∫ßy ƒë·ªß
            if not hasattr(self, 'is_uploading_youtube'):
                self.is_uploading_youtube = False

            # G·ªçi h√†m _update_youtube_ui_state ban ƒë·∫ßu ƒë·ªÉ thi·∫øt l·∫≠p tr·∫°ng th√°i c√°c n√∫t
            self.after(150, self._update_youtube_ui_state, False) # False: kh√¥ng ƒëang upload
        # --- K·∫øt th√∫c d√≤ng code m·ªõi ---

        self.view_switcher.set(final_view_to_set)
        self.switch_view(final_view_to_set)
        logging.info(f"UI ƒë∆∞·ª£c kh·ªüi t·∫°o v·ªõi view: {final_view_to_set}")

        logging.debug("Kh·ªüi t·∫°o UI (t·ªëi ∆∞u) ho√†n t·∫•t.")


# ==========================================================================================================================================================================================
# C√ÅC TAB UI ƒê√É ƒê∆Ø·ª¢C REFACTOR SANG C√ÅC FILE RI√äNG:
# - SubtitleTab: ui/tabs/subtitle_tab.py
# - DubbingTab: ui/tabs/dubbing_tab.py
# - DownloadTab: ui/tabs/download_tab.py
# - YouTubeUploadTab: ui/tabs/youtube_upload_tab.py
# - AIEditorTab: ui/tabs/ai_editor_tab.py
# ==========================================================================================================================================================================================

    def _update_youtube_path_label_display(self):
        """C·∫≠p nh·∫≠t label hi·ªÉn th·ªã ƒë∆∞·ªùng d·∫´n video ƒë√£ ch·ªçn."""
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if upload_tab:
            upload_tab._update_youtube_path_label_display()

    def _clear_youtube_log(self):
        """X√≥a n·ªôi dung trong √¥ log upload YouTube."""
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if upload_tab:
            upload_tab._clear_youtube_log()

    def _log_youtube_upload(self, message):
        """Ghi log v√†o √¥ upload log YouTube (thread-safe)."""
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if upload_tab:
            upload_tab._log_youtube_upload(message)

    def _update_youtube_progress(self, value):
        """C·∫≠p nh·∫≠t thanh ti·∫øn tr√¨nh upload YouTube (thread-safe). Gi√° tr·ªã t·ª´ 0 ƒë·∫øn 100."""
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if upload_tab:
            upload_tab._update_youtube_progress(value)

#--------------------------------------
# C√ÅC H√ÄM X·ª¨ L√ù T·∫¢I L√äN YOUTUBE ƒê·ªíNG B·ªò
    def _select_youtube_video_file(self):
        """
        M·ªü dialog ch·ªçn file video ƒë·ªÉ upload l√™n YouTube.
        C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n v√† g·ªçi h√†m t·ª± ƒë·ªông ƒëi·ªÅn th√¥ng tin.
        """
        logging.info("[YouTubeUpload] N√∫t 'Ch·ªçn Video Upload' ƒë∆∞·ª£c nh·∫•n.")

        initial_dir = os.path.dirname(self.youtube_video_path_var.get()) if self.youtube_video_path_var.get() and os.path.exists(os.path.dirname(self.youtube_video_path_var.get())) else \
                      (self.dub_output_path_var.get() if hasattr(self, 'dub_output_path_var') and self.dub_output_path_var.get() else get_default_downloads_folder())

        file_path = filedialog.askopenfilename(
            title="Ch·ªçn Video ƒë·ªÉ T·∫£i l√™n YouTube",
            filetypes=[
                ("Video Files", "*.mp4 *.mkv *.mov *.avi *.webm *.flv"),
                ("All Files", "*.*")
            ],
            initialdir=initial_dir,
            parent=self
        )

        if file_path:
            self.youtube_video_path_var.set(file_path)
            logging.info(f"[YouTubeUpload] ƒê√£ ch·ªçn video: {os.path.basename(file_path)}")
            
            # <<< S·ª¨A ƒê·ªîI CH√çNH ·ªû ƒê√ÇY >>>
            # G·ªçi h√†m x·ª≠ l√Ω t·ª± ƒë·ªông ƒëi·ªÅn th√¥ng tin t·∫≠p trung
            self._autofill_youtube_fields()
            
            self._update_youtube_ui_state(False)
        else:
            logging.info("[YouTubeUpload] Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn video.")
            if not self.youtube_video_path_var.get():
                upload_tab = getattr(self, 'youtube_upload_view_frame', None)
                if upload_tab and hasattr(upload_tab, 'youtube_video_path_display_label'):
                    upload_tab.youtube_video_path_display_label.configure(text="(Ch∆∞a ch·ªçn video)")
            
            self._update_youtube_ui_state(False)


    def _perform_autofill_if_needed(self):
        """
        Ki·ªÉm tra xem checkbox autofill c√≥ ƒë∆∞·ª£c b·∫≠t kh√¥ng V√Ä c√≥ file video h·ª£p l·ªá kh√¥ng.
        N·∫øu c√≥, s·∫Ω t·ª± ƒë·ªông ƒëi·ªÅn ti√™u ƒë·ªÅ. H√†m n√†y an to√†n ƒë·ªÉ g·ªçi b·∫•t c·ª© l√∫c n√†o.
        """
        # Ch·ªâ th·ª±c hi·ªán n·∫øu checkbox ƒëang ƒë∆∞·ª£c b·∫≠t
        if not (hasattr(self, 'youtube_autofill_var') and self.youtube_autofill_var.get()):
            return

        video_path = self.youtube_video_path_var.get()
        
        # N·∫øu kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n video th√¨ kh√¥ng l√†m g√¨ c·∫£ (v√† kh√¥ng b·ªè tick checkbox)
        if not video_path or not os.path.exists(video_path):
            return

        # N·∫øu c√≥ ƒë·ªß ƒëi·ªÅu ki·ªán, th·ª±c hi·ªán ƒëi·ªÅn ti√™u ƒë·ªÅ
        logging.info("[YouTubeUI] Autofill ƒë∆∞·ª£c k√≠ch ho·∫°t sau khi ch·ªçn file.")
        default_title = os.path.splitext(os.path.basename(video_path))[0]
        self.youtube_title_var.set(default_title)
        self.update_status(f"‚úÖ ƒê√£ t·ª± ƒë·ªông ƒëi·ªÅn ti√™u ƒë·ªÅ t·ª´ t√™n file.")


    def _start_youtube_batch_upload(self):
        """B·∫Øt ƒë·∫ßu qu√° tr√¨nh x·ª≠ l√Ω h√†ng lo·∫°t c√°c t√°c v·ª• trong h√†ng ch·ªù upload."""
        self.is_chain_handoff = False
        logging.info("[YouTubeUploadStart] ƒê√£ g·ª° kh√≥a is_chain_handoff. Qu√° tr√¨nh upload ch√≠nh th·ª©c b·∫Øt ƒë·∫ßu.")

        self._yt_batch_finished_once = False
        
        if self.is_uploading_youtube:
            messagebox.showwarning("ƒêang b·∫≠n", "ƒêang trong qu√° tr√¨nh upload h√†ng lo·∫°t.", parent=self)
            return
        if not self.youtube_upload_queue:
            messagebox.showinfo("H√†ng ch·ªù tr·ªëng", "Vui l√≤ng th√™m √≠t nh·∫•t m·ªôt video v√†o h√†ng ch·ªù upload.", parent=self)
            return

        logging.info(f"--- B·∫ÆT ƒê·∫¶U UPLOAD H√ÄNG LO·∫†T ({len(self.youtube_upload_queue)} t√°c v·ª•) ---")
        
        self.is_uploading_youtube = True
        self.shutdown_requested_by_task = self.download_shutdown_var.get()
        self.start_time = time.time()
        self.update_time_realtime()
        self.stop_event.clear()
        
        # Ki·ªÉm tra ph∆∞∆°ng th·ª©c upload v√† c√†i ƒë·∫∑t thanh ti·∫øn tr√¨nh t∆∞∆°ng ·ª©ng
        upload_method = self.youtube_upload_method_var.get()
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if upload_tab and hasattr(upload_tab, 'youtube_progress_bar'):
            if upload_method == "browser":
                logging.info("Ch·∫ø ƒë·ªô Upload Tr√¨nh duy·ªát: ƒê·∫∑t thanh ti·∫øn tr√¨nh sang 'indeterminate'.")
                upload_tab.youtube_progress_bar.configure(mode="indeterminate")
                upload_tab.youtube_progress_bar.start()
            else: # Ch·∫ø ƒë·ªô API
                logging.info("Ch·∫ø ƒë·ªô Upload API: ƒê·∫∑t thanh ti·∫øn tr√¨nh sang 'determinate'.")
                upload_tab.youtube_progress_bar.configure(mode="determinate")
                upload_tab.youtube_progress_bar.set(0) # B·∫Øt ƒë·∫ßu t·ª´ 0%

        self._update_youtube_ui_state(True)
        self.update_status(f"B·∫Øt ƒë·∫ßu upload h√†ng lo·∫°t {len(self.youtube_upload_queue)} video...")
        
        # B·∫Øt ƒë·∫ßu x·ª≠ l√Ω v·ªõi t√°c v·ª• ƒë·∫ßu ti√™n trong h√†ng ch·ªù
        self._process_next_youtube_task()

    def _process_next_youtube_task(self):
        """L·∫•y t√°c v·ª• ti·∫øp theo t·ª´ h√†ng ch·ªù upload v√† b·∫Øt ƒë·∫ßu x·ª≠ l√Ω."""
        if self.stop_event.is_set():
            logging.info("Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán. K·∫øt th√∫c h√†ng lo·∫°t upload.")
            self._on_youtube_batch_finished(stopped=True)
            return

        if not self.youtube_upload_queue:
            logging.info("H√†ng ch·ªù upload tr·ªëng. Ho√†n t·∫•t h√†ng lo·∫°t.")
            self._on_youtube_batch_finished(stopped=False)
            return
        
        task = self.youtube_upload_queue[0] 
        self.youtube_currently_processing_task_id = task['id']
        self.update_youtube_queue_display() 

        logging.info(f"ƒêang x·ª≠ l√Ω t√°c v·ª• upload: '{task['title']}' (ID: {task['id']})")
        
        # THAY ƒê·ªîI: L·∫•y tags_str m·ªôt c√°ch an to√†n, m·∫∑c ƒë·ªãnh l√† chu·ªói r·ªóng n·∫øu n√≥ l√† None
        tags_str_from_task = task.get('tags_str') or "" 
        tags = [tag.strip() for tag in tags_str_from_task.split(',') if tag.strip()]
        
        # Quy·∫øt ƒë·ªãnh lu·ªìng s·∫Ω g·ªçi (API ho·∫∑c Tr√¨nh duy·ªát)
        upload_method = self.youtube_upload_method_var.get()
        if upload_method == "api":
            thread = threading.Thread(
                target=self._perform_youtube_upload_thread,
                # L·ªánh g·ªçi cho API ƒë√£ ƒë√∫ng, kh√¥ng c·∫ßn s·ª≠a
                args=(task['video_path'], task['title'], task['description'], tags, task['privacy_status'], True, task['thumbnail_path'], task['playlist_name'], task['category_id']), # <<< TH√äM task['category_id'] V√ÄO ƒê√ÇY
                daemon=True, name="YouTubeAPIUploadWorker"
            )
            thread.start()
        elif upload_method == "browser":
            thread = threading.Thread(
                target=self._upload_video_via_browser_thread,
                # --- B·∫ÆT ƒê·∫¶U S·ª¨A ƒê·ªîI ---
                # TRUY·ªÄN TH√äM `task['thumbnail_path']` V√ÄO CU·ªêI DANH S√ÅCH ARGS
                args=(task['video_path'], task['title'], task['description'], tags, task['privacy_status'], task['playlist_name'], task['thumbnail_path'], task['category_id']), # <<< TH√äM task['category_id'] V√ÄO ƒê√ÇY
                # --- K·∫æT TH√öC S·ª¨A ƒê·ªîI ---
                daemon=True, name="YouTubeBrowserUploadWorker"
            )
            thread.start()


    def _stop_youtube_upload(self):
        """
        D·ª´ng qu√° tr√¨nh upload YouTube ƒëang di·ªÖn ra.
        """
        logging.warning("[YouTubeUpload] Ng∆∞·ªùi d√πng y√™u c·∫ßu d·ª´ng upload YouTube.")
        self.stop_event.set() # D√πng chung stop_event cho vi·ªác d·ª´ng c√°c lu·ªìng d√†i

        # C·ªë g·∫Øng d·ª´ng ti·∫øn tr√¨nh ffmpeg/gapi-client n·∫øu c√≥
        if hasattr(self, 'current_process') and self.current_process and self.current_process.poll() is None:
            logging.info(f"[YouTubeUpload] ƒêang c·ªë g·∫Øng d·ª´ng ti·∫øn tr√¨nh con (PID: {self.current_process.pid})...")
            try:
                self.current_process.terminate()
                self.current_process.wait(timeout=1.0)
            except Exception as e:
                logging.warning(f"[YouTubeUpload] L·ªói khi d·ª´ng ti·∫øn tr√¨nh con: {e}")
            finally:
                self.current_process = None

        self.update_status("üõë ƒêang y√™u c·∫ßu d·ª´ng upload YouTube...")
        # C·∫≠p nh·∫≠t UI s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong _handle_youtube_upload_completion khi lu·ªìng d·ª´ng h·∫≥n

    def _perform_youtube_upload_thread(self, video_path, title, description, tags, privacy_status, is_chained_upload, thumbnail_path, playlist_name, category_id):
        """
        (PHI√äN B·∫¢N 1.2 - HO√ÄN CH·ªàNH V·ªöI X·ª¨ L√ù L·ªñI API)
        Lu·ªìng worker th·ª±c hi·ªán t·∫£i video l√™n YouTube, c·∫≠p nh·∫≠t ti·∫øn tr√¨nh, t·∫£i thumbnail v√† x·ª≠ l√Ω l·ªói chi ti·∫øt.
        """
        worker_log_prefix = f"[YouTubeUploadWorker_V1.2]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu t·∫£i l√™n video: '{os.path.basename(video_path)}'")

        upload_success_final = False
        error_message_final = None
        uploaded_video_id_final = None
        service = None # Khai b√°o service ·ªü scope ngo√†i ƒë·ªÉ kh·ªëi except c√≥ th·ªÉ d√πng

        try:
            if self.stop_event.is_set():
                raise InterruptedError("ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng tr∆∞·ªõc khi upload.")

            from googleapiclient.http import MediaFileUpload
            from googleapiclient.errors import HttpError

            service = get_google_api_service(YOUTUBE_API_SERVICE_NAME, YOUTUBE_API_VERSION)
            
            if service is None:
                raise RuntimeError("Kh√¥ng th·ªÉ x√°c th·ª±c v·ªõi Google API cho YouTube.")

            if not os.path.exists(video_path):
                raise FileNotFoundError(f"T·ªáp video kh√¥ng t·ªìn t·∫°i: {os.path.basename(video_path)}")

            # B·∫Øt ƒë·∫ßu v·ªõi c√°c tr∆∞·ªùng b·∫Øt bu·ªôc trong snippet
            snippet = {
                'title': title,
                'categoryId': category_id
            }
            
            # Ch·ªâ th√™m c√°c tr∆∞·ªùng t√πy ch·ªçn n·∫øu ch√∫ng c√≥ gi√° tr·ªã (kh√¥ng ph·∫£i None)
            if description is not None:
                snippet['description'] = description
            
            # 'tags' ƒë√£ l√† m·ªôt list, n·∫øu n√≥ r·ªóng (kh√¥ng c√≥ tag) th√¨ s·∫Ω kh√¥ng c√≥ v·∫•n ƒë·ªÅ
            if tags:
                snippet['tags'] = tags
            
            # X√¢y d·ª±ng ƒë·ªëi t∆∞·ª£ng 'body' cu·ªëi c√πng t·ª´ c√°c ph·∫ßn ƒë√£ chu·∫©n b·ªã
            body = {
                'snippet': snippet,
                'status': { 
                    'privacyStatus': privacy_status,
                    'selfDeclaredMadeForKids': False 
                }
            }

            self._log_youtube_upload(f"B·∫Øt ƒë·∫ßu t·∫£i l√™n: '{os.path.basename(video_path)}'")
            self._log_youtube_upload(f"Ti√™u ƒë·ªÅ: '{title}'")

            media_body = MediaFileUpload(video_path, chunksize=(1024*1024), resumable=True) # S·ª≠a -1 th√†nh 1MB
            request = service.videos().insert(part=",".join(body.keys()), body=body, media_body=media_body)
            response_from_api = None
            self._log_youtube_upload("ƒêang t·∫£i l√™n video...")
            self._update_youtube_progress(0)

            while response_from_api is None:
                if self.stop_event.is_set():
                    raise InterruptedError("Qu√° tr√¨nh t·∫£i l√™n b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng.")

                try:
                    status, response_from_api = request.next_chunk()
                    if status:
                        # L·∫•y s·ªë byte ƒë√£ t·∫£i v√† t·ªïng k√≠ch th∆∞·ªõc ƒë·ªÉ t√≠nh %
                        bytes_uploaded = status.resumable_progress
                        total_size = status.total_size
                        if total_size > 0:
                            percent_complete = int((bytes_uploaded / total_size) * 100)
                            self._update_youtube_progress(percent_complete)
                            self.after(0, lambda p=percent_complete: self.update_status(f"üì§ ƒêang Upload: {p}% - {os.path.basename(video_path)}"))
                        
                except HttpError as e_chunk:
                    error_content_chunk = e_chunk.content.decode('utf-8', 'replace')
                    if "uploadLimitExceeded" in error_content_chunk:
                        raise HttpError(e_chunk.resp, e_chunk.content, uri=e_chunk.uri) # N√©m l·∫°i l·ªói ƒë·ªÉ kh·ªëi except b√™n ngo√†i b·∫Øt
                    logging.error(f"{worker_log_prefix} L·ªói khi upload chunk: {e_chunk}. S·∫Ω th·ª≠ l·∫°i sau 5 gi√¢y.")
                    self._log_youtube_upload(f"L·ªói m·∫°ng khi ƒëang upload, ƒëang th·ª≠ k·∫øt n·ªëi l·∫°i...")
                    time.sleep(5)
                    continue

            if response_from_api and not self.stop_event.is_set():
                uploaded_video_id_final = response_from_api.get('id')
                if uploaded_video_id_final:
                    upload_success_final = True
                    self._log_youtube_upload(f"‚úÖ T·∫£i l√™n video th√†nh c√¥ng! ID: {uploaded_video_id_final}")
                    self._log_youtube_upload(f"Link video: https://youtu.be/{uploaded_video_id_final}")

                    # 1. T·∫£i l√™n thumbnail n·∫øu c√≥
                    if thumbnail_path and os.path.exists(thumbnail_path):
                        upload_youtube_thumbnail(service, uploaded_video_id_final, thumbnail_path, log_callback=self._log_youtube_upload)
                    else:
                        logging.info("Kh√¥ng c√≥ thumbnail ƒë∆∞·ª£c cung c·∫•p ho·∫∑c file kh√¥ng t·ªìn t·∫°i.")

                    # 2. Th√™m v√†o danh s√°ch ph√°t n·∫øu c√≥
                    if playlist_name:
                        # Initialize cache if not exists
                        if not hasattr(self, 'playlist_cache'):
                            self.playlist_cache = {}
                        playlist_id_found = get_playlist_id_by_name(service, playlist_name, self.playlist_cache)
                        if playlist_id_found:
                            add_video_to_playlist(service, uploaded_video_id_final, playlist_id_found, log_callback=self._log_youtube_upload)
                        else:
                            self._log_youtube_upload(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ID cho danh s√°ch ph√°t '{playlist_name}', b·ªè qua.")
                    else:
                        logging.info("Kh√¥ng c√≥ t√™n danh s√°ch ph√°t ƒë∆∞·ª£c cung c·∫•p.")
                else:
                    error_message_final = "T·∫£i l√™n th√†nh c√¥ng nh∆∞ng kh√¥ng nh·∫≠n ƒë∆∞·ª£c ID video."
            elif not error_message_final:
                error_message_final = "T·∫£i l√™n kh√¥ng th√†nh c√¥ng ho·∫∑c kh√¥ng c√≥ ph·∫£n h·ªìi."            

            if not upload_success_final:
                logging.error(f"{worker_log_prefix} {error_message_final}")

        except InterruptedError as e_known:
            error_message_final = str(e_known)
            logging.warning(f"{worker_log_prefix} {error_message_final}")
        except (FileNotFoundError, RuntimeError) as e_known:
             error_message_final = str(e_known)
             logging.error(f"{worker_log_prefix} {error_message_final}", exc_info=True)
        
        ### B·∫ÆT ƒê·∫¶U KH·ªêI X·ª¨ L√ù L·ªñI HTTP N√ÇNG CAO ###
        except HttpError as e_http:
            error_content = e_http.content.decode('utf-8', 'replace') if hasattr(e_http, 'content') else ""
            error_details_parsed = ""
            try:
                error_json = json.loads(error_content)
                error_details_parsed = error_json.get('error', {}).get('message', 'Kh√¥ng c√≥ chi ti·∫øt l·ªói c·ª• th·ªÉ t·ª´ API.')
            except json.JSONDecodeError:
                error_details_parsed = f"Ph·∫£n h·ªìi l·ªói kh√¥ng ph·∫£i JSON: {error_content[:100]}..."

            if e_http.resp.status == 401:
                error_message_final = (f"L·ªói X√°c th·ª±c (401): Th√¥ng tin ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.\n\n"
                                       f"G·ª£i √Ω: Th·ª≠ x√≥a file 'token.json' v√† ch·∫°y l·∫°i ·ª©ng d·ª•ng ƒë·ªÉ x√°c th·ª±c l·∫°i t√†i kho·∫£n Google.")
                token_path_to_delete = os.path.join(os.path.dirname(get_config_path()), TOKEN_FILENAME)
                if os.path.exists(token_path_to_delete):
                    try:
                        os.remove(token_path_to_delete)
                        logging.info(f"{worker_log_prefix} ƒê√£ t·ª± ƒë·ªông x√≥a file token.json do l·ªói 401: {token_path_to_delete}")
                    except OSError as del_err:
                        logging.warning(f"{worker_log_prefix} Kh√¥ng th·ªÉ t·ª± ƒë·ªông x√≥a token.json: {del_err}")

            elif e_http.resp.status == 403 or "uploadLimitExceeded" in error_content:
                reason = "kh√¥ng r√µ"
                if "uploadLimitExceeded" in error_content:
                    reason = "ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n upload video trong ng√†y c·ªßa YouTube. Vui l√≤ng x√°c minh t√†i kho·∫£n ho·∫∑c ch·ªù 24 gi·ªù."
                elif "forbidden" in error_content.lower():
                    reason = "Kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y. H√£y ƒë·∫£m b·∫£o API YouTube Data v3 ƒë√£ ƒë∆∞·ª£c b·∫≠t trong Google Cloud Console v√† t√†i kho·∫£n c·ªßa b·∫°n c√≥ quy·ªÅn upload."
                error_message_final = f"L·ªói Quy·ªÅn truy c·∫≠p (403): {reason}\nChi ti·∫øt: {error_details_parsed}"
            
            else:
                error_message_final = f"L·ªói Google API (M√£: {e_http.resp.status}): {error_details_parsed}"

            logging.error(f"{worker_log_prefix} {error_message_final}", exc_info=False)
        ### K·∫æT TH√öC KH·ªêI X·ª¨ L√ù L·ªñI HTTP N√ÇNG CAO ###
        
        except Exception as e_general:
            if not error_message_final: error_message_final = f"L·ªói kh√¥ng mong mu·ªën: {e_general}"
            logging.critical(f"{worker_log_prefix} {error_message_final}", exc_info=True)
        
        finally:
            self.after(0, self._handle_youtube_upload_completion, 
                       upload_success_final, 
                       uploaded_video_id_final, 
                       error_message_final, 
                       is_chained_upload)




#---------------------------------

    def _handle_youtube_upload_completion(self, success, video_id, error_message, is_chained_upload):
        """
        v4 (ng·∫Øn g·ªçn): UI c√≤n th√¨ c·∫≠p nh·∫≠t b·∫±ng after(); UI ch·∫øt th√¨ v·∫´n advance batch.
        KH√îNG return s·ªõm ch·ªâ v√¨ UI ƒë√£ b·ªã ph√° h·ªßy.
        """
        log_prefix = "[YouTubeUploadCompletion_v4_Short]"
        task_id = self.youtube_currently_processing_task_id
        logging.info(f"{log_prefix} T√°c v·ª• (ID: {task_id}) ho√†n t·∫•t. Success: {success}, VideoID: {video_id}, Error: {error_message}")

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i task (b·ªô nh·ªõ, kh√¥ng ƒë·ª•ng UI)
        if task_id:
            try:
                t = next((t for t in self.youtube_upload_queue if t.get('id') == task_id), None)
                if t:
                    t['status'] = 'Ho√†n th√†nh ‚úÖ' if success else 'L·ªói ‚ùå'
                    t['video_id'] = video_id
            except Exception:
                pass

        # Log k·∫øt qu·∫£
        try:
            if success:
                self._log_youtube_upload(f"‚úÖ T·∫£i l√™n '{video_id}' th√†nh c√¥ng!")
            else:
                self._log_youtube_upload(f"‚ùå T·∫£i l√™n th·∫•t b·∫°i: {error_message}")
        except Exception:
            pass

        # UI c√≤n kh√¥ng?
        try:
            ui_alive = (not getattr(self, "_is_shutting_down", False)) and bool(self.winfo_exists())
        except Exception:
            ui_alive = False

        def _update_and_proceed():
            # X√≥a task ƒë√£ xong kh·ªèi h√†ng ƒë·ª£i
            if task_id:
                self.youtube_upload_queue = [t for t in self.youtube_upload_queue if t.get('id') != task_id]
            self.youtube_currently_processing_task_id = None

            # C·∫≠p nh·∫≠t UI n·∫øu c√≤n, tr√°nh TclError
            if ui_alive:
                try:
                    self.update_youtube_queue_display()
                except Exception as e:
                    logging.debug(f"{log_prefix} B·ªè qua update UI: {e}")

            # Ti·∫øn h√†nh t√°c v·ª• ti·∫øp theo / k·∫øt th√∫c
            try:
                if not self.stop_event.is_set():
                    if self.youtube_upload_queue:
                        self._process_next_youtube_task()
                    else:
                        self._on_youtube_batch_finished(stopped=False)
                else:
                    self._on_youtube_batch_finished(stopped=True)
            except Exception as e:
                logging.error(f"{log_prefix} L·ªói khi advance batch: {e}", exc_info=True)
                # D√π l·ªói, v·∫´n c·ªë k·∫øt th√∫c batch ƒë·ªÉ kh√¥ng treo
                try:
                    self._on_youtube_batch_finished(stopped=False)
                except Exception:
                    pass

        if ui_alive:
            # UI c√≤n ‚Üí c·∫≠p nh·∫≠t/advance tr√™n main thread
            self.after(100, _update_and_proceed)
        else:
            # UI ƒë√£ ƒë√≥ng ‚Üí v·∫´n advance ·ªü n·ªÅn, kh√¥ng treo batch
            logging.warning("[YouTubeUploadCompletion] UI ƒë√£ ƒë√≥ng. B·ªè qua UI, v·∫´n advance batch.")
            import threading
            threading.Thread(target=_update_and_proceed, daemon=True).start()


#----------------------------------
    def _on_youtube_batch_finished(self, stopped=False):
        """ƒê∆∞·ª£c g·ªçi khi t·∫•t c·∫£ c√°c t√°c v·ª• trong h√†ng ch·ªù upload ƒë√£ ho√†n th√†nh ho·∫∑c b·ªã d·ª´ng."""
        # Ch·∫∑n g·ªçi tr√πng
        if getattr(self, "_yt_batch_finished_once", False):
            logging.debug("[BatchFinished] Duplicate call ignored.")
            return
        self._yt_batch_finished_once = True

        logging.info(f"--- K·∫æT TH√öC UPLOAD H√ÄNG LO·∫†T (B·ªã d·ª´ng: {stopped}) ---")

        self.is_uploading_youtube = False
        self.youtube_currently_processing_task_id = None
        self.start_time = None

        # Progress bar/UI cleanup an to√†n
        try:
            if hasattr(self, "youtube_progress_bar") and self.youtube_progress_bar.winfo_exists():
                self.youtube_progress_bar.stop()
                self.youtube_progress_bar.configure(mode="determinate")
                self.youtube_progress_bar.set(0)
        except Exception as e:
            logging.debug(f"[BatchFinished] Progress bar cleanup skipped: {e}")

        try:
            self._update_youtube_ui_state(False, silent=True)
            self.update_youtube_queue_display()
        except Exception as e:
            logging.debug(f"[BatchFinished] UI state update skipped: {e}")

        # ƒê·ªçc c·ªù "t·∫Øt m√°y khi xong"
        should_shutdown = False
        try:
            if hasattr(self, "shutdown_after_tasks_var"):
                should_shutdown = bool(self.shutdown_after_tasks_var.get())
        except Exception:
            pass

        # Tr·∫°ng th√°i cu·ªëi
        if stopped:
            self.update_status("üõë H√†ng lo·∫°t upload ƒë√£ d·ª´ng.")
        else:
            self.update_status("‚úÖ Ho√†n t·∫•t t·∫•t c·∫£ t√°c v·ª• upload!")

        # üëâüëâ G·ªåI CHECK SHUTDOWN TR∆Ø·ªöC POPUP (ƒë·ªÉ l·ªánh t·∫Øt m√°y ch·∫°y ngay)
        try:
            self._check_completion_and_shutdown()
        except Exception as e:
            logging.debug(f"[BatchFinished] check_completion_and_shutdown error: {e}")

        # N·∫øu ƒëang b·∫≠t t·∫Øt m√°y th√¨ KH√îNG hi·ªán popup (tr√°nh ch·∫∑n)
        if not should_shutdown:
            # Ph√°t √¢m thanh (n·∫øu c√≥)
            try:
                if (hasattr(self, "download_sound_var") and self.download_sound_var.get()
                    and hasattr(self, "download_sound_path_var") and self.download_sound_path_var.get()
                    and os.path.isfile(self.download_sound_path_var.get())):
                    play_sound_async(self.download_sound_path_var.get())
            except Exception as e:
                logging.debug(f"[BatchFinished] play_sound skipped: {e}")

            # Popup th√¥ng b√°o (kh√¥ng b·∫Øt bu·ªôc)
            try:
                messagebox.showinfo("Ho√†n th√†nh", "ƒê√£ upload xong t·∫•t c·∫£ c√°c video trong h√†ng ch·ªù.", parent=self)
            except Exception as e:
                logging.debug(f"[BatchFinished] showinfo skipped: {e}")


    def _update_youtube_ui_state(self, is_uploading: bool, *, silent: bool = False):
        """
        C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa c√°c n√∫t v√† tr∆∞·ªùng nh·∫≠p li·ªáu tr√™n tab Upload YouTube.
        N·∫øu silent=True: KH√îNG c·∫≠p nh·∫≠t status_label ƒë·ªÉ tr√°nh ghi ƒë√® th√¥ng ƒëi·ªáp '‚úÖ Ho√†n t·∫•t...' ·ªü cu·ªëi batch.
        """
        logging.debug(f"[YouTubeUploadUI] C·∫≠p nh·∫≠t tr·∫°ng th√°i UI, is_uploading={is_uploading}, silent={silent}")
        self.is_uploading_youtube = is_uploading
        
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if not upload_tab:
            return

        # Ki·ªÉm Tra B·∫£n Quy·ªÅn
        is_app_active = self._is_app_fully_activated()

        # X√°c ƒë·ªãnh tr·∫°ng th√°i m·ª•c ti√™u cho c√°c control
        can_interact = is_app_active and not is_uploading
        target_state_normal = "normal" if can_interact else "disabled"

        # --- N√∫t Upload ---
        if hasattr(upload_tab, 'youtube_start_upload_button') and upload_tab.youtube_start_upload_button.winfo_exists():
            if is_uploading:
                upload_tab.youtube_start_upload_button.configure(state="disabled", text="üì§ ƒêang Upload...")
            elif not is_app_active:
                upload_tab.youtube_start_upload_button.configure(state="disabled", text="üîí K√≠ch ho·∫°t (Upload)")
            else:
                # Ch·ªâ b·∫≠t khi h√†ng ch·ªù c√≥ t√°c v·ª•
                if getattr(self, "youtube_upload_queue", None):
                    try:
                        qlen = len(self.youtube_upload_queue)
                    except Exception:
                        qlen = 0
                    upload_tab.youtube_start_upload_button.configure(state="normal", text=f"üì§ B·∫Øt ƒë·∫ßu Upload ({qlen} video)")
                else:
                    upload_tab.youtube_start_upload_button.configure(state="disabled", text="üì§ B·∫Øt ƒë·∫ßu Upload H√†ng lo·∫°t")

        # --- N√∫t D·ª´ng ---
        if hasattr(upload_tab, 'youtube_stop_upload_button') and upload_tab.youtube_stop_upload_button.winfo_exists():
            upload_tab.youtube_stop_upload_button.configure(state="normal" if is_uploading else "disabled")

        # --- N√∫t Ch·ªçn Video ---
        if hasattr(upload_tab, 'youtube_select_video_button') and upload_tab.youtube_select_video_button.winfo_exists():
            if not is_app_active:
                upload_tab.youtube_select_video_button.configure(state="disabled", text="üîí K√≠ch ho·∫°t")
            else:
                upload_tab.youtube_select_video_button.configure(state=target_state_normal, text="üìÅ Ch·ªçn Video Upload...")

        # --- C√°c tr∆∞·ªùng nh·∫≠p li·ªáu ---
        if hasattr(upload_tab, 'youtube_title_entry') and upload_tab.youtube_title_entry and upload_tab.youtube_title_entry.winfo_exists():
            upload_tab.youtube_title_entry.configure(state=target_state_normal)
        if hasattr(upload_tab, 'youtube_tags_entry') and upload_tab.youtube_tags_entry and upload_tab.youtube_tags_entry.winfo_exists():
            upload_tab.youtube_tags_entry.configure(state=target_state_normal)
        if hasattr(upload_tab, 'youtube_privacy_optionmenu') and upload_tab.youtube_privacy_optionmenu and upload_tab.youtube_privacy_optionmenu.winfo_exists():
            upload_tab.youtube_privacy_optionmenu.configure(state=target_state_normal)
        if hasattr(upload_tab, 'youtube_description_textbox') and upload_tab.youtube_description_textbox and upload_tab.youtube_description_textbox.winfo_exists():
            upload_tab.youtube_description_textbox.configure(state=target_state_normal)

        # --- N√∫t Clear Log ---
        if hasattr(upload_tab, 'youtube_clear_log_button') and upload_tab.youtube_clear_log_button.winfo_exists():
            upload_tab.youtube_clear_log_button.configure(state=target_state_normal)

        # --- Checkbox T·ª± ƒë·ªông Upload ---
        if hasattr(upload_tab, 'auto_upload_checkbox') and upload_tab.auto_upload_checkbox.winfo_exists():
            upload_tab.auto_upload_checkbox.configure(state=target_state_normal)

        # --- Progressbar: ch·∫ø ƒë·ªô & an to√†n kh√¥ng b·ªã k·∫πt ---
        try:
            if hasattr(upload_tab, 'youtube_progress_bar') and upload_tab.youtube_progress_bar.winfo_exists():
                if is_uploading:
                    # B·∫Øt ƒë·∫ßu upload: ƒë·∫£m b·∫£o indeterminate + ch·∫°y animation
                    upload_tab.youtube_progress_bar.stop()              # reset v√≤ng l·∫∑p n·∫øu c√≥
                    upload_tab.youtube_progress_bar.configure(mode="indeterminate")
                    upload_tab.youtube_progress_bar.set(0)              # thanh tr·ªëng (kh√¥ng % c·ª• th·ªÉ)
                    try:
                        # CTkProgressBar: start() kh√¥ng nh·∫≠n tham s·ªë; n·∫øu b·∫°n d√πng ttk th√¨ start(10) = 10ms/step
                        upload_tab.youtube_progress_bar.start()
                    except Exception:
                        pass
                else:
                    # Kh√¥ng upload: d·ª´ng, chuy·ªÉn determinate, v·ªÅ 0
                    upload_tab.youtube_progress_bar.stop()
                    upload_tab.youtube_progress_bar.configure(mode="determinate")
                    upload_tab.youtube_progress_bar.set(0)
        except Exception as e:
            logging.debug(f"[YouTubeUploadUI] Progressbar cleanup skipped: {e}")

        # --- C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i (tu·ª≥ theo silent) ---
        if not silent and hasattr(self, 'status_label'):
            if is_uploading:
                # Th√¥ng ƒëi·ªáp m·∫∑c ƒë·ªãnh khi ƒëang upload (n·∫øu n∆°i kh√°c ch∆∞a set c·ª• th·ªÉ)
                self.update_status("üì§ ƒêang upload l√™n YouTube...")
            else:
                if not is_app_active:
                    self.update_status("‚õî Y√™u c·∫ßu K√≠ch ho·∫°t (YouTube Upload)")
                else:
                    # Ki·ªÉm tra input c∆° b·∫£n ƒë·ªÉ g·ª£i √Ω 's·∫µn s√†ng'
                    has_path = False
                    has_title = False
                    try:
                        has_path = bool(self.youtube_video_path_var.get().strip())
                    except Exception:
                        pass
                    try:
                        has_title = bool(self.youtube_title_var.get().strip())
                    except Exception:
                        pass
                    if has_path and has_title:
                        self.update_status("‚úÖ YouTube: S·∫µn s√†ng upload.")
                    else:
                        self.update_status("‚ÑπÔ∏è YouTube: ƒêang ch·ªù ch·ªçn video/nh·∫≠p th√¥ng tin.")


# C·∫≠p nh·∫≠t thanh ti·∫øn tr√¨nh upload YouTube (thread-safe)


# 2 H√†m Logic ƒë·ªÉ Ch·ªçn File Thumbnail
    def _select_youtube_thumbnail(self):
        """M·ªü dialog ƒë·ªÉ ch·ªçn file ·∫£nh cho thumbnail."""
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn ·∫¢nh Thumbnail (t·ª∑ l·ªá 16:9)",
            filetypes=[
                ("Image Files", "*.jpg *.jpeg *.png"),
                ("All Files", "*.*")
            ],
            parent=self
        )
        if file_path and os.path.exists(file_path):
            self.youtube_thumbnail_path_var.set(file_path)
            # C·∫≠p nh·∫≠t label hi·ªÉn th·ªã
            upload_tab = getattr(self, 'youtube_upload_view_frame', None)
            if upload_tab and hasattr(upload_tab, 'youtube_thumbnail_path_display_label'):
                upload_tab.youtube_thumbnail_path_display_label.configure(text=os.path.basename(file_path), text_color=("#0B8457", "lightgreen"))
            self.update_status(f"ƒê√£ ch·ªçn thumbnail: {os.path.basename(file_path)}")
        elif not file_path:
            # N·∫øu ng∆∞·ªùi d√πng h·ªßy v√† ch∆∞a c√≥ g√¨ ƒë∆∞·ª£c ch·ªçn, reset l·∫°i
            if not self.youtube_thumbnail_path_var.get():
                upload_tab = getattr(self, 'youtube_upload_view_frame', None)
                if upload_tab and hasattr(upload_tab, 'youtube_thumbnail_path_display_label'):
                    upload_tab.youtube_thumbnail_path_display_label.configure(text="(Ch∆∞a ch·ªçn ·∫£nh)", text_color=("gray30", "gray70"))
            logging.info("Ng∆∞·ªùi d√πng h·ªßy ch·ªçn thumbnail.")
        else:
            messagebox.showwarning("File kh√¥ng t·ªìn t·∫°i", f"File ·∫£nh '{file_path}' kh√¥ng t·ªìn t·∫°i.", parent=self)
            self.youtube_thumbnail_path_var.set("")
            upload_tab = getattr(self, 'youtube_upload_view_frame', None)
            if upload_tab and hasattr(upload_tab, 'youtube_thumbnail_path_display_label'):
                upload_tab.youtube_thumbnail_path_display_label.configure(text="(File kh√¥ng t·ªìn t·∫°i!)", text_color="red")

#----------------------------
# C√ÅC H√ÄM CHO UPLOAD B·∫∞NG TR√åNH DUY·ªÜT
    def _on_upload_method_changed(self, selected_method):
        """
        X·ª≠ l√Ω khi ng∆∞·ªùi d√πng thay ƒë·ªïi ph∆∞∆°ng th·ª©c upload (API ho·∫∑c Tr√¨nh duy·ªát).
        Hi·ªÉn th·ªã ho·∫∑c ·∫©n khung c·∫•u h√¨nh Chrome Portable.
        """
        logging.info(f"Ph∆∞∆°ng th·ª©c Upload YouTube thay ƒë·ªïi th√†nh: {selected_method}")
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if upload_tab:
            if selected_method == "browser":
                if hasattr(upload_tab, 'chrome_portable_config_frame') and hasattr(upload_tab, 'upload_method_radio_browser'):
                    upload_tab.chrome_portable_config_frame.pack(fill="x", padx=10, pady=(0, 10), after=upload_tab.upload_method_radio_browser.master)
                # C·∫≠p nh·∫≠t hi·ªÉn th·ªã label cho ƒë∆∞·ªùng d·∫´n hi·ªán t·∫°i
                if hasattr(upload_tab, 'chrome_portable_path_display_label'):
                    update_path_label(upload_tab.chrome_portable_path_display_label, self.chrome_portable_path_var.get())
                if hasattr(upload_tab, 'chromedriver_path_display_label'):
                    update_path_label(upload_tab.chromedriver_path_display_label, self.chromedriver_path_var.get())
                self.update_status("üì§ YouTube: ƒê√£ ch·ªçn upload qua Tr√¨nh duy·ªát.")
            else:
                if hasattr(upload_tab, 'chrome_portable_config_frame'):
                    upload_tab.chrome_portable_config_frame.pack_forget()
                self.update_status("üì§ YouTube: ƒê√£ ch·ªçn upload qua API.")
        
        # L∆∞u l·∫°i l·ª±a ch·ªçn v√†o config
        self.cfg["youtube_upload_method"] = selected_method
        self.save_current_config()
        # C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa n√∫t "B·∫Øt ƒë·∫ßu Upload"
        self._update_youtube_ui_state(self.is_uploading_youtube)


    def _browse_chrome_portable_path(self):
        """M·ªü dialog ch·ªçn ƒë∆∞·ªùng d·∫´n ƒë·∫øn Chrome.exe c·ªßa Chrome Portable."""
        initial_dir = os.path.dirname(self.chrome_portable_path_var.get()) if self.chrome_portable_path_var.get() else os.path.expanduser("~")
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn Chrome.exe (trong th∆∞ m·ª•c Chrome Portable)",
            initialdir=initial_dir,
            filetypes=[("Executable files", "*.exe"), ("All files", "*.*")],
            parent=self
        )
        if file_path:
            self.chrome_portable_path_var.set(file_path)
            upload_tab = getattr(self, 'youtube_upload_view_frame', None)
            if upload_tab and hasattr(upload_tab, 'chrome_portable_path_display_label'):
                update_path_label(upload_tab.chrome_portable_path_display_label, file_path)
            self.cfg["chrome_portable_path"] = file_path # L∆∞u v√†o config
            self.save_current_config()


    def _browse_chromedriver_path(self):
        """M·ªü dialog ch·ªçn ƒë∆∞·ªùng d·∫´n ƒë·∫øn chromedriver.exe."""
        initial_dir = os.path.dirname(self.chromedriver_path_var.get()) if self.chromedriver_path_var.get() else os.path.expanduser("~")
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn chromedriver.exe",
            initialdir=initial_dir,
            filetypes=[("Executable files", "chromedriver.exe"), ("All files", "*.*")],
            parent=self
        )
        if file_path:
            self.chromedriver_path_var.set(file_path)
            upload_tab = getattr(self, 'youtube_upload_view_frame', None)
            if upload_tab and hasattr(upload_tab, 'chromedriver_path_display_label'):
                update_path_label(upload_tab.chromedriver_path_display_label, file_path)
            self.cfg["chromedriver_path"] = file_path # L∆∞u v√†o config
            self.save_current_config()


# ======================================================================================
# PHI√äN B·∫¢N 9.6 - T√çCH H·ª¢P H√ÄM CLICK M·∫†NH M·∫º
# ======================================================================================

# Ph∆∞∆°ng th·ª©c click "t·ªëi th∆∞·ª£ng" v·ªõi 3 l·ªõp fallback v√† c∆° ch·∫ø ch·ªëng Stale Element
# Method _click_with_fallback ƒë√£ ƒë∆∞·ª£c extracted v√†o services/youtube_browser_upload_service.py

# H√†m upload ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·ªÉ s·ª≠ d·ª•ng h√†m click m·ªõi        
    def _upload_video_via_browser_thread(self, video_path, title, description, tags, privacy_status, playlist_name, thumbnail_path_from_task, category_id):
        """
        Lu·ªìng worker th·ª±c hi·ªán upload qua tr√¨nh duy·ªát.
        >>> PHI√äN B·∫¢N 9.10: N√¢ng c·∫•p ch·ªçn Th·∫ª video ƒë·ªÉ l·∫•y ng·∫´u nhi√™n 1 trong T·∫§T C·∫¢ c√°c playlist c√≥ s·∫µn. <<<
        >>> S·ª¨A L·ªñI v9.8: ƒê√£ s·ª≠a t·∫•t c·∫£ c√°c l·ªánh click ƒë·ªÉ truy·ªÅn LOCATOR thay v√¨ ELEMENT. <<<
        """
        import random
        
        with keep_awake("Upload YouTube via browser"):  # <<< GI·ªÆ M√ÅY TH·ª®C TRONG SU·ªêT QU√Å TR√åNH UP

            worker_log_prefix = "[BrowserUploadWorker_v9.8_FixedCalls]"
            logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu upload video '{os.path.basename(video_path)}' qua tr√¨nh duy·ªát.")

            # --- Ph·∫ßn kh·ªüi t·∫°o driver gi·ªØ nguy√™n ---
            # (Gi·ªØ nguy√™n to√†n b·ªô ph·∫ßn kh·ªüi t·∫°o driver v√† c√°c c·∫•u h√¨nh c·ªßa b·∫°n)
            chrome_portable_exe_path = self.chrome_portable_path_var.get()
            chromedriver_exe_path = self.chromedriver_path_var.get()

            if not chrome_portable_exe_path or not os.path.exists(chrome_portable_exe_path):
                error_msg = "ƒê∆∞·ªùng d·∫´n Chrome Portable kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t√¨m th·∫•y. Vui l√≤ng c·∫•u h√¨nh l·∫°i trong tab 'Upload YT'."
                logging.error(f"{worker_log_prefix} {error_msg}")
                self.after(0, lambda: messagebox.showerror("L·ªói C·∫•u H√¨nh", error_msg, parent=self))
                self._handle_youtube_upload_completion(False, None, error_msg, False)
                return

            if not chromedriver_exe_path or not os.path.exists(chromedriver_exe_path):
                logging.warning(f"{worker_log_prefix} ChromeDriver kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t√¨m th·∫•y. Th·ª≠ t·ª± ƒë·ªông t·∫£i...")
                try:
                    chromedriver_exe_path = ChromeDriverManager().install()
                    self.chromedriver_path_var.set(chromedriver_exe_path)
                    self.save_current_config()
                    logging.info(f"{worker_log_prefix} ƒê√£ t·ª± ƒë·ªông t·∫£i ChromeDriver th√†nh c√¥ng: {chromedriver_exe_path}")
                except Exception as e_chromedriver_dl:
                    error_msg = f"Kh√¥ng th·ªÉ t√¨m ho·∫∑c t·ª± ƒë·ªông t·∫£i ChromeDriver. L·ªói: {e_chromedriver_dl}.\n\nVui l√≤ng t·∫£i ChromeDriver th·ªß c√¥ng..."
                    logging.error(f"{worker_log_prefix} {error_msg}")
                    self.after(0, lambda: messagebox.showerror("L·ªói ChromeDriver", error_msg, parent=self))
                    self._handle_youtube_upload_completion(False, None, error_msg, False)
                    return

            driver = None
            service = None
            max_driver_init_retries = 3
            driver_init_delay_seconds = 5
            config_directory = os.path.dirname(get_config_path())
            user_data_dir_for_chrome = os.path.join(config_directory, "ChromeProfile")

            cleanup_stale_chrome_processes(user_data_dir_for_chrome)
            time.sleep(1)

            for attempt in range(max_driver_init_retries):
                try:
                    logging.info(f"{worker_log_prefix} ƒêang kh·ªüi t·∫°o WebDriver (th·ª≠ l·∫ßn {attempt + 1}/{max_driver_init_retries})...")
                    chrome_options = webdriver.ChromeOptions()
                    chrome_options.binary_location = chrome_portable_exe_path                
                    # 1. Gi·∫£ m·∫°o User-Agent c·ªßa m·ªôt tr√¨nh duy·ªát Chrome th·∫≠t tr√™n Windows
                    user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"
                    chrome_options.add_argument(f'user-agent={user_agent}')
                    
                    # 2. C√°c c·ªù ƒë·ªÉ v√¥ hi·ªáu h√≥a t√≠nh nƒÉng t·ª± ƒë·ªông h√≥a m√† trang web c√≥ th·ªÉ ph√°t hi·ªán
                    chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
                    chrome_options.add_experimental_option('useAutomationExtension', False)
                    chrome_options.add_argument("--disable-blink-features=AutomationControlled")

                    # <<< THAY ƒê·ªîI 1: Lu√¥n thi·∫øt l·∫≠p k√≠ch th∆∞·ªõc c·ª≠a s·ªï cho headless mode >>>
                    if self.youtube_headless_var.get():
                        logging.info(f"{worker_log_prefix} Ch·∫°y ·ªü ch·∫ø ƒë·ªô kh√¥ng ƒë·∫ßu (headless) v·ªõi k√≠ch th∆∞·ªõc c·ª≠a s·ªï 1920x1080.")
                        chrome_options.add_argument("--headless=new")
                        chrome_options.add_argument("--window-size=1920,1080") # R·∫•t quan tr·ªçng!
                    else:
                        logging.info(f"{worker_log_prefix} Ch·∫°y ·ªü ch·∫ø ƒë·ªô c√≥ giao di·ªán.")        

                    chrome_options.add_argument("--no-sandbox")
                    chrome_options.add_argument("--disable-dev-shm-usage")
                    chrome_options.add_argument("--disable-gpu")
                    chrome_options.add_argument("--disable-extensions")
                    chrome_options.add_argument("--disable-infobars")
                    chrome_options.add_argument("--disable-browser-side-navigation")
                    chrome_options.add_argument("--disable-features=RendererCodeIntegrity")
                    chrome_options.add_argument("--disable-background-networking")
                    chrome_options.add_argument("--disable-default-apps")
                    chrome_options.add_argument("--disable-sync")
                    chrome_options.add_argument("--no-default-browser-check")
                    chrome_options.add_argument("--disable-popup-blocking")
                    chrome_options.add_argument("--ignore-certificate-errors")
                    chrome_options.add_argument("--remote-debugging-port=9222")
                    chrome_options.add_argument("--log-level=3")
                    prefs = {"profile.default_content_setting_values.notifications": 2}
                    chrome_options.add_experimental_option("prefs", prefs)
                    os.makedirs(user_data_dir_for_chrome, exist_ok=True)
                    chrome_options.add_argument(f"user-data-dir={user_data_dir_for_chrome}")
                    logging.info(f"{worker_log_prefix} S·ª≠ d·ª•ng User Data Directory: {user_data_dir_for_chrome}")
                    service = Service(chromedriver_exe_path, log_path=os.path.join(config_directory, "chromedriver.log"))
                    driver = webdriver.Chrome(service=service, options=chrome_options)
                    logging.info(f"{worker_log_prefix} WebDriver ƒë√£ kh·ªüi ƒë·ªông th√†nh c√¥ng.")
                    break
                except Exception as e_driver_init:
                    logging.error(f"{worker_log_prefix} L·ªói khi kh·ªüi t·∫°o WebDriver (th·ª≠ l·∫ßn {attempt + 1}): {e_driver_init}", exc_info=False)
                    if os.path.exists(user_data_dir_for_chrome):
                        try:
                            shutil.rmtree(user_data_dir_for_chrome)
                            logging.warning(f"{worker_log_prefix} ƒê√£ x√≥a th∆∞ m·ª•c User Data Directory.")
                        except Exception as e_rm:
                            logging.error(f"{worker_log_prefix} L·ªói khi x√≥a th∆∞ m·ª•c profile: {e_rm}")
                    if attempt < max_driver_init_retries - 1:
                        time.sleep(driver_init_delay_seconds)
                    else:
                        error_msg_init = f"Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông tr√¨nh duy·ªát Chrome sau {max_driver_init_retries} l·∫ßn th·ª≠."
                        self.after(0, lambda: messagebox.showerror("L·ªói Kh·ªüi T·∫°o Tr√¨nh Duy·ªát", f"{error_msg_init}\n\nChi ti·∫øt: {e_driver_init}", parent=self))
                        self._handle_youtube_upload_completion(False, None, error_msg_init, False)
                        return
            
            if driver is None:
                self._handle_youtube_upload_completion(False, None, "WebDriver kh√¥ng kh·ªüi t·∫°o ƒë∆∞·ª£c.", False)
                return

            # --- C·∫¨P NH·∫¨T LOCATORS: TH√äM ID CHO LINK VIDEO ---
            YOUTUBE_LOCATORS = {
                # --- C√°c locators kh√¥ng ƒë·ªïi ---
                "title": (By.XPATH, "//div[@aria-label='Th√™m ti√™u ƒë·ªÅ ƒë·ªÉ m√¥ t·∫£ video c·ªßa b·∫°n (nh·∫≠p k√Ω t·ª± @ ƒë·ªÉ ƒë·ªÅ c·∫≠p t√™n m·ªôt k√™nh)' or @aria-label='Add a title that describes your video (type @ to mention a channel)']"),
                "description": (By.XPATH, "//div[@aria-label='Gi·ªõi thi·ªáu v·ªÅ video c·ªßa b·∫°n cho ng∆∞·ªùi xem (nh·∫≠p k√Ω t·ª± @ ƒë·ªÉ ƒë·ªÅ c·∫≠p t√™n m·ªôt k√™nh)' or @aria-label='Tell viewers about your video (type @ to mention a channel)']"),
                "not_for_kids": (By.NAME, "VIDEO_MADE_FOR_KIDS_NOT_MFK"),
                "next_button": (By.ID, "next-button"),
                "done_button": (By.ID, "done-button"),
                "video_url_link": (By.XPATH, "//a[contains(@href, 'youtu.be/') or contains(@href, '/shorts/')]"),
                "privacy_private_radio": (By.CSS_SELECTOR, "tp-yt-paper-radio-button[name='PRIVATE']"),
                "privacy_unlisted_radio": (By.CSS_SELECTOR, "tp-yt-paper-radio-button[name='UNLISTED']"),
                "privacy_public_radio": (By.CSS_SELECTOR, "tp-yt-paper-radio-button[name='PUBLIC']"),
                "thumbnail_file_input": (By.XPATH, "//input[@id='file-loader']"),
                "tags_container": (By.ID, "tags-container"),
                "tags_input": (By.ID, "text-input"),
                "uploading_popup": (By.XPATH, "//ytcp-dialog[.//h1[contains(text(), 'T·∫£i video l√™n') or contains(text(), 'Uploading video')]]"),
                "alternative_upload_popup": (By.CSS_SELECTOR, "ytcp-multi-progress-monitor"),
                "add_cards_button": (By.ID, "cards-button"),
                "cards_editor_dialog": (By.ID, "dialog"),
                "ALL_PLAYLISTS_IN_LIST": (By.XPATH, "//ytcp-entity-card"),
                "cards_editor_save_button": (By.ID, "save-button"),
                "cards_editor_save_button_ENABLED": (By.CSS_SELECTOR, "ytcp-button#save-button:not([disabled])"),
                "ENDSCREEN_VIDEO_TIMELINE_TRACK": (By.ID, "VIDEO_THUMBNAILS"),
                "RETRY_BUTTON_IN_EDITOR": (By.ID, "error-retry-button"),

                # --- C√ÅC LOCATORS ƒê√É ƒê∆Ø·ª¢C C·∫¨P NH·∫¨T ƒêA NG√îN NG·ªÆ ---
                "show_more_button": (By.XPATH, "//ytcp-button[.//div[contains(text(),'Hi·ªán th√™m') or contains(text(), 'Show more')]]"),

                "CARD_TYPE_PLAYLIST": (By.XPATH, "//div[contains(@class, 'info-card-type-option-container') and .//span[contains(text(), 'Danh s√°ch ph√°t') or contains(text(), 'Playlist')]]"),
                
                "SELECTED_PLAYLIST_NAME_IN_CARD_EDITOR": (By.XPATH, "//div[@id='label-container']//div[contains(@class, 'entityName') and (contains(., 'Danh s√°ch ph√°t:') or contains(., 'Playlist:'))]"),

                "add_end_screen_button": (By.XPATH, "//ytcp-button[@id='endscreens-button']"),

                "endscreen_template_1vid_1sub": (By.XPATH, "//div[@aria-label='1 video, 1 ƒëƒÉng k√Ω' or @aria-label='1 video, 1 subscribe']"),

                "save_button_on_main_page_ENABLED": (By.XPATH, "//ytcp-button[@id='save-button' and not(@disabled)]"),

                # N√∫t n√†y r·∫•t quan tr·ªçng, ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
                "DISCARD_CHANGES_BUTTON": (By.XPATH, "//ytcp-button-shape[.//div[contains(text(), 'H·ªßy thay ƒë·ªïi') or contains(text(), 'Discard changes')]]//button"),

                # Dialog editor End screen (ƒëa ng√¥n ng·ªØ, CH·ªà khi ƒëang m·ªü)
                "ENDSCREEN_EDITOR_DIALOG": (
                    By.XPATH,
                    "//ytcp-dialog[@opened and .//h1[contains(., 'M√†n h√¨nh k·∫øt th√∫c') or contains(., 'End screen')]]"
                ),

                # Dialog editor Cards (ƒëa ng√¥n ng·ªØ, CH·ªà khi ƒëang m·ªü)
                "CARDS_EDITOR_DIALOG": (
                    By.XPATH,
                    "//ytcp-dialog[@opened and .//h1[contains(., 'Th·∫ª') or contains(., 'Cards')]]"
                ),

                # B·∫•t k·ª≥ dialog editor chung (fallback, CH·ªà khi ƒëang m·ªü)
                "EDITOR_DIALOG_ANY": (
                    By.CSS_SELECTOR,
                    "ytcp-dialog[opened], tp-yt-paper-dialog[opened]"
                ),
                
            }

            try:
                # B∆Ø·ªöC 1: ƒêI·ªÄU H∆Ø·ªöNG V√Ä T·∫¢I FILE VIDEO L√äN
                self.after(0, lambda: self.update_status(f"üì§ Tr√¨nh duy·ªát: ƒêang m·ªü trang upload..."))
                driver.get("https://www.youtube.com/upload")
                self._log_youtube_upload("ƒê√£ m·ªü trang YouTube Studio...")
                self.after(0, lambda: self.update_status(f"üì§ Tr√¨nh duy·ªát: ƒêang g·ª≠i t·ªáp video..."))
                file_input_element = WebDriverWait(driver, 60).until(EC.presence_of_element_located((By.XPATH, "//input[@type='file']")))
                file_input_element.send_keys(os.path.abspath(video_path))
                logging.info(f"{worker_log_prefix} ƒê√£ g·ª≠i t·ªáp video. ƒêang ch·ªù x√°c ƒë·ªãnh giao di·ªán upload...")
                self.after(0, lambda: self.update_status(f"üì§ Tr√¨nh duy·ªát: ƒê√£ g·ª≠i t·ªáp, ƒëang ch·ªù giao di·ªán..."))

                # Kh·ªüi t·∫°o bi·∫øn ·ªü ƒë√¢y ƒë·ªÉ tr√°nh l·ªói UnboundLocalError
                uploaded_video_id = None

                try:
                    # Ch·ªù 60 gi√¢y ƒë·ªÉ M·ªòT TRONG HAI giao di·ªán xu·∫•t hi·ªán
                    wait = WebDriverWait(driver, 60)
                    
                    condition_normal_page = EC.presence_of_element_located(YOUTUBE_LOCATORS["title"])
                    condition_alternative_popup = EC.presence_of_element_located(YOUTUBE_LOCATORS["alternative_upload_popup"])
                    
                    wait.until(EC.any_of(condition_normal_page, condition_alternative_popup))
                    logging.info(f"{worker_log_prefix} ƒê√£ ph√°t hi·ªán m·ªôt giao di·ªán upload.")

                    try:
                        # Th·ª≠ t√¨m popup nh·ªè tr∆∞·ªõc
                        alt_popup = driver.find_element(*YOUTUBE_LOCATORS["alternative_upload_popup"])
                        
                        logging.warning(f"{worker_log_prefix} ‚ö†Ô∏è ƒê√É PH√ÅT HI·ªÜN GIAO DI·ªÜN UPLOAD NH·ªé (MINI UPLOADER).")
                        
                        log_message_for_failed_task = f"B·ªè qua (G·∫∑p popup nh·ªè): {os.path.basename(video_path)}"
                        log_failed_task(log_message_for_failed_task)
                        
                        self._log_youtube_upload("‚ö†Ô∏è L·ªói Giao Di·ªán: YouTube hi·ªÉn th·ªã popup upload nh·ªè. T√°c v·ª• s·∫Ω ƒë∆∞·ª£c coi l√† th√†nh c√¥ng nh∆∞ng kh√¥ng th·ªÉ ƒëi·ªÅn chi ti·∫øt (m√¥ t·∫£, playlist, v.v.).")
                        
                        self.after(0, lambda: self.update_status(f"‚ÑπÔ∏è Tr√¨nh duy·ªát: G·∫∑p giao di·ªán nh·ªè, k·∫øt th√∫c s·ªõm."))
                        
                        time.sleep(5)
                        # S·ª¨A L·ªñI 1: Truy·ªÅn LOCATOR v√†o
                        click_with_fallback(driver, (By.ID, "close-button"))
                        
                        self._handle_youtube_upload_completion(True, None, "Ph√°t hi·ªán popup upload nh·ªè, coi nh∆∞ th√†nh c√¥ng.", False)
                        return

                    except NoSuchElementException: # B√¢y gi·ªù Python ƒë√£ bi·∫øt NoSuchElementException l√† g√¨
                        logging.info(f"{worker_log_prefix} ‚úÖ ƒê√£ x√°c nh·∫≠n giao di·ªán upload ƒë·∫ßy ƒë·ªß. Ti·∫øp t·ª•c quy tr√¨nh...")
                        self._log_youtube_upload("G·∫∑p giao di·ªán upload ƒë·∫ßy ƒë·ªß, ti·∫øp t·ª•c ƒëi·ªÅn th√¥ng tin.")

                except TimeoutException:
                    error_msg_no_ui = "Sau khi g·ª≠i file, kh√¥ng c√≥ giao di·ªán upload n√†o c·ªßa YouTube xu·∫•t hi·ªán."
                    logging.error(f"{worker_log_prefix} {error_msg_no_ui}")
                    self._handle_youtube_upload_completion(False, None, error_msg_no_ui, False)
                    return

                # L·∫§Y LINK NGAY L·∫¨P T·ª®C --- >>>
                try:
                    # Ch·ªù cho ƒë·∫øn khi th·∫ª <a> ch·ª©a link video xu·∫•t hi·ªán.
                    video_link_element = WebDriverWait(driver, 120).until(
                        EC.presence_of_element_located(YOUTUBE_LOCATORS["video_url_link"])
                    )
                    
                    # L·∫•y URL v√† tr√≠ch xu·∫•t ID
                    video_url = video_link_element.get_attribute("href")
                    # C·∫≠p nh·∫≠t regex ƒë·ªÉ kh·ªõp v·ªõi 'youtu.be' ho·∫∑c 'http://googleusercontent.com/youtube.com/6'
                    match = re.search(r'youtu\.be/([a-zA-Z0-9_-]+)', video_url)
                    if match:
                        uploaded_video_id = match.group(1)
                        logging.info(f"{worker_log_prefix} ‚úÖ L·∫§Y LINK TH√ÄNH C√îNG! Video ID: {uploaded_video_id}")
                        self._log_youtube_upload(f"L·∫•y ƒë∆∞·ª£c link video s·ªõm: {video_url}")
                    else:
                        logging.warning(f"{worker_log_prefix} ƒê√£ t√¨m th·∫•y th·∫ª link nh∆∞ng kh√¥ng tr√≠ch xu·∫•t ƒë∆∞·ª£c ID t·ª´ URL: {video_url}")
                
                except Exception as e_get_link:
                    # N·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c link ·ªü b∆∞·ªõc n√†y, t√°c v·ª• s·∫Ω th·∫•t b·∫°i v√¨ ƒë√¢y l√† b∆∞·ªõc quan tr·ªçng.
                    logging.error(f"{worker_log_prefix} Kh√¥ng th·ªÉ l·∫•y link video sau khi t·∫£i t·ªáp l√™n. H·ªßy t√°c v·ª•. L·ªói: {e_get_link}")
                    self._handle_youtube_upload_completion(False, None, "Kh√¥ng th·ªÉ l·∫•y link video t·ª´ YouTube Studio.", False)
                    return # Tho√°t kh·ªèi h√†m ngay l·∫≠p t·ª©c

                # B∆Ø·ªöC 2: TI·∫æP T·ª§C ƒêI·ªÄN TH√îNG TIN V√Ä CHUY·ªÇN TRANG
                self.after(0, lambda: self.update_status(f"üñã Tr√¨nh duy·ªát: ƒêang ƒëi·ªÅn ti√™u ƒë·ªÅ..."))
                
                # S·ª¨A L·ªñI 2: D√πng h√†m click m·ªõi ƒë·ªÉ l·∫•y element
                title_element = click_with_fallback(driver, YOUTUBE_LOCATORS["title"], timeout=60)
                time.sleep(0.5)
                title_element.send_keys(Keys.CONTROL + "a")
                title_element.send_keys(Keys.DELETE)
                time.sleep(0.5)
                # --- L√ÄM S·∫†CH TI√äU ƒê·ªÄ TR∆Ø·ªöC KHI G·ª¨I ---
                cleaned_title = sanitize_youtube_text(title, max_length=100) # Gi·ªõi h·∫°n 100 k√Ω t·ª±
                title_element.send_keys(cleaned_title)
                self._log_youtube_upload(f"üñã ƒê√£ ƒëi·ªÅn ti√™u ƒë·ªÅ video.")
                logging.info(f"{worker_log_prefix} ƒê√£ ƒëi·ªÅn ti√™u ƒë·ªÅ.")
                
                self.after(0, lambda: self.update_status(f"üñã Tr√¨nh duy·ªát: ƒêang ƒëi·ªÅn m√¥ t·∫£..."))
                if description is not None:
                    # S·ª¨A L·ªñI 3: D√πng h√†m click m·ªõi ƒë·ªÉ l·∫•y element
                    description_element = click_with_fallback(driver, YOUTUBE_LOCATORS["description"])
                    time.sleep(0.5)
                    description_element.send_keys(Keys.CONTROL + "a")
                    description_element.send_keys(Keys.DELETE)
                    time.sleep(0.5)
                    # --- L√ÄM S·∫†CH M√î T·∫¢ TR∆Ø·ªöC KHI G·ª¨I ---
                    cleaned_description = sanitize_youtube_text(description, max_length=5000) # Gi·ªõi h·∫°n 5000 k√Ω t·ª±
                    # Fix: Remove non-BMP characters for ChromeDriver compatibility
                    cleaned_description = ''.join(c for c in cleaned_description if ord(c) < 0x10000)
                    description_element.send_keys(cleaned_description)
                    self._log_youtube_upload(f"üñã ƒê√£ ƒëi·ªÅn m√¥ t·∫£ video.")
                    logging.info(f"{worker_log_prefix} ƒê√£ ƒëi·ªÅn m√¥ t·∫£.")
                else:
                    self._log_youtube_upload(f"üñã B·ªè qua ƒëi·ªÅn m√¥ t·∫£.")
                    logging.info(f"{worker_log_prefix} B·ªè qua ƒëi·ªÅn m√¥ t·∫£ (ƒë·ªÉ YouTube d√πng m·∫∑c ƒë·ªãnh).")

                self.after(0, lambda: self.update_status(f"‚úî Tr√¨nh duy·ªát: ƒêang ch·ªçn 'Kh√¥ng d√†nh cho tr·∫ª em'..."))
                # S·ª¨A L·ªñI 4: Truy·ªÅn LOCATOR v√†o
                click_with_fallback(driver, YOUTUBE_LOCATORS["not_for_kids"], timeout=30)
                logging.info(f"{worker_log_prefix} ƒê√£ ch·ªçn 'Kh√¥ng ph·∫£i n·ªôi dung cho tr·∫ª em'.")

                # Upload Thumbnail
                thumbnail_path = thumbnail_path_from_task
                if thumbnail_path and os.path.exists(thumbnail_path):
                    try:
                        self.after(0, lambda: self.update_status(f"üñº Tr√¨nh duy·ªát: ƒêang t·∫£i l√™n thumbnail..."))
                        self._log_youtube_upload("üñº ƒêang t√¨m v·ªã tr√≠ upload thumbnail...")
                        thumbnail_input_element = WebDriverWait(driver, 30).until(EC.presence_of_element_located(YOUTUBE_LOCATORS["thumbnail_file_input"]))
                        thumbnail_input_element.send_keys(os.path.abspath(thumbnail_path))
                        logging.info(f"{worker_log_prefix} ƒê√£ g·ª≠i ƒë∆∞·ªùng d·∫´n thumbnail: {os.path.basename(thumbnail_path)}")
                        self._log_youtube_upload(f"‚úÖ ƒê√£ t·∫£i l√™n thumbnail.")
                        self.after(0, lambda: self.update_status(f"üñº Tr√¨nh duy·ªát: T·∫£i thumbnail xong."))
                        time.sleep(5)
                    except Exception as e_thumb:
                        logging.warning(f"{worker_log_prefix} L·ªói khi upload thumbnail: {e_thumb}")
                        self._log_youtube_upload(f"‚ö†Ô∏è Kh√¥ng th·ªÉ upload thumbnail.")        

                # DANH S√ÅCH PH√ÅT
                if playlist_name:
                    try:
                        self._log_youtube_upload(f"üé∂ ƒêang t√¨m danh s√°ch ph√°t: '{playlist_name}'...")
                        self.after(0, lambda: self.update_status(f"üé∂ ƒêang t√¨m playlist: {playlist_name}..."))
                        
                        playlist_dropdown_xpath = "//ytcp-dropdown-trigger[@aria-label='Ch·ªçn danh s√°ch ph√°t']"
                        # S·ª¨A L·ªñI 5: Truy·ªÅn LOCATOR (tuple) v√†o
                        click_with_fallback(driver, (By.XPATH, playlist_dropdown_xpath), timeout=20)
                        logging.info(f"{worker_log_prefix} ƒê√£ click v√†o dropdown danh s√°ch ph√°t.")
                        time.sleep(2)

                        all_playlist_items_selector = "li.row"
                        all_items = WebDriverWait(driver, 20).until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, all_playlist_items_selector)))
                        logging.info(f"{worker_log_prefix} ƒê√£ t√¨m th·∫•y {len(all_items)} m·ª•c trong danh s√°ch ph√°t.")

                        found_playlist = False
                        for item in all_items:
                            try:
                                playlist_label_element = item.find_element(By.CSS_SELECTOR, "span.label-text")
                                playlist_label_text_from_web = playlist_label_element.get_attribute('textContent').strip()
                                playlist_name_from_task = playlist_name.strip()
                                normalized_web_text = normalize_string_for_comparison(playlist_label_text_from_web)
                                normalized_task_text = normalize_string_for_comparison(playlist_name_from_task)
                                
                                logging.info(f"NORMALIZED: So s√°nh '{normalized_web_text}' V·ªöI '{normalized_task_text}'")

                                if normalized_web_text and normalized_web_text == normalized_task_text:
                                    logging.info(f"{worker_log_prefix} >>> ƒê√É T√åM TH·∫§Y '{playlist_label_text_from_web}'! ƒêang click...")
                                    checkbox_to_click = item.find_element(By.TAG_NAME, "ytcp-checkbox-lit")
                                    # S·ª¨A L·ªñI 6: D√πng JS click cho element con (v√¨ _click_with_fallback y√™u c·∫ßu locator)
                                    driver.execute_script("arguments[0].click();", checkbox_to_click)
                                    found_playlist = True
                                    break
                            except Exception as e_find_playlist_item:
                                logging.warning(f"L·ªói nh·ªè khi duy·ªát qua m·ªôt m·ª•c playlist: {e_find_playlist_item}")
                                continue
                        
                        if not found_playlist:
                            raise Exception(f"Kh√¥ng t√¨m th·∫•y danh s√°ch ph√°t c√≥ t√™n '{playlist_name}' trong danh s√°ch.")

                        time.sleep(1)
                        done_button_xpath = "//ytcp-button[.//div[text()='Xong']]"
                        # S·ª¨A L·ªñI 7: Truy·ªÅn LOCATOR (tuple) v√†o
                        click_with_fallback(driver, (By.XPATH, done_button_xpath), timeout=10)
                        logging.info(f"{worker_log_prefix} ƒê√£ click n√∫t 'Xong' sau khi ch·ªçn danh s√°ch ph√°t.")
                        self._log_youtube_upload(f"‚úÖ ƒê√£ ch·ªçn danh s√°ch ph√°t: '{playlist_name}'.")
                        self.after(0, lambda: self.update_status(f"üé∂ Tr√¨nh duy·ªát: ƒê√£ ch·ªçn xong playlist."))

                    except Exception as e_playlist:
                        logging.warning(f"{worker_log_prefix} L·ªói khi ch·ªçn danh s√°ch ph√°t: {e_playlist}", exc_info=False)
                        self._log_youtube_upload(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ ch·ªçn danh s√°ch ph√°t: '{playlist_name}'.")
                        try:
                            from selenium.webdriver.common.action_chains import ActionChains
                            ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                            logging.info(f"{worker_log_prefix} ƒê√£ th·ª≠ nh·∫•n Escape ƒë·ªÉ ƒë√≥ng dialog playlist.")
                        except Exception:
                            pass

                # B∆Ø·ªöC 1: CLICK "HI·ªÜN TH√äM"
                try:
                    self.after(0, lambda: self.update_status(f"... ƒêang t√¨m n√∫t 'Hi·ªán th√™m'..."))
                    self._log_youtube_upload("üîé ƒêang t√¨m n√∫t 'Hi·ªán th√™m'...")
                    # S·ª¨A L·ªñI 8: Truy·ªÅn LOCATOR v√†o (h√†m click m·ªõi ƒë√£ t·ª± cu·ªôn)
                    click_with_fallback(driver, YOUTUBE_LOCATORS["show_more_button"], timeout=20)
                    logging.info(f"{worker_log_prefix} ƒê√£ click 'Hi·ªán th√™m'.")
                    self.after(0, lambda: self.update_status(f"‚úÖ ƒê√£ nh·∫•n 'Hi·ªán th√™m'."))
                    time.sleep(1.5)
                except Exception as e_show_more:
                    logging.warning(f"{worker_log_prefix} Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng click ƒë∆∞·ª£c n√∫t 'Hi·ªán th√™m': {e_show_more}")
                    self._log_youtube_upload("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n√∫t 'Hi·ªán th√™m'.")

                # --- B∆Ø·ªöC 2: CH·ªåN DANH M·ª§C VIDEO (T√çCH H·ª¢P 2 PH∆Ø∆†NG PH√ÅP) ---
                if category_id and category_id in YOUTUBE_CATEGORIES:
                    category_name_to_select = YOUTUBE_CATEGORIES[category_id]
                    
                    try:
                        # --- C√ÅC B∆Ø·ªöC CHUNG ---
                        self.after(0, lambda: self.update_status(f"... ƒêang ch·ªçn danh m·ª•c..."))
                        self._log_youtube_upload(f"üè∑ B·∫Øt ƒë·∫ßu qu√° tr√¨nh ch·ªçn danh m·ª•c: '{category_name_to_select}'")

                        # Click ƒë·ªÉ m·ªü dropdown (d√πng chung cho c·∫£ 2 ph∆∞∆°ng ph√°p)
                        category_dropdown_trigger_xpath = "//ytcp-form-select[@id='category']//ytcp-dropdown-trigger"
                        # S·ª¨A L·ªñI 9: Truy·ªÅn LOCATOR (tuple) v√†o
                        click_with_fallback(driver, (By.XPATH, category_dropdown_trigger_xpath), timeout=15)
                        logging.info(f"{worker_log_prefix} ƒê√£ click m·ªü dropdown danh m·ª•c.")
                        
                        time.sleep(1.5)

                        # --- TH·ª¨ PH∆Ø∆†NG PH√ÅP 1: T√åM THEO VƒÇN B·∫¢N (∆ØU TI√äN) ---
                        try:
                            logging.info(f"{worker_log_prefix} ƒêang th·ª≠ Ph∆∞∆°ng ph√°p 1: T√¨m theo vƒÉn b·∫£n...")
                            
                            category_item_xpath = f"//tp-yt-paper-listbox//yt-formatted-string[normalize-space(.)='{category_name_to_select}']"
                            # S·ª¨A L·ªñI 10: Truy·ªÅn LOCATOR (tuple) v√†o
                            click_with_fallback(driver, (By.XPATH, category_item_xpath), timeout=10)
                            
                            logging.info(f"{worker_log_prefix} ‚úÖ Ph∆∞∆°ng ph√°p 1 TH√ÄNH C√îNG: ƒê√£ ch·ªçn '{category_name_to_select}' b·∫±ng vƒÉn b·∫£n.")

                        # --- N·∫æU PH∆Ø∆†NG PH√ÅP 1 TH·∫§T B·∫†I, CHUY·ªÇN SANG PH∆Ø∆†NG PH√ÅP 2: D√ôNG B√ÄN PH√çM ---
                        except Exception as e_text_method:
                            logging.warning(f"{worker_log_prefix} ‚ö†Ô∏è Ph∆∞∆°ng ph√°p 1 th·∫•t b·∫°i: {e_text_method}. Chuy·ªÉn sang Ph∆∞∆°ng ph√°p 2: D√πng b√†n ph√≠m.")
                            self._log_youtube_upload(f"L·ªói ch·ªçn theo text, ƒëang th·ª≠ l·∫°i b·∫±ng b√†n ph√≠m...")

                            # T√¨m th·∫ª <body> ƒë·ªÉ g·ª≠i ph√≠m
                            body_element = driver.find_element(By.TAG_NAME, "body")

                            # L·∫•y s·ªë l·∫ßn nh·∫•n ph√≠m t·ª´ "b·∫£n ƒë·ªì" ƒëi·ªÅu h∆∞·ªõng c·ªßa b·∫°n
                            number_of_presses = YOUTUBE_CATEGORY_NAVIGATION_ORDER.get(category_id, -1)
                            
                            if number_of_presses == -1:
                                raise Exception(f"Kh√¥ng t√¨m th·∫•y th·ª© t·ª± ƒëi·ªÅu h∆∞·ªõng b√†n ph√≠m cho Category ID '{category_id}'.")
                                
                            logging.info(f"{worker_log_prefix} S·∫Ω nh·∫•n M≈©i t√™n xu·ªëng {number_of_presses} l·∫ßn.")

                            # G·ª≠i c√°c ph√≠m m≈©i t√™n xu·ªëng
                            for _ in range(number_of_presses):
                                body_element.send_keys(Keys.ARROW_DOWN)
                                time.sleep(0.15) # Gi·ªØ kho·∫£ng ngh·ªâ ƒë·ªÉ ·ªïn ƒë·ªãnh

                            # G·ª≠i ph√≠m Enter ƒë·ªÉ ch·ªçn
                            body_element.send_keys(Keys.ENTER)
                            logging.info(f"{worker_log_prefix} ‚úÖ Ph∆∞∆°ng ph√°p 2 TH√ÄNH C√îNG: ƒê√£ ch·ªçn '{category_name_to_select}' b·∫±ng b√†n ph√≠m.")

                        # --- LOG K·∫æT QU·∫¢ TH√ÄNH C√îNG CHUNG ---
                        self._log_youtube_upload(f"‚úÖ ƒê√£ ch·ªçn danh m·ª•c: '{category_name_to_select}'.")
                        self.after(0, lambda: self.update_status(f"‚úÖ ƒê√£ ch·ªçn danh m·ª•c."))
                        
                        # Ch·ªù cho dropdown ƒë√≥ng l·∫°i ƒë·ªÉ x√°c nh·∫≠n h√†nh ƒë·ªông ho√†n t·∫•t
                        WebDriverWait(driver, 10).until(
                            EC.invisibility_of_element_located((By.XPATH, "//tp-yt-paper-listbox"))
                        )

                    # --- N·∫æU C·∫¢ 2 PH∆Ø∆†NG PH√ÅP ƒê·ªÄU TH·∫§T B·∫†I ---
                    except Exception as e_category:
                        logging.critical(f"{worker_log_prefix} L·ªñI NGHI√äM TR·ªåNG: C·∫£ 2 ph∆∞∆°ng ph√°p ch·ªçn danh m·ª•c ƒë·ªÅu th·∫•t b·∫°i. L·ªói: {e_category}", exc_info=True)
                        self._log_youtube_upload(f"‚ùå L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ ch·ªçn danh m·ª•c '{category_name_to_select}'.")
                        
                        try:
                            config_directory = os.path.dirname(get_config_path())
                            screenshot_path = os.path.join(config_directory, f"error_screenshot_category_{int(time.time())}.png")
                            driver.save_screenshot(screenshot_path)
                            logging.info(f"ƒê√£ l∆∞u ·∫£nh ch·ª•p m√†n h√¨nh l·ªói t·∫°i: {screenshot_path}")
                            self.after(0, lambda: messagebox.showwarning("L·ªói Ch·ªçn Danh M·ª•c",
                                                                       f"Kh√¥ng th·ªÉ t·ª± ƒë·ªông ch·ªçn danh m·ª•c.\n"
                                                                       f"·∫¢nh ch·ª•p m√†n h√¨nh l·ªói ƒë√£ ƒë∆∞·ª£c l∆∞u t·∫°i:\n\n{screenshot_path}\n\n"
                                                                       f"Vui l√≤ng ki·ªÉm tra ·∫£nh ƒë·ªÉ xem l·ªói v√† th·ª≠ l·∫°i.", parent=self))
                        except Exception as e_ss:
                            logging.error(f"Kh√¥ng th·ªÉ ch·ª•p ·∫£nh m√†n h√¨nh l·ªói: {e_ss}")

                # B∆Ø·ªöC 3: ƒêI·ªÄN TH·∫∫ TAG (PHI√äN B·∫¢N K·∫æT H·ª¢P T·ªêT NH·∫§T)
                if tags: # tags l√† m·ªôt list
                    try:
                        self.after(0, lambda: self.update_status(f"... ƒêang ƒëi·ªÅn th·∫ª tags..."))
                        self._log_youtube_upload("üîé ƒêang t√¨m v√† ch·ªù √¥ nh·∫≠p th·∫ª tags s·∫µn s√†ng...")

                        # 1. D√ôNG LOGIC C≈®: T√¨m container tr∆∞·ªõc ƒë·ªÉ ƒë·∫£m b·∫£o ph·∫°m vi ch√≠nh x√°c.
                        tags_container = WebDriverWait(driver, 20).until(
                            EC.visibility_of_element_located(YOUTUBE_LOCATORS["tags_container"])
                        )

                        # 2. T√åM √î INPUT B√äN TRONG CONTAINER V√Ä L∆ØU L·∫†I THAM CHI·∫æU (reference).
                        tags_input_field = tags_container.find_element(*YOUTUBE_LOCATORS["tags_input"])

                        # 3. D√ôNG H√ÄM CLICK M·∫†NH M·∫º ƒê·ªÇ CLICK V√ÄO √î NH·∫¨P LI·ªÜU.
                        click_with_fallback(driver, YOUTUBE_LOCATORS["tags_input"])
                        time.sleep(0.8)
                        
                        self._log_youtube_upload(f"üñã ƒêang ƒëi·ªÅn {len(tags)} th·∫ª tags...")
                        
                        # 4. G·ª¨I KEYS V√ÄO THAM CHI·∫æU ·ªîN ƒê·ªäNH ƒê√É T√åM ·ªû B∆Ø·ªöC 2.
                        cleaned_tags = [sanitize_youtube_text(tag, max_length=50) for tag in tags]
                        tags_string = ", ".join([tag for tag in cleaned_tags if tag.strip()])
                        
                        tags_input_field.send_keys(tags_string)
                        time.sleep(0.5)
                        tags_input_field.send_keys(',')
                        
                        logging.info(f"{worker_log_prefix} ƒê√£ ƒëi·ªÅn xong c√°c th·∫ª tags.")
                        self._log_youtube_upload("‚úÖ ƒê√£ ƒëi·ªÅn xong th·∫ª tags.")
                        self.after(0, lambda: self.update_status(f"‚úÖ ƒê√£ ƒëi·ªÅn xong tags."))

                    except Exception as e_tags:
                        logging.warning(f"{worker_log_prefix} L·ªói khi ƒëi·ªÅn th·∫ª tags: {e_tags}", exc_info=True)
                        self._log_youtube_upload(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ƒëi·ªÅn th·∫ª tags.")

                # === B∆Ø·ªöC 2: NH·∫§N "TI·∫æP THEO" L·∫¶N 1 ƒê·ªÇ ƒê·∫æN TRANG "Y·∫æU T·ªê VIDEO" ===
                self.after(0, lambda: self.update_status(f"‚û° Tr√¨nh duy·ªát: Chuy·ªÉn ƒë·∫øn trang Y·∫øu t·ªë video..."))
                click_with_fallback(driver, YOUTUBE_LOCATORS["next_button"], timeout=60)

                WebDriverWait(driver, 30).until(EC.element_to_be_clickable(YOUTUBE_LOCATORS["add_end_screen_button"]))
                logging.info(f"{worker_log_prefix} Trang 'Y·∫øu t·ªë video' ƒë√£ t·∫£i xong.")

                # TH√äM V√ÄO: Cho YouTube th·ªùi gian ƒë·ªÉ ·ªïn ƒë·ªãnh ho√†n to√†n
                logging.info(f"{worker_log_prefix} T·∫°m d·ª´ng 2 gi√¢y ƒë·ªÉ ·ªïn ƒë·ªãnh trang 'Y·∫øu t·ªë video'...")
                self.after(0, lambda: self.update_status(f"·ªîn ƒë·ªãnh trang Y·∫øu t·ªë video..."))
                time.sleep(2)

                # === HELPERS (drop-in): Retry/Discard & Dialog visibility/invisibility ===
                # C√°c key dialog trong YOUTUBE_LOCATORS
                DIALOG_KEYS = ("ENDSCREEN_EDITOR_DIALOG", "CARDS_EDITOR_DIALOG", "EDITOR_DIALOG_ANY")

                def _is_visible(locator) -> bool:
                    """Tr·∫£ v·ªÅ True n·∫øu c√≥ √≠t nh·∫•t 1 element ƒëang HI·ªÇN TH·ªä (displayed=True)."""
                    try:
                        elems = driver.find_elements(*locator)
                        return any(e.is_displayed() for e in elems)
                    except Exception:
                        return False

                def _wait_dialogs_invisible(timeout_each: int = 15):
                    """Ch·ªù c√°c dialog editor bi·∫øn m·∫•t (·∫©n h·∫≥n). Kh√¥ng raise n·∫øu 1 v√†i c√°i kh√¥ng k·ªãp t·∫Øt."""
                    for key in DIALOG_KEYS:
                        try:
                            WebDriverWait(driver, timeout_each).until(
                                EC.invisibility_of_element_located(YOUTUBE_LOCATORS[key])
                            )
                        except Exception:
                            continue
                    # L·ªõp ƒë·∫£m b·∫£o cu·ªëi: h·∫øt m·ªçi dialog ƒëang m·ªü ([@opened]) th√¨ m·ªõi coi nh∆∞ ƒë√≥ng xong
                    try:
                        WebDriverWait(driver, 5).until(
                            lambda d: len(d.find_elements(By.CSS_SELECTOR, "ytcp-dialog[opened], tp-yt-paper-dialog[opened]")) == 0
                        )
                    except Exception:
                        pass

                def _overlay_retry_visible() -> bool:
                    """Overlay l·ªói (n√∫t 'Th·ª≠ l·∫°i') c√≥ ƒëang HI·ªÇN TH·ªä th·∫≠t hay kh√¥ng."""
                    try:
                        return _is_visible(YOUTUBE_LOCATORS["RETRY_BUTTON_IN_EDITOR"])
                    except Exception:
                        return False

                def _try_retry_overlay(editor_name: str, max_tries: int = 2) -> bool:
                    """
                    N·∫øu th·∫•y overlay l·ªói, th·ª≠ b·∫•m 'Th·ª≠ l·∫°i' t·ªëi ƒëa max_tries l·∫ßn.
                    Tr·∫£ v·ªÅ True n·∫øu overlay ƒë√£ bi·∫øn m·∫•t; False n·∫øu v·∫´n c√≤n.
                    """
                    for i in range(max_tries):
                        if not _overlay_retry_visible():
                            return True
                        self._log_youtube_upload(f"‚ÑπÔ∏è {editor_name}: th·∫•y overlay l·ªói ‚Üí nh·∫•n 'Th·ª≠ l·∫°i' (l·∫ßn {i+1}/{max_tries})")
                        try:
                            click_with_fallback(driver, YOUTUBE_LOCATORS["RETRY_BUTTON_IN_EDITOR"], timeout=5)
                        except Exception:
                            pass
                        # ch·ªù overlay bi·∫øn m·∫•t
                        try:
                            WebDriverWait(driver, 10).until(lambda d: not _overlay_retry_visible())
                            return True
                        except Exception:
                            continue
                    return not _overlay_retry_visible()

                def _discard_and_wait_close(editor_name: str, quick: bool = False):
                    """
                    ƒê√≥ng editor an to√†n:
                    - quick=True: ch·ªâ b·∫•m Discard n·∫øu clickable nhanh; n·∫øu kh√¥ng th√¨ ESC (d√πng cho Gate tr∆∞·ªõc Next).
                    - quick=False: b·∫•m Discard v·ªõi timeout d√†i h∆°n; fallback ESC n·∫øu fail.
                    Sau ƒë√≥ lu√¥n ch·ªù dialog bi·∫øn m·∫•t h·∫≥n.
                    """
                    try:
                        self._log_youtube_upload(f"‚ö†Ô∏è {editor_name}: g·∫∑p l·ªói/overlay ‚Üí H·ªßy thay ƒë·ªïi & b·ªè qua.")
                        if quick:
                            # ch·ªâ click khi th·ª±c s·ª± clickable nhanh, tr√°nh stale
                            try:
                                WebDriverWait(driver, 5).until(EC.element_to_be_clickable(YOUTUBE_LOCATORS["DISCARD_CHANGES_BUTTON"]))
                                click_with_fallback(driver, YOUTUBE_LOCATORS["DISCARD_CHANGES_BUTTON"], timeout=5)
                            except Exception:
                                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                        else:
                            click_with_fallback(driver, YOUTUBE_LOCATORS["DISCARD_CHANGES_BUTTON"], timeout=10)
                    except Exception:
                        # Fallback: nh·∫•n ESC 1‚Äì2 l·∫ßn n·∫øu kh√¥ng b·∫•m ƒë∆∞·ª£c Discard
                        try:
                            ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                            time.sleep(0.3)
                            ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                        except Exception:
                            pass

                    # Ch·ªù dialog ƒë√≥ng h·∫≥n (kh√¥ng d·ª±a v√†o //ytve-player)
                    _wait_dialogs_invisible(timeout_each=15)
                    self._log_youtube_upload(f"‚úÖ {editor_name}: dialog ƒë√£ ƒë√≥ng, ti·∫øp t·ª•c.")

                # === Jitter helper: t·∫°o tr·ªÖ ng·∫´u nhi√™n ng·∫Øn ƒë·ªÉ ch·ªù UI ‚Äúch√≠n‚Äù ===
                def _jitter(base=0.25, rand=0.35):
                    try:
                        import random, time as _t
                        _t.sleep(base + random.random() * rand)
                    except Exception:
                        time.sleep(base)

                # --- X·ª≠ l√Ω M√†n h√¨nh k·∫øt th√∫c ---
                if self.youtube_add_end_screen_var.get():
                    self.after(0, lambda: self.update_status(f"‚ûï B·∫Øt ƒë·∫ßu th√™m M√†n h√¨nh k·∫øt th√∫c..."))
                    self._log_youtube_upload("‚ûï ƒêang th·ª≠ th√™m M√†n h√¨nh k·∫øt th√∫c...")
                    try:
                        # 1) M·ªü editor
                        logging.info(f"{worker_log_prefix} ƒêang m·ªü tr√¨nh ch·ªânh s·ª≠a M√†n h√¨nh k·∫øt th√∫c...")
                        click_with_fallback(driver, YOUTUBE_LOCATORS["add_end_screen_button"], timeout=30)

                        # 2) Ch·ªù 1 trong 3 tr·∫°ng th√°i
                        wait_for_editor = WebDriverWait(driver, 120)
                        logging.info(f"{worker_log_prefix} ‚è≥ ƒêang ch·ªù Editor t·∫£i (th√†nh c√¥ng) ho·∫∑c b√°o l·ªói (th·∫•t b·∫°i)...")
                        self.after(0, lambda: self.update_status(f"‚è≥ ƒêang ch·ªù tr√¨nh ch·ªânh s·ª≠a M√†n h√¨nh k·∫øt th√∫c t·∫£i..."))
                        wait_for_editor.until(EC.any_of(
                            EC.visibility_of_element_located(YOUTUBE_LOCATORS["ENDSCREEN_VIDEO_TIMELINE_TRACK"]),
                            EC.visibility_of_element_located(YOUTUBE_LOCATORS["RETRY_BUTTON_IN_EDITOR"]),
                            EC.element_to_be_clickable(YOUTUBE_LOCATORS["DISCARD_CHANGES_BUTTON"])
                        ))

                        proceed_end = True
                        if _overlay_retry_visible():
                            logging.warning(f"{worker_log_prefix} End screen editor c√≥ overlay l·ªói (Retry). Th·ª≠ Retry tr∆∞·ªõc khi b·ªè qua.")
                            if not _try_retry_overlay("End screen", max_tries=2):
                                self.after(0, lambda: self.update_status(f"‚ö† G·∫∑p l·ªói editor, b·ªè qua M√†n h√¨nh k·∫øt th√∫c..."))
                                _discard_and_wait_close("End screen")
                                proceed_end = False
                            else:
                                self._log_youtube_upload("‚úÖ Overlay ƒë√£ h·∫øt sau khi Retry. Ti·∫øp t·ª•c thao t√°c End screen.")

                        # 4) N·∫øu editor s·∫µn s√†ng ‚Üí ch·ªçn template + l∆∞u
                        if proceed_end and not _overlay_retry_visible():
                            logging.info(f"{worker_log_prefix} ‚úÖ Editor M√†n h√¨nh k·∫øt th√∫c s·∫µn s√†ng (kh√¥ng overlay).")
                            self.after(0, lambda: self.update_status(f"‚úÖ Editor ƒë√£ t·∫£i, ƒëang √°p d·ª•ng m·∫´u..."))
                            self._log_youtube_upload("‚úÖ Editor M√†n h√¨nh k·∫øt th√∫c ƒë√£ t·∫£i, b·∫Øt ƒë·∫ßu thao t√°c.")
                            _jitter()

                            WebDriverWait(driver, 20).until(
                                EC.element_to_be_clickable(YOUTUBE_LOCATORS["endscreen_template_1vid_1sub"])
                            )
                            click_with_fallback(driver, YOUTUBE_LOCATORS["endscreen_template_1vid_1sub"], timeout=20)
                            _jitter()

                            self.after(0, lambda: self.update_status(f"ƒêang l∆∞u M√†n h√¨nh k·∫øt th√∫c..."))
                            save_button_locator = (By.XPATH, "//ytcp-button[@id='save-button' and not(@disabled)]")
                            click_with_fallback(driver, save_button_locator, timeout=60)

                            # Ch·ªù dialog ƒë√≥ng h·∫≥n theo [opened]
                            try:
                                WebDriverWait(driver, 10).until(
                                    lambda d: len(d.find_elements(
                                        By.CSS_SELECTOR, "ytcp-dialog[opened], tp-yt-paper-dialog[opened]"
                                    )) == 0
                                )
                            except Exception:
                                try:
                                    WebDriverWait(driver, 5).until(
                                        EC.invisibility_of_element_located(YOUTUBE_LOCATORS["EDITOR_DIALOG_ANY"])
                                    )
                                except Exception:
                                    pass

                            self.after(0, lambda: self.update_status(f"‚úÖ ƒê√£ th√™m M√†n h√¨nh k·∫øt th√∫c."))
                            self._log_youtube_upload("‚úÖ ƒê√£ th√™m M√†n h√¨nh k·∫øt th√∫c th√†nh c√¥ng.")

                    except Exception as e_endscreen:
                        logging.error(f"{worker_log_prefix} ‚ùå L·ªói End screen: {e_endscreen}", exc_info=False)
                        _discard_and_wait_close("End screen")
                        self.after(0, lambda: self.update_status(f"‚ùå L·ªói, b·ªè qua M√†n h√¨nh k·∫øt th√∫c."))
                        self._log_youtube_upload("‚ùå B·ªè qua M√†n h√¨nh k·∫øt th√∫c do l·ªói.")

                time.sleep(1.0)

                # --- X·ª≠ l√Ω Th·∫ª ---
                if self.youtube_add_cards_var.get():
                    self.after(0, lambda: self.update_status(f"‚ûï B·∫Øt ƒë·∫ßu th√™m Th·∫ª..."))
                    self._log_youtube_upload("‚ûï ƒêang th·ª≠ th√™m Th·∫ª...")
                    try:
                        # 1) M·ªü editor
                        logging.info(f"{worker_log_prefix} ƒêang m·ªü tr√¨nh ch·ªânh s·ª≠a Th·∫ª...")
                        click_with_fallback(driver, YOUTUBE_LOCATORS["add_cards_button"], timeout=30)

                        # 2) Ch·ªù 1 trong 3 tr·∫°ng th√°i
                        wait_for_editor = WebDriverWait(driver, 120)
                        logging.info(f"{worker_log_prefix} ‚è≥ ƒêang ch·ªù Editor t·∫£i (th√†nh c√¥ng) ho·∫∑c b√°o l·ªói (th·∫•t b·∫°i)...")
                        self.after(0, lambda: self.update_status(f"‚è≥ ƒêang ch·ªù tr√¨nh ch·ªânh s·ª≠a Th·∫ª t·∫£i..."))
                        wait_for_editor.until(EC.any_of(
                            EC.visibility_of_element_located(YOUTUBE_LOCATORS["ENDSCREEN_VIDEO_TIMELINE_TRACK"]),
                            EC.visibility_of_element_located(YOUTUBE_LOCATORS["RETRY_BUTTON_IN_EDITOR"]),
                            EC.element_to_be_clickable(YOUTUBE_LOCATORS["DISCARD_CHANGES_BUTTON"])
                        ))

                        proceed_cards = True
                        if _overlay_retry_visible():
                            logging.warning(f"{worker_log_prefix} Cards editor c√≥ overlay l·ªói (Retry). Th·ª≠ Retry tr∆∞·ªõc khi b·ªè qua.")
                            if not _try_retry_overlay("Cards", max_tries=2):
                                self.after(0, lambda: self.update_status(f"‚ö†Ô∏è G·∫∑p l·ªói editor, b·ªè qua Th·∫ª..."))
                                _discard_and_wait_close("Cards")
                                proceed_cards = False
                            else:
                                self._log_youtube_upload("‚úÖ Overlay ƒë√£ h·∫øt sau khi Retry. Ti·∫øp t·ª•c thao t√°c Cards.")

                        # 4) N·∫øu editor s·∫µn s√†ng ‚Üí CH·ªåN PLAYLIST NG·∫™U NHI√äN TH·∫¨T S·ª∞ + l∆∞u
                        if proceed_cards and not _overlay_retry_visible():
                            logging.info(f"{worker_log_prefix} ‚úÖ Editor Th·∫ª s·∫µn s√†ng (kh√¥ng overlay).")
                            self.after(0, lambda: self.update_status(f"‚úÖ Editor ƒë√£ t·∫£i, ƒëang ch·ªçn playlist..."))
                            self._log_youtube_upload("‚úÖ Editor Th·∫ª ƒë√£ t·∫£i, b·∫Øt ƒë·∫ßu thao t√°c.")
                            _jitter()

                            WebDriverWait(driver, 20).until(
                                EC.element_to_be_clickable(YOUTUBE_LOCATORS["CARD_TYPE_PLAYLIST"])
                            )
                            click_with_fallback(driver, YOUTUBE_LOCATORS["CARD_TYPE_PLAYLIST"], timeout=20)
                            _jitter()

                            # L·∫•y danh s√°ch item hi·ªán c√≥ trong DOM
                            all_cards = WebDriverWait(driver, 30).until(
                                EC.presence_of_all_elements_located(YOUTUBE_LOCATORS["ALL_PLAYLISTS_IN_LIST"])
                            )

                            # L·ªçc nh·ªØng item c√≥ text h·ª£p l·ªá, tr√°nh "T·∫°o danh s√°ch ph√°t"/"Create playlist"
                            valid = []
                            for el in all_cards:
                                try:
                                    txt = el.text.strip()
                                    if not txt:
                                        continue
                                    low = txt.lower()
                                    if ("t·∫°o danh s√°ch" in low) or ("create playlist" in low):
                                        continue
                                    valid.append((el, txt))
                                except Exception:
                                    continue

                            if not valid:
                                raise RuntimeError("Kh√¥ng t√¨m th·∫•y playlist h·ª£p l·ªá trong Cards editor.")

                            # ƒê·ªçc label ƒëang hi·ªÉn th·ªã (n·∫øu c√≥) ƒë·ªÉ ki·ªÉm tra ƒë√£ ƒë·ªïi sau khi click
                            try:
                                before_label = driver.find_element(*YOUTUBE_LOCATORS["SELECTED_PLAYLIST_NAME_IN_CARD_EDITOR"]) \
                                                     .get_attribute("textContent").strip()
                            except Exception:
                                before_label = None

                            # Th·ª≠ t·ªëi ƒëa 3 l·∫ßn ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªçn kh√°c m·∫∑c ƒë·ªãnh
                            import random as _r
                            picked_ok = False
                            for _ in range(3):
                                el, txt = _r.choice(valid)

                                # Scroll v√†o gi·ªØa viewport ƒë·ªÉ tr√°nh element ‚Äúngo√†i t·∫ßm‚Äù
                                try:
                                    driver.execute_script("arguments[0].scrollIntoView({block:'center', inline:'nearest'});", el)
                                    _jitter(0.2, 0.25)
                                except Exception:
                                    pass

                                # ƒê·ª£i clickable r·ªìi click v·ªõi fallback
                                try:
                                    WebDriverWait(driver, 10).until(lambda d: el.is_displayed())
                                    try:
                                        WebDriverWait(driver, 5).until(EC.element_to_be_clickable(el))
                                        el.click()
                                    except Exception:
                                        try:
                                            # click v√†o checkbox/radio con n·∫øu c√≥
                                            sub = None
                                            for sel in ("ytcp-checkbox-lit", "ytcp-radio-button", "ytcp-icon-button"):
                                                try:
                                                    sub = el.find_element(By.CSS_SELECTOR, sel)
                                                    break
                                                except Exception:
                                                    continue
                                            target = sub if sub else el
                                            driver.execute_script("arguments[0].click();", target)
                                        except Exception:
                                            driver.execute_script("arguments[0].click();", el)
                                except Exception:
                                    continue

                                _jitter(0.3, 0.35)

                                # X√°c nh·∫≠n label ƒë√£ ƒë·ªïi
                                try:
                                    label_el = WebDriverWait(driver, 10).until(
                                        EC.visibility_of_element_located(YOUTUBE_LOCATORS["SELECTED_PLAYLIST_NAME_IN_CARD_EDITOR"])
                                    )
                                    after_label = label_el.get_attribute("textContent").strip()
                                except Exception:
                                    after_label = None

                                # Log g·ªçn, kh√¥ng hi·ªán "Label tr∆∞·ªõc/sau"
                                if (after_label and (after_label != before_label)) or (before_label is None and after_label):
                                    # ƒê√£ x√°c nh·∫≠n ƒë·ªïi ƒë∆∞·ª£c playlist
                                    self._log_youtube_upload(f"üé≤ Ch·ªçn playlist: '{txt}' ‚Äî ‚úÖ ƒë√£ x√°c nh·∫≠n.")
                                    picked_ok = True
                                    break
                                else:
                                    # Ch∆∞a x√°c nh·∫≠n ƒë∆∞·ª£c, th·ª≠ ti·∫øp (log ng·∫Øn g·ªçn)
                                    self._log_youtube_upload(f"üé≤ Ch·ªçn playlist: '{txt}' ‚Äî ‚è≥ ch∆∞a x√°c nh·∫≠n, th·ª≠ l·∫°i...")


                                if (after_label and (after_label != before_label)) or (before_label is None and after_label):
                                    picked_ok = True
                                    break

                            if not picked_ok:
                                logging.warning(f"{worker_log_prefix} Kh√¥ng x√°c nh·∫≠n ƒë∆∞·ª£c label ƒë·ªïi, v·∫´n ti·∫øp t·ª•c l∆∞u theo l·ª±a ch·ªçn hi·ªán t·∫°i.")

                            self.after(0, lambda: self.update_status(f"ƒêang l∆∞u Th·∫ª..."))
                            save_button_element = WebDriverWait(driver, 20).until(
                                EC.element_to_be_clickable(YOUTUBE_LOCATORS["cards_editor_save_button_ENABLED"])
                            )
                            save_button_element.click()
                            _jitter()

                            # Ch·ªù dialog ƒë√≥ng h·∫≥n theo [opened]
                            try:
                                WebDriverWait(driver, 10).until(
                                    lambda d: len(d.find_elements(
                                        By.CSS_SELECTOR, "ytcp-dialog[opened], tp-yt-paper-dialog[opened]"
                                    )) == 0
                                )
                            except Exception:
                                try:
                                    WebDriverWait(driver, 5).until(
                                        EC.invisibility_of_element_located(YOUTUBE_LOCATORS["EDITOR_DIALOG_ANY"])
                                    )
                                except Exception:
                                    pass

                            self.after(0, lambda: self.update_status(f"‚úÖ ƒê√£ th√™m Th·∫ª."))
                            self._log_youtube_upload("‚úÖ ƒê√£ th√™m Th·∫ª th√†nh c√¥ng.")

                    except Exception as e_cards:
                        logging.error(f"{worker_log_prefix} ‚ùå L·ªói Th·∫ª: {e_cards}", exc_info=False)
                        _discard_and_wait_close("Cards")
                        self.after(0, lambda: self.update_status(f"‚ùå L·ªói, b·ªè qua Th·∫ª."))
                        self._log_youtube_upload("‚ùå B·ªè qua Th·∫ª do l·ªói.")

                # R·ªùi dialog/iframe n·∫øu c√≥
                driver.switch_to.default_content()
                time.sleep(1.0)

                # === B∆Ø·ªöC TI·∫æP THEO: NH·∫§N "TI·∫æP" 2 L·∫¶N ƒê·ªÇ HO√ÄN T·∫§T ===
                logging.info(f"{worker_log_prefix} Chu·∫©n b·ªã nh·∫•n 'Ti·∫øp' 2 l·∫ßn ƒë·ªÉ ho√†n t·∫•t...")
                self._log_youtube_upload("‚û° Chu·∫©n b·ªã chuy·ªÉn qua c√°c b∆∞·ªõc cu·ªëi c√πng...")

                for i in range(2):  # (1) Y·∫øu t·ªë -> Ki·ªÉm tra, (2) Ki·ªÉm tra -> Ch·∫ø ƒë·ªô hi·ªÉn th·ªã
                    if self.stop_event.is_set():
                        raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng.")

                    log_message = f"Chuy·ªÉn ƒë·∫øn trang Ki·ªÉm tra..." if i == 0 else f"Chuy·ªÉn ƒë·∫øn trang Ch·∫ø ƒë·ªô hi·ªÉn th·ªã..."
                    self.after(0, lambda i=i, msg=log_message: self.update_status(f"‚û° {msg} ({i+1}/2)"))

                    self._log_youtube_upload(f"‚û° ƒêang nh·∫•n 'Ti·∫øp' ƒë·ªÉ {log_message.lower()}")
                    try:
                        click_with_fallback(driver, YOUTUBE_LOCATORS["next_button"], timeout=60)
                        logging.info(f"{worker_log_prefix} ƒê√£ nh·∫•n n√∫t 'Ti·∫øp' th√†nh c√¥ng (l·∫ßn l·∫∑p {i+1}).")
                        time.sleep(2.5)  # Ch·ªù trang m·ªõi t·∫£i xong
                    except Exception as e_click_next:
                        logging.error(f"{worker_log_prefix} L·ªói khi nh·∫•n n√∫t 'Ti·∫øp' ·ªü l·∫ßn l·∫∑p {i+1}: {e_click_next}")
                        raise RuntimeError(f"Kh√¥ng th·ªÉ nh·∫•n n√∫t 'Ti·∫øp' ·ªü b∆∞·ªõc chuy·ªÉn trang th·ª© {i+1}.")

                # === CH·ªåN QUY·ªÄN RI√äNG T∆Ø V√Ä XU·∫§T B·∫¢N ===        
                self.after(0, lambda: self.update_status(f"üîí ƒêang c√†i ƒë·∫∑t quy·ªÅn ri√™ng t∆∞..."))
                self._log_youtube_upload(f"üîí ƒêang ch·ªçn quy·ªÅn ri√™ng t∆∞: {privacy_status}.")
                target_privacy_locator = YOUTUBE_LOCATORS.get(f"privacy_{privacy_status.lower()}_radio")

                if target_privacy_locator:
                    click_with_fallback(driver, target_privacy_locator, timeout=30)
                    logging.info(f"{worker_log_prefix} ƒê√£ ch·ªçn quy·ªÅn ri√™ng t∆∞: {privacy_status}.")

                # --- B∆Ø·ªöC 5: NH·∫§N XU·∫§T B·∫¢N ---
                self.after(0, lambda: self.update_status(f"üöÄ Chu·∫©n b·ªã xu·∫•t b·∫£n video..."))
                self._log_youtube_upload("üöÄ ƒêang nh·∫•n n√∫t Xu·∫•t b·∫£n/L∆∞u cu·ªëi c√πng...")
                click_with_fallback(driver, YOUTUBE_LOCATORS["done_button"], timeout=30)
                logging.info(f"{worker_log_prefix} ƒê√£ click n√∫t 'Xu·∫•t b·∫£n'.")
                self.after(0, lambda: self.update_status(f"üöÄ ƒê√£ nh·∫•n 'Xu·∫•t b·∫£n'. ƒêang ch·ªù x√°c nh·∫≠n..."))

                # --- B∆Ø·ªöC 6: X√ÅC NH·∫¨N CU·ªêI C√ôNG (GUARD 1h) ---
                try:
                    GUARD_SECS = int(getattr(self, "youtube_final_guard_seconds", 3600))
                    deadline_ts = time.time() + GUARD_SECS

                    logging.info(f"{worker_log_prefix} ƒêang ki·ªÉm tra s·ª± xu·∫•t hi·ªán c·ªßa popup 'T·∫£i l√™n' (ch·ªù 7 gi√¢y)...")

                    try:
                        # 1) Th·∫•y popup "T·∫£i video l√™n" ‚Üí ch·ªù bi·∫øn m·∫•t nh∆∞ng kh√¥ng qu√° GUARD_SECS
                        WebDriverWait(driver, 7).until(
                            EC.visibility_of_element_located(YOUTUBE_LOCATORS["uploading_popup"])
                        )
                        logging.info(f"{worker_log_prefix} ƒê√£ ph√°t hi·ªán popup 'T·∫£i l√™n'. Ch·ªù bi·∫øn m·∫•t (t·ªëi ƒëa {GUARD_SECS}s)...")
                        self.after(0, lambda: self.update_status("üì§ Tr√¨nh duy·ªát: Video ƒëang ƒë∆∞·ª£c t·∫£i l√™n server YouTube..."))

                        while True:
                            if getattr(self, "stop_event", None) and self.stop_event.is_set():
                                raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng trong khi ch·ªù popup bi·∫øn m·∫•t.")

                            remaining = deadline_ts - time.time()
                            if remaining <= 0:
                                logging.warning(f"{worker_log_prefix} ‚è± H·∫øt th·ªùi gian guard {GUARD_SECS}s. Auto-continue.")
                                self._handle_youtube_upload_completion(True, uploaded_video_id, "‚è± Qu√° 1h ‚Äî auto-continue.", False)
                                return

                            per_try = min(remaining, 30)
                            try:
                                WebDriverWait(driver, per_try).until(
                                    EC.invisibility_of_element_located(YOUTUBE_LOCATORS["uploading_popup"])
                                )
                                logging.info(f"{worker_log_prefix} ‚úÖ Popup 'T·∫£i l√™n' ƒë√£ bi·∫øn m·∫•t. Upload th√†nh c√¥ng!")
                                self._handle_youtube_upload_completion(True, uploaded_video_id, None, False)
                                return
                            except TimeoutException:
                                continue

                    except TimeoutException:
                        # 2) Kh√¥ng th·∫•y popup trong 7s ‚Üí video ng·∫Øn/redirect nhanh ‚Üí coi nh∆∞ OK
                        logging.info(f"{worker_log_prefix} ‚úÖ Kh√¥ng th·∫•y popup 'T·∫£i l√™n' sau 7s. Gi·∫£ ƒë·ªãnh upload ƒë√£ ho√†n t·∫•t.")
                        self._handle_youtube_upload_completion(True, uploaded_video_id, None, False)
                        return

                except (StaleElementReferenceException, NoSuchWindowException, WebDriverException) as e:
                    logging.info(f"{worker_log_prefix} ‚úÖ UI ƒë·ªïi/ƒë√≥ng trong khi ch·ªù ({type(e).__name__}). Gi·∫£ ƒë·ªãnh ƒë√£ ho√†n t·∫•t.")
                    self._handle_youtube_upload_completion(True, uploaded_video_id, None, False)
                    return        

                # Th√™m m·ªôt kho·∫£ng ngh·ªâ ng·∫Øn ƒë·ªÉ ƒë·∫£m b·∫£o m·ªçi th·ª© ·ªïn ƒë·ªãnh tr∆∞·ªõc khi ƒë√≥ng tr√¨nh duy·ªát
                logging.info(f"{worker_log_prefix} T·∫°m d·ª´ng 2 gi√¢y tr∆∞·ªõc khi ƒë√≥ng tr√¨nh duy·ªát.")
                time.sleep(2)        

            except InterruptedError as ie:
                logging.warning(f"{worker_log_prefix} T√°c v·ª• b·ªã d·ª´ng: {ie}")
                self._handle_youtube_upload_completion(False, uploaded_video_id, f"ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng: {ie}", False)
            except Exception as e_upload_browser:
                # B·∫Øt t·∫•t c·∫£ c√°c l·ªói kh√°c, bao g·ªìm c·∫£ TimeoutException n·∫øu C·∫¢ HAI ƒëi·ªÅu ki·ªán ƒë·ªÅu kh√¥ng x·∫£y ra.
                error_msg_final = f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi upload qua tr√¨nh duy·ªát: {type(e_upload_browser).__name__} - {e_upload_browser}"
                logging.critical(f"{worker_log_prefix} {error_msg_final}", exc_info=True)
                try:
                    if driver:
                        screenshot_path = os.path.join(config_directory, f"error_screenshot_{int(time.time())}.png")
                        driver.save_screenshot(screenshot_path)
                        error_msg_final += f"\n\n·∫¢nh ch·ª•p m√†n h√¨nh l·ªói ƒë√£ ƒë∆∞·ª£c l∆∞u t·∫°i:\n{screenshot_path}"
                except Exception as e_ss:
                    logging.error(f"{worker_log_prefix} Kh√¥ng th·ªÉ ch·ª•p ·∫£nh m√†n h√¨nh l·ªói: {e_ss}")
                self._handle_youtube_upload_completion(False, uploaded_video_id, error_msg_final, False)

            finally:
                if driver:
                    try:
                        import threading  # ch·ªâ threading, KH√îNG import os ·ªü ƒë√¢y
                        quit_err = {"e": None}
                        def _q():
                            try:
                                driver.quit()
                            except Exception as _e:
                                quit_err["e"] = _e
                        t = threading.Thread(target=_q, daemon=True)
                        t.start()
                        t.join(8)  # ch·ªù t·ªëi ƒëa 8s

                        if t.is_alive():
                            logging.warning(f"{worker_log_prefix} driver.quit() qu√° 8s -> kill chromedriver.")
                            try:
                                if service and hasattr(service, "process") and service.process:
                                    service.process.kill()
                            except Exception as kill_e:
                                logging.warning(f"{worker_log_prefix} Kh√¥ng th·ªÉ kill service process: {kill_e}")
                    except Exception as e_quit:
                        logging.error(f"{worker_log_prefix} L·ªói khi ƒë√≥ng tr√¨nh duy·ªát: {e_quit}")


# >>> B·∫ÆT ƒê·∫¶U C√ÅC H√ÄM M·ªöI CHO H√ÄNG CH·ªú UPLOAD <<<
    def _get_youtube_description(self):
        """L·∫•y n·ªôi dung m√¥ t·∫£ t·ª´ textbox YouTube upload."""
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if upload_tab and hasattr(upload_tab, 'youtube_description_textbox') and upload_tab.youtube_description_textbox and upload_tab.youtube_description_textbox.winfo_exists():
            return upload_tab.youtube_description_textbox.get("1.0", "end-1c").strip()
        return ""

    def _add_youtube_task_to_queue(self):
        """Thu th·∫≠p th√¥ng tin t·ª´ UI, t·∫°o m·ªôt task v√† th√™m v√†o h√†ng ch·ªù upload."""
        log_prefix = "[YouTubeQueue]"
        
        # 1. L·∫•y v√† x√°c th·ª±c th√¥ng tin
        video_path = self.youtube_video_path_var.get().strip()
        title = self.youtube_title_var.get().strip()

        if len(title) > 100:
            title = title[:100] # C·∫Øt b·ªõt ti√™u ƒë·ªÅ n·∫øu d√†i h∆°n 100 k√Ω t·ª±
            logging.warning(f"[YouTubeQueue] Ti√™u ƒë·ªÅ qu√° d√†i, ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông c·∫Øt c√≤n 100 k√Ω t·ª±: '{title}'")  
        
        if not video_path or not os.path.exists(video_path):
            messagebox.showwarning("Thi·∫øu Video", "Vui l√≤ng ch·ªçn m·ªôt file video h·ª£p l·ªá.", parent=self)
            return
        if not title:
            messagebox.showwarning("Thi·∫øu Ti√™u ƒë·ªÅ", "Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ cho video.", parent=self)
            return

        # 2. T·∫°o m·ªôt dictionary cho t√°c v·ª•
        task_data = {
            "id": str(uuid.uuid4()),
            "video_path": video_path,
            "title": title,
            "description": self._get_youtube_description(),
            "tags_str": self.youtube_tags_var.get().strip(),
            "playlist_name": self.youtube_playlist_var.get().strip(),
            "thumbnail_path": self.youtube_thumbnail_path_var.get().strip(),
            "privacy_status": self.youtube_privacy_status_var.get(),
            "category_id": self.youtube_category_id_var.get(),
            "status": "Ch·ªù x·ª≠ l√Ω"
        }
        
        # 3. Th√™m v√†o h√†ng ch·ªù v√† c·∫≠p nh·∫≠t UI
        self.youtube_upload_queue.append(task_data)
        logging.info(f"{log_prefix} ƒê√£ th√™m t√°c v·ª• '{title}' v√†o h√†ng ch·ªù. T·ªïng s·ªë: {len(self.youtube_upload_queue)}")
        
        # 4. Reset c√°c √¥ nh·∫≠p li·ªáu ƒë·ªÉ chu·∫©n b·ªã cho t√°c v·ª• ti·∫øp theo
        self.youtube_video_path_var.set("")
        self.youtube_title_var.set("")
        self.youtube_thumbnail_path_var.set("")
        
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        if upload_tab and hasattr(upload_tab, 'youtube_thumbnail_path_display_label') and upload_tab.youtube_thumbnail_path_display_label and upload_tab.youtube_thumbnail_path_display_label.winfo_exists():
            upload_tab.youtube_thumbnail_path_display_label.configure(text="(Ch∆∞a ch·ªçn ·∫£nh)", text_color=("gray30", "gray70"))        
        self.update_youtube_queue_display()
        self.update_status(f"‚úÖ ƒê√£ th√™m '{title[:30]}...' v√†o h√†ng ch·ªù upload.")


# C·∫≠p nh·∫≠t giao di·ªán c·ªßa h√†ng ch·ªù upload YouTube
    def update_youtube_queue_display(self):
        """C·∫≠p nh·∫≠t giao di·ªán c·ªßa h√†ng ch·ªù upload YouTube."""
        upload_tab = getattr(self, 'youtube_upload_view_frame', None)
        queue_widget = getattr(upload_tab, 'youtube_queue_display_frame', None) if upload_tab else None
        
        if not queue_widget or not queue_widget.winfo_exists():
            return

        for widget in queue_widget.winfo_children():
            if widget.winfo_exists(): # Th√™m ki·ªÉm tra cho t·ª´ng widget con n·ªØa cho an to√†n
                widget.destroy()

        # L·∫•y t√°c v·ª• ƒëang x·ª≠ l√Ω ƒë·ªÉ hi·ªÉn th·ªã ri√™ng
        processing_task = None
        if self.youtube_currently_processing_task_id:
            processing_task = next((t for t in self.youtube_upload_queue if t.get('id') == self.youtube_currently_processing_task_id), None)
        
        # Hi·ªÉn th·ªã t√°c v·ª• ƒëang x·ª≠ l√Ω
        if processing_task:
            frame = ctk.CTkFrame(queue_widget, fg_color="#006933", corner_radius=5)
            frame.pack(fill="x", pady=(2, 5), padx=2)
            
            # <<< B·∫ÆT ƒê·∫¶U C·∫¨P NH·∫¨T CHO M·ª§C ƒêANG UPLOAD >>>
            label_text = f"‚ñ∂ ƒêANG UPLOAD:\n   {processing_task['title']}"
            
            # 1. G√°n label cho m·ªôt bi·∫øn
            label_widget = ctk.CTkLabel(frame, text=label_text, font=("Poppins", 11, "bold"), justify="left", anchor='w', text_color="white")
            # 2. Pack label ƒë√≥
            label_widget.pack(side="left", padx=5, pady=3, fill="x")
            # 3. Th√™m Tooltip cho label, hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß ti√™u ƒë·ªÅ
            Tooltip(label_widget, text=processing_task['title'])
            # <<< K·∫æT TH√öC C·∫¨P NH·∫¨T >>>

        # Hi·ªÉn th·ªã c√°c t√°c v·ª• ƒëang ch·ªù
        waiting_tasks = [task for task in self.youtube_upload_queue if task.get('id') != self.youtube_currently_processing_task_id]

        if not waiting_tasks and not processing_task:
            ctk.CTkLabel(queue_widget, text="[H√†ng ch·ªù upload tr·ªëng]", font=("Segoe UI", 11), text_color="gray").pack(pady=20)
            self._update_youtube_ui_state(False) # C·∫≠p nh·∫≠t l·∫°i n√∫t Start Upload
            return

        for index, task in enumerate(waiting_tasks):
            item_frame = ctk.CTkFrame(queue_widget, fg_color="transparent")
            item_frame.pack(fill="x", padx=2, pady=(1,2))
            
            # <<< B·∫ÆT ƒê·∫¶U C·∫¨P NH·∫¨T CHO C√ÅC M·ª§C ƒêANG CH·ªú >>>
            info_text = f"{index + 1}. {task['title']}"
            if task.get('status') != 'Ch·ªù x·ª≠ l√Ω':
                info_text += f" [{task['status']}]"

            # 1. G√°n label cho m·ªôt bi·∫øn
            label_widget = ctk.CTkLabel(item_frame, text=info_text, anchor="w", font=("Segoe UI", 10))
            # 2. Pack label ƒë√≥
            label_widget.pack(side="left", padx=(5, 0), expand=True, fill="x")
            # 3. Th√™m Tooltip cho label
            Tooltip(label_widget, text=task['title'])
            # <<< K·∫æT TH√öC C·∫¨P NH·∫¨T >>>

            # Frame nh·ªè ƒë·ªÉ ch·ª©a c√°c n√∫t ƒëi·ªÅu khi·ªÉn
            controls_frame = ctk.CTkFrame(item_frame, fg_color="transparent")
            controls_frame.pack(side="right", padx=(5, 5))

            # N√∫t X√≥a
            button_state = ctk.DISABLED if self.is_uploading_youtube else ctk.NORMAL
            del_button = ctk.CTkButton(
                controls_frame, text="‚úï",
                width=28, height=28,
                font=("Segoe UI", 12, "bold"),
                fg_color="#E74C3C", hover_color="#C0392B",
                command=lambda task_id=task['id']: self._remove_youtube_task_from_queue(task_id),
                state=button_state
            )
            del_button.pack()


    def _remove_youtube_task_from_queue(self, task_id_to_remove):
        """X√≥a m·ªôt t√°c v·ª• kh·ªèi h√†ng ch·ªù upload YouTube d·ª±a tr√™n ID."""
        if self.is_uploading_youtube:
            messagebox.showwarning("ƒêang x·ª≠ l√Ω", "Kh√¥ng th·ªÉ x√≥a t√°c v·ª• khi ƒëang upload.", parent=self)
            return

        initial_len = len(self.youtube_upload_queue)
        # T·∫°o m·ªôt danh s√°ch m·ªõi kh√¥ng ch·ª©a t√°c v·ª• c·∫ßn x√≥a
        self.youtube_upload_queue = [task for task in self.youtube_upload_queue if task.get('id') != task_id_to_remove]
        
        if len(self.youtube_upload_queue) < initial_len:
            logging.info(f"ƒê√£ x√≥a t√°c v·ª• upload (ID: {task_id_to_remove}) kh·ªèi h√†ng ch·ªù.")
            self.update_youtube_queue_display() # C·∫≠p nh·∫≠t l·∫°i giao di·ªán
            self.update_status("‚ÑπÔ∏è ƒê√£ x√≥a 1 t√°c v·ª• kh·ªèi h√†ng ch·ªù upload.")

            # H·∫πn gi·ªù 4 gi√¢y (4000ms) sau s·∫Ω g·ªçi h√†m reset status
            self.after(4000, self._reset_status_to_default)

        else:
            logging.warning(f"Kh√¥ng t√¨m th·∫•y t√°c v·ª• upload v·ªõi ID '{task_id_to_remove}' ƒë·ªÉ x√≥a.")


    def _reset_status_to_default(self):
        """
        (PHI√äN B·∫¢N 2.0 - TH√îNG MINH H∆†N)
        ƒê·∫∑t l·∫°i thanh tr·∫°ng th√°i v·ªÅ m·∫∑c ƒë·ªãnh, C√ì X√âT ƒë·∫øn tab (view) hi·ªán t·∫°i.
        """
        # 1. Ki·ªÉm tra xem c√≥ t√°c v·ª• n√†o ƒëang ch·∫°y kh√¥ng, n·∫øu c√≥ th√¨ kh√¥ng l√†m g√¨ c·∫£
        is_busy = (
            self.is_subbing or self.is_downloading or self.is_loading_model_for_timer or
            self.dub_is_processing or self.is_creating_slideshow or self.is_gpt_processing_script or
            self.is_dalle_processing or self.is_gemini_processing or self.is_imagen_processing or
            self.is_uploading_youtube
        )
        if is_busy:
            return

        # 2. X√°c ƒë·ªãnh tr·∫°ng th√°i m·∫∑c ƒë·ªãnh d·ª±a tr√™n b·∫£n quy·ªÅn
        is_app_active = self._is_app_fully_activated()
        
        default_status_msg = "‚úÖ S·∫µn s√†ng!" # M·∫∑c ƒë·ªãnh chung

        # Ki·ªÉm tra tab hi·ªán t·∫°i ƒë·ªÉ ƒë∆∞a ra th√¥ng b√°o ph√π h·ª£p
        if is_app_active:
            current_view = self.current_view if hasattr(self, 'current_view') else ""
            if current_view == "üì§ Upload YT":
                default_status_msg = "‚úÖ YouTube: S·∫µn s√†ng upload."
            elif current_view == "‚Üì T·∫£i Xu·ªëng":
                default_status_msg = "‚úÖ Download: S·∫µn s√†ng nh·∫≠n link."
            elif current_view == "‚â° T·∫°o Ph·ª• ƒê·ªÅ":
                default_status_msg = "‚úÖ Subtitle: S·∫µn s√†ng x·ª≠ l√Ω file."
            elif current_view == "‚ô™ Thuy·∫øt Minh":
                default_status_msg = "‚úÖ Dubbing: S·∫µn s√†ng l·ªìng ti·∫øng."
            # N·∫øu kh√¥ng ·ªü tab n√†o c·ª• th·ªÉ, n√≥ s·∫Ω d√πng "‚úÖ S·∫µn s√†ng!" ƒë√£ ƒë·∫∑t ·ªü tr√™n
        else:
            default_status_msg = "‚õî Y√™u c·∫ßu K√≠ch ho·∫°t"
        
        # 3. C·∫≠p nh·∫≠t l·∫°i thanh tr·∫°ng th√°i
        self.update_status(default_status_msg)


# Ki·ªÉm tra checkbox t·ª± ƒë·ªông v√† th√™m video ƒë√£ ho√†n th√†nh v√†o h√†ng ch·ªù upload.
    def _add_completed_video_to_upload_queue(self, final_task_object):
        """
        (PHI√äN B·∫¢N 5.0 - D√πng Task Object)
        Nh·∫≠n m·ªôt "ƒê·ªëi t∆∞·ª£ng T√°c v·ª•" ƒë√£ ho√†n th√†nh, tra c·ª©u metadata d·ª±a tr√™n
        'identifier' b·∫•t bi·∫øn v√† th√™m v√†o h√†ng ch·ªù upload.
        """
        log_prefix = "[AutoUploadChain_v5_TaskObject]"

        # 1. Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán ƒë·∫ßu v√†o
        if not (hasattr(self, 'auto_upload_to_youtube_var') and self.auto_upload_to_youtube_var.get()):
            logging.info(f"{log_prefix} T·ª± ƒë·ªông upload kh√¥ng ƒë∆∞·ª£c b·∫≠t. B·ªè qua.")
            return

        if not isinstance(final_task_object, dict):
            logging.error(f"{log_prefix} L·ªói: ƒê·∫ßu v√†o kh√¥ng ph·∫£i l√† m·ªôt ƒê·ªëi t∆∞·ª£ng T√°c v·ª• (dictionary).")
            return

        # L·∫•y ƒë∆∞·ªùng d·∫´n video cu·ªëi c√πng t·ª´ task object (ki·ªÉm tra nhi·ªÅu key c√≥ th·ªÉ c√≥)
        final_video_path = (final_task_object.get('branded_path') or
                           final_task_object.get('dubbed_video_path') or
                           final_task_object.get('final_video_path') or # Key ch√∫ng ta ƒë√£ th√™m
                           final_task_object.get('downloaded_video_path'))
                           
        identifier = final_task_object.get('identifier')

        if not final_video_path or not os.path.exists(final_video_path):
            logging.warning(f"{log_prefix} Kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n video h·ª£p l·ªá trong t√°c v·ª• (ID: {identifier}).")
            return
        
        if not identifier:
            logging.warning(f"{log_prefix} Kh√¥ng c√≥ 'identifier' trong t√°c v·ª• ƒë·ªÉ tra c·ª©u metadata. S·∫Ω d√πng t√™n file l√†m fallback.")
            # N·∫øu kh√¥ng c√≥ identifier, quay v·ªÅ logic c≈© l√† d√πng t√™n file
            identifier = os.path.splitext(os.path.basename(final_video_path))[0]

        logging.info(f"{log_prefix} Chu·∫©n b·ªã th√™m video '{os.path.basename(final_video_path)}' (ID: {identifier}) v√†o h√†ng ch·ªù upload...")

        # 2. Tra c·ª©u metadata trong cache
        metadata = None
        if hasattr(self, 'master_metadata_cache') and self.master_metadata_cache:
            metadata = self.master_metadata_cache.get(identifier)

        if metadata:
            logging.info(f"{log_prefix} T√¨m th·∫•y metadata cho key '{identifier}'.")
            # L·∫•y th√¥ng tin t·ª´ metadata. N·∫øu key kh√¥ng t·ªìn t·∫°i ho·∫∑c gi√° tr·ªã l√† chu·ªói r·ªóng, s·∫Ω tr·∫£ v·ªÅ None.
            video_title = metadata.get('title') or os.path.splitext(os.path.basename(final_video_path))[0]
            video_description = metadata.get('description') or None
            video_tags = metadata.get('tags') or None
            thumbnail_path = metadata.get('thumbnail') or None
            playlist_name = metadata.get('playlist') or None
        else:
            # Fallback n·∫øu kh√¥ng t√¨m th·∫•y key trong file JSON -> l·∫•y theo t√™n file v√† ƒë·ªÉ tr·ªëng c√°c tr∆∞·ªùng kh√°c
            logging.warning(f"{log_prefix} Kh√¥ng t√¨m th·∫•y key '{identifier}' trong Master Metadata. S·ª≠ d·ª•ng logic m·∫∑c ƒë·ªãnh.")
            video_title = os.path.splitext(os.path.basename(final_video_path))[0]
            video_description = None # ƒê·ªÉ YouTube t·ª± ƒëi·ªÅn default
            video_tags = None        # ƒê·ªÉ YouTube t·ª± ƒëi·ªÅn default
            thumbnail_path = None
            playlist_name = None     # Kh√¥ng th√™m v√†o playlist n√†o

        # Ki·ªÉm tra v√† c·∫Øt b·ªõt ti√™u ƒë·ªÅ n·∫øu c·∫ßn
        if len(video_title) > 100:
            video_title = video_title[:100]
            logging.warning(f"[_add_completed_video_to_upload_queue] Ti√™u ƒë·ªÅ t·ª´ metadata/filename qu√° d√†i, ƒë√£ c·∫Øt c√≤n 100 k√Ω t·ª±: '{video_title}'")

        # 3. T·∫°o t√°c v·ª• upload v·ªõi th√¥ng tin ƒë√£ l·∫•y ƒë∆∞·ª£c
        upload_task = {
            "id": str(uuid.uuid4()),
            "video_path": final_video_path,
            "title": video_title,
            "description": video_description,
            "tags_str": video_tags,
            "thumbnail_path": thumbnail_path,
            "playlist_name": playlist_name,
            "privacy_status": self.youtube_privacy_status_var.get(), # L·∫•y t·ª´ UI
            "category_id": self.youtube_category_id_var.get(), # L·∫•y t·ª´ UI
            "status": "Ch·ªù x·ª≠ l√Ω"
        }
        
        # Th√™m v√†o h√†ng ch·ªù v√† c·∫≠p nh·∫≠t UI
        self.youtube_upload_queue.append(upload_task)
        logging.info(f"{log_prefix} ƒê√£ th√™m t√°c v·ª• '{video_title}' v√†o h√†ng ch·ªù upload.")
        
        # G·ªçi c·∫≠p nh·∫≠t UI tr√™n lu·ªìng ch√≠nh
        self.after(0, self.update_youtube_queue_display)
        self.after(0, lambda: self.update_status(f"üì§ ƒê√£ th√™m '{video_title[:30]}...' v√†o h√†ng ch·ªù upload."))


# M·ªü c·ª≠a s·ªï Tr√¨nh Qu·∫£n l√Ω Metadata
    def _open_metadata_manager(self):
        """M·ªü c·ª≠a s·ªï Tr√¨nh Qu·∫£n l√Ω Metadata."""
        if hasattr(self, '_metadata_manager_win') and self._metadata_manager_win and self._metadata_manager_win.winfo_exists():
            self._metadata_manager_win.focus()
            return
        
        self._metadata_manager_win = MetadataManagerWindow(master_app=self) 


# T·∫£i d·ªØ li·ªáu t·ª´ file master_metadata.json cu·ªëi c√πng ƒë∆∞·ª£c s·ª≠ d·ª•ng v√†o b·ªô nh·ªõ ƒë·ªám
    def _load_master_metadata_cache(self):
        """T·∫£i d·ªØ li·ªáu t·ª´ file master_metadata.json cu·ªëi c√πng ƒë∆∞·ª£c s·ª≠ d·ª•ng v√†o b·ªô nh·ªõ ƒë·ªám."""
        log_prefix = "[MetadataCache]"
        # L·∫•y ƒë∆∞·ªùng d·∫´n file ƒë√£ l∆∞u t·ª´ config
        last_metadata_path = self.cfg.get('last_master_metadata_path')

        if not last_metadata_path or not os.path.exists(last_metadata_path):
            logging.info(f"{log_prefix} Kh√¥ng c√≥ file master metadata n√†o ƒë∆∞·ª£c c·∫•u h√¨nh ho·∫∑c file kh√¥ng t·ªìn t·∫°i.")
            self.master_metadata_cache = {} # ƒê·∫£m b·∫£o cache r·ªóng
            return

        try:
            with open(last_metadata_path, 'r', encoding='utf-8') as f:
                self.master_metadata_cache = json.load(f)
            logging.info(f"{log_prefix} ƒê√£ t·∫£i th√†nh c√¥ng {len(self.master_metadata_cache)} m·ª•c t·ª´ '{os.path.basename(last_metadata_path)}' v√†o cache.")
        
        except (json.JSONDecodeError, TypeError) as e:
            logging.error(f"{log_prefix} L·ªói khi ƒë·ªçc ho·∫∑c ph√¢n t√≠ch file JSON metadata: {e}")
            self.master_metadata_cache = {} # Reset cache n·∫øu l·ªói
            # Th√¥ng b√°o cho ng∆∞·ªùi d√πng m·ªôt c√°ch an to√†n tr√™n lu·ªìng ch√≠nh
            self.after(0, lambda: messagebox.showwarning("L·ªói T·∫£i Metadata",
                                   f"Kh√¥ng th·ªÉ t·∫£i file master metadata t·∫°i:\n{last_metadata_path}\n\nL·ªói: {e}\n\n"
                                   "T√≠nh nƒÉng t·ª± ƒë·ªông ƒëi·ªÅn th√¥ng tin upload s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.",
                                   parent=self))
        except Exception as e:
            logging.error(f"{log_prefix} L·ªói kh√¥ng mong mu·ªën khi t·∫£i file metadata: {e}", exc_info=True)
            self.master_metadata_cache = {}


# H√†m X·ª≠ l√Ω khi m·ªôt trong c√°c checkbox metadata ƒë∆∞·ª£c nh·∫•n,
    def _on_metadata_checkbox_toggled(self, source):
        """
        X·ª≠ l√Ω khi m·ªôt trong c√°c checkbox metadata ƒë∆∞·ª£c nh·∫•n,
        ƒë·∫£m b·∫£o ch√∫ng lo·∫°i tr·ª´ l·∫´n nhau v√† c·∫≠p nh·∫≠t UI.
        """
        # NgƒÉn ch·∫∑n thay ƒë·ªïi n·∫øu ƒëang upload
        if self.is_uploading_youtube:
            # Ho·∫∑c hi·ªán messagebox c·∫£nh b√°o, ho·∫∑c √¢m th·∫ßm kh√¥ng l√†m g√¨
            return

        if source == 'fetch' and self.youtube_fetch_metadata_var.get():
            self.youtube_autofill_var.set(False)
        elif source == 'autofill' and self.youtube_autofill_var.get():
            self.youtube_fetch_metadata_var.set(False)

        # Sau khi thay ƒë·ªïi tr·∫°ng th√°i, g·ªçi h√†m √°p d·ª•ng logic
        self._autofill_youtube_fields()
        # L∆∞u l·∫°i c√†i ƒë·∫∑t
        self.save_current_config()


# T·ª± ƒë·ªông ƒëi·ªÅn c√°c tr∆∞·ªùng th√¥ng tin YouTube d·ª±a tr√™n checkbox n√†o ƒëang ƒë∆∞·ª£c b·∫≠t.
    def _autofill_youtube_fields(self):
        """
        T·ª± ƒë·ªông ƒëi·ªÅn c√°c tr∆∞·ªùng th√¥ng tin YouTube d·ª±a tr√™n checkbox n√†o ƒëang ƒë∆∞·ª£c b·∫≠t.
        ∆Øu ti√™n "L·∫•y metadata" tr∆∞·ªõc, sau ƒë√≥ m·ªõi ƒë·∫øn "L·∫•y theo t√™n file".
        """
        video_path = self.youtube_video_path_var.get()
        if not video_path or not os.path.exists(video_path):
            return # Kh√¥ng l√†m g√¨ n·∫øu ch∆∞a c√≥ video ƒë∆∞·ª£c ch·ªçn

        # ∆Øu ti√™n 1: L·∫•y t·ª´ Master Metadata
        if self.youtube_fetch_metadata_var.get():
            identifier = get_identifier_from_source(video_path)
            logging.info(f"ƒêang t√¨m metadata cho key: '{identifier}'")

            if hasattr(self, 'master_metadata_cache') and identifier in self.master_metadata_cache:
                metadata = self.master_metadata_cache[identifier]
                
                self.youtube_title_var.set(metadata.get('title', ''))
                self.youtube_tags_var.set(metadata.get('tags', ''))
                self.youtube_playlist_var.set(metadata.get('playlist', ''))
                self.youtube_thumbnail_path_var.set(metadata.get('thumbnail', ''))
                
                self.youtube_description_textbox.delete("1.0", "end")
                self.youtube_description_textbox.insert("1.0", metadata.get('description', ''))
                
                # C·∫≠p nh·∫≠t label hi·ªÉn th·ªã thumbnail
                thumb_path = self.youtube_thumbnail_path_var.get()
                if thumb_path and os.path.exists(thumb_path):
                    self.youtube_thumbnail_path_display_label.configure(text=os.path.basename(thumb_path), text_color=("gray10", "lightgreen"))
                else:
                    self.youtube_thumbnail_path_display_label.configure(text="(Ch∆∞a c√≥ ·∫£nh trong metadata)", text_color=("gray30", "gray70"))

                self.update_status(f"‚úÖ ƒê√£ t·ª± ƒë·ªông ƒëi·ªÅn th√¥ng tin t·ª´ Master Metadata cho '{identifier}'.")
                logging.info(f"ƒê√£ √°p d·ª•ng th√†nh c√¥ng metadata cho key '{identifier}'.")
            else:
                self.update_status(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y metadata cho '{identifier}'.")
                logging.warning(f"Kh√¥ng t√¨m th·∫•y metadata cho key '{identifier}' trong cache.")

        # ∆Øu ti√™n 2: L·∫•y theo t√™n file (ch·ªâ ch·∫°y n·∫øu ∆∞u ti√™n 1 kh√¥ng ƒë∆∞·ª£c ch·ªçn)
        elif self.youtube_autofill_var.get():
            default_title = os.path.splitext(os.path.basename(video_path))[0]
            self.youtube_title_var.set(default_title)
            self.update_status("‚úÖ ƒê√£ t·ª± ƒë·ªông ƒëi·ªÅn ti√™u ƒë·ªÅ t·ª´ t√™n file.")

# ==========================================================================================================================================================================================

# H√†m logic UI: Chuy·ªÉn ƒë·ªïi gi·ªØa c√°c ch·∫ø ƒë·ªô xem (tab)
    def switch_view(self, selected_value):
        """Chuy·ªÉn ch·∫ø ƒë·ªô xem: ·∫©n t·∫•t c·∫£ frame c≈© r·ªìi hi·ªán frame m·ªõi an to√†n."""
        logging.info(f"ƒêang chuy·ªÉn ch·∫ø ƒë·ªô xem sang: {selected_value}")

        # Map t√™n tab -> thu·ªôc t√≠nh frame
        frames_map = {
            "‚â° T·∫°o Ph·ª• ƒê·ªÅ":  "subtitle_view_frame",
            "‚Üì T·∫£i Xu·ªëng":   "download_view_frame",
            "‚ô™ Thuy·∫øt Minh": "dubbing_view_frame",
            "üì§ Upload YT":  "youtube_upload_view_frame",
            "‚úç AI Bi√™n T·∫≠p": "ai_editor_view_frame",
        }

        # 1) ·∫®n T·∫§T C·∫¢ frame ƒëang pack ƒë·ªÉ tr√°nh ch·ªìng ch√©o
        for attr in frames_map.values():
            f = getattr(self, attr, None)
            if f and f.winfo_exists():
                try:
                    f.pack_forget()
                except Exception:
                    pass

        # 2) Hi·ªán frame m·ªõi theo l·ª±a ch·ªçn
        target_attr = frames_map.get(selected_value)
        target = getattr(self, target_attr, None) if target_attr else None
        if target:
            target.pack(expand=True, fill="both")

        # 3) C·∫≠p nh·∫≠t tr·∫°ng th√°i hi·ªán t·∫°i
        self.current_view = selected_value
        self.update_idletasks()

        # 4) T√≠nh tr·∫°ng th√°i t√°c v·ª• ƒëang ch·∫°y (tr√°nh ƒë√® status khi ƒëang x·ª≠ l√Ω)
        any_timer_task_active_on_switch = bool(
            getattr(self, 'is_manual_sub_processing', False) or
            getattr(self, 'is_subbing', False) or
            getattr(self, 'is_downloading', False) or
            getattr(self, 'is_loading_model_for_timer', False) or
            getattr(self, 'dub_is_processing', False) or
            getattr(self, 'is_creating_slideshow', False) or   # b·ªè b·∫£n tr√πng
            getattr(self, 'is_gpt_processing_script', False) or
            getattr(self, 'is_dalle_processing', False) or
            getattr(self, 'is_performing_single_task', False)
        )

        # 5) C·∫≠p nh·∫≠t nh√£n tr·∫°ng th√°i + set UI c·ªßa tab n·∫øu r·∫£nh
        if getattr(self, 'initial_ui_setup_complete', False):
            is_in_a_chain = getattr(self, 'chain_download_sub_dub_active', False)
            if not any_timer_task_active_on_switch and not is_in_a_chain:

                def _set_ready_after_switch_if_appropriate(selected):
                    # Ki·ªÉm tra k√≠ch ho·∫°t
                    try:
                        is_active = self._is_app_fully_activated()
                    except Exception:
                        is_active = False

                    ready_map = {
                        "‚Üì T·∫£i Xu·ªëng":   "‚úÖ Download: S·∫µn s√†ng nh·∫≠n link.",
                        "‚â° T·∫°o Ph·ª• ƒê·ªÅ":  "‚úÖ Subtitle: S·∫µn s√†ng x·ª≠ l√Ω file.",
                        "‚ô™ Thuy·∫øt Minh": "‚úÖ Dubbing: S·∫µn s√†ng l·ªìng ti·∫øng.",
                        "üì§ Upload YT":  "‚úÖ Upload YT: S·∫µn s√†ng upload Video.",
                        "‚úç AI Bi√™n T·∫≠p": "‚úÖ AI Bi√™n T·∫≠p: S·∫µn s√†ng bi√™n t·∫≠p K·ªãch B·∫£n.",
                    }
                    locked_map = {
                        "‚Üì T·∫£i Xu·ªëng":   "üîí Download: C·∫ßn k√≠ch ho·∫°t.",
                        "‚â° T·∫°o Ph·ª• ƒê·ªÅ":  "üîí Subtitle: C·∫ßn k√≠ch ho·∫°t.",
                        "‚ô™ Thuy·∫øt Minh": "üîí Dubbing: C·∫ßn k√≠ch ho·∫°t.",
                        "üì§ Upload YT":  "üîí Upload YT: C·∫ßn k√≠ch ho·∫°t.",
                        "‚úç AI Bi√™n T·∫≠p": "üîí AI Bi√™n T·∫≠p: C·∫ßn k√≠ch ho·∫°t.",
                    }

                    if not is_active:
                        msg = locked_map.get(selected, "üîí C·∫ßn k√≠ch ho·∫°t.")
                    else:
                        current_base = ""
                        if getattr(self, "status_label", None) and self.status_label.winfo_exists():
                            current_base = self.status_label.cget("text").split(" | ‚è± ")[0]
                        is_specific = current_base.startswith(("‚ÑπÔ∏è ", "‚ùå ", "‚ö†Ô∏è ", "üõë")) and \
                                      not current_base.startswith(("‚úÖ S·∫µn s√†ng!", "‚úÖ ·ª®ng d·ª•ng ƒë√£ s·∫µn s√†ng"))
                        if is_specific:
                            logging.info(f"Switch view '{selected}': gi·ªØ nguy√™n th√¥ng b√°o c·ª• th·ªÉ: '{current_base}'.")
                            return
                        msg = ready_map.get(selected, "‚úÖ S·∫µn s√†ng!")

                    try:
                        self.update_status(msg)
                    except Exception:
                        pass
                    logging.info(f"Switch view sang '{selected}', c·∫≠p nh·∫≠t status: '{msg}'.")

                    # G·ªçi set-state tab t∆∞∆°ng ·ª©ng (s·ª≠a l·ªói bi·∫øn 'view_name' -> d√πng 'selected')
                    try:
                        if selected == "‚ô™ Thuy·∫øt Minh" and hasattr(self, "_set_dubbing_tab_ui_state"):
                            self.after(0, self._set_dubbing_tab_ui_state)
                        elif selected == "‚â° T·∫°o Ph·ª• ƒê·ªÅ" and hasattr(self, "_set_subtitle_tab_ui_state"):
                            self.after(0, lambda: self._set_subtitle_tab_ui_state(getattr(self, "is_subbing", False)))
                        elif selected == "üì§ Upload YT" and hasattr(self, "_set_upload_tab_ui_state"):
                            self.after(0, self._set_upload_tab_ui_state)
                        elif selected == "‚úç AI Bi√™n T·∫≠p" and hasattr(self, "_set_ai_edit_tab_ui_state"):
                            self.after(0, self._set_ai_edit_tab_ui_state)
                        elif selected == "‚Üì T·∫£i Xu·ªëng" and hasattr(self, 'download_view_frame') and hasattr(self.download_view_frame, 'set_download_ui_state'):
                            self.after(0, lambda: self.download_view_frame.set_download_ui_state(downloading=False))
                    except Exception:
                        pass

                _set_ready_after_switch_if_appropriate(selected_value)
                self.after(250, lambda sv=selected_value: _set_ready_after_switch_if_appropriate(sv))


# ==========================================================================================================================================================================================

# H√†m ƒê√≥ng c·ª≠a s·ªï SPLASH SCREEN khi nh·∫•n X
    def _force_show_from_splash_close(self):
        """
        ƒê∆∞·ª£c g·ªçi b·ªüi n√∫t X tr√™n splash screen.
        ƒê√≥ng splash screen v√† hi·ªÉn th·ªã c·ª≠a s·ªï ch√≠nh ngay l·∫≠p t·ª©c, b·ªè qua vi·ªác ch·ªù c√°c t√°c v·ª• kh·ªüi ƒë·ªông.
        """
        logging.warning("B·ªè qua ch·ªù kh·ªüi ƒë·ªông t·ª´ Splash Screen.")

        # 1. ƒê√≥ng splash screen n·∫øu n√≥ ƒëang t·ªìn t·∫°i
        if hasattr(self, 'splash') and self.splash and self.splash.winfo_exists():
            self.splash.close()
            self.splash = None
        
        # 2. Hi·ªÉn th·ªã c·ª≠a s·ªï ch√≠nh
        if not self.winfo_viewable(): # Ch·ªâ hi·ªÉn th·ªã n·∫øu n√≥ ƒëang b·ªã ·∫©n
            self.deiconify()
            self.lift()
            self.attributes("-topmost", True)
            # Sau m·ªôt kho·∫£ng tr·ªÖ nh·ªè, b·ªè c·ªù topmost ƒë·ªÉ c√°c c·ª≠a s·ªï kh√°c c√≥ th·ªÉ ƒë√® l√™n
            self.after(200, lambda: self.attributes("-topmost", False))
            self.focus_force()

        # 3. C·∫≠p nh·∫≠t c√°c c·ªù tr·∫°ng th√°i ƒë·ªÉ ·ª©ng d·ª•ng ho·∫°t ƒë·ªông
        # ƒê√°nh d·∫•u qu√° tr√¨nh kh·ªüi t·∫°o ƒë√£ k·∫øt th√∫c (d√π b·ªã b·ªè qua)
        self.is_app_initializing = False
        self.initial_ui_setup_complete = True # Cho ph√©p c√°c UI kh√°c ho·∫°t ƒë·ªông
        
        # 4. ƒê·∫∑t m·ªôt th√¥ng b√°o c·∫£nh b√°o tr√™n thanh tr·∫°ng th√°i
        self.update_status("‚ö†Ô∏è Kh·ªüi ƒë·ªông b·ªã b·ªè qua, m·ªôt s·ªë ch·ª©c nƒÉng c√≥ th·ªÉ ch∆∞a s·∫µn s√†ng.")
        
        # L∆∞u √Ω: C√°c lu·ªìng ki·ªÉm tra (b·∫£n quy·ªÅn, c·∫≠p nh·∫≠t) ƒë√£ ƒë∆∞·ª£c kh·ªüi ch·∫°y trong n·ªÅn s·∫Ω
        # ti·∫øp t·ª•c ch·∫°y v√† t·ª± ho√†n th√†nh. Khi ch√∫ng xong, ch√∫ng c√≥ th·ªÉ s·∫Ω c·∫≠p nh·∫≠t l·∫°i
        # thanh tr·∫°ng th√°i v·ªõi th√¥ng tin ch√≠nh x√°c.

#------------------------------------------------------------------------------------------------------------------------------------

# C√°c h√†m h·ªó tr·ª£ t·∫£i font
    def _load_system_fonts_in_background(self, callback=None):
        """
        (PHI√äN B·∫¢N T·ªêI ∆ØU)
        T·∫£i danh s√°ch font t·ª´ file cache n·∫øu c√≥. N·∫øu kh√¥ng, qu√©t h·ªá th·ªëng
        trong m·ªôt lu·ªìng n·ªÅn, l∆∞u v√†o cache, v√† c·∫≠p nh·∫≠t UI.
        """
        font_cache_path = get_font_cache_path()

        # --- ∆ØU TI√äN 1: ƒê·ªåC T·ª™ FILE CACHE ---
        if os.path.exists(font_cache_path):
            logging.info(f"T√¨m th·∫•y file font cache t·∫°i: {font_cache_path}. ƒêang ƒë·ªçc...")
            try:
                with open(font_cache_path, "r", encoding="utf-8") as f:
                    self.system_fonts_cache = json.load(f)
                logging.info(f"ƒê√£ t·∫£i th√†nh c√¥ng {len(self.system_fonts_cache)} font t·ª´ file cache.")
                if callback:
                    self.after(10, callback) # G·ªçi callback tr√™n lu·ªìng ch√≠nh
                return # Ho√†n th√†nh, kh√¥ng c·∫ßn qu√©t h·ªá th·ªëng
            except (json.JSONDecodeError, IOError) as e:
                logging.warning(f"L·ªói khi ƒë·ªçc file font cache: {e}. S·∫Ω th·ª±c hi·ªán qu√©t l·∫°i h·ªá th·ªëng.")
                # N·∫øu l·ªói, ti·∫øp t·ª•c th·ª±c hi·ªán qu√©t h·ªá th·ªëng b√™n d∆∞·ªõi

        # --- ∆ØU TI√äN 2: QU√âT H·ªÜ TH·ªêNG (N·∫æU KH√îNG C√ì CACHE) ---
        if self.fonts_are_loading:
            logging.info("ƒê√£ c√≥ lu·ªìng ƒëang t·∫£i font h·ªá th·ªëng. B·ªè qua.")
            return

        def _save_font_cache_to_file(font_list_to_save):
            """H√†m helper ƒë·ªÉ l∆∞u danh s√°ch font v√†o file JSON."""
            try:
                with open(font_cache_path, "w", encoding="utf-8") as f:
                    json.dump(font_list_to_save, f, ensure_ascii=False)
                logging.info(f"ƒê√£ l∆∞u th√†nh c√¥ng {len(font_list_to_save)} font v√†o file cache: {font_cache_path}")
            except Exception as e_save:
                logging.error(f"Kh√¥ng th·ªÉ l∆∞u file font cache: {e_save}")

        def _font_loader_thread_target():
            """H√†m m·ª•c ti√™u cho lu·ªìng t·∫£i font."""
            logging.info("[FontLoaderThread] B·∫Øt ƒë·∫ßu qu√©t font h·ªá th·ªëng (v√¨ kh√¥ng c√≥ cache)...")
            self.fonts_are_loading = True
            try:
                temp_root_for_font = tk.Tk()
                temp_root_for_font.withdraw()
                loaded_fonts = sorted(list(tkfont.families(temp_root_for_font)))
                temp_root_for_font.destroy()

                # C·∫≠p nh·∫≠t cache tr√™n lu·ªìng ch√≠nh
                self.after(0, self._update_font_cache, loaded_fonts)
                
                # <<< TH√äM M·ªöI: L√™n l·ªãch l∆∞u file cache tr√™n lu·ªìng ch√≠nh >>>
                self.after(0, _save_font_cache_to_file, loaded_fonts)
                
                if callback:
                    self.after(10, callback)

            except Exception as e:
                logging.error(f"[FontLoaderThread] L·ªói nghi√™m tr·ªçng khi qu√©t font h·ªá th·ªëng: {e}", exc_info=True)
                self.after(0, self._update_font_cache, [])
                if callback:
                    self.after(10, callback)
            finally:
                self.after(0, lambda: setattr(self, 'fonts_are_loading', False))

        font_thread = threading.Thread(target=_font_loader_thread_target, daemon=True, name="SystemFontScanner")
        font_thread.start()

    def _update_font_cache(self, font_list):
        """Callback ƒë·ªÉ c·∫≠p nh·∫≠t cache font tr√™n lu·ªìng ch√≠nh."""
        self.system_fonts_cache = font_list
        logging.info(f"ƒê√£ c·∫≠p nh·∫≠t cache v·ªõi {len(self.system_fonts_cache)} font h·ªá th·ªëng.")


# X√≥a file cache font v√† k√≠ch ho·∫°t qu√©t l·∫°i h·ªá th·ªëng.
    def _force_rescan_fonts(self):
        """X√≥a file cache font v√† k√≠ch ho·∫°t qu√©t l·∫°i h·ªá th·ªëng."""
        logging.info("Ng∆∞·ªùi d√πng y√™u c·∫ßu qu√©t l·∫°i danh s√°ch font h·ªá th·ªëng.")
        font_cache_path = get_font_cache_path()
        try:
            if os.path.exists(font_cache_path):
                os.remove(font_cache_path)
                logging.info(f"ƒê√£ x√≥a file font cache: {font_cache_path}")

            # X√≥a cache trong b·ªô nh·ªõ v√† b·∫Øt ƒë·∫ßu qu√©t l·∫°i
            self.system_fonts_cache = []
            self.update_status("üîÑ ƒêang qu√©t l·∫°i danh s√°ch font h·ªá th·ªëng...")

            # H√†m callback sau khi qu√©t xong s·∫Ω hi·ªÉn th·ªã th√¥ng b√°o
            def after_rescan_callback():
                self.update_status("‚úÖ ƒê√£ c·∫≠p nh·∫≠t danh s√°ch font th√†nh c√¥ng!")
                messagebox.showinfo("Ho√†n th√†nh", "ƒê√£ qu√©t v√† c·∫≠p nh·∫≠t l·∫°i danh s√°ch font h·ªá th·ªëng th√†nh c√¥ng.", parent=self)

            self._load_system_fonts_in_background(callback=after_rescan_callback)

        except Exception as e:
            logging.error(f"L·ªói khi x√≥a file font cache: {e}")
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ x√≥a file font cache.\nL·ªói: {e}", parent=self)

        
# ==========================================================
# C√ÅC H√ÄM M·ªöI CHO T√çNH NƒÇNG BI√äN T·∫¨P B·∫∞NG GEMINI
# ==========================================================

# H√†m Nh·∫≠n b√†n giao t·ª´ AIEditorTab, x·ª≠ l√Ω metadata v√† kh·ªüi ƒë·ªông chu·ªói AI ch√≠nh.
    def _handle_chain_handoff_from_editor(self, batch_results):
        """
        (PHI√äN B·∫¢N 2.4 - S·ª¨A L·ªñI TƒÇNG S·ªê CHO M·ª§C ƒê·∫¶U TI√äN)
        Nh·∫≠n b√†n giao, x·ª≠ l√Ω metadata (v·ªõi logic tƒÉng s·ªë thumbnail) v√† kh·ªüi ƒë·ªông chu·ªói AI ch√≠nh.
        """
        log_prefix = "[ChainHandoff_v2.4_FirstItemFix]"
        logging.info(f"{log_prefix} Nh·∫≠n b√†n giao v·ªõi {len(batch_results)} k·∫øt qu·∫£ bi√™n t·∫≠p.")

        if not batch_results:
            messagebox.showwarning("Kh√¥ng c√≥ k·∫øt qu·∫£", "Qu√° tr√¨nh bi√™n t·∫≠p kh√¥ng t·∫°o ra file k·∫øt qu·∫£ n√†o ƒë·ªÉ ti·∫øp t·ª•c.", parent=self)
            self.is_ai_batch_processing = False
            self._check_completion_and_shutdown()
            return

        self.update_status("‚úç C·∫≠p nh·∫≠t metadata t·ª´ c√°c file ƒë√£ bi√™n t·∫≠p...")
        
        content_files_for_chain = []
        
        ### B·∫ÆT ƒê·∫¶U KH·ªêI S·ª¨A L·ªñI ###
        # Bi·∫øn ƒë·ªÉ theo d√µi thumbnail c·ªßa m·ª•c v·ª´a x·ª≠ l√Ω.
        # S·∫Ω ch·ªß ƒë·ªông t√¨m thumbnail c·ªßa m·ª•c cu·ªëi c√πng trong cache ƒë·ªÉ l√†m ƒëi·ªÉm b·∫Øt ƒë·∫ßu.
        last_generated_thumbnail = None
        if self.metadata_auto_increment_thumb_var.get() and self.master_metadata_cache:
            try:
                # L·∫•y key c·ªßa m·ª•c cu·ªëi c√πng ƒë√£ ƒë∆∞·ª£c th√™m v√†o dictionary (y√™u c·∫ßu Python 3.7+)
                last_key_in_cache = list(self.master_metadata_cache.keys())[-1]
                last_entry_in_cache = self.master_metadata_cache[last_key_in_cache]
                last_thumbnail_in_cache = last_entry_in_cache.get("thumbnail")

                if last_thumbnail_in_cache:
                    last_generated_thumbnail = last_thumbnail_in_cache
                    logging.info(f"{log_prefix} L·∫•y thumbnail cu·ªëi c√πng t·ª´ cache l√†m c∆° s·ªü cho l√¥ m·ªõi: '{last_generated_thumbnail}'")
            except (IndexError, KeyError) as e:
                logging.warning(f"{log_prefix} Kh√¥ng th·ªÉ l·∫•y thumbnail cu·ªëi c√πng t·ª´ cache: {e}. S·∫Ω d√πng m·∫´u m·∫∑c ƒë·ªãnh cho m·ª•c ƒë·∫ßu ti√™n.")
        ### K·∫æT TH√öC KH·ªêI S·ª¨A L·ªñI ###

        for content_path, title_path in batch_results:
            try:
                content_files_for_chain.append(content_path)
                identifier_key = os.path.splitext(os.path.basename(content_path))[0]
                
                with open(title_path, "r", encoding="utf-8-sig") as f:
                    ai_generated_title = f.read().strip()
                
                # G·ªçi h√†m _update_metadata_cache_entry v·ªõi thumbnail c∆° s·ªü c·ªßa l·∫ßn l·∫∑p tr∆∞·ªõc
                self._update_metadata_cache_entry(identifier_key, ai_generated_title, base_thumbnail_for_increment=last_generated_thumbnail)
                
                # Sau khi ƒë√£ c·∫≠p nh·∫≠t, l·∫•y l·∫°i thumbnail v·ª´a ƒë∆∞·ª£c t·∫°o ƒë·ªÉ d√πng cho l·∫ßn l·∫∑p sau
                if self.metadata_auto_increment_thumb_var.get():
                    newly_created_entry = self.master_metadata_cache.get(identifier_key, {})
                    last_generated_thumbnail = newly_created_entry.get("thumbnail")
                    logging.debug(f"   -> C·∫≠p nh·∫≠t last_generated_thumbnail cho v√≤ng l·∫∑p ti·∫øp theo: '{last_generated_thumbnail}'")

            except Exception as e_meta:
                logging.error(f"{log_prefix} L·ªói khi x·ª≠ l√Ω metadata cho file '{content_path}': {e_meta}")
        
        self._save_master_metadata_cache()
        
        logging.info(f"{log_prefix} Metadata xong. Chuy·ªÉn giao {len(content_files_for_chain)} file cho chu·ªói AI ch√≠nh.")
        self.update_status(f"‚úÖ Metadata xong! B·∫Øt ƒë·∫ßu chu·ªói AI ch√≠nh...")

        self.view_switcher.set("‚â° T·∫°o Ph·ª• ƒê·ªÅ")
        self.switch_view("‚â° T·∫°o Ph·ª• ƒê·ªÅ")

        self.start_ai_batch_processing(
            file_queue=content_files_for_chain,
            batch_prompt="",
            trigger_dubbing_for_batch=True
        )


    # H√ÄM HELPER CHO METADATA
    def _update_metadata_cache_entry(self, key, title, base_thumbnail_for_increment=None):
        """
        (PHI√äN B·∫¢N N√ÇNG C·∫§P CHO CHU·ªñI AI)
        C·∫≠p nh·∫≠t cache, ∆∞u ti√™n tƒÉng s·ªë t·ª´ `base_thumbnail_for_increment` n·∫øu ƒë∆∞·ª£c cung c·∫•p.
        N·∫øu kh√¥ng, s·∫Ω fallback v·ªÅ vi·ªác l·∫•y m·∫´u t·ª´ m·ª•c ƒë·∫ßu ti√™n trong cache.
        """
        if not hasattr(self, 'master_metadata_cache'):
            self.master_metadata_cache = {}
        
        template_description = ""
        template_tags = ""
        template_playlist = ""
        template_thumbnail = ""
        source_of_template = "Kh√¥ng x√°c ƒë·ªãnh"

        ### B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI ###
        
        # ∆ØU TI√äN 1: TƒÉng s·ªë t·ª´ thumbnail c∆° s·ªü ƒë∆∞·ª£c cung c·∫•p (n·∫øu c√≥ v√† checkbox ƒë∆∞·ª£c b·∫≠t)
        if self.metadata_auto_increment_thumb_var.get() and base_thumbnail_for_increment:
            logging.info(f"[MetadataUpdate] ƒêang th·ª≠ tƒÉng s·ªë thumbnail t·ª´ c∆° s·ªü: '{base_thumbnail_for_increment}'")
            source_of_template = f"TƒÉng d·∫ßn t·ª´ '{os.path.basename(base_thumbnail_for_increment)}'"
            try:
                dir_name = os.path.dirname(base_thumbnail_for_increment)
                base_name = os.path.basename(base_thumbnail_for_increment)
                filename_no_ext, ext = os.path.splitext(base_name)

                match_thumb = re.search(r'(\d+)(?!.*\d)', filename_no_ext) # T√¨m s·ªë cu·ªëi c√πng trong t√™n file

                if match_thumb:
                    number_str = match_thumb.group(1)
                    original_length = len(number_str)
                    number = int(number_str)
                    new_number = number + 1
                    
                    start, end = match_thumb.span(1)
                    new_filename_no_ext = filename_no_ext[:start] + str(new_number).zfill(original_length) + filename_no_ext[end:]
                    
                    new_base_name = new_filename_no_ext + ext
                    template_thumbnail = os.path.join(dir_name, new_base_name)
                    logging.info(f"ƒê√£ t·ª± ƒë·ªông tƒÉng thumbnail th√†nh c√¥ng: '{template_thumbnail}'")
                else:
                    template_thumbnail = base_thumbnail_for_increment # Gi·ªØ nguy√™n n·∫øu kh√¥ng t√¨m th·∫•y s·ªë
                    logging.warning(f"Kh√¥ng t√¨m th·∫•y s·ªë ƒë·ªÉ tƒÉng trong t√™n thumbnail c∆° s·ªü: '{base_name}'")
            except Exception as e_thumb:
                logging.error(f"L·ªói khi x·ª≠ l√Ω tƒÉng s·ªë thumbnail: {e_thumb}")
                template_thumbnail = base_thumbnail_for_increment # Gi·ªØ nguy√™n n·∫øu l·ªói
        
        # ∆ØU TI√äN 2: L·∫•y m·∫´u t·ª´ m·ª•c ƒë·∫ßu ti√™n trong cache (logic c≈©)
        # Ch·ªâ ch·∫°y n·∫øu ∆∞u ti√™n 1 kh√¥ng th√†nh c√¥ng (template_thumbnail v·∫´n r·ªóng)
        if not template_thumbnail:
            try:
                if self.master_metadata_cache and isinstance(self.master_metadata_cache, dict):
                    first_key = next(iter(self.master_metadata_cache))
                    template_data = self.master_metadata_cache[first_key]
                    template_thumbnail = template_data.get("thumbnail", "")
                    source_of_template = f"M·ª•c ƒë·∫ßu ti√™n (key: '{first_key}') t·ª´ Master Metadata cache"
                else:
                    raise ValueError("Cache metadata r·ªóng ho·∫∑c kh√¥ng ph·∫£i dictionary.")
            except Exception:
                source_of_template = "Giao di·ªán Tab Upload YT (Fallback cu·ªëi c√πng)"
        
        # ∆ØU TI√äN 3: L·∫•y c√°c th√¥ng tin c√≤n l·∫°i t·ª´ m·∫´u ƒë√£ t√¨m ƒë∆∞·ª£c ho·∫∑c t·ª´ UI
        try:
            # L·∫•y description, tags, playlist t·ª´ M·ªòT ngu·ªìn duy nh·∫•t ƒë·ªÉ nh·∫•t qu√°n
            # ∆Øu ti√™n m·∫´u t·ª´ cache tr∆∞·ªõc
            if self.master_metadata_cache and isinstance(self.master_metadata_cache, dict):
                first_key = next(iter(self.master_metadata_cache))
                template_data = self.master_metadata_cache[first_key]
                template_description = template_data.get("description", "")
                template_tags = template_data.get("tags", "")
                template_playlist = template_data.get("playlist", "")
            else: # Fallback v·ªÅ UI
                template_description = self.youtube_description_textbox.get("1.0", "end-1c").strip()
                template_tags = self.youtube_tags_var.get().strip()
                template_playlist = self.youtube_playlist_var.get().strip()
        except Exception as e_get_template:
            logging.warning(f"Kh√¥ng th·ªÉ l·∫•y m·∫´u description/tags/playlist: {e_get_template}")

        ### K·∫æT TH√öC THAY ƒê·ªîI ###

        # T·∫°o m·ª•c metadata m·ªõi v·ªõi ƒë·∫ßy ƒë·ªß th√¥ng tin ƒë√£ l·∫•y
        self.master_metadata_cache[key] = {
            "title": title,
            "description": template_description,
            "tags": template_tags,
            "thumbnail": template_thumbnail,
            "playlist": template_playlist
        }
        logging.info(f"[MetadataUpdate] ƒê√£ c·∫≠p nh·∫≠t/th√™m key '{key}' (Ngu·ªìn m·∫´u: {source_of_template})")

    # H√ÄM HELPER CHO METADATA
    def _save_master_metadata_cache(self):
        """L∆∞u master_metadata_cache hi·ªán t·∫°i ra file JSON."""
        save_path = self.cfg.get('last_master_metadata_path')
        if not save_path:
            logging.warning("[MetadataSave] Kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n file master metadata ƒë·ªÉ l∆∞u. B·ªè qua.")
            return
        try:
            with open(save_path, 'w', encoding='utf-8') as f:
                json.dump(self.master_metadata_cache, f, ensure_ascii=False, indent=2)
            logging.info(f"ƒê√£ l∆∞u th√†nh c√¥ng {len(self.master_metadata_cache)} m·ª•c v√†o file master metadata: {save_path}")
        except Exception as e:
            logging.error(f"L·ªói khi l∆∞u file master metadata: {e}", exc_info=True)


#------------------------------------------------------------------------------

# H√†m trigger cho chu·ªói Gemini -> Imagen -> Dub
    def _trigger_gemini_script_processing_with_chain(self, target_textbox_widget, context, user_prompt,
                                                         trigger_imagen_chain_flag=False,
                                                         trigger_dub_chain_flag=False,
                                                         input_script_override=None,
                                                         base_filename_for_chain=None): # <<< TH√äM THAM S·ªê M·ªöI N√ÄY V√ÄO ƒê√ÇY
        ## H√†m n√†y c√≥ c·∫•u tr√∫c r·∫•t gi·ªëng v·ªõi h√†m trigger c·ªßa GPT
        log_prefix = f"[GeminiChainTrigger:{context}]"

        # <<< TH√äM D√íNG N√ÄY ƒê·ªÇ RESET H√ÄNG CH·ªú >>>
        # ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o t√°c v·ª• ƒë∆°n l·∫ª kh√¥ng b·ªã ·∫£nh h∆∞·ªüng b·ªüi c√°c l√¥ ch·∫°y tr∆∞·ªõc
        if not input_script_override: # Ch·ªâ reset n·∫øu ƒë√¢y l√† t√°c v·ª• ƒë∆°n l·∫ª, kh√¥ng ph·∫£i m·ªôt ph·∫ßn c·ªßa l√¥ AI
            self.files_for_chained_dubbing = []
        
        self.stop_event.clear()
        logging.info(f"{log_prefix} ƒê√£ x√≥a (clear) self.stop_event ƒë·ªÉ chu·∫©n b·ªã cho chu·ªói t√°c v·ª• m·ªõi.")        
        logging.info(f"{log_prefix} K√≠ch ho·∫°t chu·ªói Gemini -> Imagen. Prompt: '{user_prompt[:50]}...', TriggerImagen: {trigger_imagen_chain_flag}, TriggerDub: {trigger_dub_chain_flag}")

        ## 1. Ki·ªÉm tra API Key (Gi·ªØ nguy√™n code c≈© c·ªßa b·∫°n)
        if not self.gemini_key_var.get():
            messagebox.showerror("Thi·∫øu API Key", "Vui l√≤ng c·∫•u h√¨nh Gemini API Key trong C√†i ƒë·∫∑t API Keys.", parent=self)
            return

        ## 2. L·∫•y n·ªôi dung script hi·ªán t·∫°i
        script_content = ""
        text_in_widget_before = ""
        
        if input_script_override is not None:
            # N·∫øu ƒëang ch·∫°y h√†ng lo·∫°t, s·ª≠ d·ª•ng k·ªãch b·∫£n ƒë∆∞·ª£c truy·ªÅn v√†o
            script_content = input_script_override
            logging.info(f"{log_prefix} S·ª≠ d·ª•ng k·ªãch b·∫£n ƒë∆∞·ª£c truy·ªÅn v√†o t·ª´ ch·∫ø ƒë·ªô h√†ng lo·∫°t (d√†i {len(script_content)} chars).")
            # V·∫´n l·∫•y n·ªôi dung widget ƒë·ªÉ c√≥ th·ªÉ ho√†n t√°c v·ªÅ tr·∫°ng th√°i tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu l√¥
            if target_textbox_widget and target_textbox_widget.winfo_exists():
                text_in_widget_before = target_textbox_widget.get("1.0", "end-1c")
        else:
            # N·∫øu ch·∫°y ƒë∆°n l·∫ª, l·∫•y k·ªãch b·∫£n t·ª´ textbox nh∆∞ c≈©
            if target_textbox_widget and target_textbox_widget.winfo_exists():
                text_in_widget_before = target_textbox_widget.get("1.0", "end-1c")
                temp_content = text_in_widget_before.strip()
                if not self._is_textbox_content_invalid_for_script(temp_content):
                    script_content = temp_content

        ## 3. L∆∞u tr·∫°ng th√°i ƒë·ªÉ Ho√†n t√°c (Undo) v√† Vi·∫øt l·∫°i (Gi·ªØ nguy√™n code c≈© c·ªßa b·∫°n)
        self.gemini_undo_buffer[context] = {"original_text": text_in_widget_before}
        self.last_gemini_parameters_used[context] = {
            "prompt": user_prompt,
            "input_script_for_this_prompt": script_content
        }
        logging.info(f"{log_prefix} ƒê√£ l∆∞u tr·∫°ng th√°i Undo v√† Rewrite cho Gemini.")

        ## 4. C·∫≠p nh·∫≠t giao di·ªán (Gi·ªØ nguy√™n code c≈© c·ªßa b·∫°n)
        self.is_gemini_processing = True 
        self.start_time = time.time()
        self._set_subtitle_tab_ui_state(True)
        self.update_queue_display() # G·ªçi ƒë·ªÉ hi·ªÉn th·ªã m·ª•c "ƒêANG X·ª¨ L√ù..."
        self.update_status(f"üíé Gemini ƒëang t·∫°o k·ªãch b·∫£n...")
        self.update_time_realtime()
        
        if hasattr(self, 'ai_edit_button_sub_tab'): self.ai_edit_button_sub_tab.configure(state="disabled", text="AI ƒêang ch·∫°y...")
        if hasattr(self, 'ai_edit_dub_script_button'): self.ai_edit_dub_script_button.configure(state="disabled", text="AI ƒêang ch·∫°y...")

        selected_model = self.gemini_model_for_script_editing_var.get()
        logging.info(f"{log_prefix} Model Gemini ƒë∆∞·ª£c ch·ªçn cho chu·ªói t·ª± ƒë·ªông: {selected_model}")

        # L·∫•y th√¥ng tin D√†n di·ªÖn vi√™n t·ª´ config ƒë√£ l∆∞u
        character_sheet_text = self.cfg.get("imagen_last_character_sheet", "")
        logging.info(f"{log_prefix} L·∫•y ƒë∆∞·ª£c character_sheet t·ª´ config (d√†i {len(character_sheet_text)} chars) ƒë·ªÉ truy·ªÅn cho lu·ªìng.")

        thread = threading.Thread(
            target=self._execute_gemini_script_editing_thread_for_chain,
            args=(script_content, user_prompt, selected_model, target_textbox_widget, context,
                  trigger_imagen_chain_flag, trigger_dub_chain_flag, character_sheet_text, # Gi·ªØ nguy√™n d√≤ng n√†y
                  base_filename_for_chain), 
            daemon=True,
            name=f"GeminiChainThread_{context}"
        )
        thread.start()
        logging.info(f"{log_prefix} ƒê√£ kh·ªüi ƒë·ªông lu·ªìng x·ª≠ l√Ω n·ªÅn cho chu·ªói Gemini (ƒë√£ bao g·ªìm character_sheet).")


# <<<--- TH√äM H√ÄM M·ªöI N√ÄY V√ÄO B√äN D∆Ø·ªöI H√ÄM TRIGGER B·∫†N V·ª™A T·∫†O ·ªû B∆Ø·ªöC 2 ---<<<
    def _execute_gemini_script_editing_thread_for_chain(self, script_content, user_instruction, selected_model, target_widget, context,
                                                    trigger_imagen_chain_flag, trigger_dub_chain_flag, character_sheet_text,
                                                    base_filename_for_chain): # <<< TH√äM V√ÄO ƒê√ÇY
        """
        (ƒê√É C·∫¨P NH·∫¨T) (Worker) T√°ch l·ªùi tho·∫°i, g·ªçi API Gemini, v√† truy·ªÅn d·ªØ li·ªáu nh√¢n v·∫≠t ƒëi ti·∫øp.
        """
        # G·ªåI API GEMINI ---
        import google.generativeai as genai
        from google.api_core import exceptions as google_exceptions

        log_prefix = f"[GeminiChainExec_v2:{context}]" # TƒÉng version log
        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu x·ª≠ l√Ω k·ªãch b·∫£n v·ªõi Gemini...")

        processed_script = None
        error_message = None
        
        try:
            # --- B∆Ø·ªöC 1: KI·ªÇM TRA V√Ä CHU·∫®N B·ªä VƒÇN B·∫¢N G·ª¨I CHO AI ---
            # Ki·ªÉm tra xem vƒÉn b·∫£n ƒë·∫ßu v√†o c√≥ ph·∫£i l√† ƒë·ªãnh d·∫°ng SRT kh√¥ng
            is_input_srt = re.match(r"^\d+\s*[\r\n]+\d{2}:\d{2}:\d{2}[,.]\d{3}\s*-->", script_content.strip(), re.MULTILINE) is not None
            text_to_send_to_ai = script_content # M·∫∑c ƒë·ªãnh

            if is_input_srt:
                logging.info(f"{log_prefix} Input l√† SRT. ƒêang tr√≠ch xu·∫•t l·ªùi tho·∫°i thu·∫ßn t√∫y ƒë·ªÉ g·ª≠i cho AI...")
                # S·ª≠ d·ª•ng h√†m c√≥ s·∫µn ƒë·ªÉ l·∫•y ch·ªâ ph·∫ßn text, b·ªè qua index v√† timing
                text_to_send_to_ai = extract_dialogue_from_srt_string(script_content)
            
            # --- B∆Ø·ªöC 2: X√ÇY D·ª∞NG PROMPT ---
            action_type = "t·∫°o m·ªõi" if not script_content else "bi√™n t·∫≠p"
            prompt_parts = [
                f"B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n {action_type} k·ªãch b·∫£n cho video. H√£y th·ª±c hi·ªán y√™u c·∫ßu sau: '{user_instruction}'.",
                "Xin h√£y gi·ªØ l·∫°i c·∫•u tr√∫c v√† s·ªë l∆∞·ª£ng d√≤ng c·ªßa vƒÉn b·∫£n g·ªëc n·∫øu c√≥ th·ªÉ.",
                "QUAN TR·ªåNG: Ch·ªâ tr·∫£ v·ªÅ DUY NH·∫§T n·ªôi dung k·ªãch b·∫£n ƒë√£ x·ª≠ l√Ω, kh√¥ng th√™m b·∫•t k·ª≥ l·ªùi d·∫´n, gi·∫£i th√≠ch hay ƒë·ªãnh d·∫°ng markdown n√†o."
            ]
            if text_to_send_to_ai: # Ch·ªâ th√™m ph·∫ßn n√†y n·∫øu c√≥ text ƒë·ªÉ g·ª≠i ƒëi
                prompt_parts.append(f"\nN·ªôi dung k·ªãch b·∫£n g·ªëc ƒë·ªÉ bi√™n t·∫≠p:\n---\n{text_to_send_to_ai}\n---")
            
            final_prompt = "\n".join(prompt_parts)
            # KI·ªÇM TRA D·ª™NG TR∆Ø·ªöC KHI G·ªåI API >>>
            if self.stop_event.is_set():
                raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng tr∆∞·ªõc khi g·ªçi API Gemini t·∫°o k·ªãch b·∫£n.")

            gemini_api_key = self.gemini_key_var.get()
            if not gemini_api_key:
                raise ValueError("L·ªói: Vui l√≤ng nh·∫≠p Gemini API Key trong C√†i ƒë·∫∑t.")

            genai.configure(api_key=gemini_api_key)
            logging.info(f"{log_prefix} S·ª≠ d·ª•ng model: {selected_model}")
            model = genai.GenerativeModel(selected_model) 

            logging.info(f"{log_prefix} ƒêang g·ª≠i y√™u c·∫ßu ƒë·∫øn Gemini...")
            response = model.generate_content(final_prompt)

            if not response.candidates:
                block_reason = response.prompt_feedback.block_reason.name if response.prompt_feedback else "Kh√¥ng r√µ"
                raise RuntimeError(f"Y√™u c·∫ßu ƒë√£ b·ªã ch·∫∑n b·ªüi b·ªô l·ªçc an to√†n c·ªßa Gemini (L√Ω do: {block_reason}).")

            processed_script = response.text
            self._track_api_call(service_name="gemini_calls", units=1)
            logging.info(f"{log_prefix} Gemini ƒë√£ x·ª≠ l√Ω th√†nh c√¥ng.")

        except google_exceptions.PermissionDenied as e: 
            error_message = f"L·ªói x√°c th·ª±c Gemini: API Key kh√¥ng ƒë√∫ng ho·∫∑c kh√¥ng c√≥ quy·ªÅn. Chi ti·∫øt: {e}"
            logging.error(f"{log_prefix} {error_message}")
        except ValueError as ve:
            error_message = str(ve)
            logging.error(f"{log_prefix} {error_message}")

        except InterruptedError as ie: 
            error_message = f"ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng: {ie}"
            logging.warning(f"{log_prefix} {error_message}")

        except Exception as e:
            error_message = f"L·ªói khi g·ªçi API Gemini: {type(e).__name__} - {e}"
            logging.error(f"{log_prefix} {error_message}", exc_info=True)
            
        # --- B∆Ø·ªöC 3: G·ªåI H√ÄM HANDLER V√Ä TRUY·ªÄN `character_sheet_text` ƒêI TI·∫æP ---
        self.after(0, self._handle_gemini_script_editing_result_for_chain,
                   processed_script,
                   error_message,
                   target_widget,
                   context,
                   trigger_imagen_chain_flag,
                   trigger_dub_chain_flag,
                   selected_model,
                   script_content,
                   character_sheet_text,
                   base_filename_for_chain) # <<< TH√äM V√ÄO CU·ªêI C√ôNG


# <<<--- TH√äM H√ÄM M·ªöI N√ÄY V√ÄO B√äN D∆Ø·ªöI H√ÄM WORKER B·∫†N V·ª™A T·∫†O ·ªû B∆Ø·ªöC 3 ---<<<
# H√†m x·ª≠ l√Ω k·∫øt qu·∫£ t·ª´ Gemini
    def _handle_gemini_script_editing_result_for_chain(self, processed_script, error_message, target_widget, context,
                                                       trigger_imagen_chain_flag, trigger_dub_chain_flag, selected_model,
                                                       original_input_script, character_sheet_text,
                                                       base_filename_for_chain): # <<< TH√äM V√ÄO ƒê√ÇY
        
        log_prefix = f"[HandleGeminiChainResult_v8:{context}]"

        # --- KH·ªêI 1: KI·ªÇM TRA L·ªÜNH D·ª™NG T·ª™ NG∆Ø·ªúI D√ôNG ---
        if self.stop_event.is_set():
            logging.warning(f"{log_prefix} Ph√°t hi·ªán stop_event. H·ªßy b·ªè x·ª≠ l√Ω k·∫øt qu·∫£ v√† th·ª±c hi·ªán d·ªçn d·∫πp ƒë·∫ßy ƒë·ªß.")
            
            # N·∫øu ƒëang trong m·ªôt l√¥ AI, g·ªçi h√†m d·ªçn d·∫πp c·ªßa l√¥ ƒë√≥
            if self.is_ai_batch_processing:
                self._on_ai_batch_finished(stopped=True)
            else: 
                # N·∫øu l√† t√°c v·ª• ƒë∆°n l·∫ª, th·ª±c hi·ªán d·ªçn d·∫πp t·∫°i ch·ªó
                
                # 1. Reset c·ªù x·ª≠ l√Ω c·ªßa ch√≠nh n√≥
                self.is_gemini_processing = False
                self.is_gpt_processing_script = False # Reset c·∫£ c√°c c·ªù li√™n quan
                self.is_creating_slideshow = False
                self.is_dalle_processing = False
                self.is_imagen_processing = False
                self.is_subbing = False # ƒê·∫£m b·∫£o c·ªù sub (d√πng cho hardsub) c≈©ng ƒë∆∞·ª£c reset

                # 2. G·ªçi h√†m ki·ªÉm tra ho√†n th√†nh chung ƒë·ªÉ reset ƒë·ªìng h·ªì
                self._check_completion_and_shutdown()
                
                # 3. C·∫≠p nh·∫≠t l·∫°i to√†n b·ªô giao di·ªán c·ªßa tab Subtitle v·ªÅ tr·∫°ng th√°i ch·ªù
                #    ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng nh·∫•t ƒë·ªÉ k√≠ch ho·∫°t l·∫°i c√°c n√∫t
                self._set_subtitle_tab_ui_state(False)
                
                # 4. C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i v·ªõi th√¥ng b√°o cu·ªëi c√πng
                self.update_status("üõë T√°c v·ª• ƒë√£ ƒë∆∞·ª£c d·ª´ng.")
                
            return # D·ª´ng h√†m t·∫°i ƒë√¢y, kh√¥ng x·ª≠ l√Ω g√¨ th√™m

        # --- KH·ªêI 2: KI·ªÇM TRA L·ªñI T·ª™ K·∫æT QU·∫¢ C·ª¶A AI ---
        if error_message or not processed_script:
            is_user_stop = "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng" in (error_message or "")
            error_to_show = error_message or "Gemini kh√¥ng tr·∫£ v·ªÅ k·∫øt qu·∫£ k·ªãch b·∫£n."
            logging.error(f"{log_prefix} L·ªói t·∫°o k·ªãch b·∫£n t·ª´ Gemini: {error_to_show}")
            
            final_status_msg = f"üõë ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng." if is_user_stop else f"‚ùå L·ªói Gemini: {error_to_show[:60]}..."
            self.update_status(final_status_msg)

            if not is_user_stop:
                messagebox.showerror("L·ªói Gemini API", error_to_show, parent=self)
            
            self.is_gemini_processing = False
            self._check_completion_and_shutdown()
            # <<< TH√äM D√íNG N√ÄY ƒê·ªÇ ƒê·∫¢M B·∫¢O UI C≈®NG ƒê∆Ø·ª¢C RESET KHI C√ì L·ªñI >>>
            self._set_subtitle_tab_ui_state(False)
            return

        logging.info(f"{log_prefix} T·∫°o k·ªãch b·∫£n th√†nh c√¥ng. B·∫Øt ƒë·∫ßu x·ª≠ l√Ω timing...")
        
        is_original_srt = re.match(r"^\d+\s*[\r\n]+\d{2}:\d{2}:\d{2}[,.]\d{3}\s*-->", original_input_script.strip(), re.MULTILINE) is not None

        final_script_for_display = processed_script
        script_for_chain_timing = processed_script 

        split_config_from_ui = {
            "split_enabled": self.enable_split_var.get(),
            "mode": self.split_mode_var.get(),
            "max_chars": safe_int(self.max_chars_var.get(), 90),
            "max_lines": safe_int(self.max_lines_var.get(), 1),
            "DEFAULT_CPS_FOR_TIMING": safe_int(self.sub_cps_for_timing_var.get(), 17),
            "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1, 
            "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
        }
        logging.info(f"{log_prefix} C·∫•u h√¨nh chia d√≤ng l·∫•y t·ª´ UI: {split_config_from_ui}")

        if is_original_srt:
            logging.info(f"{log_prefix} Input g·ªëc l√† SRT. S·∫Ω b·∫£o to√†n timing.")
            self.update_status("üíé Gemini ƒë√£ s·ª≠a xong. ƒêang √°nh x·∫° l·∫°i timing g·ªëc...")
            
            original_srt_data = self._parse_plain_text_to_srt_data(original_input_script, force_plain_text_processing=False)
            
            if original_srt_data:
                new_text_segments = self._parse_plain_text_to_srt_data(
                    processed_script, 
                    force_plain_text_processing=True, 
                    split_config_override=split_config_from_ui
                )

                final_mapped_data = self._map_optimized_segments_to_original_srt_timings(new_text_segments, original_srt_data)
                
                if final_mapped_data:
                    final_srt_string = format_srt_data_to_string(final_mapped_data)
                    final_script_for_display = final_srt_string
                    script_for_chain_timing = final_srt_string
                    logging.info(f"{log_prefix} √Ånh x·∫° timing th√†nh c√¥ng.")
                else:
                    logging.warning(f"{log_prefix} √Ånh x·∫° timing th·∫•t b·∫°i.")
            else:
                logging.warning(f"{log_prefix} Kh√¥ng parse ƒë∆∞·ª£c d·ªØ li·ªáu timing t·ª´ SRT g·ªëc.")

        else:
            logging.info(f"{log_prefix} Input g·ªëc l√† Plain Text. S·∫Ω t·∫°o timing m·ªõi.")
            self.update_status("üíé Gemini ƒë√£ t·∫°o k·ªãch b·∫£n. ƒêang ∆∞·ªõc t√≠nh timing...")

            srt_data_content = self._parse_plain_text_to_srt_data(
                processed_script, 
                force_plain_text_processing=True, 
                split_config_override=split_config_from_ui
            )
            
            if srt_data_content:
                srt_output_string = format_srt_data_to_string(srt_data_content)
                final_script_for_display = srt_output_string
                script_for_chain_timing = srt_output_string
                logging.info(f"{log_prefix} T·∫°o SRT v√† timing m·ªõi th√†nh c√¥ng.")
            else:
                logging.warning(f"{log_prefix} Kh√¥ng t·∫°o ƒë∆∞·ª£c d·ªØ li·ªáu SRT.")
        
        if target_widget and target_widget.winfo_exists():
            target_widget.configure(state="normal")
            target_widget.delete("1.0", "end")
            target_widget.insert("1.0", final_script_for_display)

        # --- S·ª¨A L·ªñI ·ªû ƒê√ÇY ---
        if not trigger_imagen_chain_flag:
            self.update_status("‚úÖ Gemini ƒë√£ bi√™n t·∫≠p xong k·ªãch b·∫£n.")
            messagebox.showinfo("Ho√†n th√†nh", "Gemini ƒë√£ x·ª≠ l√Ω v√† c·∫≠p nh·∫≠t n·ªôi dung k·ªãch b·∫£n.", parent=self)
            
            # TH√äM KH·ªêI CODE KH√îI PH·ª§C N√öT V√ÄO ƒê√ÇY
            is_app_active = self._is_app_fully_activated()

            if is_app_active:
                if hasattr(self, 'ai_edit_button_sub_tab') and self.ai_edit_button_sub_tab.winfo_exists():
                    self.ai_edit_button_sub_tab.configure(state="normal", text="‚ú® Bi√™n t·∫≠p (AI)")
                if hasattr(self, 'ai_edit_dub_script_button') and self.ai_edit_dub_script_button.winfo_exists():
                    self.ai_edit_dub_script_button.configure(state="normal", text="‚ú® Bi√™n t·∫≠p (AI)")
            logging.info(f"{log_prefix} ƒê√£ kh√¥i ph·ª•c c√°c n√∫t Bi√™n t·∫≠p AI (chu·ªói ng·∫Øn).")
            # K·∫æT TH√öC KH·ªêI CODE TH√äM

            self.is_gemini_processing = False
            self._set_subtitle_tab_ui_state(False)
            self._check_completion_and_shutdown()
            return
        
        # Logic ti·∫øp t·ª•c chu·ªói Imagen (gi·ªØ nguy√™n)
        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu b∆∞·ªõc 2: Y√™u c·∫ßu Gemini t·∫°o prompt cho Imagen...")
        self.update_status("üíé Gemini t·∫°o k·ªãch b·∫£n xong! Chu·∫©n b·ªã y√™u c·∫ßu Gemini chia c·∫£nh...")

        try:
            num_images = int(self.cfg.get("imagen_last_num_images", "1"))
            # <<< TH√äM D√íNG N√ÄY ƒê·ªÇ ƒê·ªåC C√ÄI ƒê·∫∂T M·ªöI >>>
            auto_split_scenes = self.cfg.get("imagen_auto_split_scenes", True)
        except (ValueError, TypeError):
            num_images = 1
            auto_split_scenes = True # M·∫∑c ƒë·ªãnh an to√†n
        
        thread = threading.Thread(
            target=self._execute_gemini_scene_division_thread,
            args=(
                processed_script,
                script_for_chain_timing,
                num_images,
                selected_model,
                target_widget,
                context,
                trigger_dub_chain_flag,
                character_sheet_text,
                base_filename_for_chain,
                auto_split_scenes 
            ),
            daemon=True,
            name=f"GeminiSceneDivisionThread_{context}"
        )
        thread.start()


# <<<--- TH√äM H√ÄM M·ªöI N√ÄY V√ÄO B√äN D∆Ø·ªöI H√ÄM V·ª™A T·∫†O ·ªû B∆Ø·ªöC 4 ---<<<
    def _execute_gemini_scene_division_thread(self, script_content, formatted_srt_for_slideshow, num_images, selected_model, target_widget, context, trigger_dub_chain_flag, character_sheet_text,
                                              base_filename_for_chain, auto_split_scenes):
        """
        (PHI√äN B·∫¢N 13 - T√çCH H·ª¢P GI·ªöI H·∫†N TH·ªúI GIAN)
        Y√™u c·∫ßu Gemini ph√¢n t√≠ch k·ªãch b·∫£n, t·∫°o prompt JSON v√† tu√¢n th·ªß gi·ªõi h·∫°n th·ªùi gian t·ªëi thi·ªÉu cho m·ªói c·∫£nh.
        """
        worker_log_prefix = f"[{threading.current_thread().name}_GeminiSceneDivision_v13_TimeLimit]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu chia k·ªãch b·∫£n v√† t·∫°o {num_images} c·∫∑p scene/prompt.")

        gemini_response_text = None
        error_message = None
        
        max_retries = 2
        initial_retry_delay_s = 15.0

        for attempt in range(max_retries + 1):
            if self.stop_event.is_set():
                error_message = "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng tr∆∞·ªõc khi g·ªçi API Gemini chia c·∫£nh."
                logging.warning(f"{worker_log_prefix} {error_message}")
                break

            try:
                import google.generativeai as genai
                from google.api_core import exceptions as google_exceptions
                from google.genai.types import HarmCategory, HarmBlockThreshold

                # === THAY ƒê·ªîI QUAN TR·ªåNG: G·ªåI H√ÄM L√ÄM S·∫†CH K·ªäCH B·∫¢N ===
                sanitized_script_for_ai = sanitize_script_for_ai(script_content, self.cfg)
                # =======================================================

                genai.configure(api_key=self.gemini_key_var.get())
                model = genai.GenerativeModel(selected_model)

                # --- Ph·∫ßn x·ª≠ l√Ω "D√†n di·ªÖn vi√™n" v√† x√¢y d·ª±ng prompt gi·ªØ nguy√™n nh∆∞ c≈© ---
                natural_language_character_sheet = ""
                use_character_sheet = self.cfg.get("imagen_use_character_sheet", False)
                if use_character_sheet and character_sheet_text:
                    source_of_cached_sheet = self.cfg.get("imagen_source_of_cached_sheet", None)
                    cached_optimized_sheet = self.cfg.get("imagen_cached_optimized_sheet", None)
                    if character_sheet_text == source_of_cached_sheet and cached_optimized_sheet:
                        natural_language_character_sheet = cached_optimized_sheet
                        logging.info(f"{worker_log_prefix} HIT CACHE: D√†n di·ªÖn vi√™n kh√¥ng ƒë·ªïi. S·ª≠ d·ª•ng phi√™n b·∫£n ƒë√£ t·ªëi ∆∞u t·ª´ cache.")
                    else:
                        logging.info(f"{worker_log_prefix} MISS CACHE: D√†n di·ªÖn vi√™n ƒë√£ thay ƒë·ªïi. B·∫Øt ƒë·∫ßu t·ªëi ∆∞u h√≥a b·∫±ng AI...")
                        summarization_prompt = (
                            "You are a helpful assistant. Below is a character sheet written with image generation keywords. "
                            "Your task is to convert it into a natural language description, focusing only on visual appearance. "
                            "Maintain the 'Alias: Description' format. Respond only with the converted text.\n\n"
                            f"--- ORIGINAL SHEET ---\n{character_sheet_text}\n--- CONVERTED NATURAL LANGUAGE DESCRIPTION ---"
                        )
                        summarization_response = model.generate_content(summarization_prompt)
                        if not summarization_response.candidates:
                            natural_language_character_sheet = character_sheet_text
                            logging.warning(f"{worker_log_prefix} Y√™u c·∫ßu t·ªëi ∆∞u 'D√†n di·ªÖn vi√™n' b·ªã ch·∫∑n. D√πng b·∫£n g·ªëc.")
                        else:
                            natural_language_character_sheet = summarization_response.text.strip()
                            logging.info(f"{worker_log_prefix} K·∫æT QU·∫¢ T·ªêI ∆ØU:\n--- D√ÄN DI·ªÑN VI√äN (ƒê√É T·ªêI ∆ØU) ---\n{natural_language_character_sheet}\n---------------------------------")
                            self.cfg["imagen_source_of_cached_sheet"] = character_sheet_text
                            self.cfg["imagen_cached_optimized_sheet"] = natural_language_character_sheet
                            self.after(0, self.save_current_config)
                
                saved_style_name = self.cfg.get("imagen_last_style", "M·∫∑c ƒë·ªãnh (AI t·ª± do)")
                style_prompt_fragment = ImagenSettingsWindow.IMAGEN_ART_STYLES.get(saved_style_name, "")
                character_instruction_block = ""
                if natural_language_character_sheet:
                    character_instruction_block = (
                        "\n\n**CHARACTER DESCRIPTIONS (HIGHEST PRIORITY):**\n"
                        "If a character from this list appears in a scene, you MUST use their description to create a consistent visual representation.\n"
                        f"--- CHARACTER SHEET ---\n{natural_language_character_sheet}\n--- END CHARACTER SHEET ---\n"
                    )
                style_instruction_block = (
                    "\n\n**ART STYLE INSTRUCTIONS:**\n"
                    f"The final image prompts MUST strictly follow the user's chosen art style: '{saved_style_name}'. "
                    f"Incorporate these keywords and concepts: '{style_prompt_fragment}'.\n"
                    "If the style is 'M·∫∑c ƒë·ªãnh (AI t·ª± do)', you MUST prioritize photorealistic, highly detailed, cinematic 3D renders."
                )
                # TH√äM H∆Ø·ªöNG D·∫™N AN TO√ÄN 
                # ƒê·∫∑t ngay ƒë·∫ßu system message ƒë·ªÉ c√≥ ƒë·ªô ∆∞u ti√™n cao nh·∫•t
                safety_instruction_block = (
                    "**CRITICAL SAFETY MANDATE (HIGHEST PRIORITY):**\n"
                    "You are a safety-conscious assistant. Your absolute primary goal is to generate text that is 100% safe for Google's most restrictive safety filters. "
                    "All output MUST be SFW (Safe-for-Work).\n\n"
                    "**FORBIDDEN CONTENT IN OUTPUT 'image_prompt':**\n"
                    "- **ABSOLUTELY NO** direct descriptions of violence, gore, blood, or death.\n"
                    "- **ABSOLUTELY NO** weapons (swords, knives, guns, bows), especially not in a threatening pose or during use. If a weapon is essential, describe it neutrally and statically (e.g., 'a decorative sword hanging on a wall', 'a sheathed katana at a warrior's hip').\n"
                    "- **ABSOLUTELY NO** sexually suggestive content, nudity, or hateful imagery.\n\n"
                    "**SAFE REPHRASING STRATEGY:**\n"
                    "When you encounter a sensitive scene in the script (e.g., a fight, an injury), you MUST NOT describe it literally. Instead, you MUST rephrase it using one of these safe methods:\n"
                    "1.  **Focus on Emotion & Aftermath:** Describe the character's facial expression (anger, determination, sadness) or the scene after the conflict is over.\n"
                    "    * *Instead of:* 'A man stabs another.'\n"
                    "    * *Use:* 'Close-up on a man's face, filled with anguish and regret, a single tear rolling down his cheek. The background is dark and somber.'\n"
                    "2.  **Use Symbolism & Metaphor:** Represent the conflict with symbolic imagery.\n"
                    "    * *Instead of:* 'Two armies clash with swords.'\n"
                    "    * *Use:* 'A split screen showing two opposing house crests, a fiery red lion and an icy blue wolf, with storm clouds gathering between them.'\n"
                    "3.  **Focus on Tension & Environment:** Describe the moment *before* the action, emphasizing the tension.\n"
                    "    * *Instead of:* 'He draws his sword to fight.'\n"
                    "    * *Use:* 'A warrior's hand rests on the hilt of his sheathed sword, knuckles white. The air is thick with tension under a stormy sky.'\n"
                )

                ### B·∫ÆT ƒê·∫¶U TH√äM: X·ª≠ l√Ω gi·ªõi h·∫°n th·ªùi gian ###

                min_duration_instruction = ""
                # 1. ƒê·ªçc c√†i ƒë·∫∑t t·ª´ UI
                min_duration_setting = self.imagen_min_scene_duration_var.get()
                
                # 2. Chuy·ªÉn ƒë·ªïi sang gi√¢y
                duration_map = { "15 gi√¢y": 15, "30 gi√¢y": 30, "1 ph√∫t": 60, "2 ph√∫t": 120, "3 ph√∫t": 180 }
                min_duration_seconds = 0
                for key, value in duration_map.items():
                    if key in min_duration_setting:
                        min_duration_seconds = value
                        break
                
                # 3. Ch·ªâ th√™m v√†o prompt n·∫øu c√≥ gi·ªõi h·∫°n ƒë∆∞·ª£c ch·ªçn
                if min_duration_seconds > 0:
                    # T√≠nh t·ªïng th·ªùi l∆∞·ª£ng k·ªãch b·∫£n g·ªëc
                    total_duration_ms = 0
                    original_timed_segments = self._parse_plain_text_to_srt_data(formatted_srt_for_slideshow)
                    if original_timed_segments:
                        total_duration_ms = original_timed_segments[-1]['end_ms'] - original_timed_segments[0]['start_ms']
                    
                    if total_duration_ms > 0:
                        total_duration_seconds = total_duration_ms / 1000.0
                        logging.info(f"{worker_log_prefix} √Åp d·ª•ng gi·ªõi h·∫°n th·ªùi gian: T·ªëi thi·ªÉu {min_duration_seconds}s/c·∫£nh. T·ªïng th·ªùi l∆∞·ª£ng k·ªãch b·∫£n: {total_duration_seconds:.2f}s.")
                        estimated_scene_count = max(1, int(total_duration_seconds / min_duration_seconds))                        

                        # 4. T·∫°o ch·ªâ d·∫´n cho prompt
                        # Kh·ªüi t·∫°o c√°c bi·∫øn ƒë·ªÉ x√¢y d·ª±ng prompt
                        main_task_description = ""
                        final_instruction = ""
                        duration_rules_block = "" # Ch·ªâ th√™m kh·ªëi n√†y khi c·∫ßn

                        # K·ªäCH B·∫¢N 1: C√ì GI·ªöI H·∫†N TH·ªúI L∆Ø·ª¢·ª¢NG (∆ØU TI√äN TUY·ªÜT ƒê·ªêI)
                        if min_duration_seconds > 0 and total_duration_seconds > 0:

                            # === T√çNH TO√ÅN KHO·∫¢NG G·ª¢I √ù S√ÅNG T·∫†O M·ªû R·ªòNG ===
                            base_upper_bound = max(1, int(total_duration_seconds / min_duration_seconds))
                            lower_bound_scenes = max(1, int(base_upper_bound * 0.5)) # N·ªõi l·ªèng c·∫≠n d∆∞·ªõi xu·ªëng 50%
                            creative_upper_bound = max(base_upper_bound, int(base_upper_bound * 1.25)) # Cho ph√©p c·∫≠n tr√™n s√°ng t·∫°o cao h∆°n 25%
                            # ===============================================

                            # 1. M√¥ t·∫£ nhi·ªám v·ª• ch√≠nh - Nh·∫•n m·∫°nh s·ª± s√°ng t·∫°o v√† b·ªëi c·∫£nh
                            main_task_description = (
                                "You are a creative script analyst and director's assistant. You are processing a single, **continuous, and coherent narrative**. "
                                "Your primary task is to read this script and divide it into meaningful visual scenes. Your decisions must maintain character and story consistency across all scenes. "
                                "You must follow one strict rule, but otherwise have complete creative freedom to ensure the best narrative pacing."
                            )

                            # 2. X√¢y d·ª±ng kh·ªëi quy t·∫Øc chi ti·∫øt v·ªÅ th·ªùi l∆∞·ª£ng (PHI√äN B·∫¢N S√ÅNG T·∫†O & LINH HO·∫†T NH·∫§T)
                            duration_rules_block = (
                                "\n\n**CRITICAL DURATION AND SCENE DIVISION RULES:**\n"
                                f"1.  **The Hard Rule (Non-Negotiable):** Each 'scene_script' MUST represent a segment of AT LEAST **{min_duration_seconds} seconds**. This is your only strict constraint.\n"
                                f"2.  **Creative Guideline (For Reference Only):** Based on the script's length ({total_duration_seconds:.0f} seconds), similar projects often result in **{lower_bound_scenes} to {creative_upper_bound}** scenes. Consider this a general observation, NOT a target you must hit.\n"
                                "3.  **Your Director's Judgment (Highest Priority):** Your main goal is to serve the story's rhythm and emotional impact. You have full authority to determine the final number of scenes. If the story is best told with **more scenes** than the guideline (e.g., 8, 9, or more), you are encouraged to do so, provided each scene respects the Hard Rule. If the story flows better with fewer, longer scenes, that is also a valid creative choice. **The final decision is yours.**"
                            )

                            # 3. Ch·ªâ d·∫´n cu·ªëi c√πng - Nh·∫Øc l·∫°i s·ª± c√¢n b·∫±ng gi·ªØa quy t·∫Øc v√† s√°ng t·∫°o
                            final_instruction = (
                                "Generate the JSON output. Strictly follow the minimum duration rule. "
                                "Use your creative judgment to select the best number of scenes for optimal storytelling, using the provided range as a creative guideline. Remember to maintain narrative consistency throughout."
                            )

                        # K·ªäCH B·∫¢N 2: KH√îNG C√ì GI·ªöI H·∫†N TH·ªúI L∆Ø·ª¢·ª¢NG (D√ôNG LOGIC S·ªê L∆Ø·ª¢NG ·∫¢NH)
                        else:
                            if auto_split_scenes:
                                # 1. M√¥ t·∫£ nhi·ªám v·ª• ch√≠nh T·∫¨P TRUNG v√†o vi·ªác t·ª± ƒë·ªông chia
                                main_task_description = (
                                    "You are an expert script analyst... You are processing a single, **continuous, and coherent narrative**. Your primary task is to read this script and divide it into the most important visual scenes that capture the story's essence. "
                                    f"The number of scenes should be appropriate for the script's content, but MUST NOT EXCEED {num_images} scenes."
                                )
                                # 2. Ch·ªâ d·∫´n cu·ªëi c√πng
                                final_instruction = f"Generate the JSON output, dividing the script into a suitable number of scenes (up to a maximum of {num_images}). Remember to maintain narrative consistency throughout."
                            else:
                                # 1. M√¥ t·∫£ nhi·ªám v·ª• ch√≠nh T·∫¨P TRUNG v√†o s·ªë l∆∞·ª£ng ·∫£nh ch√≠nh x√°c
                                main_task_description = (
                                    "You are an expert script analyst... You are processing a single, **continuous, and coherent narrative**. Your primary task is to read this script and divide it into "
                                    f"EXACTLY {num_images} key visual scenes."
                                )
                                # 2. Ch·ªâ d·∫´n cu·ªëi c√πng
                                final_instruction = f"Generate the JSON output, dividing the script into exactly {num_images} scenes. Remember to maintain narrative consistency throughout."

                            # Kh·ªëi quy t·∫Øc th·ªùi l∆∞·ª£ng s·∫Ω r·ªóng trong tr∆∞·ªùng h·ª£p n√†y
                            duration_rules_block = ""

                        # --- X√¢y d·ª±ng System Message cu·ªëi c√πng ---
                        system_message_content = (
                            f"{main_task_description}"
                            f"{safety_instruction_block}"
                            f"{character_instruction_block}"
                            f"{style_instruction_block}"
                            f"{duration_rules_block}" # S·∫Ω r·ªóng n·∫øu kh√¥ng c√≥ gi·ªõi h·∫°n th·ªùi gian
                            "\n\n**OUTPUT FORMAT (CRITICAL):**\n"
                            "- You MUST respond with a valid JSON array of objects. NO OTHER TEXT OR EXPLANATIONS.\n"
                            "- Each object in the array represents one scene and MUST have two keys: 'scene_script' and 'image_prompt'.\n"
                            "- The 'scene_script' value MUST be the EXACT, UNMODIFIED text segment from the original script that corresponds to the scene.\n"
                            "- The 'image_prompt' value MUST be the concise, high-quality, safe-for-work image prompt in ENGLISH for that scene.\n"
                            "- All image prompts must adhere to the art style instructions."
                        )

                        # --- X√¢y d·ª±ng User Message cu·ªëi c√πng ---
                        user_message_content = (
                            "Here is an example of the required JSON output format.\n"
                            "SCRIPT INPUT:\n'Ti√™u Vi√™m m·ªâm c∆∞·ªùi, nh√¨n v·ªÅ ph√≠a g√≥c ch·ª£. ·ªû ƒë√≥, m·ªôt c√¥ g√°i thanh t√∫ trong b·ªô v√°y xanh ƒëang ƒë·ª©ng ƒë·ª£i. C√¥ g√°i m·ªâm c∆∞·ªùi ƒë√°p l·∫°i.'\n"
                            "EXPECTED JSON OUTPUT:\n"
                            "[\n"
                            "  {\n"
                            '    "scene_script": "Ti√™u Vi√™m m·ªâm c∆∞·ªùi, nh√¨n v·ªÅ ph√≠a g√≥c ch·ª£. ·ªû ƒë√≥, m·ªôt c√¥ g√°i thanh t√∫ trong b·ªô v√°y xanh ƒëang ƒë·ª©ng ƒë·ª£i.",\n'
                            '    "image_prompt": "3D animation, ancient Chinese style. In a bustling marketplace, a handsome young man in a black robe named Ti√™u Vi√™m smiles warmly as he looks towards a graceful girl in a green dress. cinematic lighting, rendered in Unreal Engine 5, text-free."\n'
                            "  },\n"
                            "  {\n"
                            '    "scene_script": "C√¥ g√°i m·ªâm c∆∞·ªùi ƒë√°p l·∫°i.",\n'
                            '    "image_prompt": "Close-up shot, 3D animation, ancient Chinese style. The graceful girl in the green dress smiles back, her eyes sparkling. soft lighting, detailed facial expression, text-free."\n'
                            "  }\n"
                            "]\n\n"
                            "--- END OF EXAMPLE ---\n\n"
                            "Now, process the following script based on ALL my instructions.\n"
                            f"SCRIPT:\n\n{script_content}\n\n"
                            f"{final_instruction}" # <-- S·ª¨ D·ª§NG BI·∫æN final_instruction ƒê√É ƒê∆Ø·ª¢C T·∫†O
                        )

                        final_prompt_for_gemini = f"{system_message_content}\n\n{user_message_content}"                

                safety_settings = {
                    HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_ONLY_HIGH,
                    HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_ONLY_HIGH,
                    HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE, # Gi·ªØ nguy√™n
                    # N·ªõi l·ªèng c√†i ƒë·∫∑t n√†y ƒë·ªÉ cho ph√©p c√°c m√¥ t·∫£ c√≥ t√≠nh "nguy hi·ªÉm" nh·∫π ƒëi qua
                    # V√ç D·ª§: m√¥ t·∫£ m·ªôt tr·∫≠n chi·∫øn kh√¥ng c√≥ m√°u me.
                    HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_ONLY_HIGH, 
                }
                
                logging.info(f"{worker_log_prefix} (Th·ª≠ l·∫ßn {attempt + 1}/{max_retries + 1}) G·ªçi API model '{selected_model}'...")
                response = model.generate_content(
                    final_prompt_for_gemini,
                    safety_settings=safety_settings
                )

                if self.stop_event.is_set():
                    raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng sau khi API Gemini chia c·∫£nh ho√†n t·∫•t.")

                gemini_response_text = None # Kh·ªüi t·∫°o bi·∫øn

                # Ki·ªÉm tra an to√†n xem response c√≥ n·ªôi dung hay kh√¥ng
                if response.parts:
                    # N·∫øu c√≥, l·∫•y n·ªôi dung m·ªôt c√°ch an to√†n
                    gemini_response_text = response.text.strip()
                    self._track_api_call(service_name="gemini_calls", units=1)
                    if not gemini_response_text:
                        error_message = "Gemini tr·∫£ v·ªÅ n·ªôi dung r·ªóng."
                    error_message = None # Th√†nh c√¥ng, reset l·ªói
                    break # Tho√°t kh·ªèi v√≤ng l·∫∑p retry (n·∫øu c√≥)
                else:
                    # N·∫øu kh√¥ng c√≥ 'parts', nghƒ©a l√† ƒë√£ b·ªã ch·∫∑n ho·∫∑c c√≥ l·ªói
                    block_reason = "Kh√¥ng r√µ"
                    # C·ªë g·∫Øng l·∫•y l√Ω do ch·∫∑n c·ª• th·ªÉ t·ª´ prompt_feedback
                    if hasattr(response, 'prompt_feedback') and hasattr(response.prompt_feedback, 'block_reason') and response.prompt_feedback.block_reason:
                        block_reason = response.prompt_feedback.block_reason.name
                    
                    # N√©m ra m·ªôt l·ªói Runtime r√µ r√†ng ƒë·ªÉ kh·ªëi "except Exception as e:" b√™n ngo√†i b·∫Øt ƒë∆∞·ª£c
                    raise RuntimeError(f"Y√™u c·∫ßu b·ªã ch·∫∑n b·ªüi b·ªô l·ªçc an to√†n c·ªßa Gemini (L√Ω do: {block_reason}).")

            except (google_api_exceptions.ResourceExhausted, google_api_exceptions.ServiceUnavailable, google_api_exceptions.DeadlineExceeded, google_api_exceptions.InternalServerError) as e:
                # <<< B·∫ÆT C√ÅC L·ªñI C√ì TH·ªÇ TH·ª¨ L·∫†I (PHI√äN B·∫¢N S·ª¨A L·ªñI TREO) >>>
                logging.warning(f"{worker_log_prefix} (Th·ª≠ l·∫ßn {attempt + 1}) G·∫∑p l·ªói c√≥ th·ªÉ th·ª≠ l·∫°i ({type(e).__name__}). Ch·ªù {initial_retry_delay_s:.1f}s...")
                error_message = f"L·ªói t·∫°m th·ªùi t·ª´ Google API: {type(e).__name__}."
                if attempt < max_retries:
                    # 1. T·∫°o m·ªôt Event ƒë·ªÉ lu·ªìng n·ªÅn ch·ªù
                    retry_event = threading.Event()

                    # 2. Y√™u c·∫ßu lu·ªìng ch√≠nh ƒë·∫∑t h·∫πn gi·ªù v√† set Event sau khi h·∫øt gi·ªù
                    def _schedule_retry():
                        self.update_status(f"üíé Gemini: G·∫∑p l·ªói t·∫°m th·ªùi. Th·ª≠ l·∫°i sau {initial_retry_delay_s:.1f}s...")
                        # D√πng after() ƒë·ªÉ kh√¥ng ch·∫∑n lu·ªìng ch√≠nh
                        self.after(int(initial_retry_delay_s * 1000), retry_event.set)
                    
                    self.after(0, _schedule_retry)

                    # 3. Lu·ªìng n·ªÅn s·∫Ω ƒë·ª£i ·ªü ƒë√¢y cho ƒë·∫øn khi lu·ªìng ch√≠nh g·ªçi retry_event.set()
                    logging.info(f"{worker_log_prefix} Lu·ªìng n·ªÅn ƒëang ch·ªù t√≠n hi·ªáu retry t·ª´ lu·ªìng ch√≠nh...")
                    retry_event.wait() # Ch·ªù t√≠n hi·ªáu
                    logging.info(f"{worker_log_prefix} ƒê√£ nh·∫≠n t√≠n hi·ªáu, ti·∫øp t·ª•c th·ª≠ l·∫°i.")
                    
                    continue # Th·ª≠ l·∫°i v√≤ng l·∫∑p for
                else:
                    logging.error(f"{worker_log_prefix} V·∫´n g·∫∑p l·ªói sau {max_retries + 1} l·∫ßn th·ª≠. B·ªè qua.")
                    break # H·∫øt s·ªë l·∫ßn th·ª≠, tho√°t v√≤ng l·∫∑p
            
            except (RuntimeError, google_exceptions.PermissionDenied, google_exceptions.InvalidArgument) as e:
                # <<< B·∫ÆT C√ÅC L·ªñI KH√îNG TH·ªÇ TH·ª¨ L·∫†I >>>
                error_message = f"L·ªói kh√¥ng th·ªÉ th·ª≠ l·∫°i khi d√πng Gemini chia c·∫£nh: {e}"
                logging.error(f"{worker_log_prefix} {error_message}", exc_info=False) # Kh√¥ng c·∫ßn full traceback cho l·ªói ƒë√£ bi·∫øt
                break # Tho√°t v√≤ng l·∫∑p ngay l·∫≠p t·ª©c

            except InterruptedError as ie:
                error_message = f"ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng: {ie}"
                logging.warning(f"{worker_log_prefix} {error_message}")
                break
            except Exception as e:
                error_message = f"L·ªói kh√¥ng mong mu·ªën khi d√πng Gemini chia c·∫£nh: {e}"
                logging.error(f"{worker_log_prefix} {error_message}", exc_info=True)
                break
        # <<< K·∫æT TH√öC KH·ªêI LOGIC TH·ª¨ L·∫†I M·ªöI >>>

        # G·ªçi h√†m x·ª≠ l√Ω k·∫øt qu·∫£ ·ªü lu·ªìng ch√≠nh (logic n√†y kh√¥ng ƒë·ªïi)
        self.after(0, self._handle_gemini_scene_division_result,
                   gemini_response_text,
                   error_message,
                   formatted_srt_for_slideshow,
                   script_content,
                   target_widget,
                   context,
                   trigger_dub_chain_flag,
                   base_filename_for_chain)



# _sanitize_script_for_ai function - MOVED to utils/helpers.py


#-------------------------------------------------------------
# <<<--- TH√äM H√ÄM M·ªöI N√ÄY V√ÄO (B∆Ø·ªöC 6A) ---<<<
    def _handle_gemini_scene_division_result(self, gemini_response_text, error_message,
                                             script_for_slideshow_timing, original_plain_text_for_dub,
                                             target_widget, context, trigger_dub_chain_flag,
                                             base_filename_for_chain):
        """
        (PHI√äN B·∫¢N 7.0 - T√ÅI C·∫§U TR√öC & C·ª®U H·ªò JSON)
        X·ª≠ l√Ω k·∫øt qu·∫£ t·ª´ Gemini, "c·ª©u h·ªô" t·ª´ng kh·ªëi JSON h·ª£p l·ªá, v√† x·ª≠ l√Ω l·ªói nh·∫•t qu√°n qua c√°c h√†m helper.
        """
        log_prefix = f"[HandleGeminiSceneResult_v7_Salvage]"

        # --- B∆Ø·ªöC 1: X·ª¨ L√ù L·ªñI M·∫†NG HO·∫∂C K·∫æT QU·∫¢ R·ªñNG ---
        if error_message or not gemini_response_text:
            error_to_show = error_message or "Gemini kh√¥ng t·∫°o ƒë∆∞·ª£c prompt ·∫£nh n√†o."
            if self._is_in_any_batch_queue():
                self._handle_batch_error_and_continue("L·ªói Chu·ªói AI (H√†ng lo·∫°t)", error_to_show)
            else:
                self.is_gemini_processing = False
                messagebox.showerror("L·ªói Gemini Chia C·∫£nh", f"ƒê√£ x·∫£y ra l·ªói:\n\n{error_to_show}", parent=self)
                self._check_completion_and_shutdown()
            return

        try:
            # === B∆Ø·ªöC 2: PARSE JSON M·∫†NH M·∫º - "C·ª®U H·ªò" T·ª™NG KH·ªêI RI√äNG L·∫∫ ===
            logging.debug(f"{log_prefix} Ph·∫£n h·ªìi th√¥ t·ª´ Gemini:\n{gemini_response_text}")

            potential_json_blocks = re.findall(r'\{.*?\}', gemini_response_text, re.DOTALL)
            if not potential_json_blocks:
                raise json.JSONDecodeError("Kh√¥ng t√¨m th·∫•y kh·ªëi vƒÉn b·∫£n n√†o c√≥ d·∫°ng {...} trong ph·∫£n h·ªìi.", gemini_response_text, 0)

            logging.info(f"{log_prefix} T√¨m th·∫•y {len(potential_json_blocks)} kh·ªëi JSON ti·ªÅm nƒÉng. B·∫Øt ƒë·∫ßu parse...")
            
            scene_data_list, parsing_errors = [], []
            for block_str in potential_json_blocks:
                try:
                    cleaned_block_str = ''.join(c for c in block_str if c.isprintable() or c in '\n\r\t')
                    parsed_data = json.loads(cleaned_block_str)
                    if isinstance(parsed_data, dict):
                        scene_data_list.append(parsed_data)
                except json.JSONDecodeError as e:
                    parsing_errors.append(f"L·ªói parse kh·ªëi: {e} | Kh·ªëi: '{block_str}'")

            if parsing_errors:
                logging.warning(f"{log_prefix} ƒê√£ b·ªè qua {len(parsing_errors)} kh·ªëi JSON b·ªã l·ªói.")

            if not scene_data_list:
                raise ValueError("Kh√¥ng 'c·ª©u h·ªô' ƒë∆∞·ª£c b·∫•t k·ª≥ kh·ªëi JSON h·ª£p l·ªá n√†o.")

            # === B∆Ø·ªöC 3: X√ÅC TH·ª∞C V√Ä TR√çCH XU·∫§T D·ªÆ LI·ªÜU ===
            scene_scripts = [item.get("scene_script", "").strip() for item in scene_data_list]
            image_prompts = [item.get("image_prompt", "").strip() for item in scene_data_list]
            valid_pairs = [(s, p) for s, p in zip(scene_scripts, image_prompts) if s and p]
            
            if not valid_pairs:
                raise ValueError("Kh√¥ng c√≥ c·∫∑p scene/prompt h·ª£p l·ªá n√†o trong c√°c kh·ªëi JSON ƒë√£ parse.")

            final_scene_scripts = [pair[0] for pair in valid_pairs]
            final_image_prompts = [pair[1] for pair in valid_pairs]
            logging.info(f"{log_prefix} ƒê√£ 'c·ª©u h·ªô' th√†nh c√¥ng {len(final_image_prompts)} c·∫∑p scene/prompt.")

            # === B∆Ø·ªöC 4: T√çNH TO√ÅN TH·ªúI L∆Ø·ª¢NG V√Ä CHU·∫®N B·ªä T·∫†O ·∫¢NH ===
            image_durations_seconds = self._calculate_durations_for_scenes(final_scene_scripts)
            if not image_durations_seconds or len(image_durations_seconds) != len(final_image_prompts):
                raise ValueError("Kh√¥ng th·ªÉ t√≠nh to√°n th·ªùi l∆∞·ª£ng ho·∫∑c s·ªë l∆∞·ª£ng kh√¥ng kh·ªõp.")

            logging.info(f"{log_prefix} Chu·∫©n b·ªã g·ªçi Imagen v·ªõi {len(final_image_prompts)} prompt.")
            self.update_status(f"‚úÖ Gemini ƒë√£ chia c·∫£nh & t√≠nh th·ªùi l∆∞·ª£ng. Chu·∫©n b·ªã v·∫Ω {len(final_image_prompts)} ·∫£nh...")
            
            # Ph·∫ßn chu·∫©n b·ªã payload v√† g·ªçi b∆∞·ªõc ti·∫øp theo gi·ªØ nguy√™n
            output_folder = self.cfg.get("imagen_last_output_folder", get_default_downloads_folder())
            safe_base_name = create_safe_filename(base_filename_for_chain, max_length=80) if base_filename_for_chain else f"ai_chain_{uuid.uuid4().hex[:6]}"
            timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
            new_folder_name = f"Imagen_{safe_base_name}_{timestamp_str}"
            temp_imagen_output_folder = os.path.join(output_folder, new_folder_name)
            os.makedirs(temp_imagen_output_folder, exist_ok=True)

            payload_for_next_steps = {
                "image_prompts": final_image_prompts,
                "image_durations_seconds": image_durations_seconds,
                "original_plain_text_for_dub": original_plain_text_for_dub,
                "original_full_srt_for_hardsub": script_for_slideshow_timing 
            }

            self.after(100, self._handle_image_generation_and_slideshow,
                       payload_for_next_steps, temp_imagen_output_folder, target_widget,
                       context, trigger_dub_chain_flag, "Imagen 3", "Gemini",
                       base_filename_for_chain, temp_imagen_output_folder)

        except (json.JSONDecodeError, TypeError, ValueError) as e:
            # === X·ª¨ L√ù L·ªñI T·∫¨P TRUNG ===
            # T·∫•t c·∫£ c√°c l·ªói t·ª´ parse JSON, validation, t√≠nh to√°n th·ªùi l∆∞·ª£ng s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü ƒë√¢y
            error_to_show = f"L·ªói trong qu√° tr√¨nh x·ª≠ l√Ω k·∫øt qu·∫£ Gemini: {e}"
            if self._is_in_any_batch_queue():
                self._handle_batch_error_and_continue("L·ªói X·ª≠ l√Ω D·ªØ li·ªáu (H√†ng lo·∫°t)", error_to_show, gemini_response_text)
            else:
                self.is_gemini_processing = False
                messagebox.showerror("L·ªói X·ª≠ l√Ω K·∫øt qu·∫£ AI", error_to_show, parent=self)
                self._check_completion_and_shutdown()
            return

    def _is_in_any_batch_queue(self):
        """Ki·ªÉm tra xem ·ª©ng d·ª•ng c√≥ ƒëang trong m·ªôt ch·∫ø ƒë·ªô x·ª≠ l√Ω h√†ng lo·∫°t n√†o kh√¥ng."""
        # L∆∞u √Ω: S·∫Ω t·ªët h∆°n n·∫øu c√°c thu·ªôc t√≠nh n√†y ƒë∆∞·ª£c kh·ªüi t·∫°o trong __init__
        # v√≠ d·ª•: self.is_ai_batch_processing = False
        is_ai_batch = getattr(self, 'is_ai_batch_processing', False)
        is_sub_batch = getattr(self, 'is_subbing', False) and (getattr(self, 'file_queue', None) or getattr(self, 'current_file', None))
        return is_ai_batch or is_sub_batch

    def _handle_batch_error_and_continue(self, error_title, error_message, gemini_response_text=None):
        """
        H√†m tr·ª£ gi√∫p x·ª≠ l√Ω l·ªói cho ch·∫ø ƒë·ªô h√†ng lo·∫°t m·ªôt c√°ch nh·∫•t qu√°n.
        Hi·ªÉn th·ªã popup kh√¥ng ch·∫∑n, ghi log, v√† l√™n l·ªãch x·ª≠ l√Ω cho file ti·∫øp theo.
        """
        self.is_gemini_processing = False # Lu√¥n t·∫Øt c·ªù x·ª≠ l√Ω khi c√≥ l·ªói
        
        # 1. Ghi log l·ªói chi ti·∫øt
        log_prefix = "[BatchErrorHandler]"
        logging.error(f"{log_prefix} {error_title}: {error_message}")
        if gemini_response_text:
            logging.error(f"{log_prefix} Ph·∫£n h·ªìi g·ªëc g√¢y l·ªói:\n{gemini_response_text}")

        # 2. L·∫•y t√™n file hi·ªán t·∫°i ƒë·ªÉ hi·ªÉn th·ªã
        current_filename = "Kh√¥ng r√µ"
        if getattr(self, 'is_ai_batch_processing', False) and self.ai_batch_current_file:
            current_filename = os.path.basename(self.ai_batch_current_file)
        elif getattr(self, 'is_subbing', False) and self.current_file:
            if isinstance(self.current_file, dict):
                current_filename = os.path.basename(self.current_file.get('source', 'task_object'))
            else:
                current_filename = os.path.basename(str(self.current_file))

        # 3. Hi·ªÉn th·ªã popup l·ªói kh√¥ng ch·∫∑n
        batch_error_msg = f"L·ªói x·ª≠ l√Ω file '{current_filename}':\n\n{error_message}\n\n·ª®ng d·ª•ng s·∫Ω b·ªè qua file n√†y v√† ti·∫øp t·ª•c."
        self._show_non_blocking_error_popup(
            error_title, 
            batch_error_msg, 
            failed_item_identifier=current_filename
        )
        # 4. G·ªçi ƒë√∫ng h√†m x·ª≠ l√Ω file ti·∫øp theo
        if getattr(self, 'is_ai_batch_processing', False):
            self.after(100, self._process_next_ai_batch_item)
        elif getattr(self, 'is_subbing', False):
            self.after(100, self._process_next_subtitle_file)
#-------------------------------------------------------------

# <<<--- TH√äM H√ÄM M·ªöI N√ÄY V√ÄO (B∆Ø·ªöC 6B) ---<<<
    def _start_gemini_imagen_slideshow_chain(self, imagen_prompts, script_for_slideshow, target_widget, context, trigger_dub_chain_flag):
        """
        H√†m n√†y chu·∫©n b·ªã m·ªçi th·ª© v√† kh·ªüi ƒë·ªông lu·ªìng worker ƒë·ªÉ t·∫°o ·∫£nh b·∫±ng Imagen 3.
        """
        log_prefix = f"[Chain_Gemini_Imagen]"
        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu chu·ªói Imagen. S·ªë prompts: {len(imagen_prompts)}")
        
        # L·∫•y c√°c c√†i ƒë·∫∑t t·ª´ c·ª≠a s·ªï Imagen ƒë√£ ƒë∆∞·ª£c l∆∞u trong config
        try:
            num_images_total = int(self.cfg.get("imagen_last_num_images", "1"))
            aspect_ratio = self.cfg.get("imagen_last_aspect_ratio", "16:9")
            output_folder = self.cfg.get("imagen_last_output_folder", get_default_downloads_folder())
        except (ValueError, TypeError) as e:
            logging.error(f"{log_prefix} L·ªói ƒë·ªçc c√†i ƒë·∫∑t Imagen t·ª´ config: {e}")
            messagebox.showerror("L·ªói C·∫•u h√¨nh Imagen", "C√†i ƒë·∫∑t cho Imagen (s·ªë l∆∞·ª£ng, th∆∞ m·ª•c) kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i trong c·ª≠a s·ªï 'T·∫°o ·∫¢nh b·∫±ng Google Imagen'.", parent=self)
            self._check_completion_and_shutdown()
            return

        # T·∫°o th∆∞ m·ª•c con cho t√°c v·ª• n√†y ƒë·ªÉ c√°c ·∫£nh kh√¥ng b·ªã l·∫´n l·ªôn
        unique_folder_name = f"imagen_gemini_chain_{uuid.uuid4().hex[:8]}"
        temp_imagen_output_folder = os.path.join(output_folder, unique_folder_name)
        os.makedirs(temp_imagen_output_folder, exist_ok=True)
        
        # C·∫≠p nh·∫≠t tr·∫°ng th√°i ·ª©ng d·ª•ng
        self.is_imagen_processing = True
        if not self.start_time: self.start_time = time.time() # Reset timer n·∫øu c·∫ßn
        self.update_time_realtime()

        # B·∫Øt ƒë·∫ßu lu·ªìng worker t·∫°o ·∫£nh
        thread = threading.Thread(
            target=self._execute_imagen_chain_generation_iterative,
            args=(imagen_prompts, num_images_total, aspect_ratio, temp_imagen_output_folder,
                  script_for_slideshow, script_for_slideshow,
                  target_widget, # <<< S·ª¨A L·ªñI G·ªêC R·ªÑ: Truy·ªÅn widget ƒëi ti·∫øp
                  context, trigger_dub_chain_flag),
            daemon=True, name="ImagenChainGenerationThread"
        )
        thread.start()


# <<<--- TH√äM H√ÄM M·ªöI N√ÄY V√ÄO (B∆Ø·ªöC 6C) ---<<<
    def _execute_imagen_chain_generation_iterative(self, prompts, num_images_per_prompt, aspect_ratio, output_folder,
                                                   script_for_slideshow_timing, original_plain_text_for_dub,
                                                   target_widget, context, trigger_dub_chain_flag,
                                                   image_engine_name, ai_script_engine_name, style_prompt_fragment="",
                                                   base_filename_for_chain=None,
                                                   negative_prompt="",
                                                   output_dir_override=None):
        """
        (PHI√äN B·∫¢N 5 - LINH HO·∫†T KHI L·ªñI)
        L·∫∑p qua t·ª´ng prompt, g·ªçi API, th·ª≠ l·∫°i khi g·∫∑p l·ªói c√≥ th·ªÉ ph·ª•c h·ªìi.
        N·∫øu g·∫∑p l·ªói kh√¥ng th·ªÉ ph·ª•c h·ªìi cho m·ªôt ·∫£nh, s·∫Ω ghi nh·∫≠n v√† ti·∫øp t·ª•c v·ªõi ·∫£nh ti·∫øp theo.
        Ch·ªâ th·∫•t b·∫°i ho√†n to√†n n·∫øu kh√¥ng t·∫°o ƒë∆∞·ª£c ·∫£nh n√†o.
        """
        worker_log_prefix = f"[ImagenChainWorker_v5_FlexibleError]"
        all_saved_image_paths = []
        error_occurred_during_generation = False
        first_error_message_for_callback = None # <<< THAY ƒê·ªîI: Ch·ªâ l∆∞u l·ªói ƒë·∫ßu ti√™n

        with keep_awake(f"Generating {len(prompts)} Imagen images"):
            try:
                from google.genai import Client, types
                from google.api_core import exceptions as google_api_exceptions
                from google.genai import errors as google_genai_errors

                client = Client(api_key=self.gemini_key_var.get())
                
                max_retries_per_prompt = 2
                initial_retry_delay_s = 5.0

                for i, p in enumerate(prompts):
                    if self.stop_event.is_set():
                        if not first_error_message_for_callback: first_error_message_for_callback = "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng khi ƒëang t·∫°o ·∫£nh."
                        error_occurred_during_generation = True
                        break 

                    self.after(0, lambda: self.update_status(f"üñº {image_engine_name}: ƒêang chu·∫©n b·ªã ·∫£nh {i+1}/{len(prompts)}..."))

                    # Gh√©p prompt ch√≠nh v·ªõi phong c√°ch ngh·ªá thu·∫≠t
                    prompt_with_style = f"{p.strip()}, {style_prompt_fragment}" if style_prompt_fragment else p.strip()

                    # Chu·∫©n b·ªã negative prompt cu·ªëi c√πng
                    default_negative_keywords = "text, words, letters, writing, typography, signs, banners, logos, watermark, signature, extra fingers, malformed hands, lowres, blurry"
                    final_negative_prompt_str = default_negative_keywords
                    if negative_prompt:
                        final_negative_prompt_str = f"{negative_prompt}, {default_negative_keywords}"

                    # N·ªëi t·∫•t c·∫£ l·∫°i th√†nh m·ªôt prompt ho√†n ch·ªânh cho API
                    # K·ªπ thu·∫≠t d√πng (without: ...) ho·∫∑c "negative prompt:" l√† c√°ch ph·ªï bi·∫øn ƒë·ªÉ h∆∞·ªõng d·∫´n model
                    final_prompt_for_api = f"{prompt_with_style} (without: {final_negative_prompt_str})"
                    logging.info(f"{worker_log_prefix} Final prompt for image #{i+1}: {final_prompt_for_api}")
                    
                    current_retries = 0
                    prompt_succeeded = False
                    while current_retries <= max_retries_per_prompt and not prompt_succeeded:
                        if self.stop_event.is_set():
                            error_occurred_during_generation = True
                            if not first_error_message_for_callback: first_error_message_for_callback = "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng."
                            break 
                        
                        try:
                            log_attempt_msg = f"G·ªçi API cho ·∫£nh {i+1}/{len(prompts)} (Th·ª≠ l·∫ßn {current_retries + 1})."
                            logging.info(f"{worker_log_prefix} {log_attempt_msg}")
                            
                            response = client.models.generate_images(
                                model='imagen-3.0-generate-002',
                                prompt=final_prompt_for_api,
                                config=types.GenerateImagesConfig(number_of_images=1, aspect_ratio=aspect_ratio)
                            )

                            if self.stop_event.is_set():
                                raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng sau khi API Imagen t·∫°o ·∫£nh ho√†n t·∫•t.")
                            
                            if not response.generated_images:
                                reason = response.prompt_feedback.block_reason.name if hasattr(response, 'prompt_feedback') and hasattr(response.prompt_feedback, 'block_reason') else "Kh√¥ng r√µ l√Ω do."
                                warning_msg = f"Prompt cho ·∫£nh #{i+1} ƒë√£ b·ªã ch·∫∑n b·ªüi b·ªô l·ªçc an to√†n. L√Ω do: {reason}"
                                logging.warning(f"{worker_log_prefix} {warning_msg}")
                                self._show_non_blocking_error_popup(f"L·ªói T·∫°o ·∫¢nh Imagen #{i+1}", f"Y√™u c·∫ßu t·∫°o ·∫£nh c·ªßa b·∫°n ƒë√£ b·ªã b·ªô l·ªçc an to√†n c·ªßa Google ch·∫∑n.\n\nL√Ω do: {reason}\n\n·ª®ng d·ª•ng s·∫Ω ti·∫øp t·ª•c v·ªõi c√°c ·∫£nh c√≤n l·∫°i.")
                                # ƒê√°nh d·∫•u c√≥ l·ªói nh∆∞ng kh√¥ng d·ª´ng to√†n b·ªô
                                error_occurred_during_generation = True
                                if not first_error_message_for_callback: first_error_message_for_callback = warning_msg
                                break # Tho√°t v√≤ng l·∫∑p retry cho prompt n√†y, chuy·ªÉn sang prompt ti·∫øp theo

                            # ƒê·∫øm s·ªë ·∫£nh ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng trong l·∫ßn g·ªçi API n√†y
                            num_generated_images_this_call = len(response.generated_images)
                            if num_generated_images_this_call > 0:
                                self._track_api_call(service_name="imagen_images", units=num_generated_images_this_call)
                                logging.info(f"{worker_log_prefix} ƒê√£ ghi nh·∫≠n {num_generated_images_this_call} ·∫£nh Imagen v√†o th·ªëng k√™.")

                            image_bytes = response.generated_images[0].image.image_bytes
                            file_name = f"imagen_chain_{i:03d}_{uuid.uuid4().hex[:4]}.png"
                            file_path = os.path.join(output_folder, file_name)
                            with open(file_path, "wb") as f: f.write(image_bytes)
                            all_saved_image_paths.append(file_path)
                            prompt_succeeded = True
                            time.sleep(1.2)

                        except (google_api_exceptions.ResourceExhausted, google_api_exceptions.ServiceUnavailable, google_api_exceptions.InternalServerError, google_api_exceptions.DeadlineExceeded, google_genai_errors.ClientError) as e:
                            is_retryable = False
                            if isinstance(e, google_genai_errors.ClientError) and e.status_code == 499:
                                is_retryable = True
                            elif not isinstance(e, google_genai_errors.ClientError):
                                is_retryable = True

                            if is_retryable:
                                logging.warning(f"{worker_log_prefix} G·∫∑p l·ªói c√≥ th·ªÉ retry ({type(e).__name__}) cho ·∫£nh {i+1}. L·ªói: {e}")
                                current_retries += 1
                                if current_retries > max_retries_per_prompt:
                                    logging.error(f"{worker_log_prefix} ƒê√£ v∆∞·ª£t qu√° s·ªë l·∫ßn th·ª≠ l·∫°i cho ·∫£nh {i+1}. B·ªé QUA ·∫¢NH N√ÄY.")
                                    
                                    # ƒêo·∫°n code m·ªõi b·∫°n h·ªèi n·∫±m ·ªü ƒë√¢y
                                    self._show_non_blocking_error_popup(
                                        f"L·ªói T·∫°o ·∫¢nh Imagen #{i+1}",
                                        f"G·∫∑p l·ªói m·∫°ng ho·∫∑c server v√† ƒë√£ th·ª≠ l·∫°i {max_retries_per_prompt} l·∫ßn kh√¥ng th√†nh c√¥ng.\n\nL·ªói: {e}\n\n·ª®ng d·ª•ng s·∫Ω ti·∫øp t·ª•c v·ªõi c√°c ·∫£nh c√≤n l·∫°i.",
                                        failed_item_identifier=f"{base_filename_for_chain} (·∫¢nh #{i+1})"
                                    )
                                    if not first_error_message_for_callback: first_error_message_for_callback = f"L·ªói kh√¥ng th·ªÉ ph·ª•c h·ªìi cho ·∫£nh #{i+1}: {type(e).__name__}"
                                    error_occurred_during_generation = True
                                    break

                                wait_time = initial_retry_delay_s * (2 ** (current_retries - 1))
                                logging.info(f"{worker_log_prefix} S·∫Ω th·ª≠ l·∫°i sau {wait_time:.1f} gi√¢y...")
                                self.after(0, lambda: self.update_status(f"üñº {image_engine_name}: G·∫∑p l·ªói t·∫°m th·ªùi, ch·ªù {wait_time:.1f}s..."))
                                
                                for _ in range(int(wait_time * 10)):
                                    if self.stop_event.is_set(): break
                                    time.sleep(0.1)
                            else:
                                logging.error(f"{worker_log_prefix} G·∫∑p l·ªói Client kh√¥ng th·ªÉ retry cho ·∫£nh {i+1}: {e}", exc_info=True)
                                
                                # ƒêo·∫°n code m·ªõi b·∫°n h·ªèi n·∫±m ·ªü ƒë√¢y
                                self._show_non_blocking_error_popup(
                                    f"L·ªói T·∫°o ·∫¢nh Imagen #{i+1}",
                                    f"L·ªói t·ª´ ph√≠a client ho·∫∑c y√™u c·∫ßu kh√¥ng h·ª£p l·ªá.\n\nL·ªói: {e}\n\n·ª®ng d·ª•ng s·∫Ω ti·∫øp t·ª•c v·ªõi c√°c ·∫£nh c√≤n l·∫°i.",
                                    failed_item_identifier=f"{base_filename_for_chain} (·∫¢nh #{i+1})"
                                )
                                if not first_error_message_for_callback: first_error_message_for_callback = f"L·ªói kh√¥ng th·ªÉ ph·ª•c h·ªìi cho ·∫£nh #{i+1}: {type(e).__name__}"
                                error_occurred_during_generation = True
                                break
                        
                        except Exception as e_inner:
                            logging.error(f"{worker_log_prefix} L·ªói kh√¥ng th·ªÉ retry khi t·∫°o ·∫£nh Imagen #{i+1}: {e_inner}", exc_info=True)
                            
                            # ƒêo·∫°n code m·ªõi b·∫°n h·ªèi n·∫±m ·ªü ƒë√¢y
                            self._show_non_blocking_error_popup(
                                f"L·ªói T·∫°o ·∫¢nh Imagen #{i+1}",
                                f"L·ªói kh√¥ng x√°c ƒë·ªãnh ƒë√£ x·∫£y ra.\n\nL·ªói: {e_inner}\n\n·ª®ng d·ª•ng s·∫Ω ti·∫øp t·ª•c v·ªõi c√°c ·∫£nh c√≤n l·∫°i.",
                                failed_item_identifier=f"{base_filename_for_chain} (·∫¢nh #{i+1})"
                            )
                            if not first_error_message_for_callback: first_error_message_for_callback = f"L·ªói kh√¥ng th·ªÉ ph·ª•c h·ªìi cho ·∫£nh #{i+1}: {type(e_inner).__name__}"
                            error_occurred_during_generation = True
                            break         
                
                # Sau khi ƒë√£ th·ª≠ t·∫•t c·∫£ c√°c prompt, l∆∞u file prompt n·∫øu c√≥ √≠t nh·∫•t 1 ·∫£nh th√†nh c√¥ng
                if all_saved_image_paths:
                    try:
                        safe_base_filename = base_filename_for_chain if base_filename_for_chain else f"chain_{uuid.uuid4().hex[:6]}"
                        prompts_filename = f"prompts_{image_engine_name}_{safe_base_filename}.txt"
                        saved_prompts_filepath = os.path.join(output_folder, prompts_filename)
                        with open(saved_prompts_filepath, "w", encoding="utf-8") as f: f.write("\n\n".join(prompts))
                        logging.info(f"ƒê√£ l∆∞u c√°c prompt v√†o: {saved_prompts_filepath}")
                    except Exception as e: logging.error(f"L·ªói khi l∆∞u file prompt: {e}")

            except Exception as e_outer:
                if not first_error_message_for_callback: first_error_message_for_callback = f"L·ªói nghi√™m tr·ªçng trong qu√° tr√¨nh chu·∫©n b·ªã t·∫°o ·∫£nh: {e_outer}"
                logging.error(f"{worker_log_prefix} {first_error_message_for_callback}", exc_info=True)
                error_occurred_during_generation = True
            
            finally:
                self.after(0, self._handle_slideshow_creation_and_completion,
                           all_saved_image_paths,
                           script_for_slideshow_timing,
                           original_plain_text_for_dub,
                           output_folder,
                           target_widget,
                           context,
                           trigger_dub_chain_flag,
                           image_engine_name,
                           ai_script_engine_name,
                           base_filename_for_chain,
                           first_error_message_for_callback,
                           output_dir_override)


# H√ÄM HELPER M·ªöI: HI·ªÇN TH·ªä POPUP L·ªñI KH√îNG CH·∫∂N
    def _show_non_blocking_error_popup(self, title, message, failed_item_identifier=None):
        """
        Hi·ªÉn th·ªã Toplevel g·ªëc ƒë·ªÉ b√°o l·ªói kh√¥ng ch·∫∑n lu·ªìng ch√≠nh.
        - GHI L·∫†I T√ÅC V·ª§ L·ªñI v√†o file log n·∫øu c√≥ failed_item_identifier.
        - T·ª± ƒë·ªông ƒë√≥ng sau 30 gi√¢y.
        """
        # G·ªåI H√ÄM GHI LOG
        if failed_item_identifier:
            log_failed_task(failed_item_identifier)
        
        try:
            self.bell()
            import tkinter as tk
            popup = tk.Toplevel(self)
            popup.configure(bg=self._apply_appearance_mode(ctk.ThemeManager.theme["CTkFrame"]["fg_color"]))

            popup.title(title)
            popup.iconbitmap(resource_path("logo_Piu.ico"))
            
            popup.attributes("-topmost", True)
            popup.transient(self)
            
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            popup_width = 400
            popup_height = 150
            x = screen_width - popup_width - 20
            y = screen_height - popup_height - 90 
            popup.geometry(f"{popup_width}x{popup_height}+{x}+{y}")

            main_frame = ctk.CTkFrame(popup)
            main_frame.pack(expand=True, fill="both", padx=10, pady=10)
            
            ctk.CTkLabel(main_frame, text=message, wraplength=popup_width - 40, justify="left").pack(expand=True, fill="both", pady=(0, 10))
            ctk.CTkButton(main_frame, text="ƒê√£ hi·ªÉu", command=popup.destroy).pack(side="bottom", anchor="e")

            def safe_destroy():
                try:
                    if popup and popup.winfo_exists():
                        popup.destroy()
                except Exception:
                    pass

            popup.after(30000, safe_destroy) 
        except Exception as e:
            logging.error(f"Kh√¥ng th·ªÉ hi·ªÉn th·ªã popup l·ªói kh√¥ng ch·∫∑n: {e}")


# Ghi l·∫°i m·ªôt m·ª•c b·ªã l·ªói v√†o file log chuy√™n d·ª•ng (Piu_failed_tasks.log)


#------------------------------------
# H√†m k√≠ch ho·∫°t: L·∫•y text, l·∫•y prompt
    def _trigger_gemini_script_processing(self, target_textbox_widget, context, user_prompt_from_popup):
        """
        H√†m k√≠ch ho·∫°t: L·∫•y text, prompt, v√† b·∫Øt ƒë·∫ßu lu·ªìng x·ª≠ l√Ω Gemini.
        ƒê√É S·ª¨A: T∆∞∆°ng t√°c v·ªõi c√°c n√∫t AI h·ª£p nh·∫•t.
        """
        self.stop_event.clear()
        logging.info(f"[GeminiTrigger:{context}] ƒê√£ x√≥a (clear) self.stop_event.")

        log_prefix = f"[GeminiTrigger:{context}]"
        logging.info(f"{log_prefix} K√≠ch ho·∫°t bi√™n t·∫≠p Gemini v·ªõi prompt: '{user_prompt_from_popup[:50]}...'")

        gemini_key = self.gemini_key_var.get()
        if not gemini_key:
            messagebox.showerror("Thi·∫øu API Key", "Vui l√≤ng c·∫•u h√¨nh Gemini API Key.", parent=self)
            return

        script_content = ""
        text_in_widget_before = ""
        if target_textbox_widget and target_textbox_widget.winfo_exists():
            text_in_widget_before = target_textbox_widget.get("1.0", "end-1c")
            temp_content = text_in_widget_before.strip()
            if not self._is_textbox_content_invalid_for_script(temp_content):
                script_content = temp_content

        # L∆∞u tr·∫°ng th√°i ƒë·ªÉ Ho√†n t√°c (Undo) v√† Vi·∫øt l·∫°i
        self.gemini_undo_buffer[context] = {"original_text": text_in_widget_before}
        self.last_gemini_parameters_used[context] = {
            "prompt": user_prompt_from_popup,
            "input_script_for_this_prompt": script_content
        }

        # C·∫≠p nh·∫≠t UI
        self.is_gemini_processing = True
        self.start_time = time.time()
        self.update_status(f"üíé Gemini ƒëang x·ª≠ l√Ω: '{user_prompt_from_popup[:30]}...'")
        self.update_time_realtime()

        # <<< S·ª¨A ·ªû ƒê√ÇY: V√¥ hi·ªáu h√≥a c√°c n√∫t h·ª£p nh·∫•t >>>
        if hasattr(self, 'ai_edit_button_sub_tab') and self.ai_edit_button_sub_tab.winfo_exists():
            self.ai_edit_button_sub_tab.configure(state="disabled", text="AI ƒêang ch·∫°y...")
        if hasattr(self, 'ai_edit_dub_script_button') and self.ai_edit_dub_script_button.winfo_exists():
            self.ai_edit_dub_script_button.configure(state="disabled", text="AI ƒêang ch·∫°y...")
        
        # B·∫Øt ƒë·∫ßu lu·ªìng
        thread = threading.Thread(
            target=self._execute_gemini_script_editing_thread,
            args=(script_content, user_prompt_from_popup, target_textbox_widget, context),
            daemon=True,
            name=f"GeminiEditThread_{context}"
        )
        thread.start()


    def _execute_gemini_script_editing_thread(self, script_content, user_instruction, target_widget, context):
        """
        H√†m worker (ch·∫°y trong lu·ªìng): G·ªçi API Gemini v√† x·ª≠ l√Ω ph·∫£n h·ªìi.
        ƒê√É N√ÇNG C·∫§P: Th√™m logic th·ª≠ l·∫°i (retry) khi g·∫∑p l·ªói gi·ªõi h·∫°n (Rate Limit).
        """
        # <<< DI CHUY·ªÇN IMPORT L√äN ƒê·∫¶U H√ÄM >>>
        import google.generativeai as genai
        from google.api_core import exceptions as google_exceptions

        log_prefix = f"[GeminiExec_v2:{context}]" # Th√™m v2 ƒë·ªÉ d·ªÖ theo d√µi
        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu x·ª≠ l√Ω k·ªãch b·∫£n v·ªõi Gemini...")

        processed_script = None
        error_message = None
        max_retries = 3 # Th·ª≠ l·∫°i t·ªëi ƒëa 3 l·∫ßn
        retry_delay_seconds = 20 # B·∫Øt ƒë·∫ßu ch·ªù 20 gi√¢y

        for attempt in range(max_retries + 1):
            if self.stop_event.is_set():
                error_message = "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng."
                logging.info(f"{log_prefix} Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán.")
                break

            try:
                gemini_api_key = self.gemini_key_var.get()
                if not gemini_api_key: # Ki·ªÉm tra key ·ªü ƒë√¢y
                    error_message = "L·ªói: Vui l√≤ng nh·∫≠p Gemini API Key."
                    break

                genai.configure(api_key=gemini_api_key)
                
                # T·ª± ƒë·ªông ch·ªçn model kh·∫£ d·ª•ng
                model = None
                model_names_to_try = ['gemini-1.5-pro', 'gemini-1.5-flash', 'gemini-pro', 'gemini-1.5-pro-latest']
                
                for model_name in model_names_to_try:
                    try:
                        # Ch·ªâ t·∫°o model, kh√¥ng test tr∆∞·ªõc (s·∫Ω test khi g·ªçi API th·ª±c t·∫ø)
                        model = genai.GenerativeModel(model_name)
                        logging.debug(f"{log_prefix} ƒê√£ ch·ªçn model: {model_name}")
                        break
                    except Exception as model_e:
                        logging.debug(f"{log_prefix} Model {model_name} kh√¥ng kh·∫£ d·ª•ng: {model_e}")
                        continue
                
                if not model:
                    # Fallback: th·ª≠ list_models v√† l·∫•y model ƒë·∫ßu ti√™n
                    try:
                        models = genai.list_models()
                        if models:
                            first_model_name = models[0].name.split('/')[-1] if '/' in models[0].name else models[0].name
                            model = genai.GenerativeModel(first_model_name)
                            logging.debug(f"{log_prefix} D√πng fallback model: {first_model_name}")
                        else:
                            raise Exception("Kh√¥ng t√¨m th·∫•y model n√†o kh·∫£ d·ª•ng.")
                    except Exception as fallback_e:
                        error_message = f"Kh√¥ng th·ªÉ t√¨m th·∫•y model Gemini kh·∫£ d·ª•ng. L·ªói: {fallback_e}"
                        logging.error(f"{log_prefix} {error_message}")
                        break

                # X√¢y d·ª±ng prompt
                action_type = "t·∫°o m·ªõi" if not script_content else "bi√™n t·∫≠p"
                prompt_parts = [
                    f"B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n {action_type} k·ªãch b·∫£n cho video. H√£y th·ª±c hi·ªán y√™u c·∫ßu sau: '{user_instruction}'.",
                    "QUAN TR·ªåNG: Ch·ªâ tr·∫£ v·ªÅ duy nh·∫•t n·ªôi dung k·ªãch b·∫£n ƒë√£ x·ª≠ l√Ω, kh√¥ng th√™m b·∫•t k·ª≥ l·ªùi d·∫´n, gi·∫£i th√≠ch hay ƒë·ªãnh d·∫°ng markdown n√†o."
                ]
                if script_content:
                    prompt_parts.append(f"\nN·ªôi dung k·ªãch b·∫£n g·ªëc ƒë·ªÉ bi√™n t·∫≠p:\n---\n{script_content}\n---")
                final_prompt = "\n".join(prompt_parts)

                logging.info(f"{log_prefix} (Th·ª≠ l·∫ßn {attempt + 1}/{max_retries + 1}) ƒêang g·ª≠i y√™u c·∫ßu ƒë·∫øn Gemini...")

                # G·ªçi API
                response = model.generate_content(final_prompt)

                if not response.parts:
                    block_reason = response.prompt_feedback.block_reason.name if response.prompt_feedback else "Kh√¥ng r√µ"
                    raise RuntimeError(f"Y√™u c·∫ßu ƒë√£ b·ªã ch·∫∑n b·ªüi b·ªô l·ªçc an to√†n c·ªßa Gemini (L√Ω do: {block_reason}).")

                processed_script = response.text
                logging.info(f"{log_prefix} Gemini ƒë√£ x·ª≠ l√Ω th√†nh c√¥ng.")
                error_message = None # Reset l·ªói n·∫øu th√†nh c√¥ng
                break # Tho√°t kh·ªèi v√≤ng l·∫∑p retry n·∫øu th√†nh c√¥ng

            except google_exceptions.ResourceExhausted as e:
                logging.warning(f"{log_prefix} (Th·ª≠ l·∫ßn {attempt + 1}) L·ªói ResourceExhausted (Rate Limit): {e}")
                if attempt < max_retries:
                    logging.info(f"{log_prefix} S·∫Ω th·ª≠ l·∫°i sau {retry_delay_seconds} gi√¢y...")
                    self.after(0, lambda d=retry_delay_seconds: self.update_status(f"üíé Gemini: ƒê√£ ƒë·∫°t gi·ªõi h·∫°n. Th·ª≠ l·∫°i sau {d} gi√¢y..."))
                    time.sleep(retry_delay_seconds)
                    retry_delay_seconds *= 2 # TƒÉng th·ªùi gian ch·ªù cho l·∫ßn th·ª≠ sau
                else:
                    error_message = f"L·ªói gi·ªõi h·∫°n (Rate Limit) sau {max_retries + 1} l·∫ßn th·ª≠. Vui l√≤ng ƒë·ª£i m·ªôt l√°t ho·∫∑c ki·ªÉm tra g√≥i c∆∞·ªõc c·ªßa b·∫°n."
            except Exception as e:
                error_message = f"L·ªói khi g·ªçi API Gemini: {type(e).__name__} - {e}"
                logging.error(f"{log_prefix} {error_message}", exc_info=True)
                break # Tho√°t v√≤ng l·∫∑p v·ªõi c√°c l·ªói kh√°c kh√¥ng ph·∫£i Rate Limit

        # G·ªçi h√†m callback tr√™n lu·ªìng ch√≠nh ƒë·ªÉ c·∫≠p nh·∫≠t UI
        self.after(0, self._handle_gemini_script_editing_result, processed_script, error_message, target_widget, context)

    def _handle_gemini_script_editing_result(self, processed_script, error_message, target_widget, context):
        """
        H√†m callback: C·∫≠p nh·∫≠t UI sau khi c√≥ k·∫øt qu·∫£ t·ª´ Gemini.
        ƒê√É S·ª¨A: T∆∞∆°ng t√°c v·ªõi c√°c n√∫t AI h·ª£p nh·∫•t.
        """
        log_prefix = f"[GeminiResult:{context}]"
        self.is_gemini_processing = False
        
        # Lu√¥n ki·ªÉm tra tr·∫°ng th√°i k√≠ch ho·∫°t c·ªßa app v√† key tr∆∞·ªõc khi b·∫≠t l·∫°i n√∫t
        is_app_active = self._is_app_fully_activated()
        
        if is_app_active:
            if hasattr(self, 'ai_edit_button_sub_tab') and self.ai_edit_button_sub_tab.winfo_exists():
                self.ai_edit_button_sub_tab.configure(state="normal", text="‚ú® Bi√™n t·∫≠p (AI)")
            if hasattr(self, 'ai_edit_dub_script_button') and self.ai_edit_dub_script_button.winfo_exists():
                self.ai_edit_dub_script_button.configure(state="normal", text="‚ú® Bi√™n t·∫≠p (AI)")

        # X·ª≠ l√Ω l·ªói v√† c·∫≠p nh·∫≠t textbox
        if error_message:
            logging.error(f"{log_prefix} X·ª≠ l√Ω th·∫•t b·∫°i: {error_message}")
            self.update_status(f"‚ùå L·ªói Gemini: {error_message[:60]}...")
            messagebox.showerror("L·ªói Gemini API", error_message, parent=self)
        elif processed_script is not None:
            logging.info(f"{log_prefix} X·ª≠ l√Ω th√†nh c√¥ng. C·∫≠p nh·∫≠t textbox.")
            if target_widget.winfo_exists():
                target_widget.configure(state="normal")
                target_widget.delete("1.0", "end")
                target_widget.insert("1.0", processed_script)
            self.update_status("‚úÖ Gemini ƒë√£ bi√™n t·∫≠p xong k·ªãch b·∫£n.")
            messagebox.showinfo("Ho√†n th√†nh", "Gemini ƒë√£ x·ª≠ l√Ω v√† c·∫≠p nh·∫≠t n·ªôi dung k·ªãch b·∫£n.", parent=self)
        else:
            logging.warning(f"{log_prefix} X·ª≠ l√Ω kh√¥ng th√†nh c√¥ng nh∆∞ng kh√¥ng c√≥ l·ªói c·ª• th·ªÉ.")
            self.update_status("‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ Gemini.")
            messagebox.showwarning("L·ªói", "Gemini kh√¥ng tr·∫£ v·ªÅ k·∫øt qu·∫£.", parent=self)

        # Reset timer n·∫øu kh√¥ng c√≥ t√°c v·ª• n√†o kh√°c ƒëang ch·∫°y
        self._check_completion_and_shutdown()

# ==========================================================================================================================================================================================

# =====================================================================
# H√ÄM POPUP AI HO√ÄN CH·ªàNH - PHI√äN B·∫¢N C·∫¨P NH·∫¨T CHO B∆Ø·ªöC 1
# =====================================================================
# <<< THAY TH·∫æ TO√ÄN B·ªò H√ÄM C≈® B·∫∞NG H√ÄM C·∫¨P NH·∫¨T N√ÄY >>>
    def _show_ai_script_editing_popup(self, target_textbox_widget, context="subtitle"):
        """
        Hi·ªÉn th·ªã m·ªôt c·ª≠a s·ªï popup duy nh·∫•t cho ph√©p ng∆∞·ªùi d√πng ch·ªçn engine AI,
        nh·∫≠p y√™u c·∫ßu, v√† t·ª± ƒë·ªông l∆∞u/t·∫£i l·∫°i c√°c c√†i ƒë·∫∑t cho t·ª´ng engine.
        >>> PHI√äN B·∫¢N M·ªöI: Th√™m logic ƒë·ªçc v√† s·∫Øp x·∫øp file cho ch·∫ø ƒë·ªô h√†ng lo·∫°t. <<<
        """
        SubtitleApp_instance = self
        log_popup_prefix = f"[AIPopup_v11_BatchLogic:{context}]"

        can_use_gpt = HAS_OPENAI and SubtitleApp_instance.openai_key_var.get()
        can_use_gemini = self.gemini_key_var.get()

        if not can_use_gpt and not can_use_gemini:
            messagebox.showerror("Thi·∫øu API Key", "Vui l√≤ng c·∫•u h√¨nh OpenAI ho·∫∑c Gemini API Key.", parent=self)
            return

        if hasattr(self, '_ai_edit_popup_active') and self._ai_edit_popup_active:
            if hasattr(self, '_ai_edit_popup_ref') and self._ai_edit_popup_ref.winfo_exists():
                self._ai_edit_popup_ref.focus()
                return

        self._ai_edit_popup_ref = ctk.CTkToplevel(self)
        popup = self._ai_edit_popup_ref
        self._ai_edit_popup_active = True
        
        popup_context_title = 'Ph·ª• ƒê·ªÅ' if context == 'subtitle' else 'Thuy·∫øt Minh'
        popup.title(f"‚ú® AI X·ª≠ L√Ω K·ªãch B·∫£n ({popup_context_title})")
        popup.geometry("620x650") 
        popup.resizable(False, False)
        popup.attributes("-topmost", True)
        popup.grab_set()

        try:
            popup.after(50, lambda: popup.geometry(f"+{self.winfo_x() + (self.winfo_width() // 2) - (popup.winfo_width() // 2)}+{self.winfo_y() + (self.winfo_height() // 2) - (popup.winfo_height() // 2)}"))
        except Exception as e_center:
            logging.warning(f"{log_popup_prefix} Kh√¥ng th·ªÉ cƒÉn gi·ªØa popup: {e_center}")

        popup_main_frame = ctk.CTkFrame(popup, fg_color="transparent")
        popup_main_frame.pack(expand=True, fill="both", padx=15, pady=15)
        popup_main_frame.grid_columnconfigure(0, weight=1)
        popup_main_frame.grid_rowconfigure(5, weight=1)

        ctk.CTkLabel(popup_main_frame, text="Ch·ªçn Engine AI:", font=("Poppins", 13, "bold")).grid(row=0, column=0, padx=5, pady=(0, 5), sticky="w")
        
        available_engines = []
        if can_use_gpt: available_engines.append("ü§ñ GPT")
        if can_use_gemini: available_engines.append("üíé Gemini")
        
        popup.ai_engine_selection_var = ctk.StringVar(value=self.cfg.get("last_used_ai_engine", available_engines[0]))

        engine_options_container = ctk.CTkFrame(popup_main_frame, fg_color="transparent")
        engine_options_container.grid(row=2, column=0, sticky="nsew", pady=(0, 5))
        engine_options_container.grid_columnconfigure(0, weight=1)

        gpt_options_frame = ctk.CTkFrame(engine_options_container, fg_color="transparent")
        gpt_model_row = ctk.CTkFrame(gpt_options_frame, fg_color="transparent")
        gpt_model_row.pack(fill="x", expand=True, pady=(0,5))
        gpt_model_row.grid_columnconfigure(1, weight=1)
        ctk.CTkLabel(gpt_model_row, text="Model GPT:", font=("Poppins", 13)).grid(row=0, column=0, padx=(0,5), pady=5, sticky="w")
        gpt_model_menu = ctk.CTkOptionMenu(gpt_model_row, variable=self.gpt_model_for_script_editing_var, values=self.AVAILABLE_GPT_MODELS_FOR_SCRIPT_EDITING)
        gpt_model_menu.grid(row=0, column=1, padx=(0,5), pady=5, sticky="ew")        
        gpt_checkbox_row = ctk.CTkFrame(gpt_options_frame, fg_color="transparent")
        gpt_checkbox_row.pack(fill="x", pady=(5,0))
        popup.dalle_slideshow_chain_var_popup = ctk.BooleanVar(value=self.cfg.get("gpt_chain_create_video_default", False))
        dalle_chain_checkbox = ctk.CTkCheckBox(gpt_checkbox_row, text="T·∫°o ·∫¢nh & Video (DALL-E)", variable=popup.dalle_slideshow_chain_var_popup, font=("Poppins", 12), command=lambda: _toggle_chain_to_dub_checkbox_state(popup.dalle_slideshow_chain_var_popup.get()))
        dalle_chain_checkbox.pack(side="left", padx=0)
        popup.chain_to_dubbing_var_popup = ctk.BooleanVar(value=self.cfg.get("gpt_chain_to_dubbing_default", False))
        popup.chain_to_dub_checkbox_ref = ctk.CTkCheckBox(gpt_checkbox_row, text="--> Ti·∫øp t·ª•c Thuy·∫øt Minh", variable=popup.chain_to_dubbing_var_popup, font=("Poppins", 12))
        popup.chain_to_dub_checkbox_ref.pack(side="left", padx=(10,0))

        gemini_options_frame = ctk.CTkFrame(engine_options_container, fg_color="transparent")
        gemini_model_row = ctk.CTkFrame(gemini_options_frame, fg_color="transparent")
        gemini_model_row.pack(fill="x", expand=True, pady=(0,5))
        gemini_model_row.grid_columnconfigure(1, weight=1)
        ctk.CTkLabel(gemini_model_row, text="Model Gemini:", font=("Poppins", 13)).grid(row=0, column=0, padx=(0,5), pady=5, sticky="w")
        gemini_model_menu = ctk.CTkOptionMenu(gemini_model_row, variable=self.gemini_model_for_script_editing_var, values=self.AVAILABLE_GEMINI_MODELS_FOR_SCRIPT_EDITING)
        gemini_model_menu.grid(row=0, column=1, padx=(0,5), pady=5, sticky="ew")
        gemini_checkbox_row = ctk.CTkFrame(gemini_options_frame, fg_color="transparent")
        gemini_checkbox_row.pack(fill="x", pady=(5,0))
        popup.imagen_slideshow_chain_var_popup = ctk.BooleanVar(value=self.cfg.get("gemini_chain_create_video_default", False))
        imagen_chain_checkbox = ctk.CTkCheckBox(gemini_checkbox_row, text="T·∫°o ·∫¢nh & Video (Imagen 3)", variable=popup.imagen_slideshow_chain_var_popup, font=("Poppins", 12), command=lambda: _toggle_chain_to_dub_checkbox_state_gemini(popup.imagen_slideshow_chain_var_popup.get()))
        imagen_chain_checkbox.pack(side="left", padx=0)
        popup.chain_to_dubbing_var_popup_gemini = ctk.BooleanVar(value=self.cfg.get("gemini_chain_to_dubbing_default", False))
        popup.chain_to_dub_checkbox_ref_gemini = ctk.CTkCheckBox(gemini_checkbox_row, text="--> Ti·∫øp t·ª•c Thuy·∫øt Minh", variable=popup.chain_to_dubbing_var_popup_gemini, font=("Poppins", 12))
        popup.chain_to_dub_checkbox_ref_gemini.pack(side="left", padx=(10, 0))

        batch_mode_frame = ctk.CTkFrame(popup_main_frame)
        batch_mode_frame.grid(row=3, column=0, sticky="ew", pady=(15, 5))
        batch_mode_frame.grid_columnconfigure(2, weight=1)
        popup.batch_mode_var = ctk.BooleanVar(value=self.cfg.get("batch_mode_last_state", False))
        popup.batch_folder_var = ctk.StringVar(value=self.cfg.get("batch_mode_last_folder", "Ch∆∞a ch·ªçn th∆∞ m·ª•c..."))

        def _select_batch_folder():
            initial_dir = self.cfg.get("batch_mode_last_folder") if os.path.isdir(self.cfg.get("batch_mode_last_folder", "")) else str(Path.home() / "Downloads")
            folder = filedialog.askdirectory(parent=popup, initialdir=initial_dir, title="Ch·ªçn th∆∞ m·ª•c ch·ª©a k·ªãch b·∫£n")
            if folder: popup.batch_folder_var.set(folder)

        def _on_toggle_batch_mode():
            is_batch_mode = popup.batch_mode_var.get()
            # K√≠ch ho·∫°t/V√¥ hi·ªáu h√≥a n√∫t ch·ªçn th∆∞ m·ª•c
            batch_folder_button.configure(state=ctk.NORMAL if is_batch_mode else ctk.DISABLED)
            
            # 1. Lu√¥n cho ph√©p nh·∫≠p v√†o √¥ prompt
            prompt_textbox_popup_local.configure(state=ctk.NORMAL) 
            
            # 2. Thay ƒë·ªïi label h∆∞·ªõng d·∫´n cho ph√π h·ª£p v·ªõi ng·ªØ c·∫£nh
            if is_batch_mode:
                prompt_label.configure(text="Nh·∫≠p y√™u c·∫ßu chung cho c·∫£ l√¥ (ƒë·ªÉ tr·ªëng n·∫øu mu·ªën gi·ªØ nguy√™n k·ªãch b·∫£n g·ªëc):", text_color=ctk.ThemeManager.theme["CTkLabel"]["text_color"])
                process_btn_popup_local.configure(text="B·∫Øt ƒë·∫ßu h√†ng lo·∫°t")
            else:
                prompt_label.configure(text="Nh·∫≠p y√™u c·∫ßu x·ª≠ l√Ω k·ªãch b·∫£n ƒë∆°n l·∫ª (ƒë·ªÉ tr·ªëng n·∫øu mu·ªën gi·ªØ nguy√™n k·ªãch b·∫£n g·ªëc textbox):", text_color=ctk.ThemeManager.theme["CTkLabel"]["text_color"])
                # G·ªçi l·∫°i h√†m c·∫≠p nh·∫≠t text n√∫t cho ch·∫ø ƒë·ªô ƒë∆°n l·∫ª
                _update_popup_for_engine(popup.ai_engine_selection_var.get())

        batch_mode_checkbox = ctk.CTkCheckBox(batch_mode_frame, text="X·ª≠ l√Ω h√†ng lo·∫°t t·ª´ th∆∞ m·ª•c", variable=popup.batch_mode_var, font=("Poppins", 12, "bold"), command=_on_toggle_batch_mode)
        batch_mode_checkbox.grid(row=0, column=0, padx=(5,10), pady=5, sticky="w")
        batch_folder_button = ctk.CTkButton(batch_mode_frame, text="Ch·ªçn th∆∞ m·ª•c...", width=120, command=_select_batch_folder)
        batch_folder_button.grid(row=0, column=1, padx=(0, 5), pady=5)
        batch_folder_label = ctk.CTkLabel(batch_mode_frame, textvariable=popup.batch_folder_var, text_color="gray", anchor="w", wraplength=250)
        batch_folder_label.grid(row=0, column=2, padx=(5,0), pady=5, sticky="ew")

        prompt_label = ctk.CTkLabel(popup_main_frame, text="Nh·∫≠p y√™u c·∫ßu x·ª≠ l√Ω k·ªãch b·∫£n ƒë∆°n l·∫ª (ƒë·ªÉ tr·ªëng n·∫øu mu·ªën gi·ªØ nguy√™n k·ªãch b·∫£n g·ªëc textbox):", font=("Poppins", 13, "normal"), wraplength=580)
        prompt_label.grid(row=4, column=0, sticky="w", pady=(10, 2))
        prompt_textbox_popup_local = ctk.CTkTextbox(popup_main_frame, font=("Segoe UI", 13), wrap="word", border_width=1, border_color="gray50", height=150)
        prompt_textbox_popup_local.grid(row=5, column=0, sticky="nsew", pady=(0, 15))
        prompt_textbox_popup_local.focus()
        prompt_textbox_popup_local.bind("<Button-3>", textbox_right_click_menu)

        action_buttons_row_frame = ctk.CTkFrame(popup_main_frame, fg_color="transparent")
        action_buttons_row_frame.grid(row=6, column=0, sticky="ew", pady=(10, 0))
        action_buttons_row_frame.grid_columnconfigure(0, weight=1)

        def _save_ai_popup_settings_on_close():
            selected_engine = popup.ai_engine_selection_var.get()
            self.cfg["last_used_ai_engine"] = selected_engine
            prompt_text = prompt_textbox_popup_local.get("1.0", "end-1c").strip()
            self.cfg["batch_mode_last_state"] = popup.batch_mode_var.get()
            self.cfg["batch_mode_last_folder"] = popup.batch_folder_var.get()
            if "GPT" in selected_engine:
                self.cfg[f"last_used_gpt_prompt_{context}"] = prompt_text
                self.cfg["gpt_model_for_script_editing"] = self.gpt_model_for_script_editing_var.get()
                self.cfg["gpt_chain_to_dubbing_default"] = popup.chain_to_dubbing_var_popup.get()
                self.cfg["gpt_chain_create_video_default"] = popup.dalle_slideshow_chain_var_popup.get()
            elif "Gemini" in selected_engine:
                self.cfg[f"last_used_gemini_prompt_{context}"] = prompt_text
                self.cfg["gemini_model_for_script_editing"] = self.gemini_model_for_script_editing_var.get()
                self.cfg["gemini_chain_to_dubbing_default"] = popup.chain_to_dubbing_var_popup_gemini.get()
                self.cfg["gemini_chain_create_video_default"] = popup.imagen_slideshow_chain_var_popup.get()
            self.save_current_config()
            logging.info(f"{log_popup_prefix} ƒê√£ l∆∞u c√†i ƒë·∫∑t cho engine {selected_engine}.")

        def _update_popup_for_engine(selected_engine_str):
            is_gpt = "GPT" in selected_engine_str
            gpt_options_frame.pack_forget()
            gemini_options_frame.pack_forget()
            if is_gpt:
                gpt_options_frame.pack(fill="x", expand=True)
                config_key = f"last_used_gpt_prompt_{context}"
                _toggle_chain_to_dub_checkbox_state(popup.dalle_slideshow_chain_var_popup.get())
            else:
                gemini_options_frame.pack(fill="x", expand=True)
                config_key = f"last_used_gemini_prompt_{context}"
                _toggle_chain_to_dub_checkbox_state_gemini(popup.imagen_slideshow_chain_var_popup.get())
            saved_prompt = self.cfg.get(config_key, "V√≠ d·ª•: S·ª≠a l·ªói ch√≠nh t·∫£ v√† l√†m cho vƒÉn phong t·ª± nhi√™n, tr√¥i ch·∫£y h∆°n.")
            prompt_textbox_popup_local.delete("1.0", "end")
            prompt_textbox_popup_local.insert("1.0", saved_prompt)
            if not popup.batch_mode_var.get():
                process_btn_popup_local.configure(text=f"{selected_engine_str} X·ª≠ l√Ω")
            undo_button_popup.configure(state=ctk.DISABLED)
            rewrite_button_popup.configure(state=ctk.DISABLED)
        
        ai_engine_selector = ctk.CTkSegmentedButton(
            popup_main_frame, variable=popup.ai_engine_selection_var, values=available_engines,
            command=_update_popup_for_engine, height=32, font=("Segoe UI", 13, "bold")
        )
        ai_engine_selector.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        
        def _toggle_chain_to_dub_checkbox_state(is_dalle_enabled):
            popup.chain_to_dub_checkbox_ref.configure(state=ctk.NORMAL if is_dalle_enabled else ctk.DISABLED)
            if not is_dalle_enabled: popup.chain_to_dubbing_var_popup.set(False)

        def _toggle_chain_to_dub_checkbox_state_gemini(is_imagen_enabled):
            popup.chain_to_dub_checkbox_ref_gemini.configure(state=ctk.NORMAL if is_imagen_enabled else ctk.DISABLED)
            if not is_imagen_enabled: popup.chain_to_dubbing_var_popup_gemini.set(False)

        def _on_popup_cancel_local():
            _save_ai_popup_settings_on_close()
            popup.destroy()
            self._ai_edit_popup_active = False

# THAY TH·∫æ TO√ÄN B·ªò H√ÄM N√ÄY B√äN TRONG _show_ai_script_editing_popup
        def _on_popup_process_main_prompt():
            _save_ai_popup_settings_on_close()

            is_batch_mode = popup.batch_mode_var.get()
            
            if is_batch_mode:
                folder_path = popup.batch_folder_var.get()
                if not os.path.isdir(folder_path):
                    messagebox.showwarning("L·ªói Th∆∞ m·ª•c", "Vui l√≤ng ch·ªçn m·ªôt th∆∞ m·ª•c h·ª£p l·ªá ch·ª©a k·ªãch b·∫£n.", parent=popup)
                    return

                file_queue = prepare_batch_queue(folder_path)
                
                if not file_queue:
                    messagebox.showwarning("Kh√¥ng T√¨m Th·∫•y File", "Kh√¥ng t√¨m th·∫•y file .srt ho·∫∑c .txt n√†o c√≥ ch·ª©a s·ªë th·ª© t·ª± trong th∆∞ m·ª•c ƒë√£ ch·ªçn.", parent=popup)
                    return
                
                batch_prompt = prompt_textbox_popup_local.get("1.0", "end-1c").strip()
                trigger_dubbing_for_batch = False
                selected_engine = popup.ai_engine_selection_var.get()
                if "Gemini" in selected_engine:
                    if popup.imagen_slideshow_chain_var_popup.get() and popup.chain_to_dubbing_var_popup_gemini.get():
                        trigger_dubbing_for_batch = True
                
                popup.destroy()
                self._ai_edit_popup_active = False
                
                self.start_ai_batch_processing(file_queue, batch_prompt, trigger_dubbing_for_batch)

            else:  # Ch·∫ø ƒë·ªô x·ª≠ l√Ω ƒë∆°n l·∫ª
                user_prompt = prompt_textbox_popup_local.get("1.0", "end-1c").strip()
                selected_engine = popup.ai_engine_selection_var.get()

                popup.destroy()
                self._ai_edit_popup_active = False

                ### B·∫ÆT ƒê·∫¶U CODE M·ªöI: T·∫†O "TH·∫∫ T√äN" (BASE_FILENAME)
                base_filename_for_chain = ""
                # ∆Øu ti√™n l·∫•y text t·ª´ √¥ k·ªãch b·∫£n ch√≠nh n·∫øu n√≥ h·ª£p l·ªá
                script_in_textbox = target_textbox_widget.get("1.0", "end-1c").strip()
                
                # Quy·∫øt ƒë·ªãnh ngu·ªìn text ƒë·ªÉ t·∫°o t√™n: k·ªãch b·∫£n trong √¥ ch√≠nh hay prompt ng∆∞·ªùi d√πng nh·∫≠p
                if not self._is_textbox_content_invalid_for_script(script_in_textbox):

                    # Lo·∫°i b·ªè timing v√† index TR∆Ø·ªöC KHI l·∫•y 50 k√Ω t·ª± ƒë·∫ßu
                    pure_dialogue = extract_dialogue_from_srt_string(script_in_textbox)
                    base_text_for_name = pure_dialogue
                else:
                    base_text_for_name = user_prompt

                if base_text_for_name:
                    # T·∫°o t√™n file an to√†n t·ª´ 50 k√Ω t·ª± ƒë·∫ßu ti√™n
                    base_filename_for_chain = create_safe_filename(base_text_for_name[:50], remove_accents=False)
                
                # Fallback n·∫øu t√™n v·∫´n r·ªóng (v√≠ d·ª•: text to√†n k√Ω t·ª± ƒë·∫∑c bi·ªát)
                if not base_filename_for_chain:
                    base_filename_for_chain = f"piu_single_task_{uuid.uuid4().hex[:6]}"
                
                logging.info(f"ƒêang t·∫°o 'th·∫ª t√™n' cho t√°c v·ª• ƒë∆°n l·∫ª: {base_filename_for_chain}")

                # LOGIC CH√çNH N·∫∞M ·ªû ƒê√ÇY
                if user_prompt:
                    # N·∫æU C√ì PROMPT TRONG POPUP -> D√ôNG AI T·∫†O/BI√äN T·∫¨P K·ªäCH B·∫¢N
                    logging.info(f"{log_popup_prefix} Ng∆∞·ªùi d√πng ƒë√£ nh·∫≠p prompt. B·∫Øt ƒë·∫ßu chu·ªói x·ª≠ l√Ω ƒë·∫ßy ƒë·ªß.")
                    if "GPT" in selected_engine:
                        trigger_dalle = popup.dalle_slideshow_chain_var_popup.get()
                        trigger_dub = popup.chain_to_dubbing_var_popup.get() if trigger_dalle else False
                        # <<< TH√äM base_filename_for_chain V√ÄO L·ªÜNH G·ªåI N√ÄY >>>
                        self._trigger_gpt_script_processing_from_popup(None, user_prompt, self.gpt_model_for_script_editing_var.get(),
                                                                       target_textbox_widget, context,
                                                                       trigger_dalle_chain_flag=trigger_dalle,
                                                                       trigger_dub_chain_flag=trigger_dub,
                                                                       base_filename_for_chain=base_filename_for_chain)
                    elif "Gemini" in selected_engine:
                        trigger_imagen = popup.imagen_slideshow_chain_var_popup.get()
                        trigger_dub_gemini = popup.chain_to_dubbing_var_popup_gemini.get() if trigger_imagen else False
                        # <<< TH√äM base_filename_for_chain V√ÄO L·ªÜNH G·ªåI N√ÄY >>>
                        self._trigger_gemini_script_processing_with_chain(target_textbox_widget, context, user_prompt,
                                                                          trigger_imagen_chain_flag=trigger_imagen,
                                                                          trigger_dub_chain_flag=trigger_dub_gemini,
                                                                          base_filename_for_chain=base_filename_for_chain)
                else:
                    # N·∫æU KH√îNG C√ì PROMPT TRONG POPUP -> B·ªé QUA B∆Ø·ªöC CAN THI·ªÜP K·ªäCH B·∫¢N C·ª¶A AI
                    logging.info(f"{log_popup_prefix} Ng∆∞·ªùi d√πng kh√¥ng nh·∫≠p prompt. B·ªè qua b∆∞·ªõc t·∫°o/s·ª≠a k·ªãch b·∫£n, s·ª≠ d·ª•ng k·ªãch b·∫£n hi·ªán c√≥.")
                    self.stop_event.clear()
                    self.is_gemini_processing = True 
                    self.start_time = time.time()
                    self.update_status("üíé S·ª≠ d·ª•ng k·ªãch b·∫£n g·ªëc, chu·∫©n b·ªã chia c·∫£nh...")
                    self.update_time_realtime()
                    self._set_subtitle_tab_ui_state(False)

                    original_input_script_from_textbox = ""
                    if target_textbox_widget and target_textbox_widget.winfo_exists():
                        original_input_script_from_textbox = target_textbox_widget.get("1.0", "end-1c").strip()
                    
                    if self._is_textbox_content_invalid_for_script(original_input_script_from_textbox):
                        messagebox.showwarning("Thi·∫øu K·ªãch B·∫£n", "√î prompt tr·ªëng v√† √¥ k·ªãch b·∫£n ch√≠nh c≈©ng kh√¥ng c√≥ n·ªôi dung h·ª£p l·ªá.\n\nVui l√≤ng d√°n k·ªãch b·∫£n v√†o √¥ ch√≠nh tr∆∞·ªõc khi ch·∫°y chu·ªói t·ª± ƒë·ªông.", parent=self)
                        self.is_gemini_processing = False
                        self._check_completion_and_shutdown()
                        return

                    processed_dialogue_only = extract_dialogue_from_srt_string(original_input_script_from_textbox)
                    
                    trigger_imagen = popup.imagen_slideshow_chain_var_popup.get()
                    trigger_dub_gemini = popup.chain_to_dubbing_var_popup_gemini.get() if trigger_imagen else False
                    selected_model = self.gemini_model_for_script_editing_var.get()
                    character_sheet_text = self.cfg.get("imagen_last_character_sheet", "")
                    
                    # <<< TH√äM base_filename_for_chain V√ÄO L·ªÜNH G·ªåI N√ÄY >>>
                    self._handle_gemini_script_editing_result_for_chain(
                        processed_script=processed_dialogue_only,
                        error_message=None,
                        target_widget=target_textbox_widget,
                        context="subtitle_skip_edit",
                        trigger_imagen_chain_flag=trigger_imagen,
                        trigger_dub_chain_flag=trigger_dub_gemini,
                        selected_model=selected_model,
                        original_input_script=original_input_script_from_textbox,
                        character_sheet_text=character_sheet_text,
                        base_filename_for_chain=base_filename_for_chain # <<< TH√äM V√ÄO ƒê√ÇY
                    )
        button_font_popup = ("Poppins", 13)
        button_height_popup = 36
        
        cancel_btn_popup_local = ctk.CTkButton(action_buttons_row_frame, text="H·ªßy", command=_on_popup_cancel_local, width=90, height=button_height_popup, font=button_font_popup)
        cancel_btn_popup_local.pack(side="right", padx=(5,0))
        process_btn_popup_local = ctk.CTkButton(action_buttons_row_frame, command=_on_popup_process_main_prompt, font=(button_font_popup[0], button_font_popup[1], "bold"), fg_color="#1f6aa5", width=150, height=button_height_popup)
        process_btn_popup_local.pack(side="right", padx=5)
        ctk.CTkLabel(action_buttons_row_frame, text="|", font=("Segoe UI", 22), text_color="gray50").pack(side="right", padx=8)
        rewrite_button_popup = ctk.CTkButton(action_buttons_row_frame, text="üîÑ Vi·∫øt l·∫°i", width=120, height=button_height_popup, font=button_font_popup)
        rewrite_button_popup.pack(side="right", padx=4)
        undo_button_popup = ctk.CTkButton(action_buttons_row_frame, text="‚Ü©Ô∏è Ho√†n t√°c", width=120, height=button_height_popup, font=button_font_popup)
        undo_button_popup.pack(side="right", padx=(0,4))

        popup.protocol("WM_DELETE_WINDOW", _on_popup_cancel_local)
        _update_popup_for_engine(popup.ai_engine_selection_var.get())
        
        _on_toggle_batch_mode()


# H√†m b·ªï tr·ª£ t√≠nh nƒÉng AI h√†ng lo·∫°t T√¨m t·∫•t c·∫£ c√°c file .srt v√† .txt trong m·ªôt th∆∞ m·ª•c,
# H√ÄM Chu·∫©n b·ªã v√† b·∫Øt ƒë·∫ßu qu√° tr√¨nh x·ª≠ l√Ω k·ªãch b·∫£n AI h√†ng lo·∫°t.
    def start_ai_batch_processing(self, file_queue, batch_prompt, trigger_dubbing_for_batch=False): # <<< TH√äM THAM S·ªê M·ªöI ·ªû ƒê√ÇY
        """
        Chu·∫©n b·ªã v√† b·∫Øt ƒë·∫ßu qu√° tr√¨nh x·ª≠ l√Ω k·ªãch b·∫£n AI h√†ng lo·∫°t.
        """
        self.files_for_chained_dubbing = []
        
        if self.is_ai_batch_processing:
            messagebox.showwarning("ƒêang b·∫≠n", "M·ªôt qu√° tr√¨nh x·ª≠ l√Ω AI h√†ng lo·∫°t kh√°c ƒëang ch·∫°y.", parent=self)
            return

        logging.info(f"--- B·∫ÆT ƒê·∫¶U X·ª¨ L√ù AI H√ÄNG LO·∫†T ---")
        logging.info(f"S·ªë l∆∞·ª£ng k·ªãch b·∫£n: {len(file_queue)}")
        logging.info(f"Prompt chung cho c·∫£ l√¥: '{batch_prompt}'")

        # Thi·∫øt l·∫≠p tr·∫°ng th√°i
        self.is_ai_batch_processing = True
        self.ai_batch_queue = file_queue
        self.ai_batch_current_prompt = batch_prompt
        self.ai_batch_trigger_dubbing = trigger_dubbing_for_batch # <<< TH√äM D√íNG N√ÄY ƒê·ªÇ L∆ØU L·∫†I
        self.stop_event.clear()

        # C·∫≠p nh·∫≠t giao di·ªán
        self.update_status(f"B·∫Øt ƒë·∫ßu l√¥ AI: {len(self.ai_batch_queue)} k·ªãch b·∫£n...")
        self._set_subtitle_tab_ui_state(True) # V√¥ hi·ªáu h√≥a c√°c n√∫t kh√¥ng c·∫ßn thi·∫øt
        
        # B·∫Øt ƒë·∫ßu x·ª≠ l√Ω file ƒë·∫ßu ti√™n trong h√†ng ch·ªù (h√†m n√†y s·∫Ω ƒë∆∞·ª£c t·∫°o ·ªü B∆∞·ªõc 4)
        self._process_next_ai_batch_item()


# H√†m n√†y l√† "b·ªô n√£o" c·ªßa quy tr√¨nh ai T·ª∞ ƒê·ªòNG
    def _process_next_ai_batch_item(self):
        """
        X·ª≠ l√Ω file k·ªãch b·∫£n ti·∫øp theo trong h√†ng ch·ªù.
        PHI√äN B·∫¢N S·ª¨A L·ªñI: C·∫≠p nh·∫≠t giao di·ªán h√†ng ch·ªù ngay l·∫≠p t·ª©c.
        """
        if self.stop_event.is_set():
            logging.warning("[AI Batch] Ph√°t hi·ªán y√™u c·∫ßu d·ª´ng. K·∫øt th√∫c l√¥ x·ª≠ l√Ω.")
            self._on_ai_batch_finished(stopped=True)
            return

        if not self.ai_batch_queue:
            logging.info("[AI Batch] H√†ng ch·ªù ƒë√£ x·ª≠ l√Ω h·∫øt. Ho√†n t·∫•t l√¥.")
            self._on_ai_batch_finished(stopped=False)
            return

        script_path = self.ai_batch_queue.pop(0) 
        
        # C·∫≠p nh·∫≠t bi·∫øn tr·∫°ng th√°i
        self.ai_batch_current_file = script_path 

        # Ra l·ªánh cho giao di·ªán v·∫Ω l·∫°i h√†ng ch·ªù ngay l·∫≠p t·ª©c ƒë·ªÉ hi·ªÉn th·ªã file ƒëang x·ª≠ l√Ω
        self.update_queue_display()

        logging.info(f"[AI Batch] ƒêang x·ª≠ l√Ω file ti·∫øp theo: {os.path.basename(script_path)}")
        self.update_status(f"L√¥ AI: ƒêang x·ª≠ l√Ω {os.path.basename(script_path)} ({len(self.ai_batch_queue)} c√≤n l·∫°i)...")

        try:
            with open(script_path, "r", encoding="utf-8-sig") as f:
                script_content = f.read()
            if not script_content.strip():
                logging.warning(f"File k·ªãch b·∫£n '{os.path.basename(script_path)}' r·ªóng. B·ªè qua file n√†y.")
                self.after(50, self._process_next_ai_batch_item)
                return
        except Exception as e:
            logging.error(f"L·ªói khi ƒë·ªçc file k·ªãch b·∫£n '{script_path}': {e}")
            messagebox.showerror("L·ªói ƒê·ªçc File", f"Kh√¥ng th·ªÉ ƒë·ªçc file: {os.path.basename(script_path)}\n\nL·ªói: {e}\n\n·ª®ng d·ª•ng s·∫Ω b·ªè qua file n√†y v√† ti·∫øp t·ª•c v·ªõi c√°c file c√≤n l·∫°i trong h√†ng ch·ªù.")
            self.after(50, self._process_next_ai_batch_item)
            return

        # L·∫•y c·ªù dubbing ƒë√£ ƒë∆∞·ª£c l∆∞u cho c·∫£ l√¥ t·ª´ self.ai_batch_trigger_dubbing
        should_trigger_dubbing_for_this_item = getattr(self, 'ai_batch_trigger_dubbing', False)
        logging.info(f"[AI Batch] Quy·∫øt ƒë·ªãnh cho m·ª•c n√†y: S·∫Ω ti·∫øp t·ª•c thuy·∫øt minh = {should_trigger_dubbing_for_this_item}")

        if self.ai_batch_current_prompt:
            logging.info(f"[AI Batch] C√≥ prompt. G·ªçi chu·ªói Gemini ƒë·ªÉ x·ª≠ l√Ω k·ªãch b·∫£n.")

            # <<< TH√äM 2 D√íNG N√ÄY ƒê·ªÇ T·∫†O "TH·∫∫ T√äN" T·ª™ T√äN FILE >>>
            base_name_from_script = os.path.splitext(os.path.basename(script_path))[0]
            logging.info(f"[AI Batch] ƒêang t·∫°o 'th·∫ª t√™n' cho file: {base_name_from_script}")

            subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
            self._trigger_gemini_script_processing_with_chain(
                target_textbox_widget=subtitle_textbox,
                context="subtitle_batch",
                user_prompt=self.ai_batch_current_prompt,
                trigger_imagen_chain_flag=True,
                trigger_dub_chain_flag=should_trigger_dubbing_for_this_item,
                input_script_override=script_content,
                base_filename_for_chain=base_name_from_script # <<< TRUY·ªÄN "TH·∫∫ T√äN" V√ÄO ƒê√ÇY
            )
        else:
            logging.info("[AI Batch] Kh√¥ng c√≥ prompt. B·ªè qua b∆∞·ªõc x·ª≠ l√Ω k·ªãch b·∫£n c·ªßa Gemini.")
            self.update_status(f"L√¥ AI: D√πng k·ªãch b·∫£n g·ªëc c·ªßa {os.path.basename(script_path)}...")
            
            self.is_gemini_processing = True 
            self.start_time = time.time()
            self.update_time_realtime()

            selected_model = self.gemini_model_for_script_editing_var.get()
            character_sheet_text = self.cfg.get("imagen_last_character_sheet", "")

            # <<< TH√äM 2 D√íNG N√ÄY ƒê·ªÇ T·∫†O "TH·∫∫ T√äN" CHO NH√ÅNH N√ÄY >>>
            base_name_from_script = os.path.splitext(os.path.basename(script_path))[0]
            logging.info(f"[AI Batch] ƒêang t·∫°o 'th·∫ª t√™n' (kh√¥ng prompt): {base_name_from_script}")

            self._handle_gemini_script_editing_result_for_chain(
                processed_script=script_content,
                error_message=None,
                target_widget=self.subtitle_textbox,
                context="subtitle_batch_skipped_edit",
                trigger_imagen_chain_flag=True,
                trigger_dub_chain_flag=should_trigger_dubbing_for_this_item,
                selected_model=selected_model,
                original_input_script=script_content,
                character_sheet_text=character_sheet_text,
                base_filename_for_chain=base_name_from_script # <<< TH√äM THAM S·ªê V√ÄO ƒê√ÇY
            )



# ƒê∆∞·ª£c g·ªçi khi t·∫•t c·∫£ c√°c t√°c v·ª• trong l√¥ AI ƒë√£ ho√†n th√†nh ho·∫∑c b·ªã ng∆∞·ªùi d√πng d·ª´ng
    def _on_ai_batch_finished(self, stopped=False):
        """
        ƒê∆∞·ª£c g·ªçi khi t·∫•t c·∫£ c√°c t√°c v·ª• trong l√¥ AI ƒë√£ ho√†n th√†nh ho·∫∑c b·ªã d·ª´ng.
        ƒê√¢y l√† ƒëi·ªÉm duy nh·∫•t ch·ªãu tr√°ch nhi·ªám reset tr·∫°ng th√°i cho l√¥ AI.
        """
        logging.info(f"--- K·∫æT TH√öC X·ª¨ L√ù AI H√ÄNG LO·∫†T (B·ªã d·ª´ng: {stopped}) ---")
        
        # Reset t·∫•t c·∫£ c√°c c·ªù v√† d·ªØ li·ªáu li√™n quan ƒë·∫øn l√¥ AI
        self.is_ai_batch_processing = False
        self.is_gemini_processing = False
        self.is_imagen_processing = False
        self.is_gpt_processing_script = False
        self.is_dalle_processing = False
        self.is_creating_slideshow = False
        self.is_subbing = False # ƒê·∫£m b·∫£o c·ªù sub c≈©ng ƒë∆∞·ª£c reset
        self.ai_batch_current_file = None 

        files_to_dub_after_batch = list(self.files_for_chained_dubbing)
        
        # self.ai_batch_queue s·∫Ω kh√¥ng x√≥a ·ªü ƒë√¢y, ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ th·∫•y c√°c file c√≤n l·∫°i
        self.files_for_chained_dubbing = []        
        
        # c√°c n√∫t ƒëi·ªÅu khi·ªÉn h√†ng ch·ªù s·∫Ω ƒë∆∞·ª£c k√≠ch ho·∫°t.
        self.update_queue_display()
    
        if not stopped and files_to_dub_after_batch:
            logging.info(f"L√¥ AI ho√†n t·∫•t. B·∫Øt ƒë·∫ßu chu·ªói l·ªìng ti·∫øng cho {len(files_to_dub_after_batch)} file.")
            self.update_status(f"‚úÖ L√¥ AI xong! Chu·∫©n b·ªã thuy·∫øt minh cho {len(files_to_dub_after_batch)} video...")
            self.after(500, self._initiate_chained_dubbing, files_to_dub_after_batch)
        else:
            if stopped:
                self.update_status("üõë L√¥ x·ª≠ l√Ω AI ƒë√£ b·ªã d·ª´ng.")
            else:
                self.update_status("‚úÖ Ho√†n t·∫•t t·∫•t c·∫£ c√°c t√°c v·ª• trong l√¥ AI!")
                messagebox.showinfo("Ho√†n Th√†nh L√¥", "ƒê√£ x·ª≠ l√Ω xong t·∫•t c·∫£ c√°c k·ªãch b·∫£n trong th∆∞ m·ª•c.", parent=self)
            
            self._set_subtitle_tab_ui_state(False)
            self._check_completion_and_shutdown()


#---------------------------------------------------------------------------------------
#H√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi b·ªüi n√∫t "B·∫Øt ƒë·∫ßu X·ª≠ l√Ω GPT trong popup.
    def _trigger_gpt_script_processing_from_popup(self, script_content_to_process_param, user_prompt, selected_model,
                                                  target_textbox_widget, calling_button_context,
                                                  trigger_dalle_chain_flag=False,
                                                  trigger_dub_chain_flag=False,
                                                  base_filename_for_chain=None): # <<< TH√äM V√ÄO ƒê√ÇY
        log_prefix = f"[GPTScriptTrigger:{calling_button_context}]"
        self.stop_event.clear()

        current_text_in_widget_at_trigger = ""
        if target_textbox_widget and target_textbox_widget.winfo_exists():
            current_text_in_widget_at_trigger = target_textbox_widget.get("1.0", "end-1c").strip()

        logging.debug(f"{log_prefix} DEBUG_TRIGGER: current_text_in_widget_at_trigger (stripped) = '{current_text_in_widget_at_trigger}'")

        actual_script_content_for_gpt = ""
        action_type_log = "t·∫°o m·ªõi"

        is_placeholder_content = False
        if calling_button_context == "subtitle":
            defined_placeholder = getattr(self, 'subtitle_textbox_placeholder', "###MISSING_SUB_PLACEHOLDER###").strip()
            logging.debug(f"{log_prefix} DEBUG_TRIGGER (subtitle): Comparing with placeholder: '{defined_placeholder}'")
            if current_text_in_widget_at_trigger == defined_placeholder or not current_text_in_widget_at_trigger.strip(): # Th√™m ki·ªÉm tra r·ªóng
                is_placeholder_content = True
                logging.debug(f"{log_prefix} Ph√°t hi·ªán placeholder ho·∫∑c r·ªóng trong subtitle_textbox.")
        elif calling_button_context == "dubbing":
            if self._is_textbox_content_invalid_for_script(current_text_in_widget_at_trigger):
                is_placeholder_content = True
                logging.debug(f"{log_prefix} Ph√°t hi·ªán placeholder/n·ªôi dung kh√¥ng h·ª£p l·ªá trong dub_script_textbox (theo _is_textbox_content_invalid_for_script).")

        if not is_placeholder_content and current_text_in_widget_at_trigger:
            actual_script_content_for_gpt = current_text_in_widget_at_trigger
            action_type_log = "bi√™n t·∫≠p"
        else:
            actual_script_content_for_gpt = ""
            action_type_log = "t·∫°o m·ªõi"

        logging.info(f"{log_prefix} K√≠ch ho·∫°t {action_type_log} script. Model: {selected_model}, Prompt: '{user_prompt[:50]}...'")
        logging.debug(f"{log_prefix} N·ªôi dung th·ª±c t·∫ø s·∫Ω g·ª≠i cho GPT (actual_script_content_for_gpt) l√†: '{actual_script_content_for_gpt[:100].replace(chr(10),' ')}...'")

        text_in_widget_before_gpt = ""
        if target_textbox_widget and target_textbox_widget.winfo_exists():
            text_in_widget_before_gpt = target_textbox_widget.get("1.0", "end-1c")

        self.gpt_undo_buffer[calling_button_context] = {
            "original_text": text_in_widget_before_gpt,
            "target_widget": target_textbox_widget
        }
        logging.info(f"{log_prefix} ƒê√£ l∆∞u tr·∫°ng th√°i Undo cho context '{calling_button_context}'.")

        self.last_gpt_parameters_used[calling_button_context] = {
            "prompt": user_prompt,
            "model": selected_model,
            "input_script_for_this_prompt": actual_script_content_for_gpt
        }
        logging.info(f"{log_prefix} ƒê√£ l∆∞u tham s·ªë (prompt, model, input_script) cho context '{calling_button_context}' ƒë·ªÉ Rewrite.")
        # <<< CODE L∆ØU PROMPT V√ÄO CONFIG >>>
        config_key_for_prompt = f"last_used_gpt_prompt_{calling_button_context}"
        self.cfg[config_key_for_prompt] = user_prompt # L∆∞u prompt v√†o self.cfg
        logging.info(f"{log_prefix} ƒê√£ c·∫≠p nh·∫≠t self.cfg['{config_key_for_prompt}'] v·ªõi prompt: '{user_prompt[:50]}...'")
        self.save_current_config() # G·ªçi h√†m l∆∞u to√†n b·ªô config ra file JSON

        # <<< S·ª¨A ·ªû ƒê√ÇY: V√¥ hi·ªáu h√≥a c√°c n√∫t h·ª£p nh·∫•t >>>
        if hasattr(self, 'ai_edit_button_sub_tab') and self.ai_edit_button_sub_tab.winfo_exists():
            self.ai_edit_button_sub_tab.configure(state="disabled", text="AI ƒêang ch·∫°y...")
        if hasattr(self, 'ai_edit_dub_script_button') and self.ai_edit_dub_script_button.winfo_exists():
            self.ai_edit_dub_script_button.configure(state="disabled", text="AI ƒêang ch·∫°y...")

        self.is_gpt_processing_script = True 
        self.start_time = time.time()      
        self._set_subtitle_tab_ui_state(subbing_active=False)        
        status_message_gpt_starts = f"ü§ñ GPT ({selected_model}) ƒëang x·ª≠ l√Ω..."
        self.update_status(status_message_gpt_starts)
        self.update_time_realtime()

        if target_textbox_widget and target_textbox_widget.winfo_exists():
            target_textbox_widget.configure(state="disabled")
            if calling_button_context == "subtitle":
                self.allow_edit_sub = False

        # T·∫°o v√† b·∫Øt ƒë·∫ßu lu·ªìng
        thread = threading.Thread(
            target=self._execute_gpt_script_editing_thread,
            args=(script_content_to_process, user_prompt, selected_model,
                  target_textbox_widget, calling_button_context,
                  trigger_dalle_chain_flag,
                  trigger_dub_chain_flag,
                  base_filename_for_chain),
            daemon=True,
            name=f"GPTScriptEditThread_{selected_model}_{calling_button_context}"
        )
        thread.start()


# H√†m logic ch√≠nh cho ch·ª©c nƒÉng bi√™n t·∫≠p GPT
    def _execute_gpt_script_editing_thread(self, script_content_to_process, user_instruction, selected_model,
                                           target_textbox_widget, calling_button_context,
                                           trigger_dalle_chain_flag=False,
                                           trigger_dub_chain_flag=False,
                                           base_filename_for_chain=None): 

        log_prefix = f"[GPTScriptExec:{selected_model}:{calling_button_context}]"

        action_type_log = "t·∫°o m·ªõi k·ªãch b·∫£n" if not script_content_to_process.strip() else "bi√™n t·∫≠p k·ªãch b·∫£n hi·ªán c√≥"
        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu {action_type_log}. Instruction: '{user_instruction[:50]}...'")
        
        processed_script_content = None
        error_message_detail = None # S·∫Ω ch·ª©a th√¥ng ƒëi·ªáp l·ªói chi ti·∫øt cho UI

        try:
            # Ki·ªÉm tra th∆∞ vi·ªán OpenAI v√† API Key (ƒë√£ ƒë∆∞·ª£c import v√† ki·ªÉm tra ·ªü c√°c b∆∞·ªõc tr∆∞·ªõc khi g·ªçi h√†m n√†y)
            if not HAS_OPENAI or OpenAI is None: # OpenAI n√™n l√† bi·∫øn global ƒë√£ import ho·∫∑c self.OpenAI n·∫øu b·∫°n g√°n n√≥
                error_message_detail = "L·ªói nghi√™m tr·ªçng: Th∆∞ vi·ªán OpenAI kh√¥ng kh·∫£ d·ª•ng (HAS_OPENAI=False)."
                logging.critical(f"{log_prefix} {error_message_detail}")
                self.after(0, self._handle_gpt_script_editing_result, None, error_message_detail, target_textbox_widget, calling_button_context)
                return

            api_key = self.openai_key_var.get()
            if not api_key:
                error_message_detail = "L·ªói c·∫•u h√¨nh: OpenAI API Key b·ªã thi·∫øu. Vui l√≤ng ki·ªÉm tra trong 'C√†i ƒë·∫∑t API Keys'."
                logging.error(f"{log_prefix} {error_message_detail}")
                self.after(0, self._handle_gpt_script_editing_result, None, error_message_detail, target_textbox_widget, calling_button_context)
                return

            # Kh·ªüi t·∫°o OpenAI client
            client = OpenAI(api_key=api_key, timeout=180.0) # Timeout 3 ph√∫t, c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh

            # --- X√¢y d·ª±ng Prompt cho GPT ---
            system_message_content = (
                "You are an AI assistant. Your task is to either generate new script content or edit existing script content based on the user's instructions. "
                "Return ONLY the resulting script content. Do not add any introductory phrases (e.g., 'Here is the edited script:'), concluding remarks, "
                "or explanations about your actions, unless the user's instruction explicitly asks for them. "
                "If generating new content, structure it clearly, often with each distinct idea or dialogue on a new line or new paragraph as appropriate for a script. "
                "If editing existing content, try to preserve the general structure (like line breaks between dialogue blocks) unless the instruction implies changes to structure (e.g., 'merge short sentences')."
            )
            
            user_message_content_parts = [f"User Instruction: \"{user_instruction}\"\n"]

            if script_content_to_process.strip(): # N·∫øu c√≥ n·ªôi dung hi·ªán t·∫°i ƒë·ªÉ bi√™n t·∫≠p
                user_message_content_parts.append(
                    f"\nPlease apply this instruction to the following existing script content. "
                    f"Remember to return only the modified script text.\n\n"
                    f"--- EXISTING SCRIPT CONTENT START ---\n"
                    f"{script_content_to_process}\n"
                    f"--- EXISTING SCRIPT CONTENT END ---\n\n"
                    f"Processed Script Content:"
                )
            else: # N·∫øu kh√¥ng c√≥ n·ªôi dung -> y√™u c·∫ßu t·∫°o m·ªõi
                user_message_content_parts.append(
                    f"\nPlease generate the script content based on the instruction above. "
                    f"Remember to return only the generated script text.\n\n"
                    f"Generated Script Content:"
                )
            
            user_message_content = "".join(user_message_content_parts)
            
            # Logging chi ti·∫øt (c√≥ th·ªÉ b·∫≠t/t·∫Øt khi debug)
            # logging.debug(f"{log_prefix} System message: {system_message_content}")
            # log_user_instruction_part = f"User Instruction: \"{user_instruction[:100]}{'...' if len(user_instruction) > 100 else ''}\""
            # log_script_content_part = f"Script Content to Process (first 100 chars): \"{script_content_to_process[:100].replace(chr(10), ' ')}{'...' if len(script_content_to_process) > 100 else ''}\""
            # logging.debug(f"{log_prefix} User message constructed with: {log_user_instruction_part} and {log_script_content_part}")

            # <<<--- B·∫ÆT ƒê·∫¶U TH√äM CHO B∆Ø·ªöC 2.1 ---<<<
            if self.stop_event.is_set():
                raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng tr∆∞·ªõc khi g·ªçi API GPT Bi√™n T·∫≠p.")
            
            # G·ªçi API OpenAI
            logging.info(f"{log_prefix} ƒêang g·ª≠i y√™u c·∫ßu ƒë·∫øn model '{selected_model}'...")
            response = client.chat.completions.create(
                model=selected_model, 
                messages=[
                    {"role": "system", "content": system_message_content},
                    {"role": "user", "content": user_message_content}
                ],
                temperature=0.5, # Nhi·ªát ƒë·ªô cho s·ª± c√¢n b·∫±ng gi·ªØa s√°ng t·∫°o v√† ch√≠nh x√°c
                                 # C√≥ th·ªÉ tƒÉng l√™n 0.5-0.7 n·∫øu mu·ªën "s√°ng t·∫°o" h∆°n khi t·∫°o m·ªõi.
                # max_tokens: Th∆∞·ªùng OpenAI t·ª± qu·∫£n l√Ω t·ªët. N·∫øu c·∫ßn, b·∫°n c√≥ th·ªÉ ∆∞·ªõc l∆∞·ª£ng:
                # max_tokens_estimate = int(len(script_content_to_process) * 2.0) + int(len(user_instruction) * 1.5) + 300 
                # max_tokens = max(1000, max_tokens_estimate) # ƒê·∫£m b·∫£o t·ªëi thi·ªÉu 1000 tokens
            )
            
            processed_script_content = response.choices[0].message.content.strip()
            # Ghi log m·ªôt ph·∫ßn k·∫øt qu·∫£ ƒë·ªÉ ki·ªÉm tra
            logging.info(f"{log_prefix} GPT ƒë√£ x·ª≠ l√Ω xong. ƒê·ªô d√†i output: {len(processed_script_content)} chars.")
            logging.debug(f"{log_prefix} Output (first 100 chars): '{processed_script_content[:100].replace(chr(10), ' ')}...'")

        # X·ª≠ l√Ω c√°c l·ªói c·ª• th·ªÉ c·ªßa OpenAI API
        except RateLimitError as e_rate:
            error_message_detail = f"L·ªói Gi·ªõi h·∫°n Y√™u c·∫ßu (Rate Limit) t·ª´ OpenAI. Vui l√≤ng th·ª≠ l·∫°i sau m·ªôt kho·∫£ng th·ªùi gian. Chi ti·∫øt: {str(e_rate)}"
            logging.warning(f"{log_prefix} {error_message_detail}")
        except AuthenticationError as e_auth:
            error_message_detail = f"L·ªói X√°c th·ª±c OpenAI: API Key c·ªßa b·∫°n kh√¥ng h·ª£p l·ªá, h·∫øt h·∫°n, ho·∫∑c kh√¥ng c√≥ ƒë·ªß quy·ªÅn. Vui l√≤ng ki·ªÉm tra l·∫°i. Chi ti·∫øt: {str(e_auth)}"
            logging.error(f"{log_prefix} {error_message_detail}")
        except APIConnectionError as e_conn:
            error_message_detail = f"L·ªói K·∫øt n·ªëi ƒë·∫øn server OpenAI: Kh√¥ng th·ªÉ thi·∫øt l·∫≠p k·∫øt n·ªëi. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng c·ªßa b·∫°n. Chi ti·∫øt: {str(e_conn)}"
            logging.error(f"{log_prefix} {error_message_detail}")
        except APITimeoutError as e_timeout:
            error_message_detail = f"L·ªói Timeout v·ªõi OpenAI: Y√™u c·∫ßu x·ª≠ l√Ω m·∫•t qu√° nhi·ªÅu th·ªùi gian v√† ƒë√£ b·ªã ng·∫Øt. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c chia nh·ªè y√™u c·∫ßu n·∫øu k·ªãch b·∫£n qu√° d√†i. Chi ti·∫øt: {str(e_timeout)}"
            logging.error(f"{log_prefix} {error_message_detail}")
        except APIStatusError as e_status: # C√°c l·ªói tr·∫°ng th√°i kh√°c t·ª´ API
            status_code = e_status.status_code if hasattr(e_status, 'status_code') else 'N/A'
            err_msg_from_api = e_status.message if hasattr(e_status, 'message') else str(e_status)
            error_message_detail = f"L·ªói t·ª´ API OpenAI (M√£ tr·∫°ng th√°i: {status_code}): {err_msg_from_api}"
            logging.error(f"{log_prefix} {error_message_detail}")
        except ImportError: # Tr∆∞·ªùng h·ª£p HAS_OPENAI=True nh∆∞ng import OpenAI trong h√†m n√†y b·ªã l·ªói (hi·∫øm)
             error_message_detail = "L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ import th∆∞ vi·ªán OpenAI b√™n trong lu·ªìng x·ª≠ l√Ω."
             logging.critical(f"{log_prefix} {error_message_detail}")
        # <<<--- B·∫ÆT ƒê·∫¶U TH√äM CHO B∆Ø·ªöC 3.1 ---<<<
        except InterruptedError as ie:
            error_message_detail = f"ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng."
            logging.warning(f"{log_prefix} T√°c v·ª• GPT Bi√™n T·∫≠p b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng: {ie}")
        # <<<--- K·∫æT TH√öC TH√äM CHO B∆Ø·ªöC 3.1 ---<<<
        except Exception as e_general: # B·∫Øt c√°c l·ªói kh√¥ng mong mu·ªën kh√°c
            error_message_detail = f"L·ªói kh√¥ng mong mu·ªën trong qu√° tr√¨nh x·ª≠ l√Ω k·ªãch b·∫£n v·ªõi GPT: {type(e_general).__name__} - {str(e_general)}"
            logging.error(f"{log_prefix} {error_message_detail}", exc_info=True)

        # G·ªçi h√†m callback tr√™n lu·ªìng ch√≠nh ƒë·ªÉ c·∫≠p nh·∫≠t UI
        self.after(0, self._handle_gpt_script_editing_result,
                   processed_script_content,
                   error_message_detail,
                   target_textbox_widget,
                   calling_button_context,
                   trigger_dalle_chain_flag,
                   trigger_dub_chain_flag,
                   base_filename_for_chain) # <<< TH√äM V√ÄO ƒê√ÇY


# H√†m ho√†n t√°c n·ªôi dung trong texbox
    def _perform_undo_gpt_edit(self, target_textbox_widget, context, popup_window):
        """
        Ho√†n t√°c l·∫°i n·ªôi dung c·ªßa target_textbox_widget v·ªÅ tr·∫°ng th√°i
        tr∆∞·ªõc khi l·∫ßn x·ª≠ l√Ω GPT g·∫ßn nh·∫•t cho context n√†y ƒë∆∞·ª£c th·ª±c hi·ªán.
        popup_window: Tham chi·∫øu ƒë·∫øn c·ª≠a s·ªï popup ƒë·ªÉ c√≥ th·ªÉ ƒë√≥ng n√≥.
        """
        log_prefix = f"[GPTUndo:{context}]"
        logging.info(f"{log_prefix} Y√™u c·∫ßu ho√†n t√°c.")

        if not target_textbox_widget or not target_textbox_widget.winfo_exists():
            logging.error(f"{log_prefix} Textbox m·ª•c ti√™u kh√¥ng t·ªìn t·∫°i ƒë·ªÉ ho√†n t√°c.")
            if popup_window and popup_window.winfo_exists(): popup_window.destroy()
            self._gpt_edit_popup_active = False
            self._gpt_edit_popup_ref = None
            return

        undo_data = self.gpt_undo_buffer.get(context)

        if undo_data and "original_text" in undo_data:
            original_content = undo_data["original_text"]
            
            try:
                target_textbox_widget.configure(state="normal")
                target_textbox_widget.delete("1.0", "end")
                target_textbox_widget.insert("1.0", original_content)
                
                if context == "subtitle":
                    self.allow_edit_sub = True
                
                # Quan tr·ªçng: X√≥a b·ªô ƒë·ªám ho√†n t√°c cho context n√†y sau khi ƒë√£ d√πng.
                del self.gpt_undo_buffer[context]
                
                # ƒê·ªÉ ƒë∆°n gi·∫£n, ta c≈©ng c√≥ th·ªÉ x√≥a last_gpt_parameters_used cho context n√†y.
                if context in self.last_gpt_parameters_used:
                    del self.last_gpt_parameters_used[context]
                    logging.info(f"{log_prefix} ƒê√£ x√≥a last_gpt_parameters_used cho context '{context}'.")

                self.update_status(f"‚Ü©Ô∏è ƒê√£ ho√†n t√°c n·ªôi dung k·ªãch b·∫£n ({context}).")
                logging.info(f"{log_prefix} Ho√†n t√°c th√†nh c√¥ng. N·ªôi dung textbox ƒë∆∞·ª£c kh√¥i ph·ª•c.")
                messagebox.showinfo("Ho√†n t√°c", f"ƒê√£ ho√†n t√°c l·∫°i n·ªôi dung k·ªãch b·∫£n ({context}).", parent=self) # parent=self ƒë·ªÉ hi·ªán tr√™n c·ª≠a s·ªï ch√≠nh

            except Exception as e:
                logging.error(f"{log_prefix} L·ªói khi c·∫≠p nh·∫≠t textbox trong l√∫c ho√†n t√°c: {e}")
                messagebox.showerror("L·ªói Ho√†n T√°c", f"Kh√¥ng th·ªÉ ho√†n t√°c n·ªôi dung: {e}", parent=self)
        else:
            logging.warning(f"{log_prefix} Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ ho√†n t√°c cho context '{context}'.")
            messagebox.showwarning("Kh√¥ng th·ªÉ Ho√†n t√°c", "Kh√¥ng c√≥ tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥ ƒë·ªÉ ho√†n t√°c.", parent=self)

        # ƒê√≥ng popup sau khi th·ª±c hi·ªán
        if popup_window and popup_window.winfo_exists():
            popup_window.destroy()
        self._gpt_edit_popup_active = False
        self._gpt_edit_popup_ref = None
                
        # N·∫øu l√† tab dubbing, parse l·∫°i n·ªôi dung ƒë√£ ho√†n t√°c
        if context == "dubbing" and target_textbox_widget and target_textbox_widget.winfo_exists():
            content_after_undo = target_textbox_widget.get("1.0", "end-1c")
            logging.info(f"{log_prefix} N·ªôi dung dub_script_textbox sau ho√†n t√°c. ƒêang parse l·∫°i...")
            self.dub_current_script_path_for_queue_temp = "text_input" 
            parsed_data_after_undo = self._parse_plain_text_to_srt_data(content_after_undo)
            if parsed_data_after_undo:
                self.dub_temp_srt_data_for_queue = parsed_data_after_undo
                logging.info(f"{log_prefix} ƒê√£ parse l·∫°i {len(self.dub_temp_srt_data_for_queue)} m·ª•c sau ho√†n t√°c.")
            else:
                self.dub_temp_srt_data_for_queue = []
                logging.warning(f"{log_prefix} Kh√¥ng parse ƒë∆∞·ª£c m·ª•c SRT n√†o sau ho√†n t√°c.")
            self._update_dub_script_controls_state()


# H√†m y√™u c·∫ßu GPT vi·∫øt l·∫°i k·ªãch b·∫£n
    def _perform_rewrite_with_last_params(self, target_textbox_widget, context, popup_window):
        """
        Y√™u c·∫ßu GPT x·ª≠ l√Ω l·∫°i k·ªãch b·∫£n b·∫±ng c√°ch s·ª≠ d·ª•ng prompt, model,
        v√† N·ªòI DUNG ƒê·∫¶U V√ÄO G·ªêC c·ªßa l·∫ßn x·ª≠ l√Ω GPT th√†nh c√¥ng tr∆∞·ªõc ƒë√≥ cho context n√†y.
        popup_window: Tham chi·∫øu ƒë·∫øn c·ª≠a s·ªï popup ƒë·ªÉ c√≥ th·ªÉ ƒë√≥ng n√≥.
        """
        log_prefix = f"[GPTRewrite:{context}]"
        logging.info(f"{log_prefix} Y√™u c·∫ßu vi·∫øt l·∫°i v·ªõi tham s·ªë c≈©.")

        if not target_textbox_widget or not target_textbox_widget.winfo_exists():
            logging.error(f"{log_prefix} Textbox m·ª•c ti√™u kh√¥ng t·ªìn t·∫°i cho Rewrite.")
            if popup_window and popup_window.winfo_exists(): popup_window.destroy()
            self._gpt_edit_popup_active = False
            self._gpt_edit_popup_ref = None
            return

        last_params = self.last_gpt_parameters_used.get(context)

        if last_params and \
           "prompt" in last_params and \
           "model" in last_params and \
           "input_script_for_this_prompt" in last_params:
            
            last_prompt = last_params["prompt"]
            last_model = last_params["model"]
            # ƒê√¢y l√† n·ªôi dung ƒë√£ ƒë∆∞·ª£c ƒë∆∞a cho GPT x·ª≠ l√Ω trong l·∫ßn ch·∫°y m√† prompt v√† model n√†y ƒë∆∞·ª£c d√πng.
            # N·∫øu ng∆∞·ªùi d√πng nh·∫•n "Vi·∫øt l·∫°i", ch√∫ng ta mu·ªën GPT th·ª≠ l·∫°i tr√™n CH√çNH N·ªòI DUNG N√ÄY.
            script_to_rewrite = last_params["input_script_for_this_prompt"] 

            logging.info(f"{log_prefix} S·∫Ω vi·∫øt l·∫°i v·ªõi Model: {last_model}, Prompt: '{last_prompt[:50]}...'")
            logging.debug(f"{log_prefix} N·ªôi dung g·ªëc s·∫Ω ƒë∆∞·ª£c ƒë∆∞a cho GPT ƒë·ªÉ vi·∫øt l·∫°i (input_script_for_this_prompt): '{script_to_rewrite[:100].replace(chr(10),' ')}...'")

            # ƒê√≥ng popup tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu x·ª≠ l√Ω
            if popup_window and popup_window.winfo_exists():
                popup_window.destroy()
            self._gpt_edit_popup_active = False
            self._gpt_edit_popup_ref = None

            self._trigger_gpt_script_processing_from_popup(
                script_content_to_process=script_to_rewrite, # ƒê∆∞a n·ªôi dung G·ªêC c·ªßa l·∫ßn tr∆∞·ªõc cho GPT x·ª≠ l√Ω l·∫°i
                user_prompt=last_prompt,                     # D√πng l·∫°i prompt c≈©
                selected_model=last_model,                   # D√πng l·∫°i model c≈©
                target_textbox_widget=target_textbox_widget,
                calling_button_context=context
            )
        else:
            logging.warning(f"{log_prefix} Kh√¥ng c√≥ tham s·ªë ƒë√£ l∆∞u cho context '{context}' ƒë·ªÉ vi·∫øt l·∫°i.")
            messagebox.showwarning("Kh√¥ng th·ªÉ Vi·∫øt l·∫°i", 
                                   "Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ l·∫ßn x·ª≠ l√Ω GPT tr∆∞·ªõc ƒë√≥ ƒë·ªÉ th·ª±c hi·ªán vi·∫øt l·∫°i.", 
                                   parent=popup_window if popup_window and popup_window.winfo_exists() else self)
            # Kh√¥ng ƒë√≥ng popup n·∫øu l·ªói n√†y x·∫£y ra, ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ ch·ªçn h√†nh ƒë·ªông kh√°c


#  H√†m m·ªõi ƒë·ªÉ y√™u c·∫ßu GPT chia k·ªãch b·∫£n v√† t·∫°o DALL-E prompts
    def _execute_gpt_scene_division_thread(self,
                                           script_content_for_gpt_analysis, # Script ƒë·ªÉ GPT ph√¢n t√≠ch (c√≥ th·ªÉ l√† SRT)
                                           num_images_to_generate,
                                           selected_gpt_model,
                                           original_plain_gpt_text_for_dub, # Text thu·∫ßn g·ªëc t·ª´ GPT
                                           original_gpt_context,
                                           original_target_widget,
                                           original_trigger_dub_chain_flag):
        """
        Ch·∫°y trong lu·ªìng: G·ªçi GPT ƒë·ªÉ chia k·ªãch b·∫£n (t·ª´ script_content_for_gpt_analysis)
        th√†nh c√°c ph√¢n c·∫£nh v√† t·∫°o ra c√°c DALL-E prompt t∆∞∆°ng ·ª©ng.
        original_plain_gpt_text_for_dub l√† text thu·∫ßn g·ªëc t·ª´ GPT, ƒë∆∞·ª£c truy·ªÅn qua ƒë·ªÉ d√πng cho b∆∞·ªõc thuy·∫øt minh sau n√†y.
        """
        worker_log_prefix = f"[GPT_SceneDivision_{selected_gpt_model}]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu chia k·ªãch b·∫£n (input: '{script_content_for_gpt_analysis[:50].replace(chr(10),' ')}...') v√† t·∫°o {num_images_to_generate} DALL-E prompts.") #
        logging.info(f"{worker_log_prefix}   Plain text g·ªëc ƒëi k√®m (cho dub): '{original_plain_gpt_text_for_dub[:50].replace(chr(10),' ')}...'") #

        list_of_dalle_prompts = [] #
        error_message_division = None #

        try:
            if not HAS_OPENAI or OpenAI is None: #
                error_message_division = "L·ªói nghi√™m tr·ªçng: Th∆∞ vi·ªán OpenAI kh√¥ng kh·∫£ d·ª•ng." #
                logging.critical(f"{worker_log_prefix} {error_message_division}") #
                # Kh√¥ng g·ªçi self.after ·ªü ƒë√¢y n·ªØa, kh·ªëi finally s·∫Ω x·ª≠ l√Ω
                return # Tho√°t s·ªõm n·∫øu thi·∫øu th∆∞ vi·ªán c∆° b·∫£n

            api_key = self.openai_key_var.get() #
            if not api_key: #
                error_message_division = "L·ªói c·∫•u h√¨nh: OpenAI API Key b·ªã thi·∫øu." #
                logging.error(f"{worker_log_prefix} {error_message_division}") #
                return # Tho√°t s·ªõm

            client = OpenAI(api_key=api_key, timeout=180.0) #

            # --- C·∫¨P NH·∫¨T SYSTEM MESSAGE ---
            system_message_content = (
                "B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n ph√¢n t√≠ch k·ªãch b·∫£n v√† t·∫°o m√¥ t·∫£ h√¨nh ·∫£nh an to√†n, ph√π h·ª£p v·ªõi m·ªçi ƒë·ªëi t∆∞·ª£ng, v·ªõi m·ª•c ti√™u t·∫°o ra h√¨nh ·∫£nh ch√¢n th·ª±c v√† s·∫Øc n√©t. "
                "Nhi·ªám v·ª• c·ªßa b·∫°n l√† ƒë·ªçc hi·ªÉu k·ªãch b·∫£n ƒë∆∞·ª£c cung c·∫•p, sau ƒë√≥ chia n√≥ th√†nh m·ªôt s·ªë l∆∞·ª£ng ph√¢n c·∫£nh ho·∫∑c kho·∫£nh kh·∫Øc quan tr·ªçng ƒë√£ ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh. "
                "V·ªõi m·ªói ph√¢n c·∫£nh, b·∫°n ph·∫£i t·∫°o ra m·ªôt prompt m√¥ t·∫£ h√¨nh ·∫£nh ng·∫Øn g·ªçn, s√∫c t√≠ch (b·∫±ng ti·∫øng Anh, t·ªëi ƒëa kho·∫£ng 40-60 t·ª´) ph√π h·ª£p cho m·ªôt AI t·∫°o h√¨nh ·∫£nh nh∆∞ DALL-E. "
                "M·ªói prompt DALL-E n√™n t·∫≠p trung n·∫Øm b·∫Øt ƒë∆∞·ª£c b·∫£n ch·∫•t h√¨nh ·∫£nh c·ªßa ph√¢n c·∫£nh t∆∞∆°ng ·ª©ng: b·ªëi c·∫£nh, ngo·∫°i h√¨nh/h√†nh ƒë·ªông n·ªïi b·∫≠t c·ªßa nh√¢n v·∫≠t (n·∫øu c√≥), ƒë·ªëi t∆∞·ª£ng quan tr·ªçng, v√† kh√¥ng kh√≠/c·∫£m x√∫c c·ªßa c·∫£nh. "

                # --- H∆Ø·ªöNG D·∫™N PHONG C√ÅCH M·ªöI ---
                "QUAN TR·ªåNG V·ªÄ PHONG C√ÅCH ·∫¢NH: "
                "1. ∆Øu ti√™n phong c√°ch T·∫¢ TH·ª∞C, CHI TI·∫æT CAO, nh∆∞ ·∫£nh ch·ª•p ch·∫•t l∆∞·ª£ng cao ho·∫∑c render 3D ƒëi·ªán ·∫£nh. H√¨nh ·∫£nh c·∫ßn S·∫ÆC N√âT, R√ï R√ÄNG, v·ªõi nhi·ªÅu chi ti·∫øt tinh x·∫£o. "
                "2. TR·ª™ KHI K·ªäCH B·∫¢N G·ªêC Y√äU C·∫¶U R√ï R√ÄNG m·ªôt phong c√°ch kh√°c (v√≠ d·ª•: 'ho·∫°t h√¨nh', 'anime', 'tranh v·∫Ω'), h√£y M·∫∂C ƒê·ªäNH h∆∞·ªõng t·ªõi phong c√°ch CH√ÇN TH·ª∞C 3D. H·∫°n ch·∫ø t·ªëi ƒëa vi·ªác t·∫°o ra c√°c prompt g·ª£i √Ω tranh v·∫Ω 2D, ho·∫°t h√¨nh, ho·∫∑c anime n·∫øu kh√¥ng ƒë∆∞·ª£c y√™u c·∫ßu c·ª• th·ªÉ. "
                "3. ƒê·ªÉ ƒë·∫°t ƒë∆∞·ª£c ƒëi·ªÅu n√†y, h√£y c√¢n nh·∫Øc s·ª≠ d·ª•ng c√°c t·ª´ kh√≥a m√¥ t·∫£ phong c√°ch trong c√°c DALL-E prompt (b·∫±ng ti·∫øng Anh) nh∆∞: 'photorealistic', 'hyperrealistic', 'highly detailed', 'sharp focus', '3D render', 'cinematic lighting', 'Unreal Engine 5 style', 'V-Ray render', 'octane render', 'detailed skin texture', 'intricate details', 'professional photography', '8K resolution' (DALL-E s·∫Ω hi·ªÉu √Ω ƒë·ªì v·ªÅ ƒë·ªô chi ti·∫øt, d√π n√≥ kh√¥ng th·ª±c s·ª± render 8K). "
                # --- K·∫æT TH√öC H∆Ø·ªöNG D·∫™N PHONG C√ÅCH M·ªöI ---

                "QUAN TR·ªåNG V·ªÄ AN TO√ÄN N·ªòI DUNG: T·∫•t c·∫£ c√°c prompt DALL-E ph·∫£i TU√ÇN TH·ª¶ NGHI√äM NG·∫∂T ch√≠nh s√°ch n·ªôi dung c·ªßa OpenAI. "
                "TR√ÅNH TUY·ªÜT ƒê·ªêI c√°c m√¥ t·∫£ c√≥ th·ªÉ b·ªã coi l√† b·∫°o l·ª±c, ng∆∞·ªùi l·ªõn, th√π ƒë·ªãch, t·ª± h·∫°i, ho·∫∑c l·ª´a ƒë·∫£o. ∆Øu ti√™n s·ª± an to√†n v√† t√≠ch c·ª±c. "
                "Kh√¥ng m√¥ t·∫£ c√°c h√†nh ƒë·ªông c·ª• th·ªÉ c√≥ th·ªÉ b·ªã c·∫•m (v√≠ d·ª•: s·ª≠ d·ª•ng v≈© kh√≠, h√†nh vi nguy hi·ªÉm r√µ r√†ng). Thay v√†o ƒë√≥, h√£y t·∫≠p trung v√†o c·∫£m x√∫c, b·ªëi c·∫£nh v√† c√°c y·∫øu t·ªë h√¨nh ·∫£nh trung t√≠nh. "
                "TR√ÅNH ƒë∆∞a l·ªùi tho·∫°i, t√™n nh√¢n v·∫≠t ƒëang n√≥i, ho·∫∑c c√°c y·∫øu t·ªë kh√¥ng ph·∫£i l√† m√¥ t·∫£ h√¨nh ·∫£nh thu·∫ßn t√∫y v√†o prompt DALL-E. "
                "N·∫øu k·ªãch b·∫£n g·ªëc kh√¥ng ph·∫£i ti·∫øng Anh, h√£y d·ªãch c√°c y·∫øu t·ªë h√¨nh ·∫£nh quan tr·ªçng sang ti·∫øng Anh cho c√°c DALL-E prompt, ƒë·ªìng th·ªùi ƒë·∫£m b·∫£o t√≠nh an to√†n v√† phong c√°ch ch√¢n th·ª±c c·ªßa n·ªôi dung ƒë√£ d·ªãch. "
                "ƒê·∫∂C BI·ªÜT L∆ØU √ù: C√°c prompt DALL-E m√† b·∫°n t·∫°o ra ph·∫£i h∆∞·ªõng d·∫´n DALL-E KH√îNG ƒê∆Ø·ª¢C VI·∫æT B·∫§T K·ª≤ CH·ªÆ, K√ù T·ª∞, HAY VƒÇN B·∫¢N n√†o l√™n h√¨nh ·∫£nh ƒë∆∞·ª£c t·∫°o ra. H√¨nh ·∫£nh cu·ªëi c√πng ph·∫£i ho√†n to√†n kh√¥ng c√≥ ch·ªØ. N·∫øu c·∫ßn, h√£y th√™m c√°c c·ª•m t·ª´ nh∆∞ 'no text', 'text-free', 'image only, no writing', 'avoid typography', 'typography-free' v√†o cu·ªëi m·ªói DALL-E prompt ƒë·ªÉ nh·∫•n m·∫°nh y√™u c·∫ßu n√†y."
            )
            
            user_message_content = (
                f"D∆∞·ªõi ƒë√¢y l√† m·ªôt k·ªãch b·∫£n:\n\n"
                f"```script\n{script_content_for_gpt_analysis}\n```\n\n"  # << S·ª¨A ·ªû ƒê√ÇY: s·ª≠ d·ª•ng script_content_for_gpt_analysis
                f"D·ª±a v√†o k·ªãch b·∫£n tr√™n, h√£y chia n√≥ th√†nh ƒë√∫ng {num_images_to_generate} ph√¢n c·∫£nh ho·∫∑c kho·∫£nh kh·∫Øc h√¨nh ·∫£nh quan tr·ªçng. " #
                f"Sau ƒë√≥, v·ªõi m·ªói ph√¢n c·∫£nh, h√£y t·∫°o m·ªôt prompt b·∫±ng ti·∫øng Anh ƒë·ªÉ DALL-E v·∫Ω ·∫£nh minh h·ªça. " #
                f"Y√™u c·∫ßu quan tr·ªçng: Ch·ªâ tr·∫£ v·ªÅ {num_images_to_generate} prompt DALL-E n√†y, m·ªói prompt tr√™n m·ªôt d√≤ng m·ªõi. " #
                f"Kh√¥ng th√™m b·∫•t k·ª≥ gi·∫£i th√≠ch, ƒë√°nh s·ªë, hay ƒë·ªãnh d·∫°ng n√†o kh√°c ngo√†i c√°c d√≤ng prompt n√†y." #
            )

            # <<<--- B·∫ÆT ƒê·∫¶U TH√äM CHO B∆Ø·ªöC 2.2 ---<<<
            if self.stop_event.is_set():
                raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng tr∆∞·ªõc khi g·ªçi API GPT Chia C·∫£nh.")
            # <<<--- K·∫æT TH√öC TH√äM CHO B∆Ø·ªöC 2.2 ---<<<            
            logging.info(f"{worker_log_prefix} ƒêang g·ª≠i y√™u c·∫ßu ƒë·∫øn model '{selected_gpt_model}' ƒë·ªÉ t·∫°o {num_images_to_generate} DALL-E prompts...") #
            
            response = client.chat.completions.create( #
                model=selected_gpt_model, #
                messages=[ #
                    {"role": "system", "content": system_message_content}, #
                    {"role": "user", "content": user_message_content} #
                ],
                temperature=0.5, #
            )
            
            gpt_response_content = response.choices[0].message.content.strip() #
            logging.info(f"{worker_log_prefix} GPT ƒë√£ ph·∫£n h·ªìi. N·ªôi dung (r√∫t g·ªçn): '{gpt_response_content[:200].replace(chr(10), ' // ')}...'") #

            raw_prompts = gpt_response_content.splitlines() #
            for p_line in raw_prompts: #
                p_line_stripped = p_line.strip() #
                if p_line_stripped: #
                    list_of_dalle_prompts.append(p_line_stripped) #
            
            if not list_of_dalle_prompts: #
                error_message_division = "GPT kh√¥ng tr·∫£ v·ªÅ DALL-E prompt n√†o ho·∫∑c ƒë·ªãnh d·∫°ng kh√¥ng ƒë√∫ng." #
                logging.warning(f"{worker_log_prefix} {error_message_division}. Ph·∫£n h·ªìi g·ªëc: {gpt_response_content}") #
            elif len(list_of_dalle_prompts) != num_images_to_generate: #
                logging.warning(f"{worker_log_prefix} GPT tr·∫£ v·ªÅ {len(list_of_dalle_prompts)} prompts, nh∆∞ng y√™u c·∫ßu l√† {num_images_to_generate}. S·∫Ω c·ªë g·∫Øng s·ª≠ d·ª•ng c√°c prompt c√≥ ƒë∆∞·ª£c.") #

            logging.info(f"{worker_log_prefix} ƒê√£ tr√≠ch xu·∫•t ƒë∆∞·ª£c {len(list_of_dalle_prompts)} DALL-E prompt(s).") #

        except RateLimitError as e_rate: #
            error_message_division = f"L·ªói Gi·ªõi h·∫°n Y√™u c·∫ßu (Rate Limit) t·ª´ OpenAI khi t·∫°o DALL-E prompts. Chi ti·∫øt: {str(e_rate)}" #
            logging.warning(f"{worker_log_prefix} {error_message_division}") #
        except AuthenticationError as e_auth: #
            error_message_division = f"L·ªói X√°c th·ª±c OpenAI khi t·∫°o DALL-E prompts: API Key kh√¥ng h·ª£p l·ªá/h·∫øt h·∫°n. Chi ti·∫øt: {str(e_auth)}" #
            logging.error(f"{worker_log_prefix} {error_message_division}") #
        except APIConnectionError as e_conn: #
            error_message_division = f"L·ªói K·∫øt n·ªëi ƒë·∫øn server OpenAI khi t·∫°o DALL-E prompts. Chi ti·∫øt: {str(e_conn)}" #
            logging.error(f"{worker_log_prefix} {error_message_division}") #
        except APITimeoutError as e_timeout: #
            error_message_division = f"L·ªói Timeout v·ªõi OpenAI khi t·∫°o DALL-E prompts. Chi ti·∫øt: {str(e_timeout)}" #
            logging.error(f"{worker_log_prefix} {error_message_division}") #
        except APIStatusError as e_status: #
            status_code = e_status.status_code if hasattr(e_status, 'status_code') else 'N/A' #
            err_msg_from_api = e_status.message if hasattr(e_status, 'message') else str(e_status) #
            error_message_division = f"L·ªói t·ª´ API OpenAI (M√£ tr·∫°ng th√°i: {status_code}) khi t·∫°o DALL-E prompts: {err_msg_from_api}" #
            logging.error(f"{worker_log_prefix} {error_message_division}") #
        except Exception as e_general: # Ngo·∫°i l·ªá n√†y s·∫Ω b·∫Øt NameError n·∫øu v·∫´n c√≤n
            error_message_division = f"L·ªói kh√¥ng mong mu·ªën khi GPT chia c·∫£nh: {type(e_general).__name__} - {str(e_general)}" #
            logging.error(f"{worker_log_prefix} {error_message_division}", exc_info=True) #

        finally:
            # G·ªçi h√†m callback tr√™n lu·ªìng ch√≠nh ƒë·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£
            # Truy·ªÅn original_plain_gpt_text_for_dub thay cho original_processed_script c≈©
            # v√† script_content_for_gpt_analysis (l√† script ƒë√£ d√πng ƒë·ªÉ chia c·∫£nh)
            self.after(0, self._handle_gpt_scene_division_result, #
                       list_of_dalle_prompts if list_of_dalle_prompts else None,  #
                       error_message_division, #
                       script_content_for_gpt_analysis,    # Script ƒë√£ d√πng ƒë·ªÉ chia c·∫£nh (c√≥ th·ªÉ l√† SRT ho·∫∑c plain text)
                       original_plain_gpt_text_for_dub,    # Text thu·∫ßn g·ªëc t·ª´ GPT
                       original_gpt_context,  #
                       original_target_widget,  #
                       original_trigger_dub_chain_flag) #
            logging.debug(f"{worker_log_prefix} ƒê√£ l√™n l·ªãch callback _handle_gpt_scene_division_result.") #


# H√†m n√†y s·∫Ω ƒë∆°n gi·∫£n l√† l·∫•y s·ªë l∆∞·ª£ng ·∫£nh mong mu·ªën
    def _initiate_gpt_scene_division(self,
                                     script_for_scene_division, # Script d√πng ƒë·ªÉ GPT chia c·∫£nh (c√≥ th·ªÉ l√† SRT)
                                     original_plain_gpt_text_for_dub,   # Text thu·∫ßn g·ªëc t·ª´ GPT
                                     gpt_context,
                                     target_widget,
                                     trigger_dub_chain_flag):
        try:
            # ƒê·ªçc c√°c c√†i ƒë·∫∑t DALL-E t·ª´ config (ƒë√£ ƒë∆∞·ª£c l∆∞u b·ªüi DalleSettingsWindow)
            is_cost_saver_mode_dalle = self.cfg.get("dalle_cost_saver_mode", False)
            num_images_requested_by_user = int(self.cfg.get("dalle_num_images_setting", 1))
            num_images_requested_by_user = max(1, num_images_requested_by_user) # ƒê·∫£m b·∫£o √≠t nh·∫•t l√† 1

            model_for_gpt_processing = self.gpt_model_for_script_editing_var.get()
            if not model_for_gpt_processing:
                model_for_gpt_processing = "gpt-3.5-turbo" # Fallback

            logging.info(f"[GPT_SceneDivision_Init] B·∫Øt ƒë·∫ßu. CostSaverMode: {is_cost_saver_mode_dalle}, S·ªë ·∫£nh User mu·ªën: {num_images_requested_by_user}")
            logging.info(f"[GPT_SceneDivision_Init]   Script cho ph√¢n t√≠ch/chia c·∫£nh (n·∫øu kh√¥ng ph·∫£i cost saver): '{script_for_scene_division[:50].replace(chr(10),' ')}...'")
            logging.info(f"[GPT_SceneDivision_Init]   Plain text g·ªëc (cho t√≥m t·∫Øt n·∫øu cost saver, ho·∫∑c ƒë·ªÉ truy·ªÅn ƒëi cho dub): '{original_plain_gpt_text_for_dub[:50].replace(chr(10),' ')}...'")

            if is_cost_saver_mode_dalle:
                logging.info(f"[GPT_SceneDivision_Init] Ch·∫ø ƒë·ªô Ti·∫øt ki·ªám chi ph√≠ DALL-E B·∫¨T. S·∫Ω t·∫°o 1 prompt DALL-E chung t·ª´ t√≥m t·∫Øt.")
                # G·ªçi h√†m m·ªõi ƒë·ªÉ t·∫°o prompt t√≥m t·∫Øt (s·∫Ω t·∫°o h√†m n√†y ·ªü b∆∞·ªõc sau)
                thread = threading.Thread(
                    target=self._execute_gpt_single_summary_prompt_thread, # << H√ÄM M·ªöI S·∫º T·∫†O
                    args=(original_plain_gpt_text_for_dub, # D√πng text thu·∫ßn g·ªëc ƒë·ªÉ GPT t√≥m t·∫Øt
                          model_for_gpt_processing,
                          # C√°c tham s·ªë n√†y v·∫´n c·∫ßn ƒë∆∞·ª£c truy·ªÅn cho callback _handle_gpt_scene_division_result
                          script_for_scene_division,       # V·∫´n truy·ªÅn script n√†y (c√≥ th·ªÉ l√† SRT) ƒë·ªÉ d√πng cho slideshow timing sau n√†y
                          original_plain_gpt_text_for_dub, # Truy·ªÅn l·∫°i plain text g·ªëc cho c√°c b∆∞·ªõc sau n·ªØa
                          gpt_context,
                          target_widget,
                          trigger_dub_chain_flag),
                    daemon=True,
                    name=f"GPTSingleSummaryPromptThread_{model_for_gpt_processing}"
                )
                thread.start()
            else: # Ch·∫ø ƒë·ªô Ti·∫øt ki·ªám chi ph√≠ T·∫ÆT, ho·∫°t ƒë·ªông nh∆∞ c≈©
                logging.info(f"[GPT_SceneDivision_Init] Ch·∫ø ƒë·ªô Ti·∫øt ki·ªám chi ph√≠ DALL-E T·∫ÆT. S·∫Ω chia k·ªãch b·∫£n th√†nh {num_images_requested_by_user} c·∫£nh/prompts.")
                thread = threading.Thread(
                    target=self._execute_gpt_scene_division_thread, # H√†m c≈©
                    args=(script_for_scene_division,             # Script ƒë·ªÉ GPT ph√¢n t√≠ch chia c·∫£nh
                          num_images_requested_by_user,         # S·ªë l∆∞·ª£ng prompt DALL-E mong mu·ªën (b·∫±ng s·ªë ·∫£nh)
                          model_for_gpt_processing,
                          original_plain_gpt_text_for_dub,      # Text thu·∫ßn g·ªëc v·∫´n ƒë∆∞·ª£c truy·ªÅn ƒëi
                          gpt_context,
                          target_widget,
                          trigger_dub_chain_flag),
                    daemon=True,
                    name=f"GPTSceneDivisionThread_{model_for_gpt_processing}"
                )
                thread.start()

        except Exception as e_init_scene_division:
            logging.error(f"L·ªói khi kh·ªüi t·∫°o lu·ªìng chia c·∫£nh/t√≥m t·∫Øt GPT cho DALL-E: {e_init_scene_division}", exc_info=True)
            self.update_status(f"‚ùå L·ªói chu·∫©n b·ªã prompt DALL-E: {e_init_scene_division}")
            # Reset UI (t∆∞∆°ng t·ª± nh∆∞ trong h√†m g·ªëc c·ªßa b·∫°n)
            button_to_enable = None; button_text_default = "ü§ñ GPT"
            if gpt_context == "subtitle":
                if hasattr(self, 'gpt_edit_script_button_main_tab'): button_to_enable = self.gpt_edit_script_button_main_tab
            elif gpt_context == "dubbing":
                if hasattr(self, 'gpt_edit_dub_script_button'): button_to_enable = self.gpt_edit_dub_script_button
            if button_to_enable and button_to_enable.winfo_exists():
                button_to_enable.configure(state=ctk.NORMAL, text=button_text_default)
            if hasattr(self, 'is_gpt_processing_script'): self.is_gpt_processing_script = False



# H√†m G·ªçi API c·ªßa GPT v·ªõi m·ªôt prompt y√™u c·∫ßu GPT t√≥m t·∫Øt vƒÉn b·∫£n ƒë√≥ v√† t·∫°o ra m·ªôt prompt DALL-E duy nh·∫•t, t·ªïng qu√°t, an to√†n cho to√†n b·ªô k·ªãch b·∫£n.
    def _execute_gpt_single_summary_prompt_thread(self,
                                                  original_plain_script_text, # Text thu·∫ßn ƒë·ªÉ GPT t√≥m t·∫Øt
                                                  selected_gpt_model,
                                                  # C√°c tham s·ªë n√†y ƒë∆∞·ª£c truy·ªÅn th·∫≥ng cho callback
                                                  script_for_slideshow_timing_callback, # L√† script_for_scene_division t·ª´ h√†m g·ªçi
                                                  original_plain_gpt_text_for_dub_callback, # L√† original_plain_gpt_text_for_dub t·ª´ h√†m g·ªçi
                                                  original_gpt_context_callback,
                                                  original_target_widget_callback,
                                                  original_trigger_dub_chain_flag_callback):
        """
        Ch·∫°y trong lu·ªìng: G·ªçi GPT ƒë·ªÉ t√≥m t·∫Øt k·ªãch b·∫£n v√† t·∫°o M·ªòT prompt DALL-E chung.
        """
        worker_log_prefix = f"[GPTSingleSummaryPrompt_{selected_gpt_model}]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu t√≥m t·∫Øt v√† t·∫°o 1 prompt DALL-E chung t·ª´ plain text (d√†i {len(original_plain_script_text)} chars): '{original_plain_script_text[:50].replace(chr(10),' ')}...'")

        single_dalle_prompt = None
        error_message_summary = None

        try:
            if not HAS_OPENAI or OpenAI is None:
                error_message_summary = "L·ªói nghi√™m tr·ªçng: Th∆∞ vi·ªán OpenAI kh√¥ng kh·∫£ d·ª•ng (cho t√≥m t·∫Øt)."
                logging.critical(f"{worker_log_prefix} {error_message_summary}")
                # Callback s·∫Ω ƒë∆∞·ª£c g·ªçi trong finally
                return

            api_key = self.openai_key_var.get()
            if not api_key:
                error_message_summary = "L·ªói c·∫•u h√¨nh: OpenAI API Key b·ªã thi·∫øu (cho t√≥m t·∫Øt)."
                logging.error(f"{worker_log_prefix} {error_message_summary}")
                return # Callback s·∫Ω ƒë∆∞·ª£c g·ªçi trong finally

            client = OpenAI(api_key=api_key, timeout=180.0) # Timeout 3 ph√∫t

            system_message_content = (
                "B·∫°n l√† m·ªôt tr·ª£ l√Ω AI xu·∫•t s·∫Øc trong vi·ªác t√≥m t·∫Øt n·ªôi dung vƒÉn b·∫£n v√† t·∫°o m√¥ t·∫£ h√¨nh ·∫£nh an to√†n, t·ªïng qu√°t, ph√π h·ª£p v·ªõi m·ªçi ƒë·ªëi t∆∞·ª£ng, v·ªõi m·ª•c ti√™u t·∫°o ra h√¨nh ·∫£nh ch√¢n th·ª±c v√† s·∫Øc n√©t. "
                "Nhi·ªám v·ª• c·ªßa b·∫°n l√† ƒë·ªçc hi·ªÉu to√†n b·ªô k·ªãch b·∫£n ƒë∆∞·ª£c cung c·∫•p, t√≥m t·∫Øt √Ω ch√≠nh c·ªßa n√≥, v√† sau ƒë√≥ t·∫°o ra M·ªòT prompt DALL-E DUY NH·∫§T (b·∫±ng ti·∫øng Anh, ng·∫Øn g·ªçn, s√∫c t√≠ch, t·ªëi ƒëa kho·∫£ng 40-60 t·ª´). "
                "Prompt DALL-E n√†y ph·∫£i mang t√≠nh ƒë·∫°i di·ªán cho to√†n b·ªô c√¢u chuy·ªán ho·∫∑c ch·ªß ƒë·ªÅ ch√≠nh c·ªßa k·ªãch b·∫£n, ph√π h·ª£p ƒë·ªÉ t·∫°o m·ªôt h√¨nh ·∫£nh minh h·ªça chung. "

                # --- H∆Ø·ªöNG D·∫™N PHONG C√ÅCH M·ªöI ---
                "QUAN TR·ªåNG V·ªÄ PHONG C√ÅCH ·∫¢NH: "
                "1. ∆Øu ti√™n phong c√°ch T·∫¢ TH·ª∞C, CHI TI·∫æT CAO, nh∆∞ ·∫£nh ch·ª•p ch·∫•t l∆∞·ª£ng cao ho·∫∑c render 3D ƒëi·ªán ·∫£nh. H√¨nh ·∫£nh c·∫ßn S·∫ÆC N√âT, R√ï R√ÄNG, v·ªõi nhi·ªÅu chi ti·∫øt tinh x·∫£o. "
                "2. TR·ª™ KHI K·ªäCH B·∫¢N G·ªêC Y√äU C·∫¶U R√ï R√ÄNG m·ªôt phong c√°ch kh√°c (v√≠ d·ª•: 'ho·∫°t h√¨nh', 'anime', 'tranh v·∫Ω'), h√£y M·∫∂C ƒê·ªäNH h∆∞·ªõng t·ªõi phong c√°ch CH√ÇN TH·ª∞C 3D. H·∫°n ch·∫ø t·ªëi ƒëa vi·ªác t·∫°o ra c√°c prompt g·ª£i √Ω tranh v·∫Ω 2D, ho·∫°t h√¨nh, ho·∫∑c anime n·∫øu kh√¥ng ƒë∆∞·ª£c y√™u c·∫ßu c·ª• th·ªÉ. "
                "3. ƒê·ªÉ ƒë·∫°t ƒë∆∞·ª£c ƒëi·ªÅu n√†y, h√£y c√¢n nh·∫Øc s·ª≠ d·ª•ng c√°c t·ª´ kh√≥a m√¥ t·∫£ phong c√°ch trong DALL-E prompt (b·∫±ng ti·∫øng Anh) nh∆∞: 'photorealistic', 'hyperrealistic', 'highly detailed', 'sharp focus', '3D render', 'cinematic lighting', 'Unreal Engine 5 style', 'V-Ray render', 'octane render', 'detailed skin texture', 'intricate details', 'professional photography', '8K resolution' (DALL-E s·∫Ω hi·ªÉu √Ω ƒë·ªì v·ªÅ ƒë·ªô chi ti·∫øt). "
                # --- K·∫æT TH√öC H∆Ø·ªöNG D·∫™N PHONG C√ÅCH M·ªöI ---

                "QUAN TR·ªåNG V·ªÄ AN TO√ÄN N·ªòI DUNG: Prompt DALL-E ph·∫£i TU√ÇN TH·ª¶ NGHI√äM NG·∫∂T ch√≠nh s√°ch n·ªôi dung c·ªßa OpenAI. "
                "TR√ÅNH TUY·ªÜT ƒê·ªêI c√°c m√¥ t·∫£ c√≥ th·ªÉ b·ªã coi l√† b·∫°o l·ª±c, ng∆∞·ªùi l·ªõn, th√π ƒë·ªãch, t·ª± h·∫°i, ho·∫∑c l·ª´a ƒë·∫£o. ∆Øu ti√™n s·ª± an to√†n v√† t√≠ch c·ª±c. "
                "Kh√¥ng m√¥ t·∫£ c√°c h√†nh ƒë·ªông c·ª• th·ªÉ c√≥ th·ªÉ b·ªã c·∫•m. T·∫≠p trung v√†o c·∫£m x√∫c, b·ªëi c·∫£nh t·ªïng th·ªÉ, v√† c√°c y·∫øu t·ªë h√¨nh ·∫£nh trung t√≠nh. "
                "N·∫øu k·ªãch b·∫£n g·ªëc kh√¥ng ph·∫£i ti·∫øng Anh, h√£y d·ªãch c√°c y·∫øu t·ªë h√¨nh ·∫£nh quan tr·ªçng sang ti·∫øng Anh cho prompt DALL-E, ƒë·ªìng th·ªùi ƒë·∫£m b·∫£o t√≠nh an to√†n v√† phong c√°ch ch√¢n th·ª±c c·ªßa n·ªôi dung ƒë√£ d·ªãch. "
                "Ch·ªâ tr·∫£ v·ªÅ duy nh·∫•t prompt DALL-E ƒë√≥, kh√¥ng c√≥ b·∫•t k·ª≥ gi·∫£i th√≠ch hay ƒë·ªãnh d·∫°ng n√†o kh√°c. "
                "ƒê·∫∂C BI·ªÜT L∆ØU √ù: C√°c prompt DALL-E m√† b·∫°n t·∫°o ra ph·∫£i h∆∞·ªõng d·∫´n DALL-E KH√îNG ƒê∆Ø·ª¢C VI·∫æT B·∫§T K·ª≤ CH·ªÆ, K√ù T·ª∞, HAY VƒÇN B·∫¢N n√†o l√™n h√¨nh ·∫£nh ƒë∆∞·ª£c t·∫°o ra. H√¨nh ·∫£nh cu·ªëi c√πng ph·∫£i ho√†n to√†n kh√¥ng c√≥ ch·ªØ. N·∫øu c·∫ßn, h√£y th√™m c√°c c·ª•m t·ª´ nh∆∞ 'no text', 'text-free', 'image only, no writing', 'avoid typography', 'typography-free' v√†o cu·ªëi m·ªói DALL-E prompt ƒë·ªÉ nh·∫•n m·∫°nh y√™u c·∫ßu n√†y."
            )
            
            user_message_content = (
                f"D∆∞·ªõi ƒë√¢y l√† to√†n b·ªô k·ªãch b·∫£n c·∫ßn x·ª≠ l√Ω:\n\n"
                f"```script\n{original_plain_script_text}\n```\n\n"
                f"D·ª±a v√†o k·ªãch b·∫£n tr√™n, h√£y t√≥m t·∫Øt √Ω ch√≠nh v√† t·∫°o ra M·ªòT prompt DALL-E DUY NH·∫§T (b·∫±ng ti·∫øng Anh, an to√†n, t·ªïng qu√°t) ƒë·ªÉ minh h·ªça cho to√†n b·ªô k·ªãch b·∫£n n√†y. "
                f"Ch·ªâ tr·∫£ v·ªÅ duy nh·∫•t prompt DALL-E ƒë√≥."
            )
            
            logging.info(f"{worker_log_prefix} ƒêang g·ª≠i y√™u c·∫ßu ƒë·∫øn model '{selected_gpt_model}' ƒë·ªÉ t·∫°o 1 prompt DALL-E t√≥m t·∫Øt...")
            
            response = client.chat.completions.create(
                model=selected_gpt_model,
                messages=[
                    {"role": "system", "content": system_message_content},
                    {"role": "user", "content": user_message_content}
                ],
                temperature=0.3, # Nhi·ªát ƒë·ªô th·∫•p h∆°n ƒë·ªÉ prompt √≠t bay b·ªïng, t·∫≠p trung h∆°n
            )
            
            gpt_response_content = response.choices[0].message.content.strip()
            # Lo·∫°i b·ªè d·∫•u ngo·∫∑c k√©p ho·∫∑c c√°c k√Ω t·ª± kh√¥ng mong mu·ªën n·∫øu c√≥
            cleaned_prompt = gpt_response_content.replace('"', '').replace("'", "").strip()

            if cleaned_prompt:
                single_dalle_prompt = cleaned_prompt
                logging.info(f"{worker_log_prefix} GPT ƒë√£ t·∫°o prompt DALL-E t√≥m t·∫Øt: '{single_dalle_prompt}'")
            else:
                error_message_summary = "GPT kh√¥ng tr·∫£ v·ªÅ prompt DALL-E t√≥m t·∫Øt n√†o ho·∫∑c prompt r·ªóng."
                logging.warning(f"{worker_log_prefix} {error_message_summary}. Ph·∫£n h·ªìi g·ªëc: {gpt_response_content}")

        except RateLimitError as e_rate:
            error_message_summary = f"L·ªói Gi·ªõi h·∫°n Y√™u c·∫ßu (Rate Limit) t·ª´ OpenAI khi t·∫°o prompt t√≥m t·∫Øt. Chi ti·∫øt: {str(e_rate)}"
            logging.warning(f"{worker_log_prefix} {error_message_summary}")
        except AuthenticationError as e_auth:
            error_message_summary = f"L·ªói X√°c th·ª±c OpenAI khi t·∫°o prompt t√≥m t·∫Øt: API Key kh√¥ng h·ª£p l·ªá/h·∫øt h·∫°n. Chi ti·∫øt: {str(e_auth)}"
            logging.error(f"{worker_log_prefix} {error_message_summary}")
        except APIConnectionError as e_conn:
            error_message_summary = f"L·ªói K·∫øt n·ªëi ƒë·∫øn server OpenAI khi t·∫°o prompt t√≥m t·∫Øt. Chi ti·∫øt: {str(e_conn)}"
            logging.error(f"{worker_log_prefix} {error_message_summary}")
        except APITimeoutError as e_timeout:
            error_message_summary = f"L·ªói Timeout v·ªõi OpenAI khi t·∫°o prompt t√≥m t·∫Øt. Chi ti·∫øt: {str(e_timeout)}"
            logging.error(f"{worker_log_prefix} {error_message_summary}")
        except APIStatusError as e_status:
            status_code = e_status.status_code if hasattr(e_status, 'status_code') else 'N/A'
            err_msg_from_api = e_status.message if hasattr(e_status, 'message') else str(e_status)
            error_message_summary = f"L·ªói t·ª´ API OpenAI (M√£ tr·∫°ng th√°i: {status_code}) khi t·∫°o prompt t√≥m t·∫Øt: {err_msg_from_api}"
            logging.error(f"{worker_log_prefix} {error_message_summary}")
        except Exception as e_general:
            error_message_summary = f"L·ªói kh√¥ng mong mu·ªën khi GPT t·∫°o prompt t√≥m t·∫Øt: {type(e_general).__name__} - {str(e_general)}"
            logging.error(f"{worker_log_prefix} {error_message_summary}", exc_info=True)

        finally:
            prompts_for_callback = [single_dalle_prompt] if single_dalle_prompt else []
            # G·ªçi l·∫°i h√†m _handle_gpt_scene_division_result v·ªõi danh s√°ch ch·ªâ ch·ª©a 1 prompt (ho·∫∑c r·ªóng n·∫øu l·ªói)
            self.after(0, self._handle_gpt_scene_division_result,
                       prompts_for_callback,
                       error_message_summary,
                       script_for_slideshow_timing_callback,    # Truy·ªÅn l·∫°i script d√πng cho slideshow timing
                       original_plain_gpt_text_for_dub_callback, # Truy·ªÅn l·∫°i plain text g·ªëc
                       original_gpt_context_callback,
                       original_target_widget_callback,
                       original_trigger_dub_chain_flag_callback)
            logging.debug(f"{worker_log_prefix} ƒê√£ l√™n l·ªãch callback _handle_gpt_scene_division_result (t·ª´ summary thread).")


# Th√™m h√†m n√†y v√†o l·ªõp SubtitleApp
    def _handle_gpt_scene_division_result(self, 
                                          list_of_dalle_prompts, 
                                          error_message,
                                          script_for_slideshow_timing,        # << ƒê·ªïi t√™n cho r√µ (ƒë√¢y l√† script_content_for_gpt_analysis t·ª´ b∆∞·ªõc tr∆∞·ªõc)
                                          original_plain_gpt_text_for_dub,  # << THAM S·ªê M·ªöI
                                          original_gpt_context, 
                                          original_target_widget, 
                                          original_trigger_dub_chain_flag):
        log_prefix_callback = f"[GPT_SceneDivision_Result:{original_gpt_context}]"
        logging.info(f"{log_prefix_callback} Nh·∫≠n k·∫øt qu·∫£ chia c·∫£nh. S·ªë prompts: {len(list_of_dalle_prompts) if list_of_dalle_prompts else 0}, L·ªói: {error_message}")
        logging.info(f"{log_prefix_callback}   script_for_slideshow_timing (c√≥ th·ªÉ l√† SRT, d√†i {len(script_for_slideshow_timing)} chars): '{script_for_slideshow_timing[:50].replace(chr(10),' ')}...'")
        logging.info(f"{log_prefix_callback}   original_plain_gpt_text_for_dub (d√†i {len(original_plain_gpt_text_for_dub)} chars): '{original_plain_gpt_text_for_dub[:50].replace(chr(10),' ')}...'")

        if error_message or not list_of_dalle_prompts:
            # ... (ph·∫ßn x·ª≠ l√Ω l·ªói c·ªßa b·∫°n gi·ªØ nguy√™n) ...
            final_error = error_message or "GPT kh√¥ng t·∫°o ƒë∆∞·ª£c DALL-E prompt n√†o."
            logging.error(f"{log_prefix_callback} {final_error}")
            self.update_status(f"‚ùå L·ªói GPT (chia c·∫£nh): {final_error[:60]}...")
            messagebox.showerror(f"L·ªói GPT Chia C·∫£nh ({original_gpt_context.capitalize()})",
                                 f"ƒê√£ x·∫£y ra l·ªói khi y√™u c·∫ßu GPT chia c·∫£nh v√† t·∫°o DALL-E prompts:\n\n{final_error}",
                                 parent=self)
            # Reset l·∫°i c√°c n√∫t li√™n quan 
            button_to_enable = None; button_text_default = "ü§ñ GPT"
            if original_gpt_context == "subtitle":
                if hasattr(self, 'gpt_edit_script_button_main_tab'): button_to_enable = self.gpt_edit_script_button_main_tab
            elif original_gpt_context == "dubbing":
                if hasattr(self, 'gpt_edit_dub_script_button'): button_to_enable = self.gpt_edit_dub_script_button
            if button_to_enable and button_to_enable.winfo_exists():
                button_to_enable.configure(state=ctk.NORMAL, text=button_text_default)
            if hasattr(self, 'is_gpt_processing_script'): self.is_gpt_processing_script = False
            return

        logging.info(f"{log_prefix_callback} Th√†nh c√¥ng! C√≥ {len(list_of_dalle_prompts)} DALL-E prompts. Chu·∫©n b·ªã g·ªçi DALL-E...")
        self.update_status(f"‚úÖ GPT ƒë√£ t·∫°o {len(list_of_dalle_prompts)} prompt ·∫£nh. Chu·∫©n b·ªã v·∫Ω...")

        # S·ª≠a h√†m _start_gpt_dalle_slideshow_chain_multiple_prompts ƒë·ªÉ nh·∫≠n th√™m original_plain_gpt_text_for_dub
        self.after(100, self._start_gpt_dalle_slideshow_chain_multiple_prompts,
                   list_of_dalle_prompts,
                   script_for_slideshow_timing,       # D√πng cho timing slideshow
                   original_plain_gpt_text_for_dub, 
                   None,
                   original_gpt_context,
                   original_target_widget,
                   original_trigger_dub_chain_flag)


# H√†m ƒë∆∞·ª£c g·ªçi sau khi bi√™n t·∫≠p GPT ho√†n th√†nh
    def _handle_gpt_script_editing_result(self, processed_script, error_message,
                                          target_textbox_widget, calling_button_context,
                                          trigger_dalle_chain_flag=False,
                                          trigger_dub_chain_flag=False,
                                          base_filename_for_chain=None):
        log_prefix = f"[GPTScriptResult:{calling_button_context}]"
        self.is_gpt_processing_script = False 

        # Ch·ªâ b·∫≠t l·∫°i n√∫t n·∫øu kh√¥ng c√≥ chu·ªói DALL-E ti·∫øp theo
        if not trigger_dalle_chain_flag:
            is_app_active = self._is_app_fully_activated()
            
            if is_app_active:
                if hasattr(self, 'ai_edit_button_sub_tab') and self.ai_edit_button_sub_tab.winfo_exists():
                    self.ai_edit_button_sub_tab.configure(state="normal", text="‚ú® Bi√™n t·∫≠p (AI)")
                if hasattr(self, 'ai_edit_dub_script_button') and self.ai_edit_dub_script_button.winfo_exists():
                    self.ai_edit_dub_script_button.configure(state="normal", text="‚ú® Bi√™n t·∫≠p (AI)")
        # C·∫≠p nh·∫≠t log n√†y ƒë·ªÉ bao g·ªìm c·∫£ c·ªù m·ªõi
        logging.info(f"{log_prefix} GI√Å TR·ªä C·ª¶A trigger_dalle_chain_flag L√Ä: {trigger_dalle_chain_flag}, trigger_dub_chain_flag L√Ä: {trigger_dub_chain_flag}")

        # X·ª≠ l√Ω tr∆∞·ªùng h·ª£p ng∆∞·ªùi d√πng ch·ªß ƒë·ªông d·ª´ng
        if error_message and "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng" in error_message:
            self.is_gpt_processing_script = False # ƒê·∫∑t l·∫°i c·ªù
            # C·∫≠p nh·∫≠t tr·∫°ng th√°i
            self.update_status(f"üõë T√°c v·ª• GPT ({calling_button_context}) ƒë√£ ƒë∆∞·ª£c d·ª´ng.")
            # ƒê·∫£m b·∫£o textbox c√≥ th·ªÉ t∆∞∆°ng t√°c l·∫°i ƒë∆∞·ª£c
            if target_textbox_widget and target_textbox_widget.winfo_exists():
                target_textbox_widget.configure(state="normal")
            # ƒê·∫£m b·∫£o c√°c n√∫t ƒë∆∞·ª£c reset v·ªÅ tr·∫°ng th√°i ch·ªù
            if hasattr(self, '_set_subtitle_tab_ui_state'):
                self._set_subtitle_tab_ui_state(subbing_active=False)
            logging.info(f"{log_prefix} ƒê√£ x·ª≠ l√Ω xong y√™u c·∫ßu d·ª´ng c·ªßa ng∆∞·ªùi d√πng.")
            return # Tho√°t kh·ªèi h√†m s·ªõm

        self.is_gpt_processing_script = False 

        button_to_enable = None
        button_text_default = "ü§ñ GPT"
        if calling_button_context == "subtitle":
            if hasattr(self, 'gpt_edit_script_button_main_tab'):
                button_to_enable = self.gpt_edit_script_button_main_tab
        elif calling_button_context == "dubbing":
            if hasattr(self, 'gpt_edit_dub_script_button'):
                button_to_enable = self.gpt_edit_dub_script_button
        
        if button_to_enable and button_to_enable.winfo_exists():
            button_to_enable.configure(state=ctk.NORMAL, text=button_text_default)

        if target_textbox_widget and target_textbox_widget.winfo_exists():
            target_textbox_widget.configure(state="normal")

        if error_message:
            logging.error(f"{log_prefix} L·ªói t·ª´ GPT: {error_message}")
            self.update_status(f"‚ùå L·ªói GPT ({calling_button_context}): {error_message[:50]}...")
            messagebox.showerror(f"L·ªói X·ª≠ L√Ω GPT ({calling_button_context.capitalize()})",
                                 f"ƒê√£ x·∫£y ra l·ªói khi y√™u c·∫ßu GPT x·ª≠ l√Ω k·ªãch b·∫£n:\n\n{error_message}\n\nN·ªôi dung k·ªãch b·∫£n ch∆∞a ƒë∆∞·ª£c thay ƒë·ªïi.",
                                 parent=self)
            # ƒê·∫£m b·∫£o textbox ·ªü tr·∫°ng th√°i 'normal' ngay c·∫£ khi c√≥ l·ªói ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ s·ª≠a
            if target_textbox_widget and target_textbox_widget.winfo_exists():
                 target_textbox_widget.configure(state="normal")
            return 

        elif processed_script is not None: 
            logging.info(f"{log_prefix} GPT x·ª≠ l√Ω th√†nh c√¥ng. Context: {calling_button_context}.")
            
            final_script_for_display = processed_script 
            srt_data_content_for_dub_update = None # S·∫Ω d√πng cho context "dubbing"

            if calling_button_context == "subtitle":
                original_plain_gpt_text = processed_script  # L∆∞u l·∫°i text thu·∫ßn t√∫y g·ªëc t·ª´ GPT
                script_for_chain_timing = original_plain_gpt_text # M·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥ g√¨ thay ƒë·ªïi
                final_script_for_display_sub_tab = original_plain_gpt_text # Cho textbox tab Subtitle

                # Ki·ªÉm tra checkbox "T·ª± ƒë·ªông ƒë·ªãnh d·∫°ng Text sang SRT" c·ªßa tab Subtitle
                subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
                auto_format_sub_on = (hasattr(self, 'auto_format_plain_text_to_srt_var') and
                                     self.auto_format_plain_text_to_srt_var.get() and
                                     target_textbox_widget == subtitle_textbox)

                if auto_format_sub_on:
                    logging.info(f"{log_prefix} Checkbox 'AutoFormat SRT (Subtitle)' B·∫¨T. T·∫°o SRT theo rule Subtitle.")
                    gpt_split_cfg_sub = { # C·∫•u h√¨nh c·ªßa tab Subtitle
                        "split_enabled": self.enable_split_var.get(),
                        "mode": self.split_mode_var.get(),
                        "max_chars": safe_int(self.max_chars_var.get(), 90),
                        "max_lines": safe_int(self.max_lines_var.get(), 1),
                        "DEFAULT_CPS_FOR_TIMING": safe_int(self.sub_cps_for_timing_var.get(), 17),
                        "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1, 
                        "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
                    } # ƒê·∫£m b·∫£o d·∫•u } ·ªü ƒë√∫ng v·ªã tr√≠
                    gpt_srt_data_content_sub = self._parse_plain_text_to_srt_data(
                        original_plain_gpt_text,
                        force_plain_text_processing=True,
                        split_config_override=gpt_split_cfg_sub
                    )
                    if gpt_srt_data_content_sub:
                        srt_output_from_sub_rules = format_srt_data_to_string(gpt_srt_data_content_sub)
                        final_script_for_display_sub_tab = srt_output_from_sub_rules # Hi·ªÉn th·ªã SRT tr√™n tab Sub
                        script_for_chain_timing = srt_output_from_sub_rules       # D√πng SRT n√†y cho chain timing
                        logging.info(f"{log_prefix} ƒê√£ t·∫°o SRT theo rule Subtitle. final_script_for_display_sub_tab v√† script_for_chain_timing ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")
                    else:
                        logging.warning(f"{log_prefix} Kh√¥ng t·∫°o ƒë∆∞·ª£c SRT t·ª´ rule Subtitle. Gi·ªØ nguy√™n plain text cho hi·ªÉn th·ªã v√† chain timing.")
                
                # N·∫øu chu·ªói DALL-E/Dub ƒë∆∞·ª£c k√≠ch ho·∫°t V√Ä "AutoFormat SRT (Subtitle)" T·∫ÆT,
                # ch√∫ng ta v·∫´n c·∫ßn t·∫°o m·ªôt SRT c∆° b·∫£n cho chain timing.
                elif trigger_dalle_chain_flag and not auto_format_sub_on: # D√πng elif ·ªü ƒë√¢y l√† ƒë√∫ng
                    logging.info(f"{log_prefix} Chain DALL-E/Dub k√≠ch ho·∫°t v√† 'AutoFormat SRT (Subtitle)' T·∫ÆT. T·∫°o SRT c∆° b·∫£n cho chain timing t·ª´ plain text g·ªëc.")
                    basic_timing_config = {
                        "split_enabled": True, 
                        "mode": "sentence",    
                        "max_chars": 90,       
                        "max_lines": 1,        
                        "DEFAULT_CPS_FOR_TIMING": safe_int(self.sub_cps_for_timing_var.get(), 17),
                        "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1, # ƒê·∫£m b·∫£o d·∫•u ph·∫©y
                        "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
                    } # ƒê·∫£m b·∫£o d·∫•u }
                    basic_srt_data_for_chain = self._parse_plain_text_to_srt_data(
                        original_plain_gpt_text,
                        force_plain_text_processing=True,
                        split_config_override=basic_timing_config
                    )
                    if basic_srt_data_for_chain:
                        script_for_chain_timing = format_srt_data_to_string(basic_srt_data_for_chain)
                        logging.info(f"{log_prefix} ƒê√£ t·∫°o SRT c∆° b·∫£n cho chain timing. script_for_chain_timing ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")
                    else:
                        logging.warning(f"{log_prefix} Kh√¥ng t·∫°o ƒë∆∞·ª£c SRT c∆° b·∫£n cho chain timing. script_for_chain_timing v·∫´n l√† plain text.")
                    # final_script_for_display_sub_tab v·∫´n l√† original_plain_gpt_text v√¨ auto_format_sub_on T·∫ÆT

                # C·∫≠p nh·∫≠t textbox c·ªßa tab Subtitle v·ªõi final_script_for_display_sub_tab
                if target_textbox_widget and target_textbox_widget.winfo_exists():
                    target_textbox_widget.delete("1.0", "end")
                    target_textbox_widget.insert("1.0", final_script_for_display_sub_tab)
                    self.allow_edit_sub = True
                
                # K√≠ch ho·∫°t chu·ªói DALL-E n·∫øu c·∫ßn
                if trigger_dalle_chain_flag:
                    logging.info(f"{log_prefix} C·ªù trigger_dalle_chain_flag=True. B·∫Øt ƒë·∫ßu chu·ªói GPT chia c·∫£nh -> DALL-E.")
                    logging.info(f"{log_prefix}   Truy·ªÅn script_for_chain_timing (d√†i {len(script_for_chain_timing)} chars): '{script_for_chain_timing[:100].replace(chr(10),' ')}...'")
                    logging.info(f"{log_prefix}   Truy·ªÅn original_plain_gpt_text (d√†i {len(original_plain_gpt_text)} chars): '{original_plain_gpt_text[:100].replace(chr(10),' ')}...'")
                    
                    self.update_status(f"ü§ñ GPT t·∫°o k·ªãch b·∫£n xong! Chu·∫©n b·ªã y√™u c·∫ßu GPT chia c·∫£nh...")
                    
                    self.after(100, self._initiate_gpt_scene_division,
                               script_for_chain_timing,
                               original_plain_gpt_text,
                               calling_button_context, 
                               target_textbox_widget, 
                               trigger_dub_chain_flag,
                               base_filename_for_chain)
                    return            
            
            elif calling_button_context == "dubbing":
                # Kh·ªüi t·∫°o final_script_for_display b·∫±ng output thu·∫ßn t·ª´ GPT
                final_script_for_display = processed_script 
                srt_data_content_for_dub_update = None # S·∫Ω l∆∞u tr·ªØ k·∫øt qu·∫£ parse

                if hasattr(self, 'auto_format_plain_text_to_srt_dub_var') and \
                   self.auto_format_plain_text_to_srt_dub_var.get() and \
                   target_textbox_widget == self.dub_script_textbox:
                    
                    logging.info(f"{log_prefix} Checkbox 'AutoFormat SRT (Dubbing)' B·∫¨T. Th·ª≠ chuy·ªÉn ƒë·ªïi output GPT.")
                    gpt_split_cfg_dub = {
                        "split_enabled": self.enable_split_var.get(),
                        "mode": self.split_mode_var.get(),
                        "max_chars": safe_int(self.max_chars_var.get(), 90),
                        "max_lines": safe_int(self.max_lines_var.get(), 1),
                        "DEFAULT_CPS_FOR_TIMING": safe_int(self.sub_cps_for_timing_var.get(), 17),
                        "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1,
                        "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
                    }

                    temp_parsed_data = self._parse_plain_text_to_srt_data(
                        processed_script, 
                        force_plain_text_processing=True,
                        split_config_override=gpt_split_cfg_dub
                    )
                    if temp_parsed_data: # N·∫øu parse th√†nh c√¥ng v√† c√≥ n·ªôi dung
                        srt_string_from_gpt_dub = format_srt_data_to_string(temp_parsed_data)
                        final_script_for_display = srt_string_from_gpt_dub
                        srt_data_content_for_dub_update = temp_parsed_data # ƒê√¢y l√† d·ªØ li·ªáu SRT th·ª±c s·ª±
                        logging.info(f"{log_prefix} ƒê√£ chuy·ªÉn ƒë·ªïi output GPT (Dubbing) sang SRT. S·ªë m·ª•c: {len(srt_data_content_for_dub_update)}")
                    else: # Parse kh√¥ng th√†nh c√¥ng ho·∫∑c tr·∫£ v·ªÅ r·ªóng
                        logging.warning(f"{log_prefix} Kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi output GPT (Dubbing) sang SRT c·∫•u tr√∫c. Gi·ªØ nguy√™n plain text.")
                        # final_script_for_display v·∫´n l√† processed_script (plain text)
                        # C·∫ßn parse plain text n√†y ƒë·ªÉ l·∫•y srt_data_content_for_dub_update cho dub_temp_srt_data_for_queue
                        srt_data_content_for_dub_update = self._parse_plain_text_to_srt_data(
                            final_script_for_display, force_plain_text_processing=True, split_config_override=None
                        )
                        logging.info(f"{log_prefix} ƒê√£ parse l·∫°i plain text t·ª´ GPT (Dubbing) cho srt_data_content_for_dub_update. S·ªë m·ª•c: {len(srt_data_content_for_dub_update if srt_data_content_for_dub_update else [])}")
                
                else: # Checkbox AutoFormat (Dubbing) kh√¥ng ƒë∆∞·ª£c tick
                    logging.info(f"{log_prefix} Checkbox 'AutoFormat SRT (Dubbing)' T·∫ÆT. Parse output GPT nh∆∞ plain text.")
                    srt_data_content_for_dub_update = self._parse_plain_text_to_srt_data(
                        final_script_for_display, force_plain_text_processing=True, split_config_override=None
                    )
                    logging.info(f"{log_prefix} ƒê√£ parse plain text t·ª´ GPT (Dubbing) cho srt_data_content_for_dub_update (checkbox t·∫Øt). S·ªë m·ª•c: {len(srt_data_content_for_dub_update if srt_data_content_for_dub_update else [])}")

                # C·∫≠p nh·∫≠t self.dub_temp_srt_data_for_queue v·ªõi d·ªØ li·ªáu ƒë√£ parse (SRT ho·∫∑c plain text ƒë√£ ∆∞·ªõc l∆∞·ª£ng th·ªùi gian)
                self.dub_temp_srt_data_for_queue = srt_data_content_for_dub_update if srt_data_content_for_dub_update else []
                
                # C·∫≠p nh·∫≠t textbox dubbing
                if target_textbox_widget and target_textbox_widget.winfo_exists(): # ch√≠nh l√† self.dub_script_textbox
                    target_textbox_widget.configure(state="normal") 
                    target_textbox_widget.delete("1.0", "end")      
                    
                    # Ch·ªâ insert n·∫øu final_script_for_display th·ª±c s·ª± c√≥ n·ªôi dung sau khi strip
                    # N·∫øu n√≥ r·ªóng, textbox s·∫Ω tr·ªëng, v√† _update_dub_script_controls_state s·∫Ω x·ª≠ l√Ω placeholder
                    if final_script_for_display and final_script_for_display.strip():
                        target_textbox_widget.insert("1.0", final_script_for_display)
                        logging.debug(f"{log_prefix} ƒê√£ insert n·ªôi dung v√†o dub_script_textbox: '{final_script_for_display[:50]}...'")
                    else:
                        logging.debug(f"{log_prefix} final_script_for_display r·ªóng ho·∫∑c ch·ªâ ch·ª©a kho·∫£ng tr·∫Øng. dub_script_textbox s·∫Ω tr·ªëng.")
                
                # G·ªçi c√°c h√†m c·∫≠p nh·∫≠t UI sau khi textbox ƒë√£ ·ªïn ƒë·ªãnh
                self._update_dub_script_controls_state() 
                if hasattr(self, '_check_can_add_to_dub_queue'):
                    self._check_can_add_to_dub_queue()
                logging.debug(f"{log_prefix} ƒê√£ g·ªçi _update_dub_script_controls_state v√† _check_can_add_to_dub_queue.")

                    

            # X·ª≠ l√Ω chung sau khi ƒë√£ c·∫≠p nh·∫≠t textbox (n·∫øu kh√¥ng c√≥ DALL-E chain ƒë∆∞·ª£c trigger)
            if not trigger_dalle_chain_flag: 
                self.update_status(f"‚úÖ GPT ƒë√£ bi√™n t·∫≠p xong k·ªãch b·∫£n ({calling_button_context}).")
                try:
                    play_sound_on_gpt_task_complete = self.download_sound_var.get()
                    sound_file_to_play_gpt = self.download_sound_path_var.get()
                    if play_sound_on_gpt_task_complete and sound_file_to_play_gpt and \
                       os.path.isfile(sound_file_to_play_gpt) and PLAYSOUND_AVAILABLE:
                        play_sound_async(sound_file_to_play_gpt)
                except Exception as e_play_gpt_sound:
                    logging.error(f"{log_prefix} L·ªói khi th·ª≠ ph√°t √¢m thanh sau GPT: {e_play_gpt_sound}")

                messagebox.showinfo("Ho√†n th√†nh GPT",
                                    f"GPT ƒë√£ x·ª≠ l√Ω v√† c·∫≠p nh·∫≠t n·ªôi dung k·ªãch b·∫£n ({calling_button_context.capitalize()}).",
                                    parent=self)
        else: # processed_script is None (v√† kh√¥ng c√≥ l·ªói)
            logging.warning(f"{log_prefix} GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung v√† kh√¥ng b√°o l·ªói.")
            self.update_status(f"‚ö†Ô∏è GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung ({calling_button_context}).")
            messagebox.showwarning("Kh√¥ng c√≥ k·∫øt qu·∫£", 
                                   f"GPT kh√¥ng tr·∫£ v·ªÅ n·ªôi dung n√†o cho y√™u c·∫ßu c·ªßa b·∫°n ({calling_button_context.capitalize()}).\n"
                                   "Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c thay ƒë·ªïi y√™u c·∫ßu.", 
                                   parent=self)

        # ƒê·∫£m b·∫£o textbox ·ªü tr·∫°ng th√°i 'normal' n·∫øu kh√¥ng c√≥ l·ªói v√† kh√¥ng c√≥ chu·ªói DALL-E
        if target_textbox_widget and target_textbox_widget.winfo_exists() and not error_message and not (trigger_dalle_chain_flag and calling_button_context == "subtitle"):
             target_textbox_widget.configure(state="normal")
        elif target_textbox_widget and target_textbox_widget.winfo_exists() and error_message:
             target_textbox_widget.configure(state="normal")


# H√†m m·ªü n√∫t t·∫°o ·∫£nh DALL-E
    def _show_dalle_image_generation_popup(self):
        if not HAS_OPENAI or not self.openai_key_var.get():
            messagebox.showerror("Thi·∫øu API Key OpenAI", # S·ª≠a ti√™u ƒë·ªÅ cho r√µ r√†ng h∆°n
                                 "Vui l√≤ng c·∫•u h√¨nh OpenAI API Key trong 'C√†i ƒë·∫∑t API Keys' tr∆∞·ªõc khi s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.",
                                 parent=self) # parent=self ƒë·ªÉ popup hi·ªán tr√™n c·ª≠a s·ªï ch√≠nh
            logging.warning("[DALL-E Popup] B·ªã ch·∫∑n do thi·∫øu API Key OpenAI ho·∫∑c th∆∞ vi·ªán ch∆∞a c√†i ƒë·∫∑t.")
            return # NgƒÉn kh√¥ng cho DalleSettingsWindow m·ªü ra

        logging.info("[DALL-E Popup] N√∫t T·∫°o ·∫¢nh (DALL-E) ƒë∆∞·ª£c nh·∫•n (ƒë√£ qua ki·ªÉm tra key). M·ªü popup DALL-E...")

        # Ki·ªÉm tra xem c·ª≠a s·ªï DALL-E ƒë√£ m·ªü ch∆∞a ƒë·ªÉ tr√°nh m·ªü nhi·ªÅu l·∫ßn
        if hasattr(self, '_dalle_settings_win') and self._dalle_settings_win and self._dalle_settings_win.winfo_exists():
            self._dalle_settings_win.focus() # N·∫øu ƒë√£ m·ªü, ƒë∆∞a n√≥ l√™n tr√™n
            logging.info("C·ª≠a s·ªï c√†i ƒë·∫∑t DALL-E ƒë√£ ƒë∆∞·ª£c m·ªü, ƒëang focus.")
            return
        
        self._dalle_settings_win = DalleSettingsWindow(master_app=self)


# H√†m n√†y s·∫Ω nh·∫≠n k·ªãch b·∫£n ƒë√£ x·ª≠ l√Ω t·ª´ GPT, chu·∫©n b·ªã c√°c th√¥ng s·ªë c·∫ßn thi·∫øt cho DALL-E
    def _start_gpt_dalle_slideshow_chain_multiple_prompts(self,
                                                          dalle_prompts_list,
                                                          script_for_slideshow_timing,
                                                          original_plain_gpt_text_for_dub,
                                                          original_video_path_for_chain_ignored,
                                                          gpt_context,
                                                          target_textbox_widget,
                                                          trigger_dub_chain_flag=False,
                                                          base_filename_for_chain=None):
        log_prefix = f"[Chain_GPT_DALL-E_MultiPrompt:{gpt_context}]"
        
        # ƒê·ªçc c√°c c√†i ƒë·∫∑t DALL-E t·ª´ config m√† ng∆∞·ªùi d√πng ƒë√£ thi·∫øt l·∫≠p trong DalleSettingsWindow
        # v√† ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o self.cfg
        is_cost_saver_mode_active = self.cfg.get("dalle_cost_saver_mode", False)
        num_images_total_requested_by_user = int(self.cfg.get("dalle_num_images_setting", 1))
        num_images_total_requested_by_user = max(1, num_images_total_requested_by_user)

        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu chu·ªói DALL-E. CostSaver: {is_cost_saver_mode_active}, T·ªïng s·ªë ·∫£nh user mu·ªën: {num_images_total_requested_by_user}, S·ªë prompts nh·∫≠n ƒë∆∞·ª£c: {len(dalle_prompts_list)}. Trigger Dub: {trigger_dub_chain_flag}")
        logging.info(f"{log_prefix}   Script cho slideshow timing: '{script_for_slideshow_timing[:50].replace(chr(10),' ')}...'")
        logging.info(f"{log_prefix}   Plain text g·ªëc cho dub: '{original_plain_gpt_text_for_dub[:50].replace(chr(10),' ')}...'")

        if not dalle_prompts_list:
            logging.warning(f"{log_prefix} Danh s√°ch DALL-E prompt r·ªóng, kh√¥ng th·ªÉ ti·∫øp t·ª•c chu·ªói DALL-E.")
            self.update_status("‚ö†Ô∏è L·ªói: Kh√¥ng c√≥ prompt n√†o ƒë·ªÉ t·∫°o ·∫£nh DALL-E.")
            if hasattr(self, 'is_gpt_processing_script'): self.is_gpt_processing_script = False
            # ... (reset n√∫t GPT n·∫øu c·∫ßn, t∆∞∆°ng t·ª± nh∆∞ trong _handle_gpt_scene_division_result) ...
            return

        # L·∫•y c√°c tham s·ªë c·∫•u h√¨nh DALL-E kh√°c t·ª´ self.cfg
        dalle_model_cfg = self.cfg.get("dalle_model_setting", "dall-e-3")
        
        default_size_d3_cfg = "1792x1024"; default_size_d2_cfg = "1024x1024"
        default_size_for_current_model_cfg = default_size_d3_cfg if dalle_model_cfg == "dall-e-3" else default_size_d2_cfg
        image_size_cfg = self.cfg.get(f"dalle_imagesize_{dalle_model_cfg}_setting", default_size_for_current_model_cfg)
        
        # Ki·ªÉm tra l·∫°i k√≠ch th∆∞·ªõc h·ª£p l·ªá (quan tr·ªçng n·∫øu config b·ªã s·ª≠a th·ªß c√¥ng)
        valid_sizes_d3_cfg = ["1024x1024", "1792x1024", "1024x1792"]
        valid_sizes_d2_cfg = ["256x256", "512x512", "1024x1024"]
        if (dalle_model_cfg == "dall-e-3" and image_size_cfg not in valid_sizes_d3_cfg) or \
           (dalle_model_cfg == "dall-e-2" and image_size_cfg not in valid_sizes_d2_cfg):
            image_size_cfg = default_size_for_current_model_cfg
            logging.warning(f"{log_prefix} K√≠ch th∆∞·ªõc DALL-E ƒë√£ l∆∞u ('{self.cfg.get(f'dalle_imagesize_{dalle_model_cfg}_setting')}') kh√¥ng h·ª£p l·ªá cho model {dalle_model_cfg}. ƒê·∫∑t l·∫°i v·ªÅ: '{image_size_cfg}'")
            # C·∫≠p nh·∫≠t l·∫°i config n·∫øu gi√° tr·ªã kh√¥ng h·ª£p l·ªá (t√πy ch·ªçn)
            # self.cfg[f"dalle_imagesize_{dalle_model_cfg}_setting"] = image_size_cfg
            # self.save_current_config()


        dalle_quality_cfg = self.cfg.get("dalle_quality_d3_setting", "standard") if dalle_model_cfg == "dall-e-3" else None
        dalle_style_cfg = self.cfg.get("dalle_style_d3_setting", "vivid") if dalle_model_cfg == "dall-e-3" else None

        base_output_folder_dalle_cfg = self.cfg.get("dalle_output_folder_setting")
        if not base_output_folder_dalle_cfg or not os.path.isdir(base_output_folder_dalle_cfg):
            if gpt_context == "subtitle" and self.output_path_var.get() and os.path.isdir(self.output_path_var.get()):
                base_output_folder_dalle_cfg = self.output_path_var.get()
            elif gpt_context == "dubbing" and self.dub_output_path_var.get() and os.path.isdir(self.dub_output_path_var.get()):
                base_output_folder_dalle_cfg = self.dub_output_path_var.get()
            else:
                base_output_folder_dalle_cfg = self.get_default_downloads_folder()
            logging.info(f"{log_prefix} Th∆∞ m·ª•c output DALL-E kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh ho·∫∑c kh√¥ng h·ª£p l·ªá, s·ª≠ d·ª•ng th∆∞ m·ª•c d·ª± ph√≤ng: {base_output_folder_dalle_cfg}")

        # 1. L·∫•y t√™n file g·ªëc t·ª´ tham s·ªë, n·∫øu kh√¥ng c√≥ th√¨ d√πng t√™n fallback
        safe_base_name = create_safe_filename(base_filename_for_chain, max_length=80) if base_filename_for_chain else f"ai_chain_dalle_{uuid.uuid4().hex[:6]}"

        # 2. T·∫°o t√™n th∆∞ m·ª•c m·ªõi, k·∫øt h·ª£p engine, t√™n k·ªãch b·∫£n v√† timestamp
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        new_folder_name = f"DALLE_{safe_base_name}_{timestamp_str}"
        
        # 3. T·∫°o ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß v√† t·∫°o th∆∞ m·ª•c
        temp_dalle_image_output_folder = os.path.join(base_output_folder_dalle_cfg, new_folder_name)
        try:
            os.makedirs(temp_dalle_image_output_folder, exist_ok=True)
        except OSError as e:
            logging.error(f"{log_prefix} Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c t·∫°m cho DALL-E: {e}")
            self.update_status(f"‚ùå L·ªói t·∫°o th∆∞ m·ª•c DALL-E: {e}")
            return

        self.update_status(f"üé® Chu·∫©n b·ªã g·ªçi DALL-E (Prompts: {len(dalle_prompts_list)}, T·ªïng ·∫£nh y√™u c·∫ßu: {num_images_total_requested_by_user})...")
        logging.info(f"{log_prefix} Th√¥ng s·ªë DALL-E chung: Model={dalle_model_cfg}, Size={image_size_cfg}, Quality={dalle_quality_cfg}, Style={dalle_style_cfg}")

        self.is_dalle_processing = True
        self.start_time = time.time()
        self.after(10, self.update_time_realtime)

        # S·ª≠a h√†m _execute_dalle_chain_generation_iterative ƒë·ªÉ nh·∫≠n th√™m c√°c tham s·ªë m·ªõi
        thread = threading.Thread(
            target=self._execute_dalle_chain_generation_iterative,
            args=(dalle_prompts_list,
                  num_images_total_requested_by_user,
                  is_cost_saver_mode_active,
                  image_size_cfg,
                  temp_dalle_image_output_folder,
                  dalle_model_cfg,
                  dalle_quality_cfg,
                  dalle_style_cfg,
                  script_for_slideshow_timing,
                  original_plain_gpt_text_for_dub,
                  target_textbox_widget, # ƒê√£ c√≥ s·∫µn, ch·ªâ c·∫ßn ƒë·∫£m b·∫£o ƒë√∫ng v·ªã tr√≠
                  gpt_context,           # ƒê√£ c√≥ s·∫µn
                  trigger_dub_chain_flag, # ƒê√£ c√≥ s·∫µn
                  "DALL-E 3", # image_engine_name
                  "GPT",      # ai_script_engine_name
                  base_filename_for_chain # <<< TH√äM V√ÄO ƒê√ÇY
                  ),
            daemon=True,
            name="DalleChainIterativeGenerationThread"
        )
        thread.start()


# H√†m n√†y s·∫Ω ch·ª©a logic g·ªçi API Dall-e v√† t·∫£i ·∫£nh
    def _execute_dalle_chain_generation_iterative(self, dalle_prompts_list, num_images_total_requested_by_user,
                                                  is_cost_saver_mode_active, size, output_folder_for_images,
                                                  selected_dalle_model, quality_setting, style_setting,
                                                  script_for_slideshow_timing_next_step,
                                                  original_plain_gpt_text_for_dub_next_step,
                                                  target_textbox_widget_for_next_step, gpt_context_for_next_step,
                                                  trigger_dub_chain_flag,
                                                  image_engine_name, ai_script_engine_name,
                                                  base_filename_for_chain): # <<< TH√äM V√ÄO ƒê√ÇY

        worker_log_prefix = f"[DalleChainExecIterative:{selected_dalle_model}]" #
        # C·∫≠p nh·∫≠t log ban ƒë·∫ßu ƒë·ªÉ bao g·ªìm c√°c tham s·ªë m·ªõi
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu. CostSaver: {is_cost_saver_mode_active}, T·ªïng ·∫£nh User mu·ªën: {num_images_total_requested_by_user}, S·ªë prompts GPT tr·∫£ v·ªÅ: {len(dalle_prompts_list)}. Trigger Dub: {trigger_dub_chain_flag}") #
        logging.info(f"{worker_log_prefix}   Script cho slideshow timing (s·∫Ω truy·ªÅn ƒëi): '{script_for_slideshow_timing_next_step[:50].replace(chr(10),' ')}...'") #
        logging.info(f"{worker_log_prefix}   Plain text g·ªëc cho dub (s·∫Ω truy·ªÅn ƒëi): '{original_plain_gpt_text_for_dub_next_step[:50].replace(chr(10),' ')}...'") #

        master_app_ref = self #
        all_successfully_generated_image_paths = [] # [cite: 326]
        any_api_error_occurred = False # [cite: 326]
        final_error_message_for_callback = None #
        _worker_stopped_by_user = False #

        with keep_awake(f"Generating {len(dalle_prompts_list)} DALL-E images"):
            try:
                api_key = master_app_ref.openai_key_var.get() #
                if not api_key: #
                    final_error_message_for_callback = "L·ªói: Thi·∫øu API Key OpenAI (DALL-E)" #
                    raise ValueError("Thi·∫øu OpenAI API Key (DALL-E)") #

                if not (HAS_OPENAI and OpenAI is not None): #
                    final_error_message_for_callback = "L·ªói: Thi·∫øu th∆∞ vi·ªán OpenAI (DALL-E)" #
                    raise ImportError("Thi·∫øu th∆∞ vi·ªán OpenAI (DALL-E)") #

                client = OpenAI(api_key=api_key, timeout=180.0) # [cite: 330]

                # --- X√ÅC ƒê·ªäNH DANH S√ÅCH PROMPT S·∫º D√ôNG ƒê·ªÇ G·ªåI API DALL-E ---
                prompts_for_api_calls = []
                if is_cost_saver_mode_active:
                    if dalle_prompts_list and dalle_prompts_list[0].strip(): # Ph·∫£i c√≥ √≠t nh·∫•t 1 prompt t√≥m t·∫Øt
                        summary_prompt = dalle_prompts_list[0].strip()
                        # L·∫∑p l·∫°i prompt t√≥m t·∫Øt n√†y cho ƒë·ªß s·ªë l∆∞·ª£ng ·∫£nh ng∆∞·ªùi d√πng mu·ªën
                        prompts_for_api_calls = [summary_prompt] * num_images_total_requested_by_user
                        logging.info(f"{worker_log_prefix} Ch·∫ø ƒë·ªô Ti·∫øt ki·ªám: S·ª≠ d·ª•ng 1 prompt t√≥m t·∫Øt '{summary_prompt[:30]}...' cho {num_images_total_requested_by_user} ·∫£nh.")
                    else:
                        final_error_message_for_callback = "L·ªói: Ch·∫ø ƒë·ªô Ti·∫øt ki·ªám ƒë∆∞·ª£c b·∫≠t nh∆∞ng kh√¥ng c√≥ prompt t√≥m t·∫Øt t·ª´ GPT."
                        logging.error(f"{worker_log_prefix} {final_error_message_for_callback}")
                        raise ValueError(final_error_message_for_callback)
                else: # Kh√¥ng ph·∫£i ch·∫ø ƒë·ªô ti·∫øt ki·ªám
                    prompts_for_api_calls = [p.strip() for p in dalle_prompts_list if p.strip()]
                    if not prompts_for_api_calls: # N·∫øu sau khi strip kh√¥ng c√≤n prompt n√†o
                        final_error_message_for_callback = "L·ªói: GPT kh√¥ng tr·∫£ v·ªÅ prompt n√†o h·ª£p l·ªá sau khi chia c·∫£nh."
                        logging.error(f"{worker_log_prefix} {final_error_message_for_callback}")
                        raise ValueError(final_error_message_for_callback)
                    # Trong ch·∫ø ƒë·ªô kh√¥ng ti·∫øt ki·ªám, s·ªë ·∫£nh th·ª±c t·∫ø s·∫Ω b·∫±ng s·ªë prompt ƒë∆∞·ª£c t·∫°o
                    logging.info(f"{worker_log_prefix} Ch·∫ø ƒë·ªô Th∆∞·ªùng: S·ª≠ d·ª•ng {len(prompts_for_api_calls)} prompt chi ti·∫øt t·ª´ GPT. (Ng∆∞·ªùi d√πng y√™u c·∫ßu {num_images_total_requested_by_user} ·∫£nh, GPT ƒë√£ chia theo ƒë√≥).")
                
                total_images_to_actually_generate = len(prompts_for_api_calls) # S·ªë l·∫ßn g·ªçi API DALL-E th·ª±c t·∫ø
                if hasattr(master_app_ref, 'update_status'):
                     master_app_ref.after(0, lambda: master_app_ref.update_status(f"üé® DALL-E: Chu·∫©n b·ªã t·∫°o {total_images_to_actually_generate} ·∫£nh...")) #

                current_timestamp_dalle_iter = int(time.time()) #

                for i, current_dalle_prompt_text in enumerate(prompts_for_api_calls): #
                    prompt_index_for_log_and_file = i #
                    
                    # <<<--- B·∫ÆT ƒê·∫¶U TH√äM CHO B∆Ø·ªöC 2.3 ---<<<
                    if master_app_ref.stop_event.is_set(): #
                        logging.info(f"{worker_log_prefix} Y√™u c·∫ßu d·ª´ng t·ª´ ·ª©ng d·ª•ng (tr∆∞·ªõc khi t·∫°o ·∫£nh #{prompt_index_for_log_and_file + 1}).") #
                        _worker_stopped_by_user = True #
                        final_error_message_for_callback = "ƒê√£ h·ªßy b·ªüi ng∆∞·ªùi d√πng (DALL-E image gen loop)" #
                        break #
                    # <<<--- K·∫æT TH√öC TH√äM CHO B∆Ø·ªöC 2.3 ---<<<
                    
                    if master_app_ref.stop_event.is_set(): #
                        logging.info(f"{worker_log_prefix} Y√™u c·∫ßu d·ª´ng t·ª´ ·ª©ng d·ª•ng (tr∆∞·ªõc khi t·∫°o ·∫£nh #{prompt_index_for_log_and_file + 1}).") #
                        _worker_stopped_by_user = True #
                        final_error_message_for_callback = "ƒê√£ h·ªßy b·ªüi ng∆∞·ªùi d√πng (DALL-E image gen loop)" #
                        break #

                    # current_dalle_prompt_text ƒë√£ ƒë∆∞·ª£c strip() khi t·∫°o prompts_for_api_calls
                    # kh√¥ng c·∫ßn ki·ªÉm tra l·∫°i if not current_dalle_prompt_text.strip():

                    if hasattr(master_app_ref, 'update_status'): #
                        status_api_call_msg_iter = f"üé® PIU: ƒêang t·∫°o ·∫£nh... {prompt_index_for_log_and_file + 1}/{total_images_to_actually_generate}..." #
                        master_app_ref.after(0, lambda msg=status_api_call_msg_iter: master_app_ref.update_status(msg)) #

                    logging.info(f"{worker_log_prefix} G·ªçi API cho prompt #{prompt_index_for_log_and_file + 1}/{total_images_to_actually_generate}, Model: {selected_dalle_model}, Prompt: '{current_dalle_prompt_text[:50]}...'") #

                    generated_image_url_for_this_prompt = None #
                    try:
                        if selected_dalle_model == "dall-e-3": #
                            response = client.images.generate( #
                                model=selected_dalle_model, prompt=current_dalle_prompt_text, #
                                n=1, # DALL-E 3 lu√¥n t·∫°o 1 ·∫£nh m·ªói l·∫ßn g·ªçi v·ªõi prompt n√†y
                                size=size, #
                                quality=quality_setting, style=style_setting, #
                                response_format="url" #
                            )
                        else: # dall-e-2 #
                            response = client.images.generate( #
                                model=selected_dalle_model, prompt=current_dalle_prompt_text, #
                                n=1, # Gi·ªØ nguy√™n n=1 cho m·ªói l·∫ßn l·∫∑p ƒë·ªÉ ƒë∆°n gi·∫£n h√≥a, d√π DALL-E 2 c√≥ th·ªÉ t·∫°o nhi·ªÅu h∆°n
                                size=size, #
                                response_format="url" #
                            )

                        if response.data and response.data[0].url: #
                            generated_image_url_for_this_prompt = response.data[0].url #
                        else: #
                            logging.warning(f"{worker_log_prefix} API DALL-E kh√¥ng tr·∫£ v·ªÅ URL cho prompt #{prompt_index_for_log_and_file + 1}.") #
                            self._show_non_blocking_error_popup("L·ªói T·∫°o ·∫¢nh DALL-E", f"L·ªói t·∫°o ·∫£nh #{prompt_index_for_log_and_file + 1}:\n\nAPI kh√¥ng tr·∫£ v·ªÅ URL h√¨nh ·∫£nh.")
                            any_api_error_occurred = True #
                            continue #

                    except Exception as api_err_iter: #
                        logging.error(f"{worker_log_prefix} L·ªói API DALL-E cho prompt #{prompt_index_for_log_and_file + 1}: {api_err_iter}", exc_info=True) #
                        any_api_error_occurred = True #
                        continue #

                    if generated_image_url_for_this_prompt: #
                        if master_app_ref.stop_event.is_set(): #
                            _worker_stopped_by_user = True #
                            final_error_message_for_callback = "ƒê√£ h·ªßy b·ªüi ng∆∞·ªùi d√πng (DALL-E download loop)" #
                            break #

                        if hasattr(master_app_ref, 'update_status'): #
                            master_app_ref.after(0, lambda current_img=prompt_index_for_log_and_file+1, total_img=total_images_to_actually_generate: #
                                                 master_app_ref.update_status(f"üé® PIU: ƒêang t·∫£i ·∫£nh {current_img}/{total_img}...")) #
                        try:
                            img_response_iter = requests.get(generated_image_url_for_this_prompt, timeout=60) #
                            img_response_iter.raise_for_status() #

                            base_filename_part_iter = f"scene_{prompt_index_for_log_and_file:02d}" #
                            file_name_iter = f"dalle_{base_filename_part_iter}_{current_timestamp_dalle_iter}.png" #
                            file_path_iter = os.path.join(output_folder_for_images, file_name_iter) #

                            with open(file_path_iter, "wb") as f_iter: f_iter.write(img_response_iter.content) #
                            all_successfully_generated_image_paths.append(file_path_iter) #
                            logging.info(f"{worker_log_prefix} ƒê√£ l∆∞u ·∫£nh t·ª´ URL (Prompt #{prompt_index_for_log_and_file + 1}): {file_path_iter}") #
                        except Exception as download_err_iter: #
                            logging.error(f"{worker_log_prefix} L·ªói t·∫£i ·∫£nh DALL-E t·ª´ URL (Prompt #{prompt_index_for_log_and_file + 1}): {download_err_iter}") #

                            error_details_for_popup_dl = f"L·ªói t·∫£i ·∫£nh DALL-E #{prompt_index_for_log_and_file + 1}:\n\n{str(download_err_iter)[:500]}"
                            self._show_non_blocking_error_popup("L·ªói T·∫£i ·∫¢nh DALL-E", error_details_for_popup_dl)
                  
                            any_api_error_occurred = True #
                
                if not _worker_stopped_by_user: #
                    if any_api_error_occurred and all_successfully_generated_image_paths: #
                        final_error_message_for_callback = "M·ªôt s·ªë ·∫£nh DALL-E c√≥ th·ªÉ ƒë√£ g·∫∑p l·ªói khi t·∫°o ho·∫∑c t·∫£i." #
                    elif any_api_error_occurred and not all_successfully_generated_image_paths: #
                        final_error_message_for_callback = "L·ªói t·∫°o ho·∫∑c t·∫£i t·∫•t c·∫£ ·∫£nh DALL-E." #

            except (ValueError, ImportError) as e_setup: #
                logging.error(f"{worker_log_prefix} L·ªói thi·∫øt l·∫≠p DALL-E: {e_setup}") #
                if not final_error_message_for_callback: final_error_message_for_callback = str(e_setup) #
            except Exception as e_dalle_outer_iter: #
                logging.error(f"{worker_log_prefix} L·ªói kh√¥ng mong mu·ªën trong chu·ªói t·∫°o ·∫£nh DALL-E: {e_dalle_outer_iter}", exc_info=True) #
                if not final_error_message_for_callback: final_error_message_for_callback = f"L·ªói DALL-E kh√¥ng x√°c ƒë·ªãnh: {str(e_dalle_outer_iter)[:100]}" #
            
            finally: #
                if hasattr(master_app_ref, 'is_dalle_processing'): #
                    master_app_ref.is_dalle_processing = False #
                logging.debug(f"{worker_log_prefix} ƒê√£ k·∫øt th√∫c lu·ªìng _execute_dalle_chain_generation_iterative.") #
                
                self.after(0, self._handle_slideshow_creation_and_completion,
                           all_successfully_generated_image_paths,
                           script_for_slideshow_timing_next_step,
                           original_plain_gpt_text_for_dub_next_step,
                           output_folder_for_images,
                           target_textbox_widget_for_next_step,
                           gpt_context_for_next_step,
                           trigger_dub_chain_flag,
                           image_engine_name,
                           ai_script_engine_name,
                           base_filename_for_chain, # <<< TH√äM V√ÄO ƒê√ÇY
                           final_error_message_for_callback)
            


# H√†m trung gian: B·∫Øt ƒë·∫ßu lu·ªìng t·∫°o ·∫£nh v√† truy·ªÅn payload ch·ª©a timing ƒëi ti·∫øp.
    def _handle_image_generation_and_slideshow(self, payload, temp_output_folder, target_widget, 
                                               context, trigger_dub_chain_flag, image_engine_name, 
                                               ai_script_engine_name, base_filename_for_chain,
                                               output_dir_override=None):
        """
        H√†m trung gian: B·∫Øt ƒë·∫ßu lu·ªìng t·∫°o ·∫£nh v√† truy·ªÅn payload ch·ª©a timing ƒëi ti·∫øp.
        """
        log_prefix = f"[{image_engine_name}_GenAndShow]"
        image_prompts = payload.get("image_prompts", [])

        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu chu·ªói t·∫°o ·∫£nh. S·ªë prompts: {len(image_prompts)}")

        self.is_gemini_processing = False
        self.is_imagen_processing = True

        if not hasattr(self, 'start_time') or self.start_time is None:
            self.start_time = time.time()
        self.update_time_realtime()

        # B·∫Øt ƒë·∫ßu lu·ªìng worker t·∫°o ·∫£nh v√† truy·ªÅn to√†n b·ªô payload ƒëi
        thread = threading.Thread(
            target=self._execute_imagen_chain_generation_iterative,
            args=(
                image_prompts,
                len(image_prompts), # num_images_per_prompt s·∫Ω b·∫±ng t·ªïng s·ªë prompt
                self.cfg.get("imagen_last_aspect_ratio", "16:9"),
                temp_output_folder,
                payload, # <-- TRUY·ªÄN TO√ÄN B·ªò PAYLOAD
                payload, # Truy·ªÅn l·∫°i l·∫ßn n·ªØa cho tham s·ªë text dub
                target_widget,
                context, 
                trigger_dub_chain_flag,
                image_engine_name, 
                ai_script_engine_name,
                ImagenSettingsWindow.IMAGEN_ART_STYLES.get(self.cfg.get("imagen_last_style", ""), ""),
                base_filename_for_chain,
                self.cfg.get("imagen_last_negative_prompt", ""),
                output_dir_override # <<< TH√äM V√ÄO ƒê√ÇY
            ),
            daemon=True, name="ImagenChainGenerationThread"
        )
        thread.start()



# H√†m trung gian m·ªõi) Nh·∫≠n k·∫øt qu·∫£ t·ª´ b∆∞·ªõc t·∫°o ·∫£nh,
    def _handle_slideshow_creation_and_completion(self,
                                                  image_paths,
                                                  payload_from_previous_step,
                                                  original_plain_text_for_dub_ignored,
                                                  temp_output_folder,
                                                  target_widget, context,
                                                  trigger_dub_chain_flag,
                                                  image_engine_name,
                                                  ai_script_engine_name,
                                                  base_filename_for_chain,
                                                  error_message=None,
                                                  output_dir_override=None):
        """
        (PHI√äN B·∫¢N 9 - S·ª¨A L·ªñI T√çNH TO√ÅN T·ª∂ L·ªÜ CU·ªêI C√ôNG)
        - L·∫•y th·ªùi l∆∞·ª£ng ƒë·ªông ƒë√£ t√≠nh to√°n.
        - L·∫•y th·ªùi l∆∞·ª£ng TH·ª∞C T·∫æ t·ª´ k·ªãch b·∫£n g·ªëc.
        - D√πng th·ªùi l∆∞·ª£ng th·ª±c t·∫ø l√†m m·ª•c ti√™u ƒë·ªÉ co gi√£n t·ª∑ l·ªá m·ªôt c√°ch ch√≠nh x√°c.
        """
        log_prefix = f"[{image_engine_name}_SlideshowInit_v9_CorrectScaling]"
        
        if image_engine_name == "Imagen 3": self.is_imagen_processing = False
        elif image_engine_name == "DALL-E 3": self.is_dalle_processing = False

        # --- X·ª≠ l√Ω l·ªói ban ƒë·∫ßu ---
        if not image_paths:
            final_status_msg = error_message or f"Kh√¥ng t·∫°o ƒë∆∞·ª£c ·∫£nh {image_engine_name} n√†o."
            logging.error(f"{log_prefix} Th·∫•t b·∫°i ho√†n to√†n: {final_status_msg}")
            self.update_status(f"‚ùå L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ t·∫°o ·∫£nh.")
            
            # --- THAY ƒê·ªîI CH√çNH N·∫∞M ·ªû ƒê√ÇY ---
            if self.is_ai_batch_processing:
                # N·∫øu ƒëang trong l√¥, hi·ªÉn th·ªã popup kh√¥ng ch·∫∑n v√† ti·∫øp t·ª•c
                error_details = (
                    f"L·ªói x·ª≠ l√Ω file v·ªõi key '{base_filename_for_chain}':\n\n"
                    f"Kh√¥ng th·ªÉ t·∫°o b·∫•t k·ª≥ ·∫£nh n√†o t·ª´ k·ªãch b·∫£n n√†y.\n\n"
                    f"L·ªói: {final_status_msg}\n\n"
                    "·ª®ng d·ª•ng s·∫Ω t·ª± ƒë·ªông b·ªè qua v√† ti·∫øp t·ª•c v·ªõi file sau."
                )
                self._show_non_blocking_error_popup(f"L·ªói T·∫°o ·∫¢nh ({image_engine_name})", error_details)
                self.after(100, self._process_next_ai_batch_item)
            else:
                # N·∫øu l√† t√°c v·ª• ƒë∆°n l·∫ª, v·∫´n gi·ªØ l·∫°i messagebox ch·∫∑n ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt ngay
                if error_message:
                    messagebox.showwarning(f"L·ªói t·∫°o ·∫£nh {image_engine_name}", f"Qu√° tr√¨nh t·∫°o ·∫£nh g·∫∑p l·ªói nghi√™m tr·ªçng v√† kh√¥ng t·∫°o ƒë∆∞·ª£c file n√†o:\n{error_message}", parent=self)
                self._check_completion_and_shutdown()
            return

        logging.info(f"{log_prefix} Nh·∫≠n ƒë∆∞·ª£c {len(image_paths)} ·∫£nh th√†nh c√¥ng.")
        if error_message:
            logging.warning(f"{log_prefix} C√≥ l·ªói khi t·∫°o ·∫£nh nh∆∞ng v·∫´n c√≥ ·∫£nh th√†nh c√¥ng. S·∫Ω ph√¢n b·ªï l·∫°i th·ªùi gian.")
            self.update_status(f"‚ö†Ô∏è T·∫°o slideshow (thi·∫øu ·∫£nh, ƒëang ph√¢n b·ªï l·∫°i th·ªùi gian)...")
        else:
            self.update_status(f"‚úÖ {image_engine_name} t·∫°o xong {len(image_paths)} ·∫£nh. Chu·∫©n b·ªã slideshow...")
            
        
        ### --- PH·∫¶N LOGIC TIMING HO√ÄN CH·ªàNH --- ###
        
        # 1. L·∫•y d·ªØ li·ªáu g·ªëc t·ª´ payload
        original_prompts = payload_from_previous_step.get("image_prompts", [])
        estimated_scene_durations_s = [float(d) for d in payload_from_previous_step.get("image_durations_seconds", [])]
        original_srt_text = payload_from_previous_step.get("original_full_srt_for_hardsub", "")

        # 2. T√≠nh T·ªîNG TH·ªúI L∆Ø·ª¢NG TH·ª∞C T·∫æ t·ª´ k·ªãch b·∫£n g·ªëc
        original_timed_segments = self._parse_plain_text_to_srt_data(original_srt_text)
        true_total_duration_s = 0.0
        if original_timed_segments:
            true_total_duration_s = (original_timed_segments[-1]['end_ms'] - original_timed_segments[0]['start_ms']) / 1000.0
        
        if true_total_duration_s <= 0:
            logging.error(f"{log_prefix} L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ t√≠nh ƒë∆∞·ª£c th·ªùi l∆∞·ª£ng th·ª±c t·∫ø t·ª´ k·ªãch b·∫£n g·ªëc.")
            self._check_completion_and_shutdown()
            return
        logging.info(f"{log_prefix} Th·ªùi l∆∞·ª£ng th·ª±c t·∫ø t·ª´ k·ªãch b·∫£n g·ªëc: {true_total_duration_s:.3f}s")
        
        # 3. L·ªçc ra th·ªùi l∆∞·ª£ng c·ªßa c√°c c·∫£nh ƒë√£ ƒë∆∞·ª£c t·∫°o ·∫£nh th√†nh c√¥ng
        successful_indices = set()
        for img_path in image_paths:
            match = re.search(r'chain_(\d{3,})_', os.path.basename(img_path))
            if match: successful_indices.add(int(match.group(1)))

        base_image_durations_seconds = [] # Th·ªùi l∆∞·ª£ng ∆∞·ªõc t√≠nh ch·ªâ c·ªßa c√°c c·∫£nh th√†nh c√¥ng
        for i, duration in enumerate(estimated_scene_durations_s):
            if i in successful_indices:
                base_image_durations_seconds.append(duration)
        
        if len(base_image_durations_seconds) != len(image_paths):
            logging.error(f"{log_prefix} L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ kh·ªõp ·∫£nh th√†nh c√¥ng v·ªõi th·ªùi l∆∞·ª£ng c·ªßa ch√∫ng.")
            self._check_completion_and_shutdown()
            return

        # 4. T√≠nh to√°n t·ªïng h·ª£p v√† co gi√£n t·ª∑ l·ªá
        num_images = len(image_paths)
        padding_duration_s = 3.0
        crossfade_duration_s = 1.0
        
        # ### S·ª¨A L·ªñI ·ªû ƒê√ÇY: D√πng `true_total_duration_s` l√†m c∆° s·ªü ###
        final_video_target_duration_s = true_total_duration_s + padding_duration_s
        
        crossfade_compensation_s = (num_images - 1) * crossfade_duration_s if num_images > 1 else 0
        total_duration_to_distribute = final_video_target_duration_s + crossfade_compensation_s
        
        total_estimated_duration_s = sum(base_image_durations_seconds)
        
        scaling_factor = 1.0
        if total_estimated_duration_s > 0:
            scaling_factor = total_duration_to_distribute / total_estimated_duration_s
        
        actual_image_durations_list_for_ffmpeg = [d * scaling_factor for d in base_image_durations_seconds]
        
        logging.info(f"{log_prefix} Th·ªùi l∆∞·ª£ng m·ª•c ti√™u cu·ªëi c√πng (ƒë√£ padding): {final_video_target_duration_s:.3f}s")
        logging.info(f"{log_prefix} H·ªá s·ªë co gi√£n (Scaling Factor): {scaling_factor:.4f}")
        logging.info(f"{log_prefix} Th·ªùi l∆∞·ª£ng cu·ªëi c√πng cho FFmpeg: {[f'{d:.3f}' for d in actual_image_durations_list_for_ffmpeg]}")
        ### --- K·∫æT TH√öC PH·∫¶N LOGIC TIMING --- ###

        # Ph·∫ßn c√≤n l·∫°i c·ªßa h√†m gi·ªØ nguy√™n
        slideshow_resolution = self.cfg.get("dalle_slideshow_resolution_setting", "1920x1080")
        slideshow_fps = self.cfg.get("dalle_slideshow_fps_setting", 25)
        safe_script_engine = ai_script_engine_name.lower().replace(' ', '_')
        safe_image_engine = image_engine_name.replace(' ', '_').lower()
        temp_slideshow_video_filename = f"slideshow_{safe_script_engine}_{safe_image_engine}_{uuid.uuid4().hex[:8]}.mp4"
        temp_slideshow_video_output_path = os.path.join(temp_output_folder, temp_slideshow_video_filename)
        
        self.is_creating_slideshow = True
        self.update_time_realtime()

        thread_slideshow = threading.Thread(
            target=self._execute_slideshow_creation_chain,
            args=(
                image_paths, temp_slideshow_video_output_path, slideshow_resolution,
                slideshow_fps, 
                actual_image_durations_list_for_ffmpeg,
                None,
                original_srt_text,
                payload_from_previous_step.get("original_plain_text_for_dub", ""),
                None,
                temp_output_folder, context, target_widget, trigger_dub_chain_flag,
                image_engine_name, ai_script_engine_name, base_filename_for_chain, output_dir_override
            ),
            daemon=True, name="SlideshowCreationChainThread_Final"
        )
        thread_slideshow.start()



# H√†m n√†y s·∫Ω ch·ªãu tr√°ch nhi·ªám:L·∫•y danh s√°ch ƒë∆∞·ªùng d·∫´n ·∫£nh DALL-E.X√°c ƒë·ªãnh th·ªùi l∆∞·ª£ng cho slideshow...
    def _start_slideshow_from_images(self,
                                           dalle_image_paths,
                                           script_for_slideshow_timing,         
                                           original_plain_gpt_text_for_dub,   
                                           original_video_path,              
                                           temp_dalle_output_folder,
                                           gpt_context,
                                           target_textbox_widget,
                                           trigger_dub_chain_flag=False):
        log_prefix_slideshow = f"[Chain_Slideshow_From_DALL-E:{gpt_context}]" #
        logging.info(f"{log_prefix_slideshow} B·∫Øt ƒë·∫ßu t·∫°o slideshow t·ª´ {len(dalle_image_paths)} ·∫£nh DALL-E. Trigger Dub: {trigger_dub_chain_flag}") #
        # Th√™m log cho c√°c tham s·ªë script m·ªõi
        logging.info(f"{log_prefix_slideshow}   Script cho slideshow timing (nh·∫≠n ƒë∆∞·ª£c, d√†i {len(script_for_slideshow_timing)} chars): '{script_for_slideshow_timing[:50].replace(chr(10),' ')}...'")
        logging.info(f"{log_prefix_slideshow}   Plain text g·ªëc cho dub (nh·∫≠n ƒë∆∞·ª£c, d√†i {len(original_plain_gpt_text_for_dub)} chars): '{original_plain_gpt_text_for_dub[:50].replace(chr(10),' ')}...'")

        self.update_status(f"üéû ƒêang chu·∫©n b·ªã t·∫°o slideshow t·ª´ {len(dalle_image_paths)} ·∫£nh DALL-E...") #

        if not dalle_image_paths: #
            logging.warning(f"{log_prefix_slideshow} Kh√¥ng c√≥ ·∫£nh DALL-E ƒë·ªÉ t·∫°o slideshow.") #
            self.update_status("‚ö†Ô∏è L·ªói: Kh√¥ng c√≥ ·∫£nh DALL-E ƒë·ªÉ t·∫°o slideshow.") #
            if temp_dalle_output_folder and os.path.isdir(temp_dalle_output_folder): #
                try:
                    shutil.rmtree(temp_dalle_output_folder) #
                    logging.info(f"{log_prefix_slideshow} ƒê√£ x√≥a th∆∞ m·ª•c t·∫°m DALL-E (kh√¥ng c√≥ ·∫£nh): {temp_dalle_output_folder}") #
                except Exception as e_clean:
                    logging.warning(f"{log_prefix_slideshow} L·ªói x√≥a th∆∞ m·ª•c t·∫°m DALL-E '{temp_dalle_output_folder}': {e_clean}") #
            # K√≠ch ho·∫°t l·∫°i n√∫t GPT (b·∫°n c·∫ßn th√™m logic n√†y n·∫øu c√≥, t∆∞∆°ng t·ª± nh∆∞ trong _handle_dalle_chain_completion)
            return #

        # S·ª≠ d·ª•ng script_for_slideshow_timing ƒë·ªÉ parse v√† t√≠nh to√°n th·ªùi l∆∞·ª£ng
        slideshow_timing_data = self._parse_plain_text_to_srt_data(script_for_slideshow_timing) #
        actual_image_durations_list_for_ffmpeg = [] #
        total_slideshow_duration_s_from_script = 0.0 #

        if slideshow_timing_data: #
            try:
                last_segment = max(slideshow_timing_data, key=lambda x: x.get('end_ms', 0), default=None) #
                if last_segment and last_segment.get('end_ms', 0) > 0: #
                    total_slideshow_duration_s_from_script = last_segment['end_ms'] / 1000.0 #
                    logging.info(f"{log_prefix_slideshow} T·ªïng th·ªùi l∆∞·ª£ng slideshow t·ª´ k·ªãch b·∫£n: {total_slideshow_duration_s_from_script:.2f}s") #

                    num_dalle_images = len(dalle_image_paths) #
                    if num_dalle_images > 0 and total_slideshow_duration_s_from_script > 0: #
                        # ƒê·∫£m b·∫£o DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_CHAIN ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü ƒë√¢y ho·∫∑c l√† h·∫±ng s·ªë c·ªßa l·ªõp
                        DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_CHAIN_LOCAL = 0.7 # Ho·∫∑c self.DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_CHAIN
                        if num_dalle_images == 1 and total_slideshow_duration_s_from_script > (DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_CHAIN_LOCAL + 0.1): #
                            duration_for_original_image_s_chain = total_slideshow_duration_s_from_script - DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_CHAIN_LOCAL #
                            duration_for_original_image_s_chain = max(0.1, duration_for_original_image_s_chain) #
                            actual_image_durations_list_for_ffmpeg = [duration_for_original_image_s_chain, DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_CHAIN_LOCAL] #
                        elif num_dalle_images == 1: #
                             actual_image_durations_list_for_ffmpeg = [max(0.04, total_slideshow_duration_s_from_script)] #
                        else: #
                            duration_per_image_s_chain = total_slideshow_duration_s_from_script / float(num_dalle_images) #
                            safe_duration_per_image_s_chain = max(0.04, duration_per_image_s_chain) #
                            actual_image_durations_list_for_ffmpeg = [safe_duration_per_image_s_chain] * num_dalle_images #
                        logging.info(f"{log_prefix_slideshow} Th·ªùi l∆∞·ª£ng t·ª´ng ·∫£nh DALL-E cho slideshow: {actual_image_durations_list_for_ffmpeg}") #
                    else: #
                        logging.warning(f"{log_prefix_slideshow} Kh√¥ng th·ªÉ ph√¢n b·ªï th·ªùi gian (s·ªë ·∫£nh={num_dalle_images}, duration script={total_slideshow_duration_s_from_script}). D√πng m·∫∑c ƒë·ªãnh.") #
            except Exception as e_timing: #
                logging.error(f"{log_prefix_slideshow} L·ªói khi t√≠nh to√°n th·ªùi l∆∞·ª£ng t·ª´ k·ªãch b·∫£n: {e_timing}") #
        else: #
            logging.warning(f"{log_prefix_slideshow} Kh√¥ng parse ƒë∆∞·ª£c d·ªØ li·ªáu timing t·ª´ k·ªãch b·∫£n GPT.") #

        if not actual_image_durations_list_for_ffmpeg: #
            default_duration_per_image = 3.0 #
            actual_image_durations_list_for_ffmpeg = [default_duration_per_image] * len(dalle_image_paths) #
            total_slideshow_duration_s_from_script = sum(actual_image_durations_list_for_ffmpeg) #
            logging.info(f"{log_prefix_slideshow} S·ª≠ d·ª•ng th·ªùi l∆∞·ª£ng m·∫∑c ƒë·ªãnh cho slideshow: {default_duration_per_image}s/·∫£nh. T·ªïng: {total_slideshow_duration_s_from_script:.2f}s") #

        temp_slideshow_video_filename = f"slideshow_gpt_dalle_{uuid.uuid4().hex[:8]}.mp4" #
        temp_slideshow_video_output_path = os.path.join(temp_dalle_output_folder, temp_slideshow_video_filename) #

        slideshow_resolution = self.cfg.get("dalle_slideshow_resolution_setting", "1920x1080") #
        slideshow_fps = self.cfg.get("dalle_slideshow_fps_setting", 25) 

        self.is_creating_slideshow = True 
        self.update_time_realtime()

        image_paths_for_ffmpeg_chain = list(dalle_image_paths) 
        duplicated_dalle_image_path_temp = None 

        if len(dalle_image_paths) == 1 and len(actual_image_durations_list_for_ffmpeg) == 2: #
            original_single_dalle_img_path = dalle_image_paths[0] #
            base_dalle, ext_dalle = os.path.splitext(os.path.basename(original_single_dalle_img_path)) #
            duplicated_dalle_image_path_temp = os.path.join(temp_dalle_output_folder, f"dalle_dup_{base_dalle}_{int(time.time())}{ext_dalle}") #
            try:
                shutil.copy2(original_single_dalle_img_path, duplicated_dalle_image_path_temp) #
                image_paths_for_ffmpeg_chain.append(duplicated_dalle_image_path_temp) #
                logging.info(f"{log_prefix_slideshow} ƒê√£ nh√¢n b·∫£n ·∫£nh DALL-E ƒë∆°n l·∫ª cho slideshow (s·∫Ω x·ª≠ l√Ω nh∆∞ 2 ·∫£nh).") #
            except Exception as e_copy_dalle_dup: #
                logging.error(f"{log_prefix_slideshow} L·ªói nh√¢n b·∫£n ·∫£nh DALL-E: {e_copy_dalle_dup}. S·∫Ω d√πng 1 ·∫£nh.") #
                image_paths_for_ffmpeg_chain = list(dalle_image_paths) #
                actual_image_durations_list_for_ffmpeg = [sum(actual_image_durations_list_for_ffmpeg)] #
                duplicated_dalle_image_path_temp = None #

        # S·ª≠a h√†m _execute_slideshow_creation_chain ƒë·ªÉ nh·∫≠n th√™m original_plain_gpt_text_for_dub
        thread_slideshow = threading.Thread( #
            target=self._execute_slideshow_creation_chain, #
            args=( #
                image_paths_for_ffmpeg_chain,                 # 1. image_paths
                temp_slideshow_video_output_path,             # 2. slideshow_output_path
                slideshow_resolution,                         # 3. resolution
                slideshow_fps,                                # 4. fps
                actual_image_durations_list_for_ffmpeg,       # 5. image_durations_s
                duplicated_dalle_image_path_temp,             # 6. duplicated_dalle_image_path_temp
                script_for_slideshow_timing,                  # 7. Script d√πng cho merge (ƒë√¢y l√† script_for_slideshow_timing)
                original_plain_gpt_text_for_dub,              # << 8. TRUY·ªÄN PLAIN TEXT G·ªêC V√ÄO ƒê√ÇY
                original_video_path,                          # << 9. original_video_for_merge (gi·ªØ nguy√™n t√™n g·ªëc t·ª´ file b·∫°n cung c·∫•p)
                temp_dalle_output_folder,                     # << 10. temp_dalle_folder_for_cleanup
                gpt_context,                                  # << 11. gpt_context_for_merge
                target_textbox_widget,                        # << 12. target_textbox_widget_for_merge
                trigger_dub_chain_flag                        # << 13. trigger_dub_chain_flag (t√πy ch·ªçn)
            ),
            daemon=True, #
            name="SlideshowFromDalleThread" #
        )
        thread_slideshow.start() #


# H√†m n√†y s·∫Ω nh·∫≠n k·∫øt qu·∫£ t·ª´ _execute_slideshow_creation_chain.
    def _handle_slideshow_chain_completion(self,
                                           slideshow_video_path,
                                           script_for_merge,
                                           original_plain_text_for_dub,
                                           temp_output_folder_to_cleanup,
                                           context,
                                           target_textbox_widget,
                                           trigger_dub_chain_flag,
                                           image_engine_name,
                                           ai_script_engine_name,
                                           base_filename_for_chain,
                                           slideshow_error_message=None,
                                           output_dir_override=None):
        """
        (PHI√äN B·∫¢N S·ª¨A L·ªñI TIMEOUT)
        X·ª≠ l√Ω sau khi slideshow ƒë∆∞·ª£c t·∫°o. N·∫øu c√≥ l·ªói (bao g·ªìm c·∫£ timeout),
        s·∫Ω ki·ªÉm tra xem c√≥ ƒëang ch·∫°y batch kh√¥ng ƒë·ªÉ t·ª± ƒë·ªông chuy·ªÉn sang t√°c v·ª• ti·∫øp theo.
        """
        log_prefix_hsc = f"[Chain_HandleSlideshowComplete_v10_TimeoutFix:{context}]"
        logging.info(f"{log_prefix_hsc} Ho√†n t·∫•t t·∫°o slideshow. Path: {slideshow_video_path}, Error: {slideshow_error_message}, Trigger Dub: {trigger_dub_chain_flag}")

        # T·∫Øt c·ªù x·ª≠ l√Ω c·ªßa b∆∞·ªõc t·∫°o ·∫£nh/slideshow
        if image_engine_name == "Imagen 3": self.is_imagen_processing = False
        elif image_engine_name == "DALL-E 3": self.is_dalle_processing = False
        self.is_creating_slideshow = False

        # --- X·ª¨ L√ù L·ªñI (BAO G·ªíM C·∫¢ TIMEOUT) ---
        if slideshow_error_message or not slideshow_video_path:
            final_status_msg = slideshow_error_message or f"Kh√¥ng t·∫°o ƒë∆∞·ª£c video slideshow t·ª´ ·∫£nh."
            logging.error(f"{log_prefix_hsc} Th·∫•t b·∫°i ho√†n to√†n: {final_status_msg}")
            self.update_status(f"‚ùå L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ t·∫°o video slideshow.")

            # KI·ªÇM TRA XEM C√ì ƒêANG TRONG M·ªòT H√ÄNG CH·ªú N√ÄO KH√îNG
            is_in_any_batch_queue = self.is_ai_batch_processing or self.is_manual_sub_processing

            if is_in_any_batch_queue:
                # N·∫øu ƒëang trong m·ªôt l√¥, hi·ªÉn th·ªã l·ªói kh√¥ng ch·∫∑n v√† ti·∫øp t·ª•c
                error_details = f"L·ªói x·ª≠ l√Ω file v·ªõi key '{base_filename_for_chain}':\n\n{final_status_msg}\n\nB·ªè qua v√† ti·∫øp t·ª•c file sau."
                self._show_non_blocking_error_popup(
                    "L·ªói T·∫°o Slideshow", 
                    error_details,
                    failed_item_identifier=base_filename_for_chain # Th√™m d√≤ng n√†y
                )                
                # QUY·∫æT ƒê·ªäNH H√ÄM N√ÄO S·∫º ƒê∆Ø·ª¢C G·ªåI ƒê·ªÇ TI·∫æP T·ª§C
                if self.is_ai_batch_processing:
                    logging.info(f"{log_prefix_hsc} L·ªói x·∫£y ra trong L√¥ AI. Chuy·ªÉn sang m·ª•c ti·∫øp theo.")
                    self.after(100, self._process_next_ai_batch_item)
                elif self.is_manual_sub_processing:
                    logging.info(f"{log_prefix_hsc} L·ªói x·∫£y ra trong L√¥ Th·ªß c√¥ng. Chuy·ªÉn sang m·ª•c ti·∫øp theo.")
                    # C·∫ßn x·ª≠ l√Ω t∆∞∆°ng t·ª±, v√≠ d·ª•: g·ªçi _process_next_manual_sub_task
                    # ƒê·ªÉ ƒë∆°n gi·∫£n, ta s·∫Ω g·ªçi h√†m x·ª≠ l√Ω ho√†n th√†nh c·ªßa task th·ªß c√¥ng
                    task_id = original_context_data.get('id') if isinstance(original_context_data, dict) else None
                    self.after(100, self._handle_manual_task_completion, task_id, False, None, final_status_msg)

            else: # N·∫øu kh√¥ng ph·∫£i trong l√¥ n√†o (t√°c v·ª• ƒë∆°n l·∫ª)
                messagebox.showerror(f"L·ªói t·∫°o Slideshow", f"Qu√° tr√¨nh t·∫°o slideshow g·∫∑p l·ªói nghi√™m tr·ªçng:\n{final_status_msg}", parent=self)
                self._check_completion_and_shutdown()
            return # D·ª´ng h√†m ·ªü ƒë√¢y v√¨ ƒë√£ c√≥ l·ªói

        self.update_status(f"üéû Slideshow t·∫°o xong! Chu·∫©n b·ªã hardsub k·ªãch b·∫£n...")
        logging.info(f"{log_prefix_hsc} Slideshow: {slideshow_video_path}. Chu·∫©n b·ªã hardsub k·ªãch b·∫£n.")

        temp_srt_for_hardsub_path = None
        try:
            srt_filename = f"{ai_script_engine_name}_script_for_hardsub_{uuid.uuid4().hex[:8]}.srt"
            temp_srt_for_hardsub_path = os.path.join(self.temp_folder, srt_filename)
            
            # S·ª≠ d·ª•ng c·∫•u h√¨nh chia d√≤ng t·ª´ UI ƒë·ªÉ ƒë·ªãnh d·∫°ng l·∫°i k·ªãch b·∫£n
            split_cfg_for_hardsub = {
                "split_enabled": self.enable_split_var.get(),
                "mode": self.split_mode_var.get(),
                "max_chars": safe_int(self.max_chars_var.get(), 90),
                "max_lines": safe_int(self.max_lines_var.get(), 1),
                "DEFAULT_CPS_FOR_TIMING": safe_int(self.sub_cps_for_timing_var.get(), 17),
                "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1,
                "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
            }
            logging.info(f"{log_prefix_hsc} S·ª≠ d·ª•ng c·∫•u h√¨nh chia d√≤ng t·ª´ UI cho hardsub: {split_cfg_for_hardsub}")
            
            # Lu√¥n x·ª≠ l√Ω script nh∆∞ plain text ƒë·ªÉ √°p d·ª•ng c·∫•u h√¨nh chia d√≤ng
            srt_blocks_for_file = self._parse_plain_text_to_srt_data(
                script_for_merge, 
                force_plain_text_processing=False,
                split_config_override=split_cfg_for_hardsub
            )
            
            if not srt_blocks_for_file:
                raise ValueError("Kh√¥ng th·ªÉ t·∫°o d·ªØ li·ªáu SRT t·ª´ k·ªãch b·∫£n (cho hardsub).")
            
            srt_content_to_write_for_hardsub = format_srt_data_to_string(srt_blocks_for_file)

            with open(temp_srt_for_hardsub_path, "w", encoding="utf-8") as f_srt:
                f_srt.write(srt_content_to_write_for_hardsub)
            logging.info(f"{log_prefix_hsc} ƒê√£ l∆∞u k·ªãch b·∫£n v√†o file SRT t·∫°m cho hardsub: {temp_srt_for_hardsub_path}")

        except Exception as e_save_srt:
            logging.error(f"{log_prefix_hsc} L·ªói khi l∆∞u k·ªãch b·∫£n ra file SRT t·∫°m: {e_save_srt}", exc_info=True)
            self.update_status(f"‚ö†Ô∏è L·ªói t·∫°o file SRT t·ª´ k·ªãch b·∫£n.")
            self._check_completion_and_shutdown()
            return

        # T·∫°o m·ªôt dictionary ng·ªØ c·∫£nh ƒë·ªÉ truy·ªÅn v√†o lu·ªìng hardsub
        context_for_hardsub = {
            "image_engine_name": image_engine_name,
            "ai_script_engine_name": ai_script_engine_name
        }

        self.is_subbing = True # ƒê·∫∑t c·ªù n√†y v√¨ hardsub l√† m·ªôt ph·∫ßn c·ªßa quy tr√¨nh sub
        self.update_time_realtime()
        
        thread_hardsub = threading.Thread(
            target=self._execute_hardsub_chain,
            args=(slideshow_video_path,
                  temp_srt_for_hardsub_path,
                  original_plain_text_for_dub,
                  temp_output_folder_to_cleanup,
                  context,
                  target_textbox_widget,
                  trigger_dub_chain_flag,
                  context_for_hardsub,
                  base_filename_for_chain,
                  output_dir_override),
            daemon=True,
            name="HardsubChainThread"
        )
        thread_hardsub.start()


# H√†m worker ƒë·ªÉ g·ªçi self.burn_sub_to_video.
    def _execute_hardsub_chain(self, slideshow_video_path_hs, temp_srt_path_hs,
                               original_plain_text_for_dub,
                               temp_output_folder_hs,
                               context,
                               target_textbox_widget,
                               trigger_dub_chain_flag=False,
                               branding_context_data=None,
                               base_filename_for_chain=None,
                               output_dir_override=None):
        """
        Worker thread: Th·ª±c hi·ªán hardsub, t·ª± ƒë·ªông t·∫°o t√™n file output v√† x·ª≠ l√Ω logic chu·ªói.
        (S·ª¨A L·ªñI: Lo·∫°i b·ªè gh√©p t√™n engine b·ªã l·∫∑p)
        """
        log_prefix_exec_hs = f"[Chain_ExecHardsub:{context}]"
        hardsub_success = False
        final_error_message_hs = None
        saved_srt_path_for_next_step = None
        final_output_path_hs = None # S·∫Ω ƒë∆∞·ª£c t·∫°o ·ªü ƒë√¢y

        try:
            # === LOGIC T·∫†O T√äN FILE ƒê·ªòNG ===
            # ∆Øu ti√™n th∆∞ m·ª•c override t·ª´ chu·ªói AI, n·∫øu kh√¥ng c√≥ th√¨ m·ªõi d√πng th∆∞ m·ª•c chung
            if output_dir_override and os.path.isdir(output_dir_override):
                output_directory_for_hs = output_dir_override
                logging.info(f"Hardsub: S·ª≠ d·ª•ng th∆∞ m·ª•c output t·ª´ chu·ªói AI: {output_directory_for_hs}")
            else:
                output_directory_for_hs = self.output_path_var.get()
                if not output_directory_for_hs or not os.path.isdir(output_directory_for_hs):
                    output_directory_for_hs = self.get_default_downloads_folder()
                logging.info(f"Hardsub: S·ª≠ d·ª•ng th∆∞ m·ª•c output chung t·ª´ UI: {output_directory_for_hs}")

            # S·ª≠ d·ª•ng "th·∫ª t√™n" ƒë√£ truy·ªÅn v√†o. N·∫øu kh√¥ng c√≥ (tr∆∞·ªùng h·ª£p c≈©), fallback v·ªÅ logic c≈©.
            base_name_for_final_file = base_filename_for_chain if base_filename_for_chain else os.path.splitext(os.path.basename(slideshow_video_path_hs))[0]

            # L√†m s·∫°ch t√™n file cu·ªëi c√πng
            safe_output_base_name = create_safe_filename(base_name_for_final_file, remove_accents=False, max_length=150)
            if not safe_output_base_name:
                safe_output_base_name = f"piu_video_{uuid.uuid4().hex[:6]}" # Fallback n·∫øu t√™n qu√° t·ªá

            final_hardsub_video_filename = f"{safe_output_base_name}_hardsub.mp4"
            final_output_path_hs = os.path.join(output_directory_for_hs, final_hardsub_video_filename)

            cfg_snapshot_hs = self._get_config_snapshot()
            self.after(0, lambda: self.update_status(f"üéû ƒêang hardsub k·ªãch b·∫£n v√†o video..."))
            self.burn_sub_to_video(slideshow_video_path_hs, temp_srt_path_hs, final_output_path_hs, cfg_snapshot_hs)

            if os.path.exists(final_output_path_hs) and os.path.getsize(final_output_path_hs) > 1000:
                hardsub_success = True
                logging.info(f"{log_prefix_exec_hs} Hardsub video th√†nh c√¥ng: {final_output_path_hs}")

                if temp_srt_path_hs and os.path.exists(temp_srt_path_hs):
                    try:
                        video_output_basename_no_ext = os.path.splitext(os.path.basename(final_output_path_hs))[0]
                        srt_final_filename = f"{video_output_basename_no_ext}.srt"
                        output_directory_for_srt = os.path.dirname(final_output_path_hs)
                        saved_srt_path_for_next_step = os.path.join(output_directory_for_srt, srt_final_filename)
                        shutil.copy2(temp_srt_path_hs, saved_srt_path_for_next_step)
                        logging.info(f"{log_prefix_exec_hs} ƒê√£ t·ª± ƒë·ªông l∆∞u file SRT (t·ª´ hardsub) v√†o: {saved_srt_path_for_next_step}")
                    except Exception as e_save_srt_final:
                        logging.error(f"{log_prefix_exec_hs} L·ªói khi t·ª± ƒë·ªông l∆∞u file SRT sau hardsub: {e_save_srt_final}")
                        saved_srt_path_for_next_step = None
            else:
                final_error_message_hs = "L·ªói hardsub: File video output kh√¥ng ƒë∆∞·ª£c t·∫°o ho·∫∑c r·ªóng."
                logging.error(f"{log_prefix_exec_hs} {final_error_message_hs}")
                hardsub_success = False

        except Exception as e_hardsub:
            final_error_message_hs = f"L·ªói trong qu√° tr√¨nh hardsub: {e_hardsub}"
            logging.error(f"{log_prefix_exec_hs} {final_error_message_hs}", exc_info=True)
            hardsub_success = False
        finally:
            if temp_srt_path_hs and os.path.exists(temp_srt_path_hs):
                try:
                    os.remove(temp_srt_path_hs)
                except Exception:
                    pass

            actual_final_video_path_cb = final_output_path_hs if hardsub_success else None
            image_engine_name = branding_context_data.get('image_engine_name', 'dalle')
            ai_script_engine_name = branding_context_data.get('ai_script_engine_name', 'gpt')
            
            self.after(0, self._handle_final_chain_completion,
                       actual_final_video_path_cb,
                       saved_srt_path_for_next_step,
                       original_plain_text_for_dub,
                       temp_output_folder_hs,
                       context,
                       target_textbox_widget,
                       final_error_message_hs,
                       trigger_dub_chain_flag,
                       image_engine_name,
                       ai_script_engine_name,
                       base_filename_for_chain)


# H√†m n√†y s·∫Ω ch·ª©a logic g·ªçi _ffmpeg_create_slideshow v√† sau ƒë√≥ l√† callback cho b∆∞·ªõc "gh√©p video".
    def _execute_slideshow_creation_chain(self,
                                              image_paths,
                                              slideshow_output_path,
                                              resolution,
                                              fps,
                                              image_durations_s,
                                              duplicated_dalle_image_path_temp,
                                              script_for_merge_and_timing,
                                              original_plain_text_for_dub,
                                              original_video_for_merge,
                                              temp_dalle_folder_for_cleanup,
                                              gpt_context_for_merge,
                                              target_textbox_widget_for_merge,
                                              trigger_dub_chain_flag=False,
                                              image_engine_name="AI",
                                              ai_script_engine_name="AI",
                                              base_filename_for_chain=None,
                                              output_dir_override=None):
        """
        (PHI√äN B·∫¢N N√ÇNG C·∫§P)
        H√†m ƒëi·ªÅu ph·ªëi t·∫°o slideshow, t·ª± ƒë·ªông ch·ªçn gi·ªØa vi·ªác t·∫°o tƒ©nh (chunking)
        ho·∫∑c t·∫°o chuy·ªÉn ƒë·ªông (chunking n·∫øu c·∫ßn) d·ª±a tr√™n c√†i ƒë·∫∑t.
        """
        with keep_awake("Batch slideshow chain"):  # <<< KEEP-AWAKE START

            worker_log_prefix = f"[{threading.current_thread().name}_SlideshowChainOrchestrator]"
            logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu. S·ªë ·∫£nh: {len(image_paths)}, Engine: {image_engine_name}")

            slideshow_success = False
            final_output_video_path_for_slideshow = None
            temp_files_created_in_thread = []

            try:
                motion_effect_choice = self.cfg.get("imagen_motion_effect", "Kh√¥ng c√≥")
                
                # --- Nh√°nh 1: T·∫†O SLIDESHOW Tƒ®NH (Logic c≈© c·ªßa b·∫°n, kh√¥ng ƒë·ªïi) ---
                if motion_effect_choice == "Kh√¥ng c√≥":
                    logging.info(f"{worker_log_prefix} G·ªçi h√†m slideshow Tƒ®NH (_ffmpeg_create_slideshow) v·ªõi chunking.")
                    try:
                        CHUNK_SIZE = 25
                        image_chunks = [image_paths[i:i + CHUNK_SIZE] for i in range(0, len(image_paths), CHUNK_SIZE)]
                        duration_chunks = [image_durations_s[i:i + CHUNK_SIZE] for i in range(0, len(image_durations_s), CHUNK_SIZE)]
                        intermediate_video_clips = []
                        
                        for i, (image_chunk, duration_chunk) in enumerate(zip(image_chunks, duration_chunks)):
                            if self.stop_event.is_set(): raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
                            self.after(0, lambda i=i, total=len(image_chunks): self.update_status(f"üéû T·∫°o slideshow: ƒêang x·ª≠ l√Ω l√¥ ·∫£nh {i+1}/{total}..."))
                            
                            temp_clip_path = os.path.join(self.temp_folder, f"temp_clip_ai_{i}_{uuid.uuid4().hex[:6]}.mp4")
                            temp_files_created_in_thread.append(temp_clip_path)
                            clip_success = self._ffmpeg_create_slideshow(image_paths=image_chunk, output_video_path=temp_clip_path, resolution=resolution, fps=fps, image_durations_list_seconds=duration_chunk)
                            if not clip_success: raise RuntimeError(f"L·ªói t·∫°o clip trung gian tƒ©nh cho l√¥ {i+1}.")
                            intermediate_video_clips.append(temp_clip_path)
                        
                        if not intermediate_video_clips: raise ValueError("Kh√¥ng t·∫°o ƒë∆∞·ª£c clip trung gian n√†o.")
                        
                        if len(intermediate_video_clips) == 1:
                            shutil.move(intermediate_video_clips[0], slideshow_output_path)
                            final_output_video_path_for_slideshow = slideshow_output_path
                        else:
                            temp_concat_list_path = os.path.join(self.temp_folder, "concat_list_ai.txt")
                            temp_files_created_in_thread.append(temp_concat_list_path)
                            create_ffmpeg_concat_file_list(intermediate_video_clips, temp_concat_list_path)
                            if not self._ffmpeg_concatenate_videos_from_list(temp_concat_list_path, slideshow_output_path):
                                raise RuntimeError("L·ªói khi gh√©p c√°c video clip trung gian tƒ©nh.")
                            final_output_video_path_for_slideshow = slideshow_output_path
                        
                        slideshow_success = True
                    except Exception as e:
                        logging.error(f"{worker_log_prefix} L·ªói trong qu√° tr√¨nh t·∫°o slideshow Tƒ®NH: {e}", exc_info=True)
                        slideshow_success = False
                    finally:
                        for temp_file in temp_files_created_in_thread:
                            if os.path.exists(temp_file):
                                try: os.remove(temp_file)
                                except Exception as e_del: logging.warning(f"L·ªói x√≥a file t·∫°m '{temp_file}': {e_del}")
                
                # --- Nh√°nh 2: T·∫†O SLIDESHOW CHUY·ªÇN ƒê·ªòNG (LOGIC M·ªöI V·ªöI CHUNKING) ---
                else:
                    logging.info(f"{worker_log_prefix} G·ªçi h√†m slideshow CHUY·ªÇN ƒê·ªòNG.")
                    CHUNK_SIZE = 25 # ƒê·∫∑t l·∫°i chunk size ·ªü ƒë√¢y cho quy tr√¨nh ·∫£nh ƒë·ªông

                    # N·∫øu √≠t ·∫£nh, g·ªçi tr·ª±c ti·∫øp h√†m motion ƒë·ªÉ t·ªëi ∆∞u
                    if len(image_paths) <= CHUNK_SIZE:
                        logging.info(f"{worker_log_prefix} S·ªë l∆∞·ª£ng ·∫£nh ({len(image_paths)}) nh·ªè, g·ªçi _ffmpeg_create_slideshow_with_motion tr·ª±c ti·∫øp.")
                        slideshow_success = self._ffmpeg_create_slideshow_with_motion(
                            image_paths=image_paths, output_video_path=slideshow_output_path,
                            resolution=resolution, fps=fps, image_durations_list_seconds=image_durations_s,
                            motion_effect=motion_effect_choice
                        )
                        if slideshow_success:
                            final_output_video_path_for_slideshow = slideshow_output_path
                    else:
                        # N·∫øu nhi·ªÅu ·∫£nh, th·ª±c hi·ªán quy tr√¨nh chia ƒë·ªÉ tr·ªã
                        logging.info(f"{worker_log_prefix} S·ªë l∆∞·ª£ng ·∫£nh ({len(image_paths)}) l·ªõn, b·∫Øt ƒë·∫ßu quy tr√¨nh chia nh√≥m cho slideshow chuy·ªÉn ƒë·ªông.")
                        image_chunks = [image_paths[i:i + CHUNK_SIZE] for i in range(0, len(image_paths), CHUNK_SIZE)]
                        duration_chunks = [image_durations_s[i:i + CHUNK_SIZE] for i in range(0, len(image_durations_s), CHUNK_SIZE)]
                        intermediate_motion_clips = []
                        
                        # T·∫°o c√°c clip trung gian c√≥ hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông
                        for i, (image_chunk, duration_chunk) in enumerate(zip(image_chunks, duration_chunks)):
                            if self.stop_event.is_set(): raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
                            self.after(0, lambda i=i, total=len(image_chunks): self.update_status(f"üéû Motion: T·∫°o clip trung gian {i+1}/{total}..."))
                            temp_clip_path = os.path.join(self.temp_folder, f"temp_motion_clip_{i}_{uuid.uuid4().hex[:6]}.mp4")
                            temp_files_created_in_thread.append(temp_clip_path)

                            clip_success = self._ffmpeg_create_slideshow_with_motion(
                                image_paths=image_chunk, output_video_path=temp_clip_path,
                                resolution=resolution, fps=fps, image_durations_list_seconds=duration_chunk,
                                motion_effect=motion_effect_choice
                            )
                            if not clip_success: raise RuntimeError(f"L·ªói t·∫°o clip chuy·ªÉn ƒë·ªông trung gian cho l√¥ {i+1}.")
                            intermediate_motion_clips.append(temp_clip_path)

                        # Gh√©p n·ªëi c√°c clip trung gian b·∫±ng ph∆∞∆°ng ph√°p Concat Demuxer (nhanh, c√≥ c·∫Øt c·ª©ng)
                        self.after(0, lambda: self.update_status("üéû Motion: Gh√©p n·ªëi c√°c clip..."))
                        temp_concat_list_path = os.path.join(self.temp_folder, "concat_list_motion.txt")
                        temp_files_created_in_thread.append(temp_concat_list_path)

                        create_ffmpeg_concat_file_list(intermediate_motion_clips, temp_concat_list_path)
                        
                        if not self._ffmpeg_concatenate_videos_from_list(temp_concat_list_path, slideshow_output_path):
                            raise RuntimeError("L·ªói khi gh√©p c√°c video clip chuy·ªÉn ƒë·ªông trung gian b·∫±ng concat demuxer.")
                        
                        final_output_video_path_for_slideshow = slideshow_output_path
                        slideshow_success = True
            
            except Exception as e:
                slideshow_success = False
                logging.error(f"{worker_log_prefix} L·ªói trong qu√° tr√¨nh t·∫°o slideshow: {e}", exc_info=True)
                # H√†m g·ªçi s·∫Ω x·ª≠ l√Ω vi·ªác b√°o l·ªói, ·ªü ƒë√¢y ch·ªâ c·∫ßn ƒë·∫£m b·∫£o c·ªù `slideshow_success` l√† False
            
            finally:
                # D·ªçn d·∫πp t·∫•t c·∫£ c√°c file t·∫°m ƒë√£ t·∫°o trong lu·ªìng n√†y
                for temp_file in temp_files_created_in_thread:
                    if os.path.exists(temp_file):
                        try: os.remove(temp_file)
                        except Exception as e_del: logging.warning(f"{worker_log_prefix} L·ªói x√≥a file t·∫°m '{temp_file}': {e_del}")

                # G·ªçi callback cu·ªëi c√πng ƒë·ªÉ ti·∫øp t·ª•c chu·ªói (v√≠ d·ª•: hardsub, dubbing, v.v.)
                self.after(0, self._handle_slideshow_chain_completion,
                           final_output_video_path_for_slideshow if slideshow_success else None,
                           script_for_merge_and_timing,
                           original_plain_text_for_dub,
                           temp_dalle_folder_for_cleanup,
                           gpt_context_for_merge,
                           target_textbox_widget_for_merge,
                           trigger_dub_chain_flag,
                           image_engine_name, ai_script_engine_name, base_filename_for_chain,
                           None if slideshow_success else "L·ªói t·∫°o slideshow",
                           output_dir_override
                )


# H√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi sau khi lu·ªìng DALL-E ho√†n t·∫•t. N√≥ s·∫Ω nh·∫≠n danh s√°ch ƒë∆∞·ªùng d·∫´n c√°c ·∫£nh ƒë√£ t·∫°o v√† c√°c th√¥ng tin c·∫ßn thi·∫øt ƒë·ªÉ ti·∫øp t·ª•c chu·ªói (t·∫°o slideshow).
    def _handle_image_generation_chain_completion(self,
                                                  prompts_list,
                                                  script_for_slideshow_timing,
                                                  original_plain_text_for_dub,
                                                  temp_output_folder,
                                                  target_widget,
                                                  context,
                                                  trigger_dub_chain_flag,
                                                  image_engine_name,
                                                  ai_script_engine_name,
                                                  base_filename_for_chain, # <<< TH√äM V√ÄO ƒê√ÇY
                                                  error_message=None):
        """
        H√†m x·ª≠ l√Ω chung sau khi c√≥ prompts.
        B·∫Øt ƒë·∫ßu lu·ªìng worker ƒë·ªÉ t·∫°o ·∫£nh b·∫±ng DALL-E ho·∫∑c Imagen.
        """
        self.is_gemini_processing = False  # 1. T·∫Øt c·ªù c·ªßa b∆∞·ªõc tr∆∞·ªõc (chia c·∫£nh)
        self.is_imagen_processing = True   # 2. B·∫≠t ngay c·ªù c·ªßa b∆∞·ªõc n√†y (v·∫Ω ·∫£nh)
        logging.info(f"ƒê√£ b√†n giao c·ªù x·ª≠ l√Ω t·ª´ Gemini sang Imagen.")

        log_prefix_cb = f"[{image_engine_name}_ChainCallback:{context}]"
        # ... (ph·∫ßn c√≤n l·∫°i c·ªßa h√†m gi·ªØ nguy√™n) ...
        logging.info(f"{log_prefix_cb} B·∫Øt ƒë·∫ßu t·∫°o ·∫£nh. Engine ·∫£nh: {image_engine_name}, Engine script: {ai_script_engine_name}, S·ªë prompts: {len(prompts_list)}")

        if error_message or not prompts_list:
            final_status_msg = error_message or f"Kh√¥ng c√≥ prompt n√†o ƒë∆∞·ª£c t·∫°o ƒë·ªÉ v·∫Ω ·∫£nh."
            logging.warning(f"{log_prefix_cb} {final_status_msg}")
            self.update_status(f"‚ö†Ô∏è L·ªói: {final_status_msg[:60]}")
            self._check_completion_and_shutdown()
            return

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i ·ª©ng d·ª•ng
        self.start_time = time.time()
        self.update_time_realtime()

        # === B·∫ÆT ƒê·∫¶U KH·ªêI CODE M·ªöI ===

        # ƒê·ªçc phong c√°ch ƒë√£ l∆∞u t·ª´ config cho Imagen
        style_prompt_fragment = ""
        if image_engine_name == "Imagen 3":
            # L·∫•y t√™n style ƒë√£ l∆∞u t·ª´ config
            saved_style_name = self.cfg.get("imagen_last_style", "M·∫∑c ƒë·ªãnh (AI t·ª± do)")
            
            # Truy c·∫≠p t·ª´ ƒëi·ªÉn style t·ª´ l·ªõp ImagenSettingsWindow
            # V√¨ IMAGEN_ART_STYLES l√† m·ªôt thu·ªôc t√≠nh c·ªßa l·ªõp, ch√∫ng ta c√≥ th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp
            if hasattr(ImagenSettingsWindow, 'IMAGEN_ART_STYLES'):
                 style_prompt_fragment = ImagenSettingsWindow.IMAGEN_ART_STYLES.get(saved_style_name, "")
                 if style_prompt_fragment:
                     logging.info(f"{log_prefix_cb} S·∫Ω √°p d·ª•ng phong c√°ch ƒë√£ l∆∞u '{saved_style_name}' cho t·∫•t c·∫£ ·∫£nh Imagen trong chu·ªói.")

        # === K·∫æT TH√öC KH·ªêI CODE M·ªöI ===

        # S·ª¨A L·∫†I KH·ªêI N√ÄY
        if image_engine_name == "Imagen 3":
            self.is_imagen_processing = True

            # L·∫•y c√°c c√†i ƒë·∫∑t t·ª´ c·ª≠a s·ªï Imagen ƒë√£ ƒë∆∞·ª£c l∆∞u trong config
            try:
                num_images_total = int(self.cfg.get("imagen_last_num_images", "1"))
                aspect_ratio = self.cfg.get("imagen_last_aspect_ratio", "16:9")
                ### B·∫ÆT ƒê·∫¶U CODE M·ªöI ###
                # L·∫•y negative prompt ƒë√£ l∆∞u t·ª´ config
                negative_prompt_for_chain = self.cfg.get("imagen_last_negative_prompt", "")
                logging.info(f"[HandleImageGen] L·∫•y ƒë∆∞·ª£c negative_prompt cho chu·ªói Imagen: '{negative_prompt_for_chain}'")
                ### K·∫æT TH√öC CODE M·ªöI ###
            except (ValueError, TypeError) as e:
                logging.error(f"{log_prefix_cb} L·ªói ƒë·ªçc c√†i ƒë·∫∑t Imagen t·ª´ config: {e}")
                num_images_total = 1
                aspect_ratio = "16:9"
                negative_prompt_for_chain = "" # Fallback

            thread = threading.Thread(
                target=self._execute_imagen_chain_generation_iterative,
                args=(prompts_list, num_images_total, aspect_ratio, temp_output_folder,
                      script_for_slideshow_timing, original_plain_text_for_dub,
                      target_widget, context, trigger_dub_chain_flag,
                      image_engine_name, ai_script_engine_name, style_prompt_fragment,
                      base_filename_for_chain, 
                      negative_prompt_for_chain), # <<< TH√äM THAM S·ªê M·ªöI V√ÄO ƒê√ÇY
                daemon=True, name="ImagenChainGenerationThread"
            )
            thread.start()

        elif image_engine_name == "DALL-E 3":
            self.is_dalle_processing = True
            
            # L·∫•y c√°c c√†i ƒë·∫∑t t·ª´ c·ª≠a s·ªï DALL-E
            is_cost_saver = self.cfg.get("dalle_cost_saver_mode", False)
            num_images_total = int(self.cfg.get("dalle_num_images_setting", 1))
            dalle_model = self.cfg.get("dalle_model_setting", "dall-e-3")
            image_size = self.cfg.get(f"dalle_imagesize_{dalle_model}_setting", "1792x1024")
            quality = self.cfg.get("dalle_quality_d3_setting", "standard")
            style = self.cfg.get("dalle_style_d3_setting", "vivid")

            thread = threading.Thread(
                target=self._execute_dalle_chain_generation_iterative,
                args=(prompts_list, num_images_total, is_cost_saver, image_size, temp_output_folder,
                      dalle_model, quality, style, script_for_slideshow_timing, original_plain_text_for_dub,
                      target_widget, context, trigger_dub_chain_flag,
                      image_engine_name, ai_script_engine_name,
                      base_filename_for_chain), # <<< TH√äM V√ÄO ƒê√ÇY
                daemon=True, name="DalleChainGenerationThread"
            )
            thread.start()
        else:
            logging.error(f"{log_prefix_cb} Engine ·∫£nh kh√¥ng x√°c ƒë·ªãnh: '{image_engine_name}'")
            self._check_completion_and_shutdown()

        
# H√†m n√†y s·∫Ω d·ªçn d·∫πp, c·∫≠p nh·∫≠t tr·∫°ng th√°i v√† th√¥ng b√°o cho ng∆∞·ªùi d√πng.
    def _handle_final_chain_completion(self,
                                       final_video_path,
                                       saved_srt_path,
                                       original_plain_text_for_dub,
                                       temp_output_folder_to_cleanup,
                                       context,
                                       original_target_textbox_widget,
                                       chain_error_message=None,
                                       trigger_dub_chain_flag=False,
                                       image_engine_name="AI",
                                       ai_script_engine_name="AI",
                                       base_filename_for_chain=None):
        
        log_prefix_final = f"[HandleFinalChain_v4_FixSingleChain:{context}]" # TƒÉng version log
        logging.info(f"{log_prefix_final} Chu·ªói AI ho√†n t·∫•t. Path: {final_video_path}, Error: {chain_error_message}, TriggerDub: {trigger_dub_chain_flag}, Identifier: {base_filename_for_chain}")

        # GH√âP AUDIO CHO QUY TR√åNH AUDIO > VIDEO
        if context == "audio_to_video_chain":
            log_prefix_handoff = f"[HandleFinalChain_HandoffToMuxThread]"
            logging.info(f"{log_prefix_handoff} Chu·ªói AI t·∫°o ·∫£nh cho Audio-to-Video ƒë√£ ho√†n t·∫•t. Video hardsub: {os.path.basename(final_video_path)}. Chu·∫©n b·ªã chuy·ªÉn giao cho lu·ªìng gh√©p audio cu·ªëi c√πng.")

            # L·∫•y l·∫°i task object ƒë√£ ƒë∆∞·ª£c l∆∞u
            task_object_for_mux = getattr(self, 'current_audio_to_video_task', None)

            if not task_object_for_mux:
                logging.error(f"{log_prefix_handoff} L·ªói nghi√™m tr·ªçng: Kh√¥ng t√¨m th·∫•y 'current_audio_to_video_task' ƒë·ªÉ ti·∫øp t·ª•c gh√©p audio.")
                # N·∫øu l·ªói, v·∫´n ph·∫£i g·ªçi callback ƒë·ªÉ h√†ng ch·ªù ch√≠nh kh√¥ng b·ªã k·∫πt
                if hasattr(self, '_process_next_subtitle_file'):
                    self.after(50, self._process_next_subtitle_file)
                return

            # Kh·ªüi ch·∫°y lu·ªìng worker m·ªõi ƒë·ªÉ th·ª±c hi·ªán c√°c b∆∞·ªõc cu·ªëi c√πng
            final_mux_thread = threading.Thread(
                target=self._execute_final_mux_and_branding_thread,
                args=(task_object_for_mux, final_video_path),
                daemon=True,
                name=f"FinalMuxAndBrandThread_{task_object_for_mux.get('id', 'task')[:6]}"
            )
            final_mux_thread.start()

            # H√†m n√†y s·∫Ω k·∫øt th√∫c t·∫°i ƒë√¢y. Lu·ªìng worker m·ªõi s·∫Ω ch·ªãu tr√°ch nhi·ªám
            # g·ªçi callback _process_next_subtitle_file ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo.
            return

        # --- B∆Ø·ªöC 1: D·ªåN D·∫∏P V√Ä RESET C√ÅC C·ªú TR·∫†NG TH√ÅI ---
        if temp_output_folder_to_cleanup and os.path.isdir(temp_output_folder_to_cleanup):
            logging.info(f"{log_prefix_final} Gi·ªØ l·∫°i th∆∞ m·ª•c t·∫°m AI ƒë·ªÉ xem l·∫°i: {temp_output_folder_to_cleanup}")

        self.is_creating_slideshow = False
        self.is_dalle_processing = False
        self.is_imagen_processing = False
        self.is_subbing = False # B∆∞·ªõc hardsub (thu·ªôc is_subbing) ƒë√£ xong

        # --- B∆Ø·ªöC 2: X·ª¨ L√ù K·∫æT QU·∫¢ C·ª¶A CHU·ªñI AI ---
        if chain_error_message or not final_video_path:
            final_status_msg = chain_error_message or "Kh√¥ng t·∫°o ƒë∆∞·ª£c video cu·ªëi c√πng t·ª´ chu·ªói AI."
            logging.error(f"{log_prefix_final} {final_status_msg}")
            
            if self.is_ai_batch_processing:
                self._show_non_blocking_error_popup("L·ªói Chu·ªói AI", f"L·ªói x·ª≠ l√Ω file v·ªõi key '{base_filename_for_chain}':\n\n{final_status_msg}\n\nB·ªè qua v√† ti·∫øp t·ª•c file sau.")
                self.after(100, self._process_next_ai_batch_item)
            else: 
                self.is_gpt_processing_script = False
                self.is_gemini_processing = False
                self.update_status(f"‚ùå L·ªói chu·ªói AI: {final_status_msg[:60]}...")
                messagebox.showerror("L·ªói Chu·ªói T·ª± ƒê·ªông", f"L·ªói:\n{final_status_msg}", parent=self)
                self._check_completion_and_shutdown()
            return

        # T·∫°o Task Object cu·ªëi c√πng, s·∫µn s√†ng cho c√°c b∆∞·ªõc ti·∫øp theo
        final_task_object = {
            'source': f"AI_Chain_{base_filename_for_chain}",
            'identifier': base_filename_for_chain,
            'final_video_path': final_video_path,
            'dubbed_video_path': final_video_path,
            'branded_path': final_video_path,
            'final_srt_path': saved_srt_path,
            'script_content_type': 'srt_file',
            'script_data': saved_srt_path, # S·ª≠ d·ª•ng file SRT ƒë√£ l∆∞u n√†y!
            'video_to_dub': final_video_path,
            'chain_output_dir_override': os.path.dirname(final_video_path),
            'script_display_name_override': f"K·ªãch b·∫£n t·ª´ {ai_script_engine_name} (cho {base_filename_for_chain})",
            'original_downloaded_video': final_video_path
        }

        # --- B∆Ø·ªöC 3: QUY·∫æT ƒê·ªäNH H√ÄNH ƒê·ªòNG TI·∫æP THEO (LOGIC ƒê√É S·ª¨A) ---
        if trigger_dub_chain_flag:
            # <<< S·ª¨A ƒê·ªîI CH√çNH N·∫∞M ·ªû ƒê√ÇY >>>
            logging.info(f"{log_prefix_final} Y√™u c·∫ßu ti·∫øp t·ª•c Thuy·∫øt minh.")
            self.files_for_chained_dubbing.append(final_task_object)
            logging.info(f"{log_prefix_final} ƒê√£ th√™m Task Object v√†o h√†ng ch·ªù thuy·∫øt minh.")

            if self.is_ai_batch_processing:
                # N·∫øu l√† l√¥, ch·ªâ c·∫ßn x·ª≠ l√Ω m·ª•c ti·∫øp theo. Dub s·∫Ω ƒë∆∞·ª£c g·ªçi sau khi c·∫£ l√¥ AI xong.
                logging.info(f"{log_prefix_final} (L√¥ AI) - Chuy·ªÉn sang x·ª≠ l√Ω m·ª•c ti·∫øp theo trong l√¥ AI.")
                self.after(100, self._process_next_ai_batch_item)
            else:
                # N·∫øu l√† t√°c v·ª• ƒë∆°n l·∫ª, B·∫ÆT ƒê·∫¶U THUY·∫æT MINH NGAY L·∫¨P T·ª®C
                logging.info(f"{log_prefix_final} (T√°c v·ª• ƒë∆°n l·∫ª) - B·∫Øt ƒë·∫ßu chu·ªói thuy·∫øt minh ngay b√¢y gi·ªù...")
                self.is_gpt_processing_script = False
                self.is_gemini_processing = False
                # H√†m _initiate_chained_dubbing s·∫Ω ƒë·∫∑t c√°c c·ªù x·ª≠ l√Ω c·ªßa Dubbing
                self.after(200, self._initiate_chained_dubbing, list(self.files_for_chained_dubbing))
                
        else: # trigger_dub_chain_flag l√† False -> K·∫øt th√∫c chu·ªói AI
            logging.info(f"{log_prefix_final} Chu·ªói AI k·∫øt th√∫c. Th√™m v√†o h√†ng ch·ªù upload (n·∫øu c√≥ b·∫≠t).")
            self._add_completed_video_to_upload_queue(final_task_object)

            if self.is_ai_batch_processing:
                logging.info(f"{log_prefix_final} (L√¥ AI) - Chuy·ªÉn sang x·ª≠ l√Ω m·ª•c ti·∫øp theo trong l√¥ AI.")
                self.after(100, self._process_next_ai_batch_item)
            else: # T√°c v·ª• ƒë∆°n l·∫ª v√† k·∫øt th√∫c
                logging.info(f"{log_prefix_final} (T√°c v·ª• ƒë∆°n l·∫ª) - K·∫øt th√∫c chu·ªói, kh√¥ng dub.")
                # <--- S·ª¨A L·ªñI ·ªû ƒê√ÇY: Reset t·∫•t c·∫£ c√°c c·ªù li√™n quan ƒë·∫øn chu·ªói AI ---
                self.is_gpt_processing_script = False
                self.is_gemini_processing = False
                self.is_imagen_processing = False
                self.is_creating_slideshow = False
                self.is_subbing = False
                
                # <--- TH√äM D√íNG QUAN TR·ªåNG N√ÄY ---
                # Ra l·ªánh cho giao di·ªán c·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i c√°c n√∫t
                self._set_subtitle_tab_ui_state(False)
                
                self._check_completion_and_shutdown()
                self.update_status("‚úÖ Ho√†n t·∫•t chu·ªói AI!")
                
                # Ch·ªâ hi·ªán popup n·∫øu kh√¥ng t·ª± ƒë·ªông upload
                if not self.auto_upload_to_youtube_var.get():
                    messagebox.showinfo("Ho√†n t·∫•t", f"ƒê√£ ho√†n th√†nh chu·ªói AI!\nVideo ƒë∆∞·ª£c l∆∞u t·∫°i:\n{final_video_path}", parent=self)


# ==========================================================
# C√ÅC H√ÄM M·ªöI CHO T√çNH NƒÇNG T·∫†O ·∫¢NH B·∫∞NG IMAGEN (Imagen 3)
# ==========================================================

    def _execute_imagen_generation_thread(self, prompt, negative_prompt, number_of_images, output_folder, aspect_ratio):
        """
        (ch·∫°y trong lu·ªìng):
        S·ª≠ d·ª•ng h√†m client.models.generate_images v√† model Imagen 3 chuy√™n d·ª•ng.
        """
        with keep_awake("Imagen batch generation"):

            worker_log_prefix = "[ImagenWorkerThread_Imagen3_Correct]"
            logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu t·∫°o {number_of_images} ·∫£nh v·ªõi prompt: '{prompt[:50]}...'")

            saved_image_paths = []
            error_message = None

            try:
                # --- 1. Import v√† c·∫•u h√¨nh (S·ª≠ d·ª•ng google.genai nh∆∞ b·∫°n mu·ªën) ---
                from google import genai
                from google.genai import types
                from PIL import Image
                from io import BytesIO

                gemini_api_key = self.gemini_key_var.get()
                if not gemini_api_key:
                    error_message = "L·ªói: Vui l√≤ng c·∫•u h√¨nh Gemini API Key."
                    raise ValueError(error_message)

                # Kh·ªüi t·∫°o client
                client = genai.Client(api_key=gemini_api_key)

                self.after(0, lambda: self.update_status(f"üñº Imagen 3: ƒêang v·∫Ω {number_of_images} ·∫£nh..."))

                # --- 2. X√¢y d·ª±ng prompt v√† config cho Imagen 3 ---
                # Imagen 3 hi·ªán t·∫°i h·ªó tr·ª£ t·ªët nh·∫•t c√¢u l·ªánh ti·∫øng Anh
                # B·∫°n c√≥ th·ªÉ c√¢n nh·∫Øc th√™m m·ªôt b∆∞·ªõc d·ªãch prompt n·∫øu ng∆∞·ªùi d√πng nh·∫≠p ti·∫øng Vi·ªát
                # V√≠ d·ª•: full_prompt = f"A photorealistic image of: {prompt}"
                full_prompt = prompt # T·∫°m th·ªùi gi·ªØ nguy√™n prompt ng∆∞·ªùi d√πng nh·∫≠p

                # T·∫°o ƒë·ªëi t∆∞·ª£ng config cho vi·ªác t·∫°o ·∫£nh
                image_gen_config = types.GenerateImagesConfig(
                    number_of_images=number_of_images,
                    aspect_ratio=aspect_ratio
                    # B·∫°n c√≥ th·ªÉ th√™m c√°c tham s·ªë kh√°c ·ªü ƒë√¢y n·∫øu mu·ªën
                    # person_generation="allow_adult" 
                )
                
                logging.info(f"{worker_log_prefix} ƒêang g·ªçi client.models.generate_images(...) v·ªõi model 'imagen-3.0-generate-002'")
                # --- 3. G·ªçi API t·∫°o ·∫£nh (H√†m ƒë√∫ng) ---

                # --- B·∫ÆT ƒê·∫¶U S·ª¨A L·ªñI - PHI√äN B·∫¢N 3 (G·ªòP PROMPT) ---

                # L·∫•y prompt g·ªëc t·ª´ tham s·ªë
                base_prompt = prompt 
                
                # T·∫°o chu·ªói c√°c t·ª´ kh√≥a ph·ªß ƒë·ªãnh
                # Tham s·ªë 'negative_prompt' l√† chu·ªói b·∫°n nh·∫≠p t·ª´ c·ª≠a s·ªï "T·∫°o ·∫£nh Imagen"
                negative_keywords = "text, words, letters, writing, typography, signs, banners, logos"
                if negative_prompt:
                    negative_keywords = f"{negative_prompt}, {negative_keywords}"
                
                # --- THAY ƒê·ªîI QUAN TR·ªåNG: G·ªòP PROMPT V√Ä NEGATIVE PROMPT ---
                # Th√™m c√°c t·ª´ kh√≥a ph·ªß ƒë·ªãnh v√†o cu·ªëi prompt ch√≠nh ƒë·ªÉ h∆∞·ªõng d·∫´n AI
                full_prompt = f"{base_prompt}, cinematic, photography, sharp, high quality, (without: {negative_keywords})"
                
                logging.info(f"Prompt cu·ªëi c√πng ƒë√£ g·ªôp (g·ª≠i cho API): {full_prompt}")
                
                # T·∫°o config c∆° b·∫£n (KH√îNG C√ì negative_prompt)
                image_gen_config = types.GenerateImagesConfig(
                    number_of_images=number_of_images,
                    aspect_ratio=aspect_ratio
                )
                
                logging.info(f"{worker_log_prefix} ƒêang g·ªçi client.models.generate_images(...) v·ªõi model 'imagen-3.0-generate-002'")
                
                # G·ªçi API ch·ªâ v·ªõi prompt ƒë√£ g·ªôp
                response = client.models.generate_images(
                    model='imagen-3.0-generate-002',
                    prompt=full_prompt, # <-- Truy·ªÅn prompt ƒë√£ g·ªôp v√†o ƒë√¢y
                    config=image_gen_config
                )

                # --- 4. X·ª≠ l√Ω v√† l∆∞u ·∫£nh (Response ƒë√∫ng) ---
                # L·∫∑p qua c√°c ·∫£nh ƒë∆∞·ª£c t·∫°o trong response
                for generated_image in response.generated_images:
                    if self.stop_event.is_set():
                        error_message = "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng."
                        break

                    # L·∫•y d·ªØ li·ªáu bytes c·ªßa ·∫£nh
                    image_bytes = generated_image.image.image_bytes

                    # L∆∞u file
                    current_timestamp = int(time.time())
                    safe_prompt_part = create_safe_filename(prompt, max_length=30)
                    file_name = f"imagen3_{safe_prompt_part}_{current_timestamp}_{len(saved_image_paths)+1}.png"
                    file_path = os.path.join(output_folder, file_name)
                    
                    with open(file_path, "wb") as f:
                        f.write(image_bytes)
                    
                    saved_image_paths.append(file_path)
                    logging.info(f"{worker_log_prefix} ƒê√£ l∆∞u ·∫£nh th√†nh c√¥ng: {file_path}")

                # ƒê·∫øm S·ªë l·∫ßn g·ªçi API
                if response.generated_images:
                    num_generated = len(response.generated_images)
                    logging.info(f"{worker_log_prefix} G·ªçi h√†m _track_api_call cho {num_generated} ·∫£nh Imagen.")
                    # G·ªçi h√†m c·ªßa app ch√≠nh ƒë·ªÉ c·∫≠p nh·∫≠t v·ªõi ƒë√∫ng service_name
                    self._track_api_call(service_name="imagen_images", units=num_generated)

                if self.stop_event.is_set():
                    raise InterruptedError(error_message or "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng.")

            except ImportError as e:
                error_message = f"L·ªói thi·∫øu th∆∞ vi·ªán: {e}. Vui l√≤ng ch·∫°y: pip install google-genai pillow"
                logging.critical(f"{worker_log_prefix} {error_message}")
            except Exception as e:
                # B·∫Øt c√°c l·ªói c·ª• th·ªÉ t·ª´ API n·∫øu c√≥, v√≠ d·ª• nh∆∞ l·ªói x√°c th·ª±c, l·ªói do prompt b·ªã ch·∫∑n...
                error_message = f"L·ªói khi g·ªçi API Imagen 3: {type(e).__name__} - {str(e)}"
                logging.error(f"{worker_log_prefix} {error_message}", exc_info=True)
            finally:
                # G·ªçi h√†m callback tr√™n lu·ªìng ch√≠nh ƒë·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£
                is_success = (error_message is None and saved_image_paths)
                self.after(0, self._handle_imagen_generation_completion, 
                           is_success, 
                           saved_image_paths, 
                           error_message)

    def _handle_imagen_generation_completion(self, success, saved_paths, error_message):
        """
        H√†m callback: X·ª≠ l√Ω sau khi lu·ªìng t·∫°o ·∫£nh Imagen ho√†n t·∫•t.
        """
        self.is_imagen_processing = False
        self.start_time = None # D·ª´ng ƒë·ªìng h·ªì
        
        if success:
            msg = f"ƒê√£ t·∫°o v√† l∆∞u th√†nh c√¥ng {len(saved_paths)} ·∫£nh."
            self.update_status(f"‚úÖ {msg}")
            messagebox.showinfo("Ho√†n th√†nh", f"{msg}\nTh∆∞ m·ª•c: {os.path.dirname(saved_paths[0])}", parent=self)
        else:
            msg = error_message or "L·ªói kh√¥ng x√°c ƒë·ªãnh."
            self.update_status(f"‚ùå L·ªói t·∫°o ·∫£nh Imagen: {msg[:60]}...")
            messagebox.showerror("L·ªói Imagen", f"Kh√¥ng th·ªÉ t·∫°o ·∫£nh:\n\n{msg}", parent=self)

        # K√≠ch ho·∫°t l·∫°i c√°c n√∫t tr√™n giao di·ªán ch√≠nh (n·∫øu c·∫ßn)
        if hasattr(self, '_set_subtitle_tab_ui_state'):
            # truy·ªÅn False n·∫øu mu·ªën ch·∫Øc ch·∫Øn coi nh∆∞ ƒëang kh√¥ng sub khi refresh UI
            self._set_subtitle_tab_ui_state(subbing_active=False)

        if hasattr(self, '_set_dubbing_tab_ui_state'):
            # KH√îNG truy·ªÅn activated=... n·ªØa; h√†m t·ª± g·ªçi _is_app_fully_activated()
            self._set_dubbing_tab_ui_state()
            

# H√†m m·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t cho Imagen
    def open_imagen_settings_window(self):
        """M·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t cho Imagen."""
        if hasattr(self, '_imagen_settings_win') and self._imagen_settings_win and self._imagen_settings_win.winfo_exists():
            self._imagen_settings_win.focus()
            return
        
        self._imagen_settings_win = ImagenSettingsWindow(master_app=self)


# H√†m n√¢ng c√°p prompt d√πng GPT/GEMINI
    def _initiate_prompt_enhancement(self, short_prompt, engine, selected_style_name, negative_prompt, number_of_images, output_folder, aspect_ratio, character_sheet_text):
        """B·∫Øt ƒë·∫ßu lu·ªìng n√¢ng c·∫•p prompt."""
        self.update_status(f"‚ú® ƒêang d√πng {engine.upper()} ƒë·ªÉ n√¢ng c·∫•p prompt...")
        self.is_gpt_processing_script = True # Ho·∫∑c m·ªôt c·ªù ri√™ng cho vi·ªác n√†y
        self.start_time = time.time()
        self.update_time_realtime()
        
        thread = threading.Thread(
            target=self._execute_prompt_enhancement_thread,
            args=(short_prompt, engine, selected_style_name, negative_prompt, number_of_images, output_folder, aspect_ratio, character_sheet_text), # Truy·ªÅn ƒëi ti·∫øp
            daemon=True,
            name=f"PromptEnhancementThread_{engine}"
        )
        thread.start()


# H√†m t·∫°o Prompt n√¢ng c·∫•p ·∫£nh
    def _execute_prompt_enhancement_thread(self, short_prompt, engine, selected_style_name, negative_prompt, number_of_images, output_folder, aspect_ratio, character_sheet_text):
        """
        (ƒê√É S·ª¨A L·ªñI)
        Worker thread: G·ªçi GPT/Gemini ƒë·ªÉ n√¢ng c·∫•p prompt, c√≥ T√îN TR·ªåNG phong c√°ch ng∆∞·ªùi d√πng ƒë√£ ch·ªçn V√Ä B·∫£ng m√¥ t·∫£ nh√¢n v·∫≠t.
        """
        worker_log_prefix = f"[{threading.current_thread().name}_PromptEnhance_v3_Fixed]" # TƒÉng version log
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu n√¢ng c·∫•p prompt b·∫±ng {engine.upper()}.")
        logging.info(f"{worker_log_prefix}   Style: '{selected_style_name}'")
        logging.info(f"{worker_log_prefix}   Character Sheet (d√†i {len(character_sheet_text)} chars): '{character_sheet_text[:100]}...'")

        enhanced_prompt = None
        error_message = None

        style_prompt_fragment = ImagenSettingsWindow.IMAGEN_ART_STYLES.get(selected_style_name, "")

        character_instruction_block = ""
        if character_sheet_text:
            character_instruction_block = (
                "\n\n**CHARACTER DESCRIPTIONS (VERY IMPORTANT):**\n"
                "You are provided with a character sheet. If you detect a character's alias from this sheet in the user's idea, you MUST use their detailed description to create a consistent visual representation. This is your highest priority for character design.\n"
                "--- CHARACTER SHEET ---\n"
                f"{character_sheet_text}\n"
                "--- END CHARACTER SHEET ---\n"
            )

        style_instruction_block = ""
        if style_prompt_fragment:
            style_instruction_block = (
                f"\n\n**ART STYLE INSTRUCTIONS:**\n"
                f"The final prompt MUST strictly follow the user's chosen art style: '{selected_style_name}'. "
                f"Incorporate these keywords and concepts into your final prompt to achieve this style: '{style_prompt_fragment}'. Do not deviate to another style."
            )
        else:
            style_instruction_block = (
                "\n\n**ART STYLE INSTRUCTIONS:**\n"
                "1. Prioritize a PHOTOREALISTIC, HIGHLY DETAILED style, like a high-quality photograph or cinematic 3D render. The image should be SHARP, CLEAR, with intricate details. "
                "2. UNLESS the user's idea explicitly suggests a different style (e.g., 'anime', 'painting'), you MUST default to a REALISTIC 3D style. "
                "3. To achieve this, use descriptive keywords in the prompt (in English) like: 'photorealistic', 'hyperrealistic', 'highly detailed', 'sharp focus', '3D render', 'cinematic lighting', 'Unreal Engine 5 style', 'V-Ray render', 'octane render', 'detailed skin texture', 'intricate details', 'professional photography', '8K resolution'."
            )

        master_prompt_template = (
            "You are an expert prompt engineer for Google's Imagen 3 model. "
            "Your task is to take a user's simple idea and expand it into a rich, descriptive, and artistic prompt in English. "
            "The final prompt must be in English and ready for an image generation AI. "
            "Do not add any extra text, explanations, or quotation marks. Only return the final, enhanced prompt.\n"
            f"{character_instruction_block}"
            f"{style_instruction_block}"
            "\n\n**CONTENT SAFETY:** All prompts must STRICTLY adhere to content safety policies. AVOID any violent, adult, hateful, or harmful depictions. Prioritize safety and positivity.\n\n"
            "**NO TEXT ON IMAGE:** Ensure your prompt instructs the image model NOT to render any text, letters, or words. Use 'text-free' or similar phrases if necessary.\n"
            "---"
            "\nUser's simple idea: \"{user_idea}\""
        )

        try:
            user_idea_prompt = master_prompt_template.format(user_idea=short_prompt)
            
            if engine == "gemini":
                api_key = self.gemini_key_var.get()
                if not api_key: raise ValueError("Ch∆∞a c·∫•u h√¨nh Gemini API Key.")
                import google.generativeai as genai
                genai.configure(api_key=api_key)
                
                # T·ª± ƒë·ªông ch·ªçn model kh·∫£ d·ª•ng
                model = None
                model_names_to_try = ['gemini-1.5-pro', 'gemini-1.5-flash', 'gemini-pro', 'gemini-1.5-pro-latest']
                
                for model_name in model_names_to_try:
                    try:
                        # Ch·ªâ t·∫°o model, kh√¥ng test tr∆∞·ªõc (s·∫Ω test khi g·ªçi API th·ª±c t·∫ø)
                        model = genai.GenerativeModel(model_name)
                        logging.debug(f"[Prompt Enhancement] ƒê√£ ch·ªçn model: {model_name}")
                        break
                    except Exception as model_e:
                        logging.debug(f"[Prompt Enhancement] Model {model_name} kh√¥ng kh·∫£ d·ª•ng: {model_e}")
                        continue
                
                if not model:
                    # Fallback: th·ª≠ list_models v√† l·∫•y model ƒë·∫ßu ti√™n
                    try:
                        models = genai.list_models()
                        if models:
                            first_model_name = models[0].name.split('/')[-1] if '/' in models[0].name else models[0].name
                            model = genai.GenerativeModel(first_model_name)
                            logging.debug(f"[Prompt Enhancement] D√πng fallback model: {first_model_name}")
                        else:
                            raise ValueError("Kh√¥ng t√¨m th·∫•y model n√†o kh·∫£ d·ª•ng.")
                    except Exception as fallback_e:
                        raise ValueError(f"Kh√¥ng th·ªÉ t√¨m th·∫•y model Gemini kh·∫£ d·ª•ng. L·ªói: {fallback_e}")
                
                response = model.generate_content(user_idea_prompt)
                enhanced_prompt = response.text.strip().replace('"', '')
                self._track_api_call(service_name="gemini_calls", units=1)

            elif engine == "gpt":
                api_key = self.openai_key_var.get()
                if not api_key: raise ValueError("Ch∆∞a c·∫•u h√¨nh OpenAI API Key.")
                from openai import OpenAI
                client = OpenAI(api_key=api_key, timeout=60.0)
                response = client.chat.completions.create(
                    model="gpt-4-turbo",
                    messages=[{"role": "user", "content": user_idea_prompt}],
                    temperature=0.7
                )
                enhanced_prompt = response.choices[0].message.content.strip().replace('"', '')
                self._track_api_call(service_name="openai_calls", units=1)

            if not enhanced_prompt:
                raise RuntimeError(f"{engine.upper()} kh√¥ng tr·∫£ v·ªÅ prompt ƒë∆∞·ª£c n√¢ng c·∫•p.")

            logging.info(f"{worker_log_prefix} Prompt ƒë√£ ƒë∆∞·ª£c {engine.upper()} n√¢ng c·∫•p th√†nh c√¥ng: '{enhanced_prompt}'")
            
            # <<< S·ª¨A L·ªñI ·ªû ƒê√ÇY: B·ªè .master_app >>>
            self.is_gpt_processing_script = False
            self.is_imagen_processing = True
            
            # B·∫Øt ƒë·∫ßu lu·ªìng t·∫°o ·∫£nh v·ªõi prompt ƒë√£ ƒë∆∞·ª£c n√¢ng c·∫•p
            thread_imagen = threading.Thread(
                target=self._execute_imagen_generation_thread, 
                args=(enhanced_prompt, negative_prompt, number_of_images, output_folder, aspect_ratio),
                daemon=True, name="ImagenGenerationThread_Chained"
            )
            thread_imagen.start()

        except Exception as e:
            error_message = f"L·ªói khi n√¢ng c·∫•p prompt b·∫±ng {engine.upper()}: {e}"
            logging.error(error_message, exc_info=True)
            # <<< S·ª¨A L·ªñI ·ªû ƒê√ÇY: B·ªè .master_app v√† d√πng self l√†m parent >>>
            self.after(0, lambda: messagebox.showerror("L·ªói N√¢ng c·∫•p Prompt", error_message, parent=self))
            self.after(0, lambda: self.update_status(f"‚ùå {error_message}"))
        finally:
            # <<< S·ª¨A L·ªñI ·ªû ƒê√ÇY: B·ªè .master_app >>>
            self.is_gpt_processing_script = False

#==========================================================================================================================================================

# H√†m qu·∫£n l√Ω c√°c n√∫t ch·ª©c nƒÉng c·ªßa tab Sub
    def _set_subtitle_tab_ui_state(self, subbing_active=None):
        if subbing_active is None:
            subbing_active = bool(getattr(self, "is_subbing", False))

        is_manual_mode = bool(getattr(self, 'manual_merge_mode_var', None) and self.manual_merge_mode_var.get())
        log_prefix_set_ui = f"[UI_SubTab_SetState(Subbing:{subbing_active}, Manual:{is_manual_mode})]"

        # --- KI·ªÇM TRA B·∫¢N QUY·ªÄN (ngu·ªìn s·ª± th·∫≠t DUY NH·∫§T) ---
        try:
            is_app_active = self._is_app_fully_activated()
        except Exception:
            is_app_active = False

        unactivated_text_short = "üîí K√≠ch ho·∫°t"

        # Tr·∫°ng th√°i chung cho c√°c h√†nh ƒë·ªông ch√≠nh (n·∫øu app ƒë√£ active)
        main_action_state_if_active = ctk.DISABLED if subbing_active else ctk.NORMAL
        # Tr·∫°ng th√°i cu·ªëi cho n√∫t ch√≠nh (ph·ª• thu·ªôc active + subbing)
        final_main_action_state = main_action_state_if_active if is_app_active else ctk.DISABLED

        # ===================================================================================
        # TR·∫†NG TH√ÅI CHO WHISPER/D·ªäCH vs. CHIA D√íNG/G·ªòP KH·ªêI
        # ===================================================================================

        # Whisper/D·ªãch: ch·ªâ b·∫≠t n·∫øu app active & KH√îNG ·ªü manual mode; theo subbing_active
        whisper_translate_controls_state_effective = ctk.DISABLED
        if is_app_active and not is_manual_mode:
            whisper_translate_controls_state_effective = main_action_state_if_active

        # Chia d√≤ng / G·ªôp kh·ªëi: lu√¥n ho·∫°t ƒë·ªông n·∫øu app active; theo subbing_active
        split_and_merge_controls_state = ctk.DISABLED
        if is_app_active:
            split_and_merge_controls_state = main_action_state_if_active

        # Truy c·∫≠p widgets qua subtitle_view_frame (SubtitleTab)
        subtitle_tab = getattr(self, 'subtitle_view_frame', None)
        if not subtitle_tab:
            return  # N·∫øu SubtitleTab ch∆∞a ƒë∆∞·ª£c t·∫°o th√¨ b·ªè qua

        # --- N√∫t "B·∫Øt ƒë·∫ßu SUB" / "B·∫Øt ƒë·∫ßu Gh√©p Th·ªß C√¥ng" ---
        sub_button = getattr(subtitle_tab, 'sub_button', None)
        if sub_button and sub_button.winfo_exists():
            if not is_app_active:
                sub_button.configure(state=ctk.DISABLED, text=unactivated_text_short)
            elif subbing_active:
                sub_button.configure(state=ctk.DISABLED, text="‚è≥ ƒêang x·ª≠ l√Ω...")
            elif getattr(self, 'ai_batch_queue', None):  # N·∫øu c√≥ h√†ng ch·ªù AI
                sub_button.configure(text="üöÄ B·∫Øt ƒë·∫ßu L√¥ AI", state=final_main_action_state)
            elif is_manual_mode:
                sub_button.configure(text="üî® B·∫Øt ƒë·∫ßu Gh√©p Th·ªß C√¥ng", state=final_main_action_state)
            else:  # T·ª± ƒë·ªông (Whisper)
                sub_button.configure(text="‚ñ∂ B·∫Øt ƒë·∫ßu SUB", state=final_main_action_state)

        # N√∫t "Sub & Dub"
        sub_and_dub_button = getattr(subtitle_tab, 'sub_and_dub_button', None)
        if sub_and_dub_button and sub_and_dub_button.winfo_exists():
            sub_dub_text = "üé§ Sub & Dub" if is_app_active else unactivated_text_short
            sub_and_dub_button.configure(state=final_main_action_state, text=sub_dub_text)

        # N√∫t "Th√™m File (Sub)" (t·∫Øt khi manual_mode ƒë·ªÉ tr√°nh l·ªách logic)
        add_button = getattr(subtitle_tab, 'add_button', None)
        if add_button and add_button.winfo_exists():
            add_button_text = "‚ûï Th√™m File (Sub)" if is_app_active else unactivated_text_short
            can_add_file_now = (not subbing_active) and is_app_active and (not is_manual_mode)
            add_button.configure(state=(ctk.NORMAL if can_add_file_now else ctk.DISABLED), text=add_button_text)

        # N√∫t "M·ªü Th∆∞ M·ª•c Sub" (cho m·ªü t·ª± do nh∆∞ logic g·ªëc)
        open_sub_output_folder_button = getattr(subtitle_tab, 'open_sub_output_folder_button', None)
        if open_sub_output_folder_button and open_sub_output_folder_button.winfo_exists():
            open_sub_output_folder_button.configure(state=ctk.NORMAL)

        # N√∫t "Ch·ªçn Output"
        choose_output_dir_button = getattr(subtitle_tab, 'choose_output_dir_button', None)
        if choose_output_dir_button and choose_output_dir_button.winfo_exists():
            choose_output_text = "Ch·ªçn Output" if is_app_active else unactivated_text_short
            choose_output_dir_button.configure(state=final_main_action_state, text=choose_output_text)

        # N√∫t "Logo/Intro" (Tab Sub)
        branding_settings_button_sub_tab = getattr(subtitle_tab, 'branding_settings_button_sub_tab', None)
        if branding_settings_button_sub_tab and branding_settings_button_sub_tab.winfo_exists():
            branding_text_sub = "üñº Logo/Intro" if is_app_active else unactivated_text_short
            branding_settings_button_sub_tab.configure(state=final_main_action_state, text=branding_text_sub)

        # N√∫t "T√πy ch·ªânh Ki·ªÉu Ph·ª• ƒë·ªÅ"
        subtitle_style_settings_button = getattr(subtitle_tab, 'subtitle_style_settings_button', None)
        if subtitle_style_settings_button and subtitle_style_settings_button.winfo_exists():
            style_text_sub = "üé® T√πy ch·ªânh Ki·ªÉu Ph·ª• ƒë·ªÅ (Hardsub)..." if is_app_active else unactivated_text_short
            subtitle_style_settings_button.configure(state=final_main_action_state, text=style_text_sub)

        # --- Khung C·∫•u h√¨nh Whisper ---
        # L∆∞u √Ω: model_menu, lang_menu, format_menu c√≥ th·ªÉ l√† local variables, b·ªè qua v√¨ kh√¥ng ƒë∆∞·ª£c l∆∞u trong SubtitleTab

        # --- Khung D·ªãch Ph·ª• ƒê·ªÅ ---
        bilingual_checkbox = getattr(subtitle_tab, 'bilingual_checkbox', None)
        if bilingual_checkbox and bilingual_checkbox.winfo_exists():
            bilingual_checkbox.configure(state=whisper_translate_controls_state_effective)

        engine_menu = getattr(subtitle_tab, 'engine_menu', None)
        if engine_menu and engine_menu.winfo_exists():
            engine_menu.configure(state=whisper_translate_controls_state_effective)

        current_engine_sub = self.translation_engine_var.get() if hasattr(self, 'translation_engine_var') else "Kh√¥ng d·ªãch"
        target_lang_menu_state_sub = ctk.DISABLED
        openai_style_menu_state_sub = ctk.DISABLED

        if whisper_translate_controls_state_effective == ctk.NORMAL and current_engine_sub != "Kh√¥ng d·ªãch":
            target_lang_menu_state_sub = ctk.NORMAL
            if "ChatGPT API" in current_engine_sub:
                openai_style_menu_state_sub = ctk.NORMAL

        target_lang_menu = getattr(subtitle_tab, 'target_lang_menu', None)
        if target_lang_menu and target_lang_menu.winfo_exists():
            target_lang_menu.configure(state=target_lang_menu_state_sub)
        
        openai_style_menu = getattr(subtitle_tab, 'openai_style_menu', None)
        if openai_style_menu and openai_style_menu.winfo_exists():
            openai_style_menu.configure(state=openai_style_menu_state_sub)

        openai_style_frame = getattr(subtitle_tab, 'openai_style_frame', None)
        target_lang_frame = getattr(subtitle_tab, 'target_lang_frame', None)
        if openai_style_frame and openai_style_frame.winfo_exists():
            if openai_style_menu_state_sub == ctk.NORMAL:
                if not openai_style_frame.winfo_ismapped() and target_lang_frame and target_lang_frame.winfo_exists():
                    openai_style_frame.pack(fill='x', padx=10, pady=(0, 5), after=target_lang_frame)
            else:
                if openai_style_frame.winfo_ismapped():
                    openai_style_frame.pack_forget()

        # N√∫t API Keys (tab d·ªãch) ‚Äì cho m·ªü khi ƒë√£ k√≠ch ho·∫°t
        api_settings_button_translate_tab = getattr(subtitle_tab, 'api_settings_button_translate_tab', None)
        if api_settings_button_translate_tab and api_settings_button_translate_tab.winfo_exists():
            api_settings_button_translate_tab.configure(state=(ctk.NORMAL if is_app_active else ctk.DISABLED))

        # --- Khung G·ªôp Sub & T√πy ch·ªçn ---
        merge_sub_segmented_button_ref = getattr(subtitle_tab, 'merge_sub_segmented_button_ref', None)
        if merge_sub_segmented_button_ref and merge_sub_segmented_button_ref.winfo_exists():
            merge_sub_segmented_button_ref.configure(state=final_main_action_state)

        manual_merge_mode_checkbox = getattr(subtitle_tab, 'manual_merge_mode_checkbox', None)
        if manual_merge_mode_checkbox and manual_merge_mode_checkbox.winfo_exists():
            manual_merge_mode_checkbox.configure(
                state=(ctk.NORMAL if (is_app_active and not subbing_active) else ctk.DISABLED)
            )

        pause_edit_final_state_sub = ctk.DISABLED
        if is_app_active and not subbing_active and not is_manual_mode:
            pause_edit_final_state_sub = ctk.NORMAL
        pause_edit_checkbox = getattr(subtitle_tab, 'pause_edit_checkbox', None)
        if pause_edit_checkbox and pause_edit_checkbox.winfo_exists():
            pause_edit_checkbox.configure(state=pause_edit_final_state_sub)
            if not is_app_active or is_manual_mode:
                if hasattr(self, 'pause_for_edit_var'):
                    self.pause_for_edit_var.set(False)

        # --- Kh√≥a/M·ªü nh√≥m n√∫t Sub Editor + kh√¥i ph·ª•c text g·ªëc khi m·ªü ---
        sub_editor_buttons = [
            getattr(subtitle_tab, 'open_sub_button_ref', None),        # M·ªü Sub
            getattr(subtitle_tab, 'edit_sub_button_ref', None),        # S·ª≠a Sub
            getattr(subtitle_tab, 'save_sub_button_ref', None),        # L∆∞u Sub
            getattr(subtitle_tab, 'sub_clear_content_button', None),   # X√≥a n·ªôi dung
        ]

        def _lock_button_with_label(w):
            if w and hasattr(w, 'configure') and w.winfo_exists():
                try:
                    # L∆∞u nh√£n g·ªëc l·∫°i 1 l·∫ßn
                    if not hasattr(w, '_default_text'):
                        try:
                            w._default_text = w.cget("text")
                        except Exception:
                            w._default_text = None
                    w.configure(state=ctk.DISABLED, text="üîí K√≠ch ho·∫°t")
                except Exception:
                    pass

        def _unlock_button_restore_label(w, enable=True, fallback_text=None):
            if w and hasattr(w, 'configure') and w.winfo_exists():
                try:
                    # L·∫•y nh√£n g·ªëc n·∫øu c√≥; n·∫øu kh√¥ng c√≥ th√¨ d√πng fallback
                    label = getattr(w, '_default_text', None) or fallback_text
                    if label:
                        w.configure(state=(ctk.NORMAL if enable else ctk.DISABLED), text=label)
                    else:
                        w.configure(state=(ctk.NORMAL if enable else ctk.DISABLED))
                except Exception:
                    pass

        if not is_app_active:
            for w in sub_editor_buttons:
                _lock_button_with_label(w)
        else:
            # khi ƒë√£ k√≠ch ho·∫°t: b·∫≠t n·∫øu kh√¥ng b·∫≠n (·ªü ƒë√¢y l·∫•y theo subbing_active)
            is_busy_here = bool(subbing_active)
            # B·∫°n c√≥ th·ªÉ ƒëi·ªÅn fallback_text theo nh√£n mong mu·ªën ph√≤ng khi _default_text kh√¥ng l·∫•y ƒë∆∞·ª£c
            defaults = {
                'open_sub_button_ref':       "M·ªü Sub...",
                'edit_sub_button_ref':       "S·ª≠a Sub",
                'save_sub_button_ref':       "L∆∞u Sub",
                'sub_clear_content_button':  "X√≥a n·ªôi dung",
            }
            for name in ('open_sub_button_ref','edit_sub_button_ref','save_sub_button_ref','sub_clear_content_button'):
                w = getattr(subtitle_tab, name, None)
                _unlock_button_restore_label(w, enable=(not is_busy_here), fallback_text=defaults.get(name))


        optimize_tts_checkbox = getattr(subtitle_tab, 'optimize_whisper_tts_voice_checkbox', None)
        if optimize_tts_checkbox and optimize_tts_checkbox.winfo_exists():
            if not is_app_active or subbing_active or is_manual_mode:
                optimize_tts_checkbox.configure(state=ctk.DISABLED)
                if is_manual_mode and hasattr(self, 'optimize_whisper_tts_voice_var') and self.optimize_whisper_tts_voice_var.get():
                    self.optimize_whisper_tts_voice_var.set(False)
            else:
                optimize_tts_checkbox.configure(state=ctk.NORMAL)

        continue_merge_button_widget = getattr(subtitle_tab, 'continue_merge_button', None)
        if continue_merge_button_widget and continue_merge_button_widget.winfo_exists():
            is_actively_paused_for_edit_local = (
                is_app_active and
                subbing_active and
                bool(getattr(self, 'is_actively_paused_for_edit', False))
            )
            continue_merge_button_widget.configure(state=(ctk.NORMAL if is_actively_paused_for_edit_local else ctk.DISABLED))

        # --- Khung Chia Ph·ª• ƒë·ªÅ ---
        split_widgets = [
            getattr(subtitle_tab, 'enable_split_checkbox_ref', None),
            getattr(subtitle_tab, 'max_chars_entry_ref', None),
            getattr(subtitle_tab, 'max_lines_entry_ref', None),
            getattr(subtitle_tab, 'split_mode_menu', None),
            getattr(subtitle_tab, 'sub_cps_entry', None)
        ]
        for widget in split_widgets:
            if widget and hasattr(widget, 'configure') and widget.winfo_exists():
                widget.configure(state=split_and_merge_controls_state)

        if hasattr(self, '_toggle_split_options_state_internal'):
            self.after(10, self._toggle_split_options_state_internal)

        # --- Khung T√πy ch·ªçn G·ªôp Kh·ªëi ---
        block_merge_widgets = [
            getattr(subtitle_tab, 'enable_block_merging_checkbox', None),
            getattr(subtitle_tab, 'merge_time_gap_entry', None),
            getattr(subtitle_tab, 'merge_max_len_entry', None)
        ]
        for widget in block_merge_widgets:
            if widget and hasattr(widget, 'configure') and widget.winfo_exists():
                widget.configure(state=split_and_merge_controls_state)

        if hasattr(self, '_toggle_block_merge_options_state'):
            self.after(20, self._toggle_block_merge_options_state)

        # --- Khung T·ª± ƒë·ªông ƒë·ªãnh d·∫°ng SRT ---
        auto_format_frame = getattr(subtitle_tab, 'auto_format_srt_frame', None)
        if auto_format_frame and auto_format_frame.winfo_exists():
            for widget in auto_format_frame.winfo_children():
                if hasattr(widget, 'configure'):
                    widget.configure(state=split_and_merge_controls_state)

        # --- FINAL CLAMP: Kho√° c·ª©ng checkbox 'D·ª´ng l·∫°i ƒë·ªÉ ch·ªânh s·ª≠a sub' ---
        # pecb = pause_edit_checkbox ƒë√£ ƒë∆∞·ª£c l·∫•y ·ªü tr√™n
        if pause_edit_checkbox and pause_edit_checkbox.winfo_exists():
            # ƒêi·ªÅu ki·ªán ƒë·ªÉ V√î HI·ªÜU H√ìA checkbox (v·∫´n gi·ªØ nguy√™n)
            must_lock = (not is_app_active) or bool(is_manual_mode) or bool(subbing_active)
            pause_edit_checkbox.configure(state=(ctk.DISABLED if must_lock else ctk.NORMAL))

            # ***S·ª¨A L·ªñI ·ªû ƒê√ÇY***
            # ƒêi·ªÅu ki·ªán ƒë·ªÉ RESET (b·ªè tick) checkbox:
            # Ch·ªâ reset khi kh√¥ng k√≠ch ho·∫°t ho·∫∑c khi ·ªü ch·∫ø ƒë·ªô th·ªß c√¥ng.
            # KH√îNG reset khi ƒëang subbing_active, v√¨ l√∫c ƒë√≥ ta c·∫ßn gi·ªØ l·∫°i gi√° tr·ªã c·ªßa n√≥.
            reason_to_reset_var = (not is_app_active) or bool(is_manual_mode)
            if reason_to_reset_var and hasattr(self, 'pause_for_edit_var'):
                self.pause_for_edit_var.set(False)

        # --- C√°c n√∫t AI (Tab Sub) ---
        # L·∫•y key m·ªôt c√°ch an to√†n
        openai_key = (self.openai_key_var.get().strip() if hasattr(self, 'openai_key_var') and self.openai_key_var else "")
        gemini_key = (self.gemini_key_var.get().strip() if hasattr(self, 'gemini_key_var') and self.gemini_key_var else "")
        google_json = (self.google_key_path_var.get().strip() if hasattr(self, 'google_key_path_var') and self.google_key_path_var else "")

        allow_interaction = (not subbing_active) or bool(getattr(self, 'is_actively_paused_for_edit', False))

        ai_edit_btn_sub = getattr(subtitle_tab, 'ai_edit_button_sub_tab', None)
        if ai_edit_btn_sub and ai_edit_btn_sub.winfo_exists():
            if not is_app_active:
                ai_edit_btn_sub.configure(state=ctk.DISABLED, text=unactivated_text_short)
            else:
                can_use_ai = bool(openai_key) or bool(gemini_key)
                final_state = ctk.NORMAL if (can_use_ai and allow_interaction) else ctk.DISABLED
                ai_edit_btn_sub.configure(state=final_state, text="‚ú® Bi√™n t·∫≠p (AI)")

        dalle_btn_sub = getattr(subtitle_tab, 'dalle_button_sub_tab', None)
        if dalle_btn_sub and dalle_btn_sub.winfo_exists():
            if not is_app_active:
                dalle_btn_sub.configure(state=ctk.DISABLED, text=unactivated_text_short)
            else:
                can_use_openai = bool(openai_key)
                final_state = ctk.NORMAL if (can_use_openai and allow_interaction) else ctk.DISABLED
                dalle_btn_sub.configure(state=final_state, text="üé® T·∫°o ·∫¢nh AI")

        imagen_btn_sub = getattr(subtitle_tab, 'imagen_button_sub_tab', None)
        if imagen_btn_sub and imagen_btn_sub.winfo_exists():
            if not is_app_active:
                imagen_btn_sub.configure(state=ctk.DISABLED, text=unactivated_text_short)
            else:
                can_use_google = bool(google_json)
                final_state = ctk.NORMAL if (can_use_google and allow_interaction) else ctk.DISABLED
                imagen_btn_sub.configure(state=final_state, text="üñº ·∫¢nh(Imagen)")

        # --- N√∫t D·ª´ng ---
        stop_button = getattr(subtitle_tab, 'stop_button', None)
        if stop_button and stop_button.winfo_exists():
            any_sub_tab_task_running = (
                subbing_active or
                bool(getattr(self, 'is_gpt_processing_script', False)) or
                bool(getattr(self, 'is_dalle_processing', False)) or
                bool(getattr(self, 'is_creating_slideshow', False)) or
                bool(getattr(self, 'is_gemini_processing', False)) or
                bool(getattr(self, 'is_imagen_processing', False))
            )
            stop_button.configure(state=(ctk.NORMAL if any_sub_tab_task_running else ctk.DISABLED))

        # --- Textbox ph·ª• ƒë·ªÅ ---
        subtitle_textbox = getattr(subtitle_tab, 'subtitle_textbox', None)
        if subtitle_textbox and subtitle_textbox.winfo_exists():
            if not is_app_active:
                subtitle_textbox.configure(state=ctk.DISABLED)
            elif subbing_active and not bool(getattr(self, 'is_actively_paused_for_edit', False)):
                subtitle_textbox.configure(state=ctk.DISABLED)
                self.allow_edit_sub = False
            else:
                # Khi active & kh√¥ng b·∫≠n, cho nh·∫≠p b√¨nh th∆∞·ªùng (n·∫øu mu·ªën)
                try:
                    subtitle_textbox.configure(state=ctk.NORMAL)
                except Exception:
                    pass

        # --- C·∫≠p nh·∫≠t UI khi ·ªü Manual mode ---
        if hasattr(self, '_update_manual_mode_ui_elements'):
            self.after(20, self._update_manual_mode_ui_elements)

        # G·ªçi on_engine_change ƒë·ªÉ ƒë·ªìng b·ªô c√°c menu ph·ª• thu·ªôc (kh√¥ng ƒë√® status bar)
        if hasattr(self, 'translation_engine_var') and hasattr(self, 'on_engine_change'):
            try:
                self.on_engine_change(self.translation_engine_var.get(), update_status_bar=False)
            except Exception:
                pass


# B·∫°n c√≥ th·ªÉ c·∫ßn m·ªôt h√†m n·ªôi b·ªô ƒë·ªÉ qu·∫£n l√Ω state c·ªßa c√°c t√πy ch·ªçn chia d√≤ng
    def _toggle_split_options_state_internal(self):
        if not hasattr(self, 'enable_split_var'): return # Ch∆∞a c√≥ bi·∫øn th√¨ th√¥i
        
        dependent_state = ctk.NORMAL if self.enable_split_var.get() else ctk.DISABLED
        
        if hasattr(self, 'max_chars_entry_ref') and self.max_chars_entry_ref:
            self.max_chars_entry_ref.configure(state=dependent_state)
        if hasattr(self, 'max_lines_entry_ref') and self.max_lines_entry_ref:
            self.max_lines_entry_ref.configure(state=dependent_state)
        # Th√™m c√°c control kh√°c c·ªßa ph·∫ßn chia d√≤ng n·∫øu c√≥


# H√†m n√∫t m·ªü th∆∞ m·ª•c Sub
    def open_subtitle_tab_output_folder(self):
        """M·ªü th∆∞ m·ª•c output ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh cho tab T·∫°o Ph·ª• ƒê·ªÅ."""
        logging.info("[UI SubTab] Y√™u c·∫ßu m·ªü th∆∞ m·ª•c output c·ªßa tab Sub.")
        current_path = self.output_path_var.get()
        if current_path and os.path.isdir(current_path):
            open_file_with_default_app(current_path)
        elif current_path:
            messagebox.showwarning("ƒê∆∞·ªùng d·∫´n kh√¥ng h·ª£p l·ªá", 
                                   f"ƒê∆∞·ªùng d·∫´n ƒë√£ c·∫•u h√¨nh kh√¥ng ph·∫£i l√† m·ªôt th∆∞ m·ª•c h·ª£p l·ªá:\n{current_path}", 
                                   parent=self)
        else:
            messagebox.showwarning("Ch∆∞a ch·ªçn th∆∞ m·ª•c", 
                                   "Vui l√≤ng ch·ªçn 'Th∆∞ m·ª•c l∆∞u Sub/Video G·ªôp' tr∆∞·ªõc.", 
                                   parent=self)


# H√†m ki·ªÉm tra Audio cho ti·∫øn tr√¨nh Sub
    def check_for_audio_stream(self, filepath):
        """
        Ki·ªÉm tra xem file media c√≥ ch·ª©a √≠t nh·∫•t m·ªôt lu·ªìng √¢m thanh hay kh√¥ng b·∫±ng ffprobe.
        Tr·∫£ v·ªÅ True n·∫øu c√≥ audio, False n·∫øu kh√¥ng c√≥ ho·∫∑c c√≥ l·ªói.
        """
        ffprobe_exec = find_ffprobe() # S·ª≠ d·ª•ng h√†m find_ffprobe() b·∫°n ƒë√£ c√≥
        if not ffprobe_exec:
            logging.error("[AudioCheck] ffprobe kh√¥ng t√¨m th·∫•y, kh√¥ng th·ªÉ ki·ªÉm tra lu·ªìng √¢m thanh.")
            # Trong tr∆∞·ªùng h·ª£p ffprobe thi·∫øu, b·∫°n c√≥ th·ªÉ quy·∫øt ƒë·ªãnh tr·∫£ v·ªÅ True (ƒë·ªÉ th·ª≠ x·ª≠ l√Ω)
            # ho·∫∑c False (ƒë·ªÉ b√°o l·ªói). An to√†n h∆°n l√† b√°o l·ªói ho·∫∑c True ƒë·ªÉ gi·ªØ h√†nh vi c≈©.
            # T·∫°m th·ªùi, n·∫øu kh√¥ng c√≥ ffprobe, ch√∫ng ta kh√¥ng th·ªÉ ch·∫Øc ch·∫Øn, n√™n c√≥ th·ªÉ cho qua.
            # Tuy nhi√™n, m·ªôt ·ª©ng d·ª•ng ho√†n ch·ªânh n√™n y√™u c·∫ßu ffprobe.
            # self.after(0, lambda: messagebox.showwarning("Thi·∫øu c√¥ng c·ª•", "Kh√¥ng t√¨m th·∫•y ffprobe. Kh√¥ng th·ªÉ ki·ªÉm tra √¢m thanh c·ªßa file.", parent=self))
            return True # Gi·∫£ ƒë·ªãnh l√† c√≥ audio n·∫øu kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c, ƒë·ªÉ tr√°nh d·ª´ng c·∫£ qu√° tr√¨nh n·∫øu ffprobe thi·∫øu.

        command = [
            ffprobe_exec,
            "-v", "error",              # Ch·ªâ hi·ªÉn th·ªã l·ªói
            "-select_streams", "a",     # Ch·ªâ ch·ªçn c√°c lu·ªìng √¢m thanh
            "-show_entries", "stream=codec_type", # Y√™u c·∫ßu th√¥ng tin codec (n·∫øu c√≥ lu·ªìng audio, s·∫Ω c√≥ output)
            "-of", "csv=p=0",           # ƒê·ªãnh d·∫°ng output ƒë∆°n gi·∫£n
            os.path.abspath(filepath)
        ]
        logging.debug(f"[AudioCheck] L·ªánh ki·ªÉm tra audio: {' '.join(command)}")
        try:
            startupinfo = None
            creationflags = 0
            if sys.platform == "win32": # ·∫®n c·ª≠a s·ªï console tr√™n Windows
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                startupinfo.wShowWindow = subprocess.SW_HIDE
                creationflags = subprocess.CREATE_NO_WINDOW

            result = subprocess.run(command, capture_output=True, text=True, check=False, timeout=15, # Timeout 15 gi√¢y
                                   startupinfo=startupinfo, creationflags=creationflags)

            if result.returncode == 0 and result.stdout.strip():
                # N·∫øu l·ªánh ch·∫°y th√†nh c√¥ng v√† c√≥ output (t·ª©c l√† c√≥ th√¥ng tin codec c·ªßa √≠t nh·∫•t 1 lu·ªìng audio)
                logging.info(f"[AudioCheck] File '{os.path.basename(filepath)}' c√≥ (c√°c) lu·ªìng √¢m thanh: {result.stdout.strip()}")
                return True
            else:
                # L·ªánh ch·∫°y th√†nh c√¥ng nh∆∞ng kh√¥ng c√≥ output (kh√¥ng c√≥ audio stream) ho·∫∑c l·ªánh l·ªói
                log_msg = f"[AudioCheck] File '{os.path.basename(filepath)}' KH√îNG c√≥ lu·ªìng √¢m thanh."
                if result.returncode != 0:
                    log_msg += f" M√£ l·ªói ffprobe: {result.returncode}."
                if result.stderr.strip():
                    log_msg += f" FFprobe stderr: {result.stderr.strip()}"
                logging.warning(log_msg)
                return False
        except subprocess.TimeoutExpired:
            logging.error(f"[AudioCheck] Timeout khi ki·ªÉm tra lu·ªìng √¢m thanh cho file '{os.path.basename(filepath)}'.")
            return False # Coi nh∆∞ l·ªói, kh√¥ng c√≥ audio
        except Exception as e:
            logging.error(f"[AudioCheck] L·ªói kh√¥ng mong mu·ªën khi ki·ªÉm tra lu·ªìng √¢m thanh cho '{os.path.basename(filepath)}': {e}", exc_info=True)
            return False # Coi nh∆∞ l·ªói, kh√¥ng c√≥ audio



# H√†m h√†nh ƒë·ªông: X√≥a n·ªôi dung trong √¥ log download
# H√†m h√†nh ƒë·ªông: X√≥a n·ªôi dung trong √¥ log Sub
    def clear_subtitle_textbox_content(self):
        """ X√≥a to√†n b·ªô n·ªôi dung trong √¥ subtitle_textbox v√† b·∫≠t ch·∫ø ƒë·ªô nh·∫≠p li·ªáu. """
        subtitle_tab = getattr(self, 'subtitle_view_frame', None)
        if not subtitle_tab:
            logging.warning("Kh√¥ng t√¨m th·∫•y SubtitleTab ƒë·ªÉ x√≥a n·ªôi dung.")
            return
        textbox_widget = getattr(subtitle_tab, 'subtitle_textbox', None)
        if textbox_widget and textbox_widget.winfo_exists():
            try:
                # 1. Lu√¥n ƒë·∫∑t state="normal" ƒë·ªÉ cho ph√©p x√≥a v√† nh·∫≠p li·ªáu
                textbox_widget.configure(state="normal")
                
                # 2. X√≥a to√†n b·ªô n·ªôi dung (bao g·ªìm c·∫£ placeholder n·∫øu c√≥)
                textbox_widget.delete("1.0", "end")
                
                # 3. ƒê·∫∑t c·ªù cho ph√©p s·ª≠a v√† ƒë·∫£m b·∫£o textbox ·ªü tr·∫°ng th√°i normal
                self.allow_edit_sub = True 
                # textbox_widget.configure(state="normal") # ƒê√£ ƒë·∫∑t ·ªü tr√™n, kh√¥ng c·∫ßn l·∫∑p l·∫°i

                logging.info("Ng∆∞·ªùi d√πng ƒë√£ x√≥a n·ªôi dung trong subtitle_textbox v√† b·∫≠t ch·∫ø ƒë·ªô nh·∫≠p.")
                self.update_status("ƒê√£ x√≥a n·ªôi dung. S·∫µn s√†ng ƒë·ªÉ nh·∫≠p ph·ª• ƒë·ªÅ m·ªõi.")
                
                # Reset current_srt_path v√¨ n·ªôi dung ƒë√£ b·ªã x√≥a v√† kh√¥ng c√≤n t∆∞∆°ng ·ª©ng v·ªõi file n√†o
                self.current_srt_path = None
                
                # C·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i c√°c n√∫t li√™n quan
                if hasattr(self, '_update_manual_mode_ui_elements'):
                    self._update_manual_mode_ui_elements()
                if hasattr(self, '_set_subtitle_tab_ui_state'):
                     self._set_subtitle_tab_ui_state(self.is_subbing)

            except Exception as e:
                logging.error(f"L·ªói khi x√≥a n·ªôi dung v√† b·∫≠t normal cho subtitle_textbox: {e}")
        else:
            logging.warning("Kh√¥ng t√¨m th·∫•y subtitle_textbox ƒë·ªÉ x√≥a n·ªôi dung.")



# H√†m h√†nh ƒë·ªông: B·∫Øt ƒë·∫ßu qu√° tr√¨nh T·∫£i v√† t·ª± ƒë·ªông Sub v√† Dub sau ƒë√≥
    def start_download_and_sub(self):
        """
        L·∫•y th√¥ng tin t·ª´ UI (∆∞u ti√™n self.download_urls_list, sau ƒë√≥ ƒë·∫øn textbox),
        ki·ªÉm tra, reset retry counts, v√† b·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫£i, 
        sau ƒë√≥ t·ª± ƒë·ªông sub c√°c video ƒë√£ t·∫£i.
        """
        logging.info("--- Nh·∫•n n√∫t T·∫£i & Auto Sub ('ALL') ---")

        # Lu√¥n ƒë·∫∑t c·ªù chu·ªói t√°c v·ª• l√† True khi b·∫Øt ƒë·∫ßu quy tr√¨nh n√†y
        self.chain_download_sub_dub_active = True

        # Ch·ªâ reset danh s√°ch file dubbing n·∫øu c√≥ √Ω ƒë·ªãnh dub
        if self.download_auto_dub_after_sub_var.get():
            self.files_for_chained_dubbing = [] # Reset/kh·ªüi t·∫°o danh s√°ch cho chu·ªói m·ªõi
            logging.info("   >>> Ch·∫ø ƒë·ªô ALL: S·∫Ω t·ª± ƒë·ªông Thuy·∫øt Minh sau khi Sub.")
        else:
            logging.info("   >>> Ch·∫ø ƒë·ªô ALL: Ch·ªâ T·∫£i v√† Sub.")
    
        # --- B∆∞·ªõc 1: Reset b·ªô ƒë·∫øm l·ªói v√† x√°c ƒë·ªãnh danh s√°ch URL c·∫ßn x·ª≠ l√Ω ---
        self.download_retry_counts.clear()
        logging.info("ƒê√£ x√≥a self.download_retry_counts cho l∆∞·ª£t T·∫£i & Sub m·ªõi.")
        # self.globally_completed_urls KH√îNG ƒë∆∞·ª£c clear ·ªü ƒë√¢y.

        urls_to_process_initial = []
        source_of_urls = "" 

        if hasattr(self, 'download_urls_list') and self.download_urls_list:
            source_of_urls = "h√†ng ch·ªù hi·ªán t·∫°i (self.download_urls_list)"
            logging.info(f"S·∫Ω s·ª≠ d·ª•ng {len(self.download_urls_list)} link t·ª´ {source_of_urls} cho T·∫£i & Sub.")
            # urls_to_process_initial s·∫Ω ƒë∆∞·ª£c l·∫•y t·ª´ self.download_urls_list ·ªü d∆∞·ªõi
            
        elif hasattr(self, 'download_view_frame') and hasattr(self.download_view_frame, 'download_url_text') and self.download_view_frame.download_url_text:
            urls_text_from_box = self.download_view_frame.download_url_text.get("1.0", "end-1c").strip()
            if urls_text_from_box:
                source_of_urls = "√¥ nh·∫≠p li·ªáu textbox"
                logging.info(f"H√†ng ch·ªù (self.download_urls_list) r·ªóng. ƒê·ªçc link t·ª´ {source_of_urls} cho T·∫£i & Sub.")
                
                temp_urls_from_box = []
                seen_urls_in_box = set()
                for line in urls_text_from_box.splitlines():
                    stripped_url = line.strip()
                    if stripped_url and stripped_url.startswith(('http://', 'https://')):
                        if stripped_url not in seen_urls_in_box:
                            temp_urls_from_box.append(stripped_url)
                            seen_urls_in_box.add(stripped_url)
                    elif stripped_url:
                         logging.warning(f"B·ªè qua URL kh√¥ng h·ª£p l·ªá t·ª´ textbox: {stripped_url}")
                
                if temp_urls_from_box:
                    self.download_urls_list = list(temp_urls_from_box)
                    logging.info(f"ƒê√£ c·∫≠p nh·∫≠t self.download_urls_list v·ªõi {len(self.download_urls_list)} link t·ª´ {source_of_urls} cho T·∫£i & Sub.")
                else:
                    messagebox.showwarning("Link kh√¥ng h·ª£p l·ªá", f"Kh√¥ng t√¨m th·∫•y link h·ª£p l·ªá n√†o trong {source_of_urls}.", parent=self)
                    return
            else:
                messagebox.showwarning("Thi·∫øu link", "Vui l√≤ng nh·∫≠p link v√†o √¥ ho·∫∑c th√™m t·ª´ Google Sheet cho T·∫£i & Sub.\nH√†ng ch·ªù hi·ªán t·∫°i c≈©ng ƒëang tr·ªëng.", parent=self)
                return
        else:
            messagebox.showerror("L·ªói Giao Di·ªán", "Kh√¥ng t√¨m th·∫•y ngu·ªìn nh·∫≠p link (textbox ho·∫∑c h√†ng ch·ªù) cho T·∫£i & Sub.", parent=self)
            return

        if not self.download_urls_list:
            messagebox.showwarning("H√†ng ch·ªù tr·ªëng", f"Kh√¥ng c√≥ link n√†o ƒë·ªÉ x·ª≠ l√Ω t·ª´ {source_of_urls} cho T·∫£i & Sub.", parent=self)
            return
        urls_to_process_initial = list(self.download_urls_list)


        # --- B∆∞·ªõc 2: Ki·ªÉm tra c√°c t√πy ch·ªçn kh√°c ---
        download_path = self.download_path_var.get()
        if not download_path:
            messagebox.showerror("L·ªói ƒê∆∞·ªùng D·∫´n", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c l∆∞u t·∫£i v·ªÅ h·ª£p l·ªá.", parent=self)
            return
        if self.download_rename_var.get() and not self.download_rename_box_var.get().strip():
            messagebox.showwarning("Thi·∫øu t√™n file", "Vui l√≤ng nh·∫≠p t√™n chung khi ch·ªçn ƒë·ªïi t√™n h√†ng lo·∫°t!", parent=self)
            return
        sound_file_path = self.download_sound_path_var.get()
        if self.download_sound_var.get() and (not sound_file_path or not os.path.isfile(sound_file_path)):
            messagebox.showwarning("Thi·∫øu file √¢m thanh", "Vui l√≤ng ch·ªçn file √¢m thanh h·ª£p l·ªá ho·∫∑c b·ªè check 'Ph√°t nh·∫°c'.", parent=self)
            return

        # --- B∆∞·ªõc 3: Chu·∫©n b·ªã config cho thread ---
        config = {
            # "urls": urls_to_process_initial, # Kh√¥ng c·∫ßn truy·ªÅn list URL v√†o config n·ªØa
            "mode": self.download_mode_var.get(), 
            "folder": download_path,
            "v_quality": self.download_video_quality_var.get().replace("p", ""),
            "a_quality": self.download_audio_quality_var.get().replace("k", ""),
            "rename_all": self.download_rename_var.get(),
            "base_name": self.download_rename_box_var.get().strip(),
            "do_sound": self.download_sound_var.get(),
            "sound_file": sound_file_path,
            "do_shutdown": self.download_shutdown_var.get(),
            "stop_on_error": self.download_stop_on_error_var.get(),
            "download_playlist": self.download_playlist_var.get(),
            "auto_sub_after_download": True,
            "use_cookies": self.download_use_cookies_var.get(),
            "cookies_file": self.download_cookies_path_var.get(),            
            "and_then_dub": self.download_auto_dub_after_sub_var.get()
        }
        logging.info(f"Config T·∫¢I & SUB ƒë√£ chu·∫©n b·ªã. S·ªë link ban ƒë·∫ßu trong h√†ng ch·ªù: {len(urls_to_process_initial)} t·ª´ {source_of_urls}.")
        # logging.debug(f"Config chi ti·∫øt: {config}")

        # --- B∆∞·ªõc 4: Chu·∫©n b·ªã giao di·ªán v√† tr·∫°ng th√°i ---
        self.current_download_url = None
        self.update_download_queue_display()

        # X√≥a log download s·ª≠ d·ª•ng method c·ªßa DownloadTab
        if hasattr(self, 'download_view_frame') and hasattr(self.download_view_frame, 'clear_download_log'):
            try:
                self.download_view_frame.clear_download_log()
            except Exception as e:
                logging.error(f"L·ªói khi x√≥a log download: {e}")
        
        self.stop_event.clear()
        self.download_view_frame.set_download_ui_state(downloading=True)
        self.download_view_frame.update_download_progress(0)
        
        self.download_view_frame.log_download(f"üöÄ B·∫Øt ƒë·∫ßu qu√° tr√¨nh T·∫¢I & T·ª∞ ƒê·ªòNG SUB (Ngu·ªìn: {source_of_urls})...")
        self.download_view_frame.log_download(f"   - S·ªë link hi·ªán c√≥ trong h√†ng ch·ªù: {len(self.download_urls_list)}")

        # --- B∆∞·ªõc 5: L∆∞u c√†i ƒë·∫∑t v√† ghi nh·∫≠n y√™u c·∫ßu t·∫Øt m√°y ---
        self.save_current_config()
        self.shutdown_requested_by_task = self.download_shutdown_var.get()
        logging.info(f"ƒê√£ b·∫Øt ƒë·∫ßu t√°c v·ª• T·∫£i & Auto Sub. Y√™u c·∫ßu t·∫Øt m√°y: {self.shutdown_requested_by_task}")

        self.start_time = time.time()
        self.update_time_realtime()

        # --- B∆∞·ªõc 6: B·∫Øt ƒë·∫ßu lu·ªìng t·∫£i ---
        try:
            if self.download_thread and self.download_thread.is_alive():
                 logging.warning("Lu·ªìng t·∫£i ƒëang ch·∫°y!")
                 messagebox.showwarning("ƒêang x·ª≠ l√Ω", "Qu√° tr√¨nh t·∫£i kh√°c ƒëang ch·∫°y, vui l√≤ng ƒë·ª£i.", parent=self)
                 self.download_view_frame.set_download_ui_state(downloading=True)
                 return
            
            logging.info(f"CHU·∫®N B·ªä T·∫†O THREAD (start_download_and_sub): self.download_urls_list l√∫c n√†y = {self.download_urls_list}")
            self.download_thread = threading.Thread(target=self.run_download, args=(config,), daemon=True, name="DownloadAndSubWorker")
            self.download_thread.start()
            logging.info("ƒê√£ b·∫Øt ƒë·∫ßu lu·ªìng T·∫£i & Auto Sub.")
        except Exception as e:
            logging.error(f"Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu lu·ªìng T·∫£i & Auto Sub: {e}", exc_info=True)
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu qu√° tr√¨nh T·∫£i & Sub:\n{e}", parent=self)
            self.download_view_frame.set_download_ui_state(downloading=False)


# --- H√†m x·ª≠ l√Ω cho c√°c n√∫t ch·ªçn media m·ªõi khi t·∫°m d·ª´ng ·ªü tab Sub ---
    def _sub_pause_handle_select_media(self): # [cite: 1]
        is_manual_mode = self.manual_merge_mode_var.get()
        status_prefix_init = "Gh√©p Th·ªß C√¥ng" if is_manual_mode else "T·∫°m d·ª´ng Sub"
        log_prefix_media_select = f"[{threading.current_thread().name}_SubPauseMediaSelect_V4(Manual:{is_manual_mode})]" # TƒÉng version
        logging.info(f"{log_prefix_media_select} N√∫t 'Ch·ªçn Video/·∫¢nh...' ƒë∆∞·ª£c nh·∫•n.")

        initial_dir_media_select = ""
        if self.sub_pause_selected_media_path and os.path.exists(os.path.dirname(self.sub_pause_selected_media_path)): # [cite: 3]
            initial_dir_media_select = os.path.dirname(self.sub_pause_selected_media_path)
        elif self.current_srt_path and os.path.exists(os.path.dirname(self.current_srt_path)):
            initial_dir_media_select = os.path.dirname(self.current_srt_path)
        elif self.output_path_var.get() and os.path.isdir(self.output_path_var.get()):
            initial_dir_media_select = self.output_path_var.get()
        else:
            initial_dir_media_select = get_default_downloads_folder()

        file_options = [
            ("Media files", "*.mp4 *.mkv *.mov *.avi *.png *.jpg *.jpeg *.bmp *.webp"), # [cite: 4]
            ("Video files", "*.mp4 *.mkv *.mov *.avi"),
            ("Image files", "*.png *.jpg *.jpeg *.bmp *.webp"),
            ("All files", "*.*")
        ]

        selected_paths = filedialog.askopenfilenames(
            title="Ch·ªçn Video ho·∫∑c M·ªôt/Nhi·ªÅu File ·∫¢nh (cho Sub)", # [cite: 5]
            filetypes=file_options,
            initialdir=initial_dir_media_select,
            parent=self
        )

        if not selected_paths:
            logging.info(f"{log_prefix_media_select} Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn media.")
            self.manual_sub_original_media_source_path = None
            return

        # <<< TH√äM M·ªöI: Ghi nh·ªõ ƒë∆∞·ªùng d·∫´n g·ªëc ngay khi ng∆∞·ªùi d√πng ch·ªçn >>>
        # Ta s·∫Ω l·∫•y ƒë∆∞·ªùng d·∫´n c·ªßa file ƒë·∫ßu ti√™n l√†m tham chi·∫øu cho th∆∞ m·ª•c
        self.manual_sub_original_media_source_path = os.path.abspath(selected_paths[0])
        logging.info(f"{log_prefix_media_select} ƒê√£ ghi nh·ªõ ƒë∆∞·ªùng d·∫´n media g·ªëc: {self.manual_sub_original_media_source_path}")
        # <<< K·∫æT TH√öC TH√äM M·ªöI >>>

        first_path = selected_paths[0]
        is_single_video_file = False # [cite: 6]
        is_single_image_file = False 
        are_multiple_image_files = False 

        video_extensions = ('.mp4', '.mkv', '.mov', '.avi', '.wmv', '.flv')
        image_extensions = ('.png', '.jpg', '.jpeg', '.bmp', '.webp', '.gif')

        if len(selected_paths) == 1:
            file_lower_single = first_path.lower() # [cite: 7]
            if file_lower_single.endswith(video_extensions):
                is_single_video_file = True
            elif file_lower_single.endswith(image_extensions):
                is_single_image_file = True 
        elif len(selected_paths) > 1:
            all_selected_are_images_check = True
            for spath_check_multi in selected_paths: # [cite: 8]
                if not spath_check_multi.lower().endswith(image_extensions):
                    all_selected_are_images_check = False
                    break
            if all_selected_are_images_check:
                are_multiple_image_files = True # [cite: 9]
            else:
                messagebox.showwarning("L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá",
                                       "N·∫øu ch·ªçn nhi·ªÅu file, t·∫•t c·∫£ ph·∫£i l√† file ·∫£nh ƒë∆∞·ª£c h·ªó tr·ª£.",
                                       parent=self) # [cite: 10]
                return
        
        if is_single_video_file:
            # === B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI CHO VIDEO ƒê∆†N L·∫∫ ===
            if not self._ensure_subtitle_source_for_manual_operation("video ƒë√£ ch·ªçn"):
                self.sub_pause_selected_media_path = None 
                if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists():
                    self.sub_pause_selected_media_info_label.configure(text="Vui l√≤ng cung c·∫•p ph·ª• ƒë·ªÅ tr∆∞·ªõc.")
                logging.info(f"{log_prefix_media_select} Ch·ªçn video ƒë∆°n l·∫ª, nh∆∞ng thi·∫øu ph·ª• ƒë·ªÅ. ƒê√£ h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng.")
                return 

            # N·∫øu qua ƒë∆∞·ª£c ƒë√¢y, nghƒ©a l√† ph·ª• ƒë·ªÅ ƒë√£ s·∫µn s√†ng
            self.sub_pause_selected_media_path = first_path 
            selected_filename_video = os.path.basename(first_path)
            if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists(): # [cite: 11]
                self.sub_pause_selected_media_info_label.configure(text=f"S·∫Ω d√πng Video: {selected_filename_video}")
            logging.info(f"{log_prefix_media_select} ƒê√£ ch·ªçn Video (ƒë∆°n l·∫ª): {selected_filename_video} (Ph·ª• ƒë·ªÅ ƒë√£ s·∫µn s√†ng).")
            self.update_status(f"‚ÑπÔ∏è {status_prefix_init} - S·∫Ω d√πng Video: {selected_filename_video}")
            # === K·∫æT TH√öC THAY ƒê·ªîI CHO VIDEO ƒê∆†N L·∫∫ ===
            if self.auto_add_manual_sub_task_var.get(): # Ki·ªÉm tra checkbox m·ªõi
                logging.info(f"{log_prefix_media_select} T·ª± ƒë·ªông th√™m t√°c v·ª• video th·ªß c√¥ng v√†o h√†ng ch·ªù.")
                # G·ªçi h√†m th√™m v√†o h√†ng ch·ªù sau m·ªôt kho·∫£ng tr·ªÖ nh·ªè ƒë·ªÉ UI k·ªãp c·∫≠p nh·∫≠t
                self.after(10, self._add_manual_sub_task_to_queue)
            # N·∫øu checkbox kh√¥ng ƒë∆∞·ª£c ch·ªçn, s·∫Ω kh√¥ng l√†m g√¨ c·∫£, ng∆∞·ªùi d√πng ph·∫£i t·ª± nh·∫•n n√∫t "Th√™m"
        elif is_single_image_file or are_multiple_image_files:
            image_paths_for_slideshow_sub_ctx = list(selected_paths)
            num_images_sub_ctx = len(image_paths_for_slideshow_sub_ctx) # [cite: 12]
            
            type_selection_log_sub_ctx = "1 file ·∫£nh" if is_single_image_file else f"{num_images_sub_ctx} file ·∫£nh"
            logging.info(f"{log_prefix_media_select} ƒê√£ ch·ªçn {type_selection_log_sub_ctx} ƒë·ªÉ t·∫°o slideshow.")

            # === S·ª¨ D·ª§NG H√ÄM TR·ª¢ GI√öP M·ªöI ===
            if not self._ensure_subtitle_source_for_manual_operation(type_selection_log_sub_ctx):
                self.sub_pause_selected_media_path = None
                if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists():
                    self.sub_pause_selected_media_info_label.configure(text="Vui l√≤ng cung c·∫•p ph·ª• ƒë·ªÅ tr∆∞·ªõc.")
                logging.info(f"{log_prefix_media_select} Ch·ªçn ·∫£nh, nh∆∞ng thi·∫øu ph·ª• ƒë·ªÅ. ƒê√£ h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng.")
                return 
            
            # N·∫øu ƒë·∫øn ƒë∆∞·ª£c ƒë√¢y, nghƒ©a l√† ph·ª• ƒë·ªÅ ƒë√£ OK. Gi·ªù c·∫ßn l·∫•y ƒë∆∞·ªùng d·∫´n SRT cho slideshow.
            srt_path_for_timing_sub_ctx = self.current_srt_path
            temp_srt_from_textbox_sub_ctx = None

            if not srt_path_for_timing_sub_ctx: 
                textbox_content = ""
                subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
                if subtitle_textbox and subtitle_textbox.winfo_exists(): # Ki·ªÉm tra tr∆∞·ªõc khi get
                    textbox_content = subtitle_textbox.get("1.0", "end-1c").strip()
                # _ensure_subtitle_source_for_manual_operation ƒë√£ x√°c nh·∫≠n textbox_content h·ª£p l·ªá n·∫øu srt_path_for_timing_sub_ctx r·ªóng
                try:
                    if not os.path.exists(self.temp_folder): os.makedirs(self.temp_folder, exist_ok=True) # [cite: 14]
                    temp_srt_from_textbox_sub_ctx = os.path.join(self.temp_folder, f"temp_sub_for_timing_pause_{uuid.uuid4().hex[:4]}.srt")
                    with open(temp_srt_from_textbox_sub_ctx, "w", encoding="utf-8") as f_temp_srt_sub_ctx:
                        f_temp_srt_sub_ctx.write(textbox_content) # [cite: 15]
                    srt_path_for_timing_sub_ctx = temp_srt_from_textbox_sub_ctx
                    logging.info(f"{log_prefix_media_select} T·∫°o file SRT t·∫°m t·ª´ textbox (sau khi ƒë·∫£m b·∫£o ph·ª• ƒë·ªÅ): {temp_srt_from_textbox_sub_ctx}")
                except Exception as e_create_temp_srt_sub_ctx:
                    logging.error(f"{log_prefix_media_select} L·ªói t·∫°o SRT t·∫°m (sau khi ƒë·∫£m b·∫£o ph·ª• ƒë·ªÅ): {e_create_temp_srt_sub_ctx}")
                    messagebox.showerror("L·ªói Subtitle", "Kh√¥ng th·ªÉ x·ª≠ l√Ω n·ªôi dung subtitle t·ª´ textbox ƒë·ªÉ t·∫°o slideshow.", parent=self) # [cite: 16]
                    if hasattr(self, 'sub_pause_selected_media_info_label'): self.sub_pause_selected_media_info_label.configure(text="L·ªói: X·ª≠ l√Ω sub l·ªói")
                    return
            
            if not srt_path_for_timing_sub_ctx or not os.path.exists(srt_path_for_timing_sub_ctx):
                messagebox.showerror("L·ªói Ph·ª• ƒê·ªÅ Nghi√™m Tr·ªçng", # [cite: 17]
                                     "Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n file ph·ª• ƒë·ªÅ h·ª£p l·ªá cho slideshow.\n"
                                     "Vui l√≤ng th·ª≠ l·∫°i.", parent=self)
                logging.error(f"{log_prefix_media_select} L·ªói nghi√™m tr·ªçng: Kh√¥ng c√≥ srt_path_for_timing_sub_ctx.")
                if temp_srt_from_textbox_sub_ctx and os.path.exists(temp_srt_from_textbox_sub_ctx): # [cite: 18]
                    try: os.remove(temp_srt_from_textbox_sub_ctx)
                    except: pass
                return

            if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists():
                self.sub_pause_selected_media_info_label.configure(text=f"ƒêang t·∫°o video t·ª´ {num_images_sub_ctx} ·∫£nh...") # [cite: 13]
            
            thread = threading.Thread(
                target=self._create_video_from_images_thread_for_sub_pause, 
                args=(image_paths_for_slideshow_sub_ctx, srt_path_for_timing_sub_ctx, temp_srt_from_textbox_sub_ctx),
                daemon=True, # [cite: 19]
                name="CreateMultiImageVideoThreadSubPause_V_WithEnsure"
            )
            thread.start()
            return 
        
        else: 
            self.sub_pause_selected_media_path = None 
            if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists(): # [cite: 20]
                 self.sub_pause_selected_media_info_label.configure(text="L·ª±a ch·ªçn media kh√¥ng h·ª£p l·ªá.")
            logging.warning(f"{log_prefix_media_select} L·ª±a ch·ªçn media kh√¥ng ƒë∆∞·ª£c x·ª≠ l√Ω. First path: {first_path if selected_paths else 'N/A'}") # [cite: 21]

        if is_single_video_file:
            logging.info(f"{log_prefix_media_select} Video ƒë∆°n l·∫ª ƒë√£ ƒë∆∞·ª£c ch·ªçn v√† x·ª≠ l√Ω. Kh√¥ng g·ªçi _update_manual_mode_ui_elements() ƒë·ªÉ tr√°nh reset ƒë∆∞·ªùng d·∫´n media.")
        elif not (is_single_image_file or are_multiple_image_files):
            logging.info(f"{log_prefix_media_select} L·ª±a ch·ªçn kh√¥ng ph·∫£i l√† video ƒë∆°n l·∫ª ho·∫∑c ·∫£nh h·ª£p l·ªá. G·ªçi _update_manual_mode_ui_elements() ƒë·ªÉ reset UI.")
            if hasattr(self, '_update_manual_mode_ui_elements'):
                self._update_manual_mode_ui_elements()
        # Tr∆∞·ªùng h·ª£p is_single_image_file ho·∫∑c are_multiple_image_files th√¨ h√†m ƒë√£ return s·ªõm h∆°n sau khi b·∫Øt ƒë·∫ßu thread.


# H√†m t·∫°o slideshow cho tab Sub
    def _sub_pause_handle_select_folder(self): 
        is_manual_mode = self.manual_merge_mode_var.get() # [cite: 1]
        log_prefix_folder = f"[SubPauseFolderSelect_V3_Updated(Manual:{is_manual_mode})]" # TƒÉng version log
        logging.info(f"{log_prefix_folder} N√∫t 'T·∫°o Slideshow t·ª´ Th∆∞ m·ª•c ·∫¢nh...' ƒë∆∞·ª£c nh·∫•n.") # [cite: 1]

        # === S·ª¨ D·ª§NG H√ÄM TR·ª¢ GI√öP M·ªöI NGAY ƒê·∫¶U ===
        if not self._ensure_subtitle_source_for_manual_operation("th∆∞ m·ª•c ·∫£nh ƒë√£ ch·ªçn"):
            logging.info(f"{log_prefix_folder} Ch·ªçn th∆∞ m·ª•c ·∫£nh, nh∆∞ng thi·∫øu ph·ª• ƒë·ªÅ. ƒê√£ h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng v√† d·ª´ng.")
            # Reset c√°c l·ª±a ch·ªçn media t·∫°m th·ªùi n·∫øu c√≥, v√¨ ng∆∞·ªùi d√πng c·∫ßn cung c·∫•p SRT tr∆∞·ªõc
            self.sub_pause_selected_media_path = None
            if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists():
                self.sub_pause_selected_media_info_label.configure(text="Vui l√≤ng cung c·∫•p ph·ª• ƒë·ªÅ tr∆∞·ªõc.")
            return 
        # === K·∫æT TH√öC S·ª¨ D·ª§NG H√ÄM TR·ª¢ GI√öP ===
        
        # N·∫øu ƒë·∫øn ƒë∆∞·ª£c ƒë√¢y, nghƒ©a l√† ph·ª• ƒë·ªÅ ƒë√£ OK.
        # Ti·∫øp t·ª•c v·ªõi logic ch·ªçn th∆∞ m·ª•c v√† x·ª≠ l√Ω ·∫£nh.

        initial_dir_slideshow_folder = (getattr(self, 'dub_selected_image_folder_path_var', None).get() # [cite: 11]
                                        if hasattr(self, 'dub_selected_image_folder_path_var') # [cite: 12]
                                        else None) or \
                                       (self.output_path_var.get() or get_default_downloads_folder()) # [cite: 13]

        folder_path = filedialog.askdirectory(
            title="Ch·ªçn Th∆∞ m·ª•c ch·ª©a ·∫¢nh cho Slideshow (T·∫°m d·ª´ng Sub)",
            initialdir=initial_dir_slideshow_folder,
            parent=self
        )

        if not folder_path:
            logging.info(f"{log_prefix_folder} Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn th∆∞ m·ª•c ·∫£nh.")
            self.manual_sub_original_media_source_path = None
            return
        # <<< TH√äM M·ªöI: Ghi nh·ªõ ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c g·ªëc >>>
        self.manual_sub_original_media_source_path = os.path.abspath(folder_path)
        logging.info(f"{log_prefix_folder} ƒê√£ ghi nh·ªõ ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c g·ªëc: {self.manual_sub_original_media_source_path}")
        # <<< K·∫æT TH√öC TH√äM M·ªöI >>>

        logging.info(f"{log_prefix_folder} ƒê√£ ch·ªçn th∆∞ m·ª•c ·∫£nh: {folder_path}") # [cite: 15]

        image_extensions_supported = ('.png', '.jpg', '.jpeg', '.bmp', '.webp', '.gif') # [cite: 15]
        image_paths_from_folder = [] # [cite: 15]
        try:
            for item_name in os.listdir(folder_path):
                item_full_path = os.path.join(folder_path, item_name) # [cite: 16]
                if os.path.isfile(item_full_path) and item_name.lower().endswith(image_extensions_supported):
                    image_paths_from_folder.append(item_full_path)
            image_paths_from_folder.sort() 
        except Exception as e_listdir:
            logging.error(f"{log_prefix_folder} L·ªói khi ƒë·ªçc file t·ª´ th∆∞ m·ª•c '{folder_path}': {e_listdir}", exc_info=True)
            messagebox.showerror("L·ªói ƒê·ªçc Th∆∞ M·ª•c", f"Kh√¥ng th·ªÉ ƒë·ªçc danh s√°ch ·∫£nh t·ª´ th∆∞ m·ª•c ƒë√£ ch·ªçn.\nL·ªói: {e_listdir}", parent=self) # [cite: 17]
            if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists():
                self.sub_pause_selected_media_info_label.configure(text="L·ªói ƒë·ªçc th∆∞ m·ª•c ·∫£nh.")
            # Kh√¥ng c·∫ßn d·ªçn d·∫πp temp_srt n·ªØa v√¨ logic ƒë√£ thay ƒë·ªïi
            return

        if not image_paths_from_folder:
            messagebox.showinfo("Kh√¥ng c√≥ ·∫¢nh", "Kh√¥ng t√¨m th·∫•y file ·∫£nh n√†o ƒë∆∞·ª£c h·ªó tr·ª£ trong th∆∞ m·ª•c ƒë√£ ch·ªçn.", parent=self) # [cite: 18]
            logging.warning(f"{log_prefix_folder} Kh√¥ng t√¨m th·∫•y ·∫£nh trong th∆∞ m·ª•c: {folder_path}") # [cite: 18]
            if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists():
                self.sub_pause_selected_media_info_label.configure(text="Th∆∞ m·ª•c kh√¥ng c√≥ ·∫£nh.") # [cite: 19]
            return
        
        # L·∫•y ƒë∆∞·ªùng d·∫´n SRT cho slideshow (ƒë√£ ƒë∆∞·ª£c _ensure... x√°c nh·∫≠n l√† c√≥ m·ªôt ngu·ªìn h·ª£p l·ªá)
        srt_path_for_timing_folder = self.current_srt_path
        temp_srt_from_textbox_folder = None # Kh·ªüi t·∫°o l·∫°i ·ªü ƒë√¢y

        if not srt_path_for_timing_folder: # N·∫øu self.current_srt_path r·ªóng, nghƒ©a l√† ph·ª• ƒë·ªÅ ph·∫£i t·ª´ textbox
            textbox_content_folder = ""
            subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
            if subtitle_textbox and subtitle_textbox.winfo_exists():
                 textbox_content_folder = subtitle_textbox.get("1.0", "end-1c").strip()
            # _ensure_subtitle_source_for_manual_operation ƒë√£ x√°c nh·∫≠n textbox_content_folder h·ª£p l·ªá n·∫øu ƒë·∫øn ƒë∆∞·ª£c ƒë√¢y
            try:
                if not os.path.exists(self.temp_folder): # [cite: 3]
                    os.makedirs(self.temp_folder, exist_ok=True) # [cite: 3]
                temp_srt_from_textbox_folder = os.path.join(self.temp_folder, f"temp_sub_for_timing_folder_{int(time.time())}.srt") # [cite: 3]
                with open(temp_srt_from_textbox_folder, "w", encoding="utf-8") as f_temp_srt_folder: # [cite: 4]
                    f_temp_srt_folder.write(textbox_content_folder) # [cite: 4]
                srt_path_for_timing_folder = temp_srt_from_textbox_folder # [cite: 4]
                logging.info(f"{log_prefix_folder} ƒê√£ t·∫°o file SRT t·∫°m t·ª´ textbox cho slideshow th∆∞ m·ª•c (sau khi ƒë·∫£m b·∫£o ph·ª• ƒë·ªÅ): {temp_srt_from_textbox_folder}") # [cite: 5]
            except Exception as e_create_temp_srt_folder:
                logging.error(f"{log_prefix_folder} L·ªói t·∫°o file SRT t·∫°m t·ª´ textbox cho slideshow th∆∞ m·ª•c (sau khi ƒë·∫£m b·∫£o ph·ª• ƒë·ªÅ): {e_create_temp_srt_folder}") # [cite: 5]
                messagebox.showerror("L·ªói Subtitle", "Kh√¥ng th·ªÉ x·ª≠ l√Ω n·ªôi dung subtitle t·ª´ textbox cho slideshow th∆∞ m·ª•c.", parent=self) # [cite: 5]
                if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists(): # [cite: 6]
                     self.sub_pause_selected_media_info_label.configure(text="L·ªói: X·ª≠ l√Ω sub l·ªói") # [cite: 6]
                return
        
        # Ki·ªÉm tra l·∫°i l·∫ßn cu·ªëi ƒë∆∞·ªùng d·∫´n SRT s·∫Ω d√πng (an to√†n h∆°n)
        if not srt_path_for_timing_folder or not os.path.exists(srt_path_for_timing_folder): # [cite: 10]
            messagebox.showerror("L·ªói Ph·ª• ƒê·ªÅ Nghi√™m Tr·ªçng", # [cite: 10]
                                 "Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n file ph·ª• ƒë·ªÅ h·ª£p l·ªá cho slideshow t·ª´ th∆∞ m·ª•c.\n"
                                 "Vui l√≤ng th·ª≠ l·∫°i.", parent=self)
            logging.error(f"{log_prefix_folder} L·ªói nghi√™m tr·ªçng: Kh√¥ng c√≥ srt_path_for_timing_folder ho·∫∑c file kh√¥ng t·ªìn t·∫°i, d√π _ensure... ƒë√£ x√°c nh·∫≠n c√≥ ngu·ªìn.") # [cite: 10]
            if temp_srt_from_textbox_folder and os.path.exists(temp_srt_from_textbox_folder): # [cite: 10]
                try: os.remove(temp_srt_from_textbox_folder) # [cite: 10]
                except: pass # [cite: 11]
            return # [cite: 11]

        logging.info(f"{log_prefix_folder} T√¨m th·∫•y {len(image_paths_from_folder)} ·∫£nh. Chu·∫©n b·ªã t·∫°o slideshow (timing t·ª´ SRT: {os.path.basename(srt_path_for_timing_folder)}).") # [cite: 20]

        if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists(): # [cite: 20]
            self.sub_pause_selected_media_info_label.configure(text=f"ƒêang t·∫°o video t·ª´ {len(image_paths_from_folder)} ·∫£nh (th∆∞ m·ª•c)...") # [cite: 20]
        
        if hasattr(self, 'sub_pause_select_media_button'): self.sub_pause_select_media_button.configure(state="disabled") # [cite: 20]
        if hasattr(self, 'sub_pause_select_folder_button'): self.sub_pause_select_folder_button.configure(state="disabled") # [cite: 21]
        if is_manual_mode:
            sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
            if sub_button and sub_button.winfo_exists():
                sub_button.configure(state="disabled") # [cite: 21]
        elif not is_manual_mode and hasattr(self, 'continue_merge_button'): # [cite: 21]
            self.continue_merge_button.configure(state="disabled") # [cite: 21]
        
        thread = threading.Thread(
            target=self._create_video_from_images_thread_for_sub_pause, # [cite: 22]
            args=(image_paths_from_folder, srt_path_for_timing_folder, temp_srt_from_textbox_folder), # [cite: 22]
            daemon=True, # [cite: 22]
            name="CreateFolderSlideshowThreadSubPause_V_WithEnsure" # ƒê·ªïi t√™n thread ƒë·ªÉ ph√¢n bi·ªát
        )
        thread.start() # [cite: 22]



# H√†m h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng ch·ªçn file srt ·ªü tab Sub
    def _ensure_subtitle_source_for_manual_operation(self, media_type_description="media ƒë√£ ch·ªçn"):
        """
        Ki·ªÉm tra xem ngu·ªìn ph·ª• ƒë·ªÅ (file SRT ho·∫∑c n·ªôi dung textbox h·ª£p l·ªá) c√≥ s·∫µn s√†ng kh√¥ng.
        N·∫øu kh√¥ng, s·∫Ω hi·ªÉn th·ªã messagebox h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng.
        Args:
            media_type_description (str): M√¥ t·∫£ lo·∫°i media ƒëang ƒë∆∞·ª£c ch·ªçn (v√≠ d·ª•: "video", "·∫£nh", "th∆∞ m·ª•c ·∫£nh")
                                          ƒë·ªÉ hi·ªÉn th·ªã trong messagebox.
        Returns:
            bool: True n·∫øu ngu·ªìn ph·ª• ƒë·ªÅ ƒë√£ s·∫µn s√†ng.
                  False n·∫øu ngu·ªìn ph·ª• ƒë·ªÅ ch∆∞a s·∫µn s√†ng v√† ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c h∆∞·ªõng d·∫´n (c·∫ßn ch·ªçn l·∫°i media sau).
        """
        log_prefix_ensure = f"[{threading.current_thread().name}_EnsureSubSrc]" # Th√™m log prefix
        
        has_srt_file = self.current_srt_path and os.path.exists(self.current_srt_path)
        
        # Ki·ªÉm tra n·ªôi dung textbox
        textbox_content = ""
        subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
        if subtitle_textbox and subtitle_textbox.winfo_exists():
            textbox_content = subtitle_textbox.get("1.0", "end-1c").strip()
        
        # S·ª≠ d·ª•ng h√†m _is_textbox_content_invalid_for_script ƒë·ªÉ ki·ªÉm tra
        has_valid_textbox_content = textbox_content and not self._is_textbox_content_invalid_for_script(textbox_content)

        if has_srt_file or has_valid_textbox_content:
            source_log = []
            if has_srt_file: source_log.append(f"File SRT: {os.path.basename(self.current_srt_path)}")
            if has_valid_textbox_content: source_log.append(f"Textbox (d√†i {len(textbox_content)} chars)")
            logging.info(f"{log_prefix_ensure} Ngu·ªìn ph·ª• ƒë·ªÅ c√≥ s·∫µn ({'; '.join(source_log)}) cho {media_type_description}.")
            return True # Ngu·ªìn ph·ª• ƒë·ªÅ ƒë√£ s·∫µn s√†ng

        # N·∫øu kh√¥ng c√≥ ngu·ªìn ph·ª• ƒë·ªÅ, hi·ªÉn th·ªã prompt
        logging.info(f"{log_prefix_ensure} Kh√¥ng c√≥ ngu·ªìn ph·ª• ƒë·ªÅ. Hi·ªÉn th·ªã prompt cho {media_type_description}.")
        response = messagebox.askyesno(
            "Thi·∫øu Ph·ª• ƒê·ªÅ",
            f"Ch∆∞a c√≥ n·ªôi dung ph·ª• ƒë·ªÅ ƒë·ªÉ s·ª≠ d·ª•ng v·ªõi {media_type_description}.\n\n"
            f"B·∫°n c√≥ mu·ªën ch·ªçn m·ªôt file SRT ngay b√¢y gi·ªù kh√¥ng?\n\n"
            f"(N·∫øu kh√¥ng, b·∫°n c√≥ th·ªÉ h·ªßy v√† nh·∫≠p n·ªôi dung v√†o √¥ ph·ª• ƒë·ªÅ, sau ƒë√≥ ch·ªçn l·∫°i {media_type_description}).",
            icon='question',
            parent=self
        )

        if response:  # Ng∆∞·ªùi d√πng ch·ªçn "Yes" ƒë·ªÉ t·∫£i file SRT
            self.load_old_sub_file() # H√†m n√†y s·∫Ω m·ªü file dialog v√† c·∫≠p nh·∫≠t self.current_srt_path/textbox
            # Sau khi self.load_old_sub_file() ch·∫°y, self.current_srt_path c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.
            # Ki·ªÉm tra l·∫°i xem vi·ªác t·∫£i c√≥ th√†nh c√¥ng kh√¥ng (b·∫±ng c√°ch ki·ªÉm tra l·∫°i c√°c bi·∫øn)
            has_srt_file_after_load = self.current_srt_path and os.path.exists(self.current_srt_path)
            subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
            textbox_content_after_load = subtitle_textbox.get("1.0", "end-1c").strip() if subtitle_textbox and subtitle_textbox.winfo_exists() else "" # L·∫•y l·∫°i n·ªôi dung textbox
            has_valid_textbox_after_load = textbox_content_after_load and not self._is_textbox_content_invalid_for_script(textbox_content_after_load)

            if has_srt_file_after_load or has_valid_textbox_after_load:
                 messagebox.showinfo(
                    "Th√¥ng b√°o",
                    "File SRT ƒë√£ ƒë∆∞·ª£c t·∫£i (ho·∫∑c n·ªôi dung textbox ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t).\n\n"
                    f"Vui l√≤ng ch·ªçn l·∫°i {media_type_description} ƒë·ªÉ ti·∫øp t·ª•c.",
                    parent=self
                )
            else: # Ng∆∞·ªùi d√πng h·ªßy dialog ch·ªçn file SRT
                messagebox.showinfo(
                    "H∆∞·ªõng d·∫´n",
                    "B·∫°n ƒë√£ h·ªßy ch·ªçn file SRT.\n"
                    f"Vui l√≤ng nh·∫≠p n·ªôi dung v√†o √¥ ph·ª• ƒë·ªÅ ho·∫∑c t·∫£i m·ªôt file SRT, sau ƒë√≥ ch·ªçn l·∫°i {media_type_description}.",
                    parent=self
                )
            return False # Quan tr·ªçng: ng∆∞·ªùi d√πng c·∫ßn th·ª±c hi·ªán l·∫°i thao t√°c ch·ªçn media
        else:  # Ng∆∞·ªùi d√πng ch·ªçn "No" ho·∫∑c ƒë√≥ng dialog
            messagebox.showinfo(
                "H∆∞·ªõng d·∫´n",
                "Vui l√≤ng nh·∫≠p n·ªôi dung v√†o √¥ ph·ª• ƒë·ªÅ ho·∫∑c t·∫£i m·ªôt file SRT, "
                f"sau ƒë√≥ ch·ªçn l·∫°i {media_type_description}.",
                parent=self
            )
            return False # Quan tr·ªçng: ng∆∞·ªùi d√πng c·∫ßn th·ª±c hi·ªán l·∫°i thao t√°c ch·ªçn media


#===========================================================================================================================================================================
# (CH·∫†Y TRONG LU·ªíNG) L·∫•y danh s√°ch gi·ªçng n√≥i ti·∫øng Vi·ªát m·ªõi nh·∫•t t·ª´ Google Cloud TTS API
    def _fetch_google_tts_voices_thread(self, callback, key_path):
        """
        (CH·∫†Y TRONG LU·ªíNG) L·∫•y danh s√°ch gi·ªçng n√≥i ti·∫øng Vi·ªát V√Ä TI·∫æNG ANH m·ªõi nh·∫•t t·ª´ Google Cloud TTS API.
        """
        worker_log_prefix = "[FetchGoogleVoicesThread_vFinal]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu l·∫•y danh s√°ch gi·ªçng n√≥i Google Cloud TTS (VI & EN)...")

        try:
            from google.cloud import texttospeech
            from google.oauth2 import service_account
            from google.api_core import exceptions as google_api_exceptions

            if not key_path or not os.path.exists(key_path):
                logging.warning(f"{worker_log_prefix} ƒê∆∞·ªùng d·∫´n file Google Key JSON kh√¥ng h·ª£p l·ªá ho·∫∑c b·ªã tr·ªëng.")
                self.after(0, callback, None, "KEY_FILE_MISSING")
                return

            credentials = service_account.Credentials.from_service_account_file(key_path)
            client = texttospeech.TextToSpeechClient(credentials=credentials)
            
            # L·∫•y T·∫§T C·∫¢ c√°c gi·ªçng, sau ƒë√≥ l·ªçc ra ti·∫øng Vi·ªát v√† ti·∫øng Anh
            response = client.list_voices()
            
            voices_dict = {}
            gender_map = {
                texttospeech.SsmlVoiceGender.MALE: "Nam",
                texttospeech.SsmlVoiceGender.FEMALE: "N·ªØ",
                texttospeech.SsmlVoiceGender.NEUTRAL: "Trung t√≠nh",
            }
            
            for voice in response.voices:
                # Ch·ªâ l·∫•y c√°c gi·ªçng Ti·∫øng Vi·ªát v√† Ti·∫øng Anh
                if not (voice.language_codes[0].startswith('vi-') or voice.language_codes[0].startswith('en-')):
                    continue

                voice_id = voice.name
                gender = gender_map.get(voice.ssml_gender, "N/A")
                lang_code_prefix = f"[{voice.language_codes[0].upper()}]" # V√≠ d·ª•: [VI-VN], [EN-US]

                try:
                    parts = voice_id.split('-')
                    voice_family = parts[2]
                    model_details = "-".join(parts[3:])
                    
                    region = ""
                    # Logic x√°c ƒë·ªãnh v√πng mi·ªÅn cho ti·∫øng Vi·ªát
                    if voice.language_codes[0].startswith('vi-'):
                        VOICE_REGION_MAP = {"Puck": "Mi·ªÅn B·∫Øc", "Antares": "Mi·ªÅn B·∫Øc", "Apus": "Mi·ªÅn B·∫Øc", "Achird": "Mi·ªÅn B·∫Øc", "Algenib": "Mi·ªÅn B·∫Øc", "Fenrir": "Mi·ªÅn B·∫Øc"}
                        region = " - Mi·ªÅn Nam" # M·∫∑c ƒë·ªãnh
                        if model_details.endswith(('C', 'D')):
                            region = " - Mi·ªÅn B·∫Øc"
                        else:
                            for key, mapped_region in VOICE_REGION_MAP.items():
                                if key.lower() in voice_id.lower():
                                    region = f" - {mapped_region}"
                                    break
                    
                    display_name = f"{lang_code_prefix} {gender}{region} ({voice_family} {model_details})"

                    # S·ª≠a l·∫°i voice_id ƒë·ªÉ n√≥ l√† key duy nh·∫•t v√† ƒë·∫ßy ƒë·ªß trong map
                    voices_dict[display_name] = voice_id
                except IndexError:
                    display_name = f"{lang_code_prefix} {voice_id} ({gender})"
                    voices_dict[display_name] = voice_id

            # ƒê·∫£o ng∆∞·ª£c key v√† value ƒë·ªÉ l∆∞u v√†o cache
            final_voices_map_for_cache = {v: k for k, v in voices_dict.items()}

            logging.info(f"{worker_log_prefix} L·∫•y th√†nh c√¥ng {len(final_voices_map_for_cache)} gi·ªçng n√≥i (VI & EN).")
            self.after(0, callback, final_voices_map_for_cache, None)

        except Exception as e:
            error_msg = f"L·ªói khi l·∫•y danh s√°ch gi·ªçng n√≥i Google: {e}"
            logging.error(f"{worker_log_prefix} {error_msg}", exc_info=True)
            self.after(0, callback, None, error_msg)


# (CH·∫†Y TR√äN LU·ªíNG UI) C·∫≠p nh·∫≠t cache v√† l√†m m·ªõi menu gi·ªçng ƒë·ªçc n·∫øu c·∫ßn
    def _handle_fetched_google_voices(self, voices_dict, error):
        """
        (CH·∫†Y TR√äN LU·ªíNG UI) C·∫≠p nh·∫≠t cache trong b·ªô nh·ªõ, l∆∞u v√†o file, 
        v√† l√†m m·ªõi menu gi·ªçng ƒë·ªçc.
        """
        log_prefix = "[HandleFetchedGoogleVoices]"
        
        if error:
            logging.error(f"{log_prefix} L·ªói: {error}")
            # Logic x·ª≠ l√Ω l·ªói gi·ªØ nguy√™n...
            if error == "KEY_FILE_MISSING":
                messagebox.showinfo(
                    "Y√™u c·∫ßu C·∫•u h√¨nh",
                    "ƒê·ªÉ t·∫£i danh s√°ch gi·ªçng ƒë·ªçc Google Cloud, b·∫°n c·∫ßn cung c·∫•p file key JSON.\n\n"
                    "Vui l√≤ng v√†o 'üîë C√†i ƒë·∫∑t API Keys' v√† ch·ªçn ƒë√∫ng file key c·ªßa b·∫°n.",
                    parent=self
                )
                if self.dub_selected_tts_engine_var.get() == "Google Cloud TTS":
                    try:
                        if hasattr(self, 'dub_voice_option_menu') and hasattr(self.dub_voice_option_menu, 'update_values'):
                            self.dub_voice_option_menu.update_values({"[C·∫ßn c·∫•u h√¨nh Key JSON]": ""})
                    except Exception:
                        pass
            else:
                if self.dub_selected_tts_engine_var.get() == "Google Cloud TTS":
                    try:
                        if hasattr(self, 'dub_voice_option_menu') and hasattr(self.dub_voice_option_menu, 'update_values'):
                            self.dub_voice_option_menu.update_values({"[L·ªói t·∫£i danh s√°ch]": ""})
                    except Exception:
                        pass
            return

        if voices_dict is not None:
            logging.info(f"{log_prefix} C·∫≠p nh·∫≠t cache trong b·ªô nh·ªõ v·ªõi {len(voices_dict)} gi·ªçng n√≥i Google.")
            self.google_tts_voices_cache = voices_dict
            
            # <<< B·∫ÆT ƒê·∫¶U TH√äM M·ªöI: L∆ØU V√ÄO FILE CACHE >>>
            try:
                cache_path = get_google_voices_cache_path()
                with open(cache_path, "w", encoding="utf-8") as f:
                    json.dump(voices_dict, f, ensure_ascii=False, indent=2)
                logging.info(f"ƒê√£ l∆∞u th√†nh c√¥ng cache gi·ªçng ƒë·ªçc Google v√†o: {cache_path}")
            except Exception as e_save_cache:
                logging.error(f"L·ªói khi l∆∞u file cache gi·ªçng ƒë·ªçc Google: {e_save_cache}")
            # <<< K·∫æT TH√öC TH√äM M·ªöI >>>
            
            if self.dub_selected_tts_engine_var.get() == "Google Cloud TTS":
                logging.info(f"{log_prefix} ƒêang ·ªü tab Google TTS, l√†m m·ªõi menu gi·ªçng ƒë·ªçc...")
                self.dub_on_tts_engine_selected("Google Cloud TTS")


# H√†m m·ªõi: Ki·ªÉm tra v√† c√≥ th·ªÉ l√†m m·ªõi cache gi·ªçng ƒë·ªçc Google
    def _maybe_refresh_google_voices_cache(self):
        """Ki·ªÉm tra tu·ªïi c·ªßa file cache v√† t·∫£i l·∫°i n·∫øu c·∫ßn."""
        cache_path = get_google_voices_cache_path()
        should_refresh = True # M·∫∑c ƒë·ªãnh l√† n√™n l√†m m·ªõi

        if os.path.exists(cache_path):
            try:
                file_age_seconds = time.time() - os.path.getmtime(cache_path)
                # L√†m m·ªõi sau m·ªói 7 ng√†y (7 * 24 * 60 * 60 gi√¢y)
                if file_age_seconds < 604800:
                    should_refresh = False
            except Exception as e:
                logging.warning(f"Kh√¥ng th·ªÉ ki·ªÉm tra tu·ªïi file cache gi·ªçng ƒë·ªçc: {e}")

        if should_refresh:
            logging.info("ƒê√£ ƒë·∫øn l√∫c l√†m m·ªõi cache gi·ªçng ƒë·ªçc Google ho·∫∑c file cache kh√¥ng t·ªìn t·∫°i. B·∫Øt ƒë·∫ßu t·∫£i n·ªÅn.")
            self._start_initial_google_voice_fetch() # G·ªçi l·∫°i h√†m b·∫Øt ƒë·∫ßu lu·ªìng t·∫£i
        else:
            logging.info("Cache gi·ªçng ƒë·ªçc Google v·∫´n c√≤n m·ªõi. B·ªè qua l√†m m·ªõi.")


# H√ÄM S·ª∞ KI·ªÜN: X·ª¨ L√ù KHI CH·ªåN TTS ENGINE
# H√ÄM S·ª¨A L·ªñI: dub_on_tts_engine_selected (S·ª≠ d·ª•ng ƒë√∫ng h√†m update_values)
    def dub_on_tts_engine_selected(self, selected_engine, _from_task_setup=False):
        """
        X·ª≠ l√Ω khi ng∆∞·ªùi d√πng ch·ªçn engine TTS.
        - C·∫≠p nh·∫≠t ƒë·ªÉ nh√≥m c√°c gi·ªçng Google Cloud theo ng√¥n ng·ªØ/qu·ªëc gia.
        - ƒê√É S·ª¨A L·ªñI: G·ªçi ƒë√∫ng h√†m update_values() cho widget t√πy ch·ªânh.
        """
        is_currently_restoring_config = hasattr(self, '_is_restoring_task_config') and self._is_restoring_task_config

        if not is_currently_restoring_config and not _from_task_setup:
            if self.initial_ui_setup_complete:
                self.update_status(f"Thuy·∫øt Minh - ƒê√£ ch·ªçn engine TTS: {selected_engine}")
            else:
                logging.debug(f"[Dubbing Status Startup] initial_ui_setup_complete=False, b·ªè qua update status ban ƒë·∫ßu cho Dubbing TTS engine: {selected_engine}")

        logging.info(f"[Dubbing] Engine TTS ƒë∆∞·ª£c ch·ªçn: {selected_engine} (ƒêang kh√¥i ph·ª•c config: {is_currently_restoring_config}, T·ª´ task setup: {_from_task_setup})")

        voice_option_menu = getattr(self, 'dub_voice_option_menu', None)
        if not (voice_option_menu and voice_option_menu.winfo_exists()):
            logging.warning("[Dubbing] Menu ch·ªçn gi·ªçng ho·∫∑c frame ch·ª©a n√≥ ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.")
            return

        self.dub_current_engine_voice_display_to_id_map.clear()
        display_names_for_menu = []

        if selected_engine == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)":
            if HAS_PYTTSX3 and pyttsx3:
                try:
                    temp_engine = pyttsx3.init()
                    if temp_engine is None: raise RuntimeError("pyttsx3.init() tr·∫£ v·ªÅ None")
                    system_voices = temp_engine.getProperty('voices')
                    temp_engine.stop()
                    if system_voices:
                        preferred_vietnamese_voice = None
                        for voice in system_voices:
                            langs_decoded = [lang_raw.decode('utf-8', 'ignore').lower() if isinstance(lang_raw, bytes) else str(lang_raw).lower() for lang_raw in voice.languages] if hasattr(voice, 'languages') and voice.languages else []
                            lang_suffix = f" ({', '.join(langs_decoded)})" if langs_decoded else ""
                            display_name_with_lang = f"{voice.name}{lang_suffix}"
                            display_names_for_menu.append(display_name_with_lang)
                            self.dub_current_engine_voice_display_to_id_map[display_name_with_lang] = voice.id
                            if not preferred_vietnamese_voice and (any('vi' in ld for ld in langs_decoded) or "vietnamese" in voice.name.lower() or "vi·ªát" in voice.name.lower()):
                                preferred_vietnamese_voice = display_name_with_lang
                        if preferred_vietnamese_voice and preferred_vietnamese_voice in display_names_for_menu:
                            display_names_for_menu.insert(0, display_names_for_menu.pop(display_names_for_menu.index(preferred_vietnamese_voice)))
                    if not display_names_for_menu: display_names_for_menu = ["Kh√¥ng t√¨m th·∫•y gi·ªçng HƒêH"]
                except Exception as e_get_voices:
                    logging.error(f"L·ªói l·∫•y danh s√°ch gi·ªçng h·ªá th·ªëng: {e_get_voices}", exc_info=True)
                    display_names_for_menu = ["L·ªói l·∫•y gi·ªçng HƒêH"]
            else:
                display_names_for_menu = ["pyttsx3 ch∆∞a c√†i ƒë·∫∑t"]
        
        elif selected_engine == "Google Cloud TTS":
            if self.google_tts_voices_cache:
                logging.info("S·ª≠ d·ª•ng danh s√°ch gi·ªçng n√≥i Google t·ª´ cache ƒë·ªông (v·ªõi logic nh√≥m ng√¥n ng·ªØ).")
                vietnamese_voices = []
                en_us_voices = []
                en_gb_voices = []
                en_au_voices = []
                other_en_voices = []
                
                for voice_id, display_name in self.google_tts_voices_cache.items():
                    if voice_id.startswith('vi-VN'):
                        vietnamese_voices.append((display_name, voice_id))
                    elif voice_id.startswith('en-US'):
                        en_us_voices.append((display_name, voice_id))
                    elif voice_id.startswith('en-GB'):
                        en_gb_voices.append((display_name, voice_id))
                    elif voice_id.startswith('en-AU'):
                        en_au_voices.append((display_name, voice_id))
                    elif voice_id.startswith('en-'):
                        other_en_voices.append((display_name, voice_id))

                def add_group_to_menu(group_list, group_title):
                    if group_list:
                        display_names_for_menu.append(f"--- {group_title} ---")
                        sorted_group = sorted(group_list, key=lambda item: item[0])
                        for name, v_id in sorted_group:
                            display_names_for_menu.append(name)
                            self.dub_current_engine_voice_display_to_id_map[name] = v_id
                
                add_group_to_menu(vietnamese_voices, "Ti·∫øng Vi·ªát")
                add_group_to_menu(en_us_voices, "Ti·∫øng Anh (M·ªπ)")
                add_group_to_menu(en_gb_voices, "Ti·∫øng Anh (Anh)")
                add_group_to_menu(en_au_voices, "Ti·∫øng Anh (√öc)")
                add_group_to_menu(other_en_voices, "Ti·∫øng Anh (Kh√°c)")
            else:
                display_names_for_menu = ["ƒêang t·∫£i danh s√°ch..."]
                logging.info("Cache gi·ªçng n√≥i Google r·ªóng, k√≠ch ho·∫°t lu·ªìng t·∫£i l·∫°i.")
                key_path_for_thread_on_demand = self.google_key_path_var.get()
                if key_path_for_thread_on_demand and os.path.exists(key_path_for_thread_on_demand):
                    threading.Thread(target=self._fetch_google_tts_voices_thread, args=(self._handle_fetched_google_voices, key_path_for_thread_on_demand), daemon=True, name="OnDemandGoogleVoiceFetch").start()
                else:
                    logging.warning("Kh√¥ng th·ªÉ t·∫£i l·∫°i gi·ªçng Google v√¨ thi·∫øu file Key JSON.")
                    display_names_for_menu = ["[C·∫ßn c·∫•u h√¨nh Key JSON]"]
        
        else:
            engine_specific_voices = self.dub_tts_voice_options.get(selected_engine, {})
            if engine_specific_voices:
                for voice_id, display_name in engine_specific_voices.items():
                    display_names_for_menu.append(display_name)
                    self.dub_current_engine_voice_display_to_id_map[display_name] = voice_id
            if not display_names_for_menu:
                display_names_for_menu = ["-- Kh√¥ng c√≥ gi·ªçng t√πy ch·ªçn --"]
        
        voice_option_menu.update_values(self.dub_current_engine_voice_display_to_id_map)
        logging.debug(f"[DubOnTTSEngineSelected] ƒê√£ g·ªçi update_values cho widget dropdown t√πy ch·ªânh.")
        
        def _update_voice_menu_state_and_selection():
            if not voice_option_menu.winfo_exists(): return
            intended_state_if_not_processing = ctk.DISABLED
            
            # Ki·ªÉm tra xem danh s√°ch c√≥ tr·ªëng ho·∫∑c ch·ªâ ch·ª©a placeholder kh√¥ng
            is_placeholder_or_error_idle = not self.dub_current_engine_voice_display_to_id_map
            
            if not is_placeholder_or_error_idle:
                intended_state_if_not_processing = ctk.NORMAL
            final_menu_state_to_set = intended_state_if_not_processing
            if hasattr(self, 'dub_is_processing') and self.dub_is_processing:
                final_menu_state_to_set = ctk.DISABLED
            
            # Widget CustomVoiceDropdown kh√¥ng c√≥ configure state, ta s·∫Ω qu·∫£n l√Ω trong logic c·ªßa n√≥
            
            if _from_task_setup:
                logging.info(f"[DubOnTTSEngineSelected-Idle] _from_task_setup=True. B·ªè qua t·ª± ƒë·ªông ch·ªçn gi·ªçng.")
                if not self.dub_current_engine_voice_display_to_id_map: self.dub_selected_voice_display_name_var.set("N/A")
            else:
                if final_menu_state_to_set == ctk.NORMAL:
                    chosen_display_name_idle = ""
                    saved_voice_id_from_general_cfg_idle = self.cfg.get("dub_selected_voice_id")
                    if saved_voice_id_from_general_cfg_idle:
                        for dn_idle, vid_idle in self.dub_current_engine_voice_display_to_id_map.items():
                            if vid_idle == saved_voice_id_from_general_cfg_idle:
                                chosen_display_name_idle = dn_idle; break
                    
                    if not chosen_display_name_idle and self.dub_current_engine_voice_display_to_id_map:
                        valid_choices = [name for name in self.dub_current_engine_voice_display_to_id_map.keys() if not name.startswith("---")]
                        if valid_choices:
                            chosen_display_name_idle = valid_choices[0]
                    
                    if chosen_display_name_idle: 
                        self.dub_selected_voice_display_name_var.set(chosen_display_name_idle)
                        self.dub_on_voice_selected(chosen_display_name_idle)
                    else:
                        self.dub_selected_voice_display_name_var.set("Kh√¥ng c√≥ l·ª±a ch·ªçn")
                        if hasattr(self, 'dub_selected_voice_id_var'): self.dub_selected_voice_id_var.set("")

            ssml_frame_widget = getattr(self, 'ssml_row_frame', None)
            parent_tts_controls = getattr(self, 'dub_tts_controls_frame', None)
            voice_row_frame_widget_ref = getattr(self, 'voice_row_frame_ref', None)
            if ssml_frame_widget and parent_tts_controls and voice_row_frame_widget_ref and \
               hasattr(ssml_frame_widget, 'winfo_exists') and ssml_frame_widget.winfo_exists() and \
               hasattr(parent_tts_controls, 'winfo_exists') and parent_tts_controls.winfo_exists() and \
               hasattr(voice_row_frame_widget_ref, 'winfo_exists') and voice_row_frame_widget_ref.winfo_exists():
                if ssml_frame_widget.winfo_ismapped(): ssml_frame_widget.pack_forget()
                if selected_engine == "Google Cloud TTS":
                    ssml_frame_widget.pack(in_=parent_tts_controls, fill="x", padx=10, pady=(2,5), after=voice_row_frame_widget_ref)
            elif selected_engine == "Google Cloud TTS":
                logging.warning("[DubbingUI_SSML] ssml_row_frame ho·∫∑c parent/tham chi·∫øu c·ªßa n√≥ ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o khi c·∫ßn hi·ªÉn th·ªã.")
        
        self.after_idle(_update_voice_menu_state_and_selection)
        # Also update SSML checkbox state after engine/voice list refresh
        try:
            self.after_idle(self._update_ssml_checkbox_state)
        except Exception:
            pass
                

# --- C√ÅC H√ÄM HELPER M·ªöI HO·∫∂C C·∫¶N ƒêI·ªÄU CH·ªàNH CHO TAB THUY·∫æT MINH ---

# H√†m x·ª≠ l√Ω th√™m audio
    def dub_load_audio_file(self):
        """
        M·ªü dialog ch·ªçn file audio (.mp3, .wav, .aac, .m4a) cho t√°c v·ª• thuy·∫øt minh.
        """
        initial_dir_audio = ""
        if self.dub_audio_path_for_queue_temp: # S·ª≠ d·ª•ng bi·∫øn m·ªõi
            initial_dir_audio = os.path.dirname(self.dub_audio_path_for_queue_temp)
        elif self.dub_output_path_var.get():
            initial_dir_audio = self.dub_output_path_var.get()
        else:
            initial_dir_audio = get_default_downloads_folder()

        file_path = filedialog.askopenfilename(
            title="Ch·ªçn file Audio (.mp3, .wav, .aac, .m4a) cho Thuy·∫øt minh",
            filetypes=[
                ("Audio files", "*.mp3 *.wav *.aac *.m4a"),
                ("All files", "*.*")
            ],
            initialdir=initial_dir_audio,
            parent=self
        )

        if file_path and os.path.exists(file_path):
            self.dub_audio_path_for_queue_temp = file_path # L∆∞u ƒë∆∞·ªùng d·∫´n file audio
            audio_filename = os.path.basename(file_path)
            self.dub_current_audio_for_queue_display.set(audio_filename) # C·∫≠p nh·∫≠t hi·ªÉn th·ªã (n·∫øu c√≥ label)
            logging.info(f"[DubLoadAudio] ƒê√£ ch·ªçn file Audio: {audio_filename}")
            self.update_status(f"ƒê√£ ch·ªçn Audio: {audio_filename}")
            # G·ªçi l·∫°i h√†m ki·ªÉm tra ƒë·ªÉ c√≥ th·ªÉ t·ª± ƒë·ªông th√™m v√†o h√†ng ch·ªù
            if hasattr(self, '_try_auto_add_to_dub_queue'):
                self._try_auto_add_to_dub_queue()
            if hasattr(self, '_update_dub_start_batch_button_state'):
                self._update_dub_start_batch_button_state()
        elif file_path: # Ng∆∞·ªùi d√πng ch·ªçn nh∆∞ng file kh√¥ng t·ªìn t·∫°i
            self.dub_audio_path_for_queue_temp = ""
            self.dub_current_audio_for_queue_display.set("(L·ªói: File audio kh√¥ng t·ªìn t·∫°i)")
            logging.warning(f"[DubLoadAudio] File audio ƒë√£ ch·ªçn kh√¥ng t·ªìn t·∫°i: {file_path}")
            if hasattr(self, '_try_auto_add_to_dub_queue'): self._try_auto_add_to_dub_queue()
        else: # Ng∆∞·ªùi d√πng h·ªßy
            # Ch·ªâ reset hi·ªÉn th·ªã n·∫øu ch∆∞a c√≥ g√¨ ƒë∆∞·ª£c ch·ªçn tr∆∞·ªõc ƒë√≥
            if not self.dub_audio_path_for_queue_temp:
                 self.dub_current_audio_for_queue_display.set("(Ch∆∞a ch·ªçn audio)")
            logging.info("[DubLoadAudio] ƒê√£ h·ªßy ch·ªçn file Audio.")
            if hasattr(self, '_try_auto_add_to_dub_queue'): self._try_auto_add_to_dub_queue()


# H√†m Ki·ªÉm Tra t·ª± ƒë·ªông th√™m v√†o h√†ng ch·ªù
    def _try_auto_add_to_dub_queue(self):
        """
        Ki·ªÉm tra n·∫øu c√≥ ƒë·ªß Video/·∫¢nh v√† (K·ªãch b·∫£n HO·∫∂C Audio ngo√†i) h·ª£p l·ªá ƒë√£ ch·ªçn,
        th√¨ t·ª± ƒë·ªông g·ªçi h√†m th√™m v√†o h√†ng ch·ªù x·ª≠ l√Ω thuy·∫øt minh.
        """
        # NgƒÉn kh√¥ng cho ch·∫°y n·∫øu ƒëang trong chu·ªói t·ª± ƒë·ªông
        if getattr(self, '_is_in_chaining_process', False):
            logging.debug("[AutoAddQueue] B·ªã ch·∫∑n do ƒëang trong qu√° tr√¨nh chuy·ªÉn giao chu·ªói.")
            return
        
        can_add_now = False
        
        has_valid_video = (
            hasattr(self, 'dub_current_video_path_for_queue_temp') and 
            self.dub_current_video_path_for_queue_temp and
            os.path.exists(self.dub_current_video_path_for_queue_temp)
        )

        has_valid_script_or_external_audio = False
        source_for_log_combined = "ch∆∞a x√°c ƒë·ªãnh"

        # Ki·ªÉm tra k·ªãch b·∫£n t·ª´ file SRT
        if hasattr(self, 'dub_current_script_path_for_queue_temp') and \
           self.dub_current_script_path_for_queue_temp and \
           os.path.exists(self.dub_current_script_path_for_queue_temp) and \
           hasattr(self, 'dub_temp_srt_data_for_queue') and self.dub_temp_srt_data_for_queue:
            has_valid_script_or_external_audio = True
            source_for_log_combined = f"file SRT ({os.path.basename(self.dub_current_script_path_for_queue_temp)})"
        
        # Ki·ªÉm tra k·ªãch b·∫£n t·ª´ textbox n·∫øu ch∆∞a c√≥ t·ª´ file
        elif hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
            textbox_content_for_try = self.dub_script_textbox.get("1.0", "end-1c").strip()
            if not self._is_textbox_content_invalid_for_script(textbox_content_for_try):
                has_valid_script_or_external_audio = True
                source_for_log_combined = "n·ªôi dung textbox"
        
        # N·∫øu v·∫´n ch∆∞a c√≥ script, ki·ªÉm tra audio ngo√†i
        if not has_valid_script_or_external_audio and \
           hasattr(self, 'dub_audio_path_for_queue_temp') and \
           self.dub_audio_path_for_queue_temp and \
           os.path.exists(self.dub_audio_path_for_queue_temp):
            # Ki·ªÉm tra th√™m xem audio ngo√†i c√≥ th·ªùi l∆∞·ª£ng kh√¥ng (ƒë·ªÉ ƒë·∫£m b·∫£o n√≥ l√† file audio h·ª£p l·ªá)
            audio_duration_check_ms = self.dub_get_audio_duration_ms(self.dub_audio_path_for_queue_temp)
            if audio_duration_check_ms and audio_duration_check_ms > 0:
                has_valid_script_or_external_audio = True
                source_for_log_combined = f"file Audio ngo√†i ({os.path.basename(self.dub_audio_path_for_queue_temp)})"
                logging.info("[DubbingQueueCheck] C√≥ audio ngo√†i h·ª£p l·ªá (c√≥ duration), coi nh∆∞ ƒë·ªß ƒëi·ªÅu ki·ªán v·ªÅ 'script' ƒë·ªÉ th√™m v√†o h√†ng ch·ªù.")
            else:
                logging.warning(f"[DubbingQueueCheck] Audio ngo√†i '{self.dub_audio_path_for_queue_temp}' ƒë∆∞·ª£c ch·ªçn nh∆∞ng kh√¥ng l·∫•y ƒë∆∞·ª£c duration h·ª£p l·ªá. Kh√¥ng coi l√† ngu·ªìn script/timing.")
        
        if has_valid_video and has_valid_script_or_external_audio:
            can_add_now = True

        if can_add_now:
            logging.info(f"[DubbingQueueCheck] ƒê√£ c√≥ ƒë·ªß Video/·∫¢nh v√† (K·ªãch b·∫£n HO·∫∂C Audio ngo√†i: {source_for_log_combined}) h·ª£p l·ªá. "
                         "T·ª± ƒë·ªông th√™m v√†o h√†ng ch·ªù thuy·∫øt minh...")
            self.dub_add_to_processing_queue()
        else:
            log_msg_detail = f"Video h·ª£p l·ªá: {has_valid_video}"
            if has_valid_video:
                log_msg_detail += f" (Path: {getattr(self, 'dub_current_video_path_for_queue_temp', 'N/A')})"
            log_msg_detail += f", K·ªãch b·∫£n HO·∫∂C Audio ngo√†i h·ª£p l·ªá: {has_valid_script_or_external_audio}"
            
            if not has_valid_script_or_external_audio: # Th√™m chi ti·∫øt n·∫øu ƒëi·ªÅu ki·ªán n√†y fail
                script_file_path = getattr(self, 'dub_current_script_path_for_queue_temp', None)
                script_file_exists = os.path.exists(script_file_path) if script_file_path else False
                srt_data_exists = bool(getattr(self, 'dub_temp_srt_data_for_queue', []))
                textbox_content = getattr(self, 'dub_script_textbox', None).get("1.0", "end-1c").strip() if hasattr(self, 'dub_script_textbox') and getattr(self, 'dub_script_textbox', None).winfo_exists() else ""
                is_textbox_invalid = self._is_textbox_content_invalid_for_script(textbox_content)
                audio_file_path = getattr(self, 'dub_audio_path_for_queue_temp', None)
                audio_file_exists_and_valid = audio_file_path and os.path.exists(audio_file_path) and (self.dub_get_audio_duration_ms(audio_file_path) or 0) > 0

                log_msg_detail += (f" (Chi ti·∫øt Script: FilePath='{script_file_path}', FileExists={script_file_exists}, "
                                   f"SRTDataPopulated={srt_data_exists}, TextboxInvalid={is_textbox_invalid}. "
                                   f"Chi ti·∫øt Audio ngo√†i: Path='{audio_file_path}', ExistsAndValidDuration={audio_file_exists_and_valid})")

            logging.debug(f"[DubbingQueueCheck] Ch∆∞a ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ t·ª± ƒë·ªông th√™m v√†o h√†ng ch·ªù. {log_msg_detail}")

        if hasattr(self, '_update_dub_start_batch_button_state'):
            self._update_dub_start_batch_button_state()


# Trong l·ªõp SubtitleApp
    def dub_stop_processing(self):
        """
        X·ª≠ l√Ω y√™u c·∫ßu d·ª´ng qu√° tr√¨nh thuy·∫øt minh t·ª´ ng∆∞·ªùi d√πng.
        H√†m n√†y ch·ªâ g·ª≠i t√≠n hi·ªáu d·ª´ng v√† c·ªë g·∫Øng ti√™u di·ªát ti·∫øn tr√¨nh con.
        Vi·ªác c·∫≠p nh·∫≠t UI cu·ªëi c√πng s·∫Ω do v√≤ng l·∫∑p x·ª≠ l√Ω ch√≠nh ƒë·∫£m nhi·ªám.
        """
        log_prefix_stop = "[DubStopProcessing_v3_Fixed]" # TƒÉng version log
        logging.info(f"{log_prefix_stop} Ng∆∞·ªùi d√πng y√™u c·∫ßu d·ª´ng qu√° tr√¨nh thuy·∫øt minh...")

        # 1. ƒê·∫∑t c√°c c·ªù d·ª´ng v√† b√°o hi·ªáu cho ng∆∞·ªùi d√πng NGAY L·∫¨P T·ª®C
        self.dub_stop_event.set()
        self.dub_is_processing = False # ƒê·∫∑t v·ªÅ False ƒë·ªÉ ngƒÉn t√°c v·ª• m·ªõi b·∫Øt ƒë·∫ßu t·ª´ h√†ng ch·ªù

        # 2. C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i v·ªõi th√¥ng b√°o "ƒêang d·ª´ng..." v√† KH√îNG l√†m g√¨ th√™m
        # Th√¥ng b√°o n√†y s·∫Ω ƒë∆∞·ª£c gi·ªØ nguy√™n cho ƒë·∫øn khi v√≤ng l·∫∑p x·ª≠ l√Ω ch√≠nh th·ª±c s·ª± d·ª´ng l·∫°i
        # v√† g·ªçi h√†m on_batch_finished ƒë·ªÉ ƒë·∫∑t tr·∫°ng th√°i cu·ªëi c√πng.
        self.update_status("üõë ƒêang y√™u c·∫ßu d·ª´ng thuy·∫øt minh...")
        logging.info(f"{log_prefix_stop} ƒê√£ ƒë·∫∑t dub_stop_event v√† dub_is_processing. Status ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")

        # 3. V√¥ hi·ªáu h√≥a n√∫t "D·ª´ng" ngay ƒë·ªÉ tr√°nh nh·∫•n nhi·ªÅu l·∫ßn
        if hasattr(self, 'dub_stop_button') and self.dub_stop_button.winfo_exists():
            self.dub_stop_button.configure(state=ctk.DISABLED)

        # 4. C·ªë g·∫Øng d·ª´ng ti·∫øn tr√¨nh FFmpeg con hi·ªán t·∫°i (logic n√†y gi·ªØ nguy√™n)
        proc_to_stop = self.dub_current_ffmpeg_process
        if proc_to_stop and proc_to_stop.poll() is None:
            logging.info(f"{log_prefix_stop}   -> ƒêang c·ªë g·∫Øng d·ª´ng ti·∫øn tr√¨nh FFmpeg (PID: {proc_to_stop.pid})...")
            try:
                proc_to_stop.terminate()
                proc_to_stop.wait(timeout=1.5)
                if proc_to_stop.poll() is not None:
                    logging.info(f"{log_prefix_stop}   -> Ti·∫øn tr√¨nh FFmpeg ƒë√£ d·ª´ng (terminate/wait).")
                else:
                    logging.warning(f"{log_prefix_stop}   -> Ti·∫øn tr√¨nh FFmpeg kh√¥ng ph·∫£n h·ªìi terminate, bu·ªôc d·ª´ng (kill)...")
                    proc_to_stop.kill()
                    proc_to_stop.wait(timeout=0.5)
                    logging.info(f"{log_prefix_stop}   -> ƒê√£ kill ti·∫øn tr√¨nh FFmpeg.")
            except Exception as term_err:
                logging.warning(f"{log_prefix_stop}   -> L·ªói khi d·ª´ng ti·∫øn tr√¨nh FFmpeg (PID: {proc_to_stop.pid}): {term_err}")
            finally:
                self.dub_current_ffmpeg_process = None
                logging.debug(f"{log_prefix_stop} ƒê√£ reset self.dub_current_ffmpeg_process.")
        else:
            logging.info(f"{log_prefix_stop} Kh√¥ng c√≥ ti·∫øn tr√¨nh FFmpeg con n√†o ƒëang ch·∫°y ƒë·ªÉ d·ª´ng tr·ª±c ti·∫øp.")
            
        # 5. LO·∫†I B·ªé TO√ÄN B·ªò PH·∫¶N C·∫¨P NH·∫¨T UI CU·ªêI C√ôNG ·ªû ƒê√ÇY
        # V√≤ng l·∫∑p _dub_process_next_item_in_queue s·∫Ω ph√°t hi·ªán stop_event
        # v√† g·ªçi dub_on_batch_finished(stopped=True), h√†m ƒë√≥ s·∫Ω x·ª≠ l√Ω vi·ªác reset UI.
        logging.info(f"{log_prefix_stop} ƒê√£ g·ª≠i t√≠n hi·ªáu d·ª´ng. V√≤ng l·∫∑p ch√≠nh s·∫Ω x·ª≠ l√Ω ph·∫ßn c√≤n l·∫°i.")


    def dub_open_output_folder(self):
        current_path = self.dub_output_path_var.get()
        if current_path and os.path.isdir(current_path):
            logging.info(f"[Dubbing] ƒêang m·ªü th∆∞ m·ª•c output thuy·∫øt minh: {current_path}")
            open_file_with_default_app(current_path) # D√πng h√†m ti·ªán √≠ch chung
        else:
            messagebox.showwarning("L·ªói", "Th∆∞ m·ª•c l∆∞u video thuy·∫øt minh kh√¥ng h·ª£p l·ªá ho·∫∑c ch∆∞a ch·ªçn.", parent=self)
            logging.warning(f"[Dubbing] ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c output thuy·∫øt minh kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu: {current_path}")

    def dub_select_output_dir(self):
        initial_dir = self.dub_output_path_var.get() or get_default_downloads_folder()
        path = filedialog.askdirectory(initialdir=initial_dir, parent=self, title="Ch·ªçn th∆∞ m·ª•c l∆∞u Video Thuy·∫øt Minh")
        if path:
            self.dub_output_path_var.set(path)
            self.cfg["dub_output_path"] = path # L∆∞u v√†o config
            # self.save_current_config() # C√¢n nh·∫Øc g·ªçi h√†m l∆∞u t·ªïng th·ªÉ
            self.update_status(f"Th∆∞ m·ª•c l∆∞u video thuy·∫øt minh: {path}")

    def dub_save_script_from_textbox(self):
        if not hasattr(self, 'dub_script_textbox') or not self.dub_script_textbox:
            messagebox.showerror("L·ªói UI", "Textbox k·ªãch b·∫£n kh√¥ng t·ªìn t·∫°i.", parent=self)
            return
        
        script_content = self.dub_script_textbox.get("1.0", "end-1c")
        if not script_content.strip():
            messagebox.showinfo("N·ªôi dung r·ªóng", "Kh√¥ng c√≥ n·ªôi dung k·ªãch b·∫£n ƒë·ªÉ l∆∞u.", parent=self)
            return

        save_path = filedialog.asksaveasfilename(
            title="L∆∞u file K·ªãch b·∫£n SRT",
            defaultextension=".srt",
            filetypes=[("SRT files", "*.srt"), ("All files", "*.*")],
            parent=self,
            initialdir=self.dub_output_path_var.get() or os.getcwd() # G·ª£i √Ω th∆∞ m·ª•c output
        )
        if not save_path:
            self.update_status("ƒê√£ h·ªßy l∆∞u file k·ªãch b·∫£n.")
            return

        try:
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(script_content)
            self.update_status(f"üíæ ƒê√£ l∆∞u k·ªãch b·∫£n: {os.path.basename(save_path)}")
            logging.info(f"[Dubbing] ƒê√£ l∆∞u n·ªôi dung k·ªãch b·∫£n t·ª´ textbox v√†o: {save_path}")
            messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u k·ªãch b·∫£n v√†o:\n{save_path}", parent=self)
        except Exception as e:
            logging.error(f"[Dubbing] L·ªói khi l∆∞u file k·ªãch b·∫£n '{save_path}': {e}", exc_info=True)
            messagebox.showerror("L·ªói L∆∞u File", f"Kh√¥ng th·ªÉ l∆∞u file k·ªãch b·∫£n:\n{save_path}\n\nL·ªói: {e}", parent=self)
            self.update_status(f"‚ùå L·ªói l∆∞u k·ªãch b·∫£n: {os.path.basename(save_path)}")


# --------------------
# 4.3 X·ª≠ l√Ω S·ª± ki·ªán UI & C·∫≠p nh·∫≠t
# --------------------

# H√†m x·ª≠ l√Ω gh√©p sub th·ªß c√¥ng
    def _on_toggle_manual_merge_mode(self):
        is_manual_mode = self.manual_merge_mode_var.get()
        logging.info(f"Ch·∫ø ƒë·ªô Gh√©p Sub Th·ªß C√¥ng ƒë∆∞·ª£c {'B·∫¨T' if is_manual_mode else 'T·∫ÆT'}.")

        add_button_auto = getattr(self.subtitle_view_frame, 'add_button', None) if hasattr(self, 'subtitle_view_frame') else None
        add_button_manual = getattr(self.subtitle_view_frame, 'add_manual_task_button', None) if hasattr(self, 'subtitle_view_frame') else None
        queue_auto = getattr(self.subtitle_view_frame, 'queue_section', None) if hasattr(self, 'subtitle_view_frame') else None
        queue_manual = getattr(self.subtitle_view_frame, 'manual_queue_section', None) if hasattr(self, 'subtitle_view_frame') else None

        # LU√îN ·∫®N T·∫§T C·∫¢ TR∆Ø·ªöC
        if add_button_auto and add_button_auto.winfo_ismapped(): add_button_auto.pack_forget()
        if add_button_manual and add_button_manual.winfo_ismapped(): add_button_manual.pack_forget()
        if queue_auto and queue_auto.winfo_ismapped(): queue_auto.pack_forget()
        if queue_manual and queue_manual.winfo_ismapped(): queue_manual.pack_forget()

        # X√≥a placeholder c≈© trong c·∫£ hai h√†ng ch·ªù (n·∫øu c√≥)
        if queue_auto:
            for widget in queue_auto.winfo_children(): widget.destroy()
        if queue_manual:
            for widget in queue_manual.winfo_children(): widget.destroy()

        # HI·ªÇN TH·ªä L·∫†I C√ÅC TH√ÄNH PH·∫¶N ƒê√öNG
        sub_and_dub_button = getattr(self.subtitle_view_frame, 'sub_and_dub_button', None) if hasattr(self, 'subtitle_view_frame') else None
        btn_row_frame = sub_and_dub_button.master if sub_and_dub_button else None
        
        if is_manual_mode:
            if add_button_manual and btn_row_frame:
                add_button_manual.pack(in_=btn_row_frame, side="left", expand=True, fill="x", padx=(2, 0))
            if queue_manual:
                right_panel_sub = getattr(self.subtitle_view_frame, 'right_panel_sub', None) if hasattr(self, 'subtitle_view_frame') else None
                sub_edit_frame = getattr(self.subtitle_view_frame, 'sub_edit_frame', None) if hasattr(self, 'subtitle_view_frame') else None
                if right_panel_sub and sub_edit_frame:
                    queue_manual.pack(in_=right_panel_sub, fill="x", padx=10, pady=(10, 5), before=sub_edit_frame)
                # KI·ªÇM TRA V√Ä HI·ªÇN TH·ªä PLACEHOLDER TH·ª¶ C√îNG
                if not self.manual_sub_queue:
                    placeholder_text = (
                        "H√†ng ch·ªù tr·ªëng.\n\n"
                        "H∆∞·ªõng d·∫´n:\n"
                        "1. Cung c·∫•p Ph·ª• ƒë·ªÅ (Nh·∫≠p v√†o √¥ b√™n ph·∫£i ho·∫∑c d√πng 'M·ªü Sub...').\n"
                        "2. Ch·ªçn Media (Video/·∫¢nh) b·∫±ng n√∫t 'Ch·ªçn Video/·∫¢nh M·ªõi...'.\n"
                        "3. Nh·∫•n '‚ûï Th√™m v√†o H√†ng ch·ªù' ƒë·ªÉ t·∫°o m·ªôt t√°c v·ª•."
                    )
                    ctk.CTkLabel(queue_manual, text=placeholder_text, text_color="gray", justify="left").pack(pady=20, padx=10)
        else: # Ch·∫ø ƒë·ªô T·ª± ƒë·ªông
            if add_button_auto and btn_row_frame:
                add_button_auto.pack(in_=btn_row_frame, side="left", expand=True, fill="x", padx=(2, 0))
            if queue_auto:
                right_panel_sub = getattr(self.subtitle_view_frame, 'right_panel_sub', None) if hasattr(self, 'subtitle_view_frame') else None
                sub_edit_frame = getattr(self.subtitle_view_frame, 'sub_edit_frame', None) if hasattr(self, 'subtitle_view_frame') else None
                if right_panel_sub and sub_edit_frame:
                    queue_auto.pack(in_=right_panel_sub, fill="x", padx=10, pady=(10, 5), before=sub_edit_frame)
                # KI·ªÇM TRA V√Ä HI·ªÇN TH·ªä PLACEHOLDER T·ª∞ ƒê·ªòNG
                if not self.file_queue and not self.current_file:
                     ctk.CTkLabel(queue_auto, text="[H√†ng ch·ªù sub t·ª± ƒë·ªông tr·ªëng]", font=("Segoe UI", 11), text_color="gray").pack(anchor="center", pady=20)

        self.save_current_config()
        self._set_subtitle_tab_ui_state(False)
        self._update_manual_mode_ui_elements()


# H√†m ·∫©n hi·ªán c√°c n√∫t sub th·ªß c√¥ng
    def _update_manual_mode_ui_elements(self):
        # Truy c·∫≠p widgets qua subtitle_view_frame (SubtitleTab)
        subtitle_tab = getattr(self, 'subtitle_view_frame', None)
        if not subtitle_tab:
            return  # N·∫øu SubtitleTab ch∆∞a ƒë∆∞·ª£c t·∫°o th√¨ b·ªè qua

        try:
            if not self._is_app_fully_activated():
                pause_edit_checkbox = getattr(subtitle_tab, 'pause_edit_checkbox', None)
                if pause_edit_checkbox and pause_edit_checkbox.winfo_exists():
                    pause_edit_checkbox.configure(state=ctk.DISABLED)
                if hasattr(self, 'pause_for_edit_var'):
                    self.pause_for_edit_var.set(False)
                return
        except Exception:
            return

        is_manual_mode = self.manual_merge_mode_var.get()
        log_prefix = "[UI_ManualModeUpdate]"
        logging.debug(f"{log_prefix} B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t UI. Ch·∫ø ƒë·ªô th·ªß c√¥ng: {'B·∫≠t' if is_manual_mode else 'T·∫Øt'}")

        merge_options_parent_frame = getattr(subtitle_tab, 'merge_and_pause_frame_ref', None)
        manual_checkbox = getattr(subtitle_tab, 'manual_merge_mode_checkbox', None)
        media_options_frame = getattr(subtitle_tab, 'sub_pause_media_options_frame', None)
        pause_checkbox_auto = getattr(subtitle_tab, 'pause_edit_checkbox', None)
        continue_button_auto = getattr(subtitle_tab, 'continue_merge_button', None)
        auto_add_checkbox = getattr(subtitle_tab, 'auto_add_manual_task_checkbox', None)
        save_local_checkbox = getattr(subtitle_tab, 'save_in_media_folder_checkbox', None)
        if not merge_options_parent_frame or not merge_options_parent_frame.winfo_exists():
            logging.warning(f"{log_prefix} merge_and_pause_frame_ref kh√¥ng t·ªìn t·∫°i.")
            return

        # --- Logic chung cho c√°c control Whisper/D·ªãch t·ª± ƒë·ªông ---
        whisper_translate_controls_state = ctk.DISABLED if is_manual_mode else ctk.NORMAL
        controls_to_toggle_whisper_translate = [
            None,  # model_menu kh√¥ng c√≤n trong PiuApp, ƒë√£ ·ªü trong SubtitleTab nh∆∞ng kh√¥ng c·∫ßn toggle ·ªü ƒë√¢y
            None,  # lang_menu t∆∞∆°ng t·ª±
            getattr(subtitle_tab, 'bilingual_checkbox', None),
            getattr(subtitle_tab, 'engine_menu', None),
            getattr(subtitle_tab, 'target_lang_menu', None),
        ]
        for control in controls_to_toggle_whisper_translate:
            if control and control.winfo_exists():
                control.configure(state=whisper_translate_controls_state)

        if is_manual_mode:
            # Hi·ªán c√°c control c·ªßa ch·∫ø ƒë·ªô th·ªß c√¥ng
            if auto_add_checkbox and manual_checkbox and not auto_add_checkbox.winfo_ismapped():
                # Hi·ªÉn th·ªã checkbox "T·ª± ƒë·ªông th√™m" ngay sau checkbox "Gh√©p th·ªß c√¥ng"
                auto_add_checkbox.pack(anchor="w", padx=25, pady=(0, 5), after=manual_checkbox)            
            # Hi·ªÉn th·ªã checkbox "L∆∞u c·ª•c b·ªô" ngay sau checkbox "T·ª± ƒë·ªông th√™m"
            if save_local_checkbox and auto_add_checkbox and not save_local_checkbox.winfo_ismapped():
                save_local_checkbox.pack(anchor="w", padx=25, pady=(0, 5), after=auto_add_checkbox)

            if hasattr(self, 'bilingual_var'): self.bilingual_var.set(False)
            if hasattr(self, 'translation_engine_var'): self.translation_engine_var.set("Kh√¥ng d·ªãch")
            openai_style_frame = getattr(subtitle_tab, 'openai_style_frame', None)
            if openai_style_frame and openai_style_frame.winfo_ismapped():
                openai_style_frame.pack_forget()
        else: # Khi t·∫Øt manual mode, kh√¥i ph·ª•c UI d·ªãch
            # ·∫®n c√°c control c·ªßa ch·∫ø ƒë·ªô th·ªß c√¥ng
            if auto_add_checkbox and auto_add_checkbox.winfo_ismapped():
                auto_add_checkbox.pack_forget()            
            # ·∫®n checkbox "L∆∞u c·ª•c b·ªô" khi t·∫Øt ch·∫ø ƒë·ªô th·ªß c√¥ng 
            if save_local_checkbox and save_local_checkbox.winfo_ismapped():
                save_local_checkbox.pack_forget()

            if hasattr(self, 'translation_engine_var') and hasattr(self, 'on_engine_change'):
                 self.on_engine_change(self.translation_engine_var.get(), update_status_bar=False)

        # --- Logic cho c√°c element trong merge_and_pause_frame_ref ---

        # 1. Checkbox "D·ª´ng l·∫°i ƒë·ªÉ ch·ªânh s·ª≠a Sub tr∆∞·ªõc khi G·ªôp" (pause_checkbox_auto)
        if pause_checkbox_auto and pause_checkbox_auto.winfo_exists():
            pause_checkbox_auto.configure(state=ctk.DISABLED if is_manual_mode else ctk.NORMAL)
            if is_manual_mode:
                self.pause_for_edit_var.set(False)
            logging.debug(f"{log_prefix} pause_edit_checkbox state: {pause_checkbox_auto.cget('state')}")

        # X√°c ƒë·ªãnh xem c√≥ ƒëang trong tr·∫°ng th√°i "pause t·ª± ƒë·ªông" kh√¥ng
        is_actually_paused_auto = (not is_manual_mode and 
                                   hasattr(self, 'is_subbing') and self.is_subbing and
                                   hasattr(self, 'pause_for_edit_var') and self.pause_for_edit_var.get() and
                                   hasattr(self, 'continue_merge_event') and self.continue_merge_event and
                                   not self.continue_merge_event.is_set())

        # 2. Khung ch·ªçn media (media_options_frame)
        if media_options_frame and media_options_frame.winfo_exists():
            should_show_media_options = is_manual_mode or is_actually_paused_auto
            media_buttons_state = ctk.NORMAL if should_show_media_options else ctk.DISABLED

            current_media_options_parent = media_options_frame.master

            if should_show_media_options:
                target_widget_to_pack_after = None
                if is_manual_mode and manual_checkbox and manual_checkbox.winfo_exists():
                    target_widget_to_pack_after = manual_checkbox
                elif is_actually_paused_auto and pause_checkbox_auto and pause_checkbox_auto.winfo_exists():
                    target_widget_to_pack_after = pause_checkbox_auto

                if not media_options_frame.winfo_ismapped() or current_media_options_parent != merge_options_parent_frame:
                    if media_options_frame.winfo_ismapped(): media_options_frame.pack_forget()
                    if target_widget_to_pack_after:
                        media_options_frame.pack(in_=merge_options_parent_frame, fill="x", padx=10, pady=(5, 5), after=target_widget_to_pack_after)
                    else: # Fallback n·∫øu kh√¥ng c√≥ widget tham chi·∫øu
                        media_options_frame.pack(in_=merge_options_parent_frame, fill="x", padx=10, pady=(5,5)) 
                    logging.debug(f"{log_prefix} ƒê√£ pack media_options_frame (sau: {target_widget_to_pack_after.winfo_name() if target_widget_to_pack_after else 'N/A'}).")

                if is_manual_mode: # Ch·ªâ reset khi v√†o manual mode v√† frame ƒë∆∞·ª£c hi·ªÉn th·ªã
                    sub_pause_selected_media_info_label = getattr(subtitle_tab, 'sub_pause_selected_media_info_label', None)
                    if sub_pause_selected_media_info_label and sub_pause_selected_media_info_label.winfo_exists():
                        sub_pause_selected_media_info_label.configure(text="")
                    self.sub_pause_selected_media_path = None
            else: # should_show_media_options is False
                if media_options_frame.winfo_ismapped():
                    media_options_frame.pack_forget()
                    logging.debug(f"{log_prefix} ƒê√£ pack_forget media_options_frame.")

            sub_pause_select_media_button = getattr(subtitle_tab, 'sub_pause_select_media_button', None)
            if sub_pause_select_media_button and sub_pause_select_media_button.winfo_exists():
                sub_pause_select_media_button.configure(state=media_buttons_state)
            sub_pause_select_folder_button = getattr(subtitle_tab, 'sub_pause_select_folder_button', None)
            if sub_pause_select_folder_button and sub_pause_select_folder_button.winfo_exists():
                sub_pause_select_folder_button.configure(state=media_buttons_state)
            logging.debug(f"{log_prefix} media_options_frame is_mapped: {media_options_frame.winfo_ismapped()}, media_buttons_state: {media_buttons_state}")

        # 3. N√∫t "Ti·∫øp t·ª•c G·ªôp Sub" (continue_button_auto)
        if continue_button_auto and continue_button_auto.winfo_exists() and \
           merge_options_parent_frame and merge_options_parent_frame.winfo_exists(): # Th√™m ki·ªÉm tra parent
            
            is_actually_paused_auto_for_continue = (not is_manual_mode and 
                                     hasattr(self, 'is_subbing') and self.is_subbing and
                                     hasattr(self, 'pause_for_edit_var') and self.pause_for_edit_var.get() and
                                     hasattr(self, 'continue_merge_event') and self.continue_merge_event and
                                     not self.continue_merge_event.is_set()) # ƒêi·ªÅu ki·ªán quan tr·ªçng
            
            if is_actually_paused_auto_for_continue:
                if not continue_button_auto.winfo_ismapped() or continue_button_auto.master != merge_options_parent_frame:
                    if continue_button_auto.winfo_ismapped(): continue_button_auto.pack_forget()
                    
                    # X√°c ƒë·ªãnh widget ƒë·ªÉ pack n√∫t "Ti·∫øp t·ª•c" sau n√≥
                    widget_to_pack_continue_after = pause_checkbox_auto # M·∫∑c ƒë·ªãnh l√† sau checkbox pause t·ª± ƒë·ªông
                    if media_options_frame and media_options_frame.winfo_ismapped() and media_options_frame.master == merge_options_parent_frame:
                        widget_to_pack_continue_after = media_options_frame # N·∫øu frame media ƒëang hi·ªán trong c√πng parent, pack sau n√≥

                    if widget_to_pack_continue_after and widget_to_pack_continue_after.winfo_exists():
                        continue_button_auto.pack(in_=merge_options_parent_frame, fill="x", padx=10, pady=(5, 10), after=widget_to_pack_continue_after)
                    else: # Fallback n·∫øu kh√¥ng t√¨m th·∫•y widget_to_pack_continue_after
                        continue_button_auto.pack(in_=merge_options_parent_frame, fill="x", padx=10, pady=(5,10))
                        logging.warning(f"{log_prefix} Kh√¥ng t√¨m th·∫•y widget_to_pack_continue_after, pack continue_button ·ªü cu·ªëi.")

                continue_button_auto.configure(state=ctk.NORMAL)
                logging.debug(f"{log_prefix} continue_merge_button is_mapped (ho·∫∑c s·∫Ω ƒë∆∞·ª£c map), state: NORMAL (do pause t·ª± ƒë·ªông).")
            else: 
                if continue_button_auto.winfo_ismapped():
                    continue_button_auto.pack_forget()
                continue_button_auto.configure(state=ctk.DISABLED)
                logging.debug(f"{log_prefix} continue_merge_button pack_forget (ho·∫∑c gi·ªØ nguy√™n n·∫øu ch∆∞a map), state: DISABLED.")

        if is_manual_mode:
            subtitle_tab_local = getattr(self, 'subtitle_view_frame', None)
            subtitle_textbox_local = getattr(subtitle_tab_local, 'subtitle_textbox', None) if subtitle_tab_local else None
            if self.current_srt_path or (subtitle_textbox_local and subtitle_textbox_local.winfo_exists() and subtitle_textbox_local.get("1.0", "end-1c").strip()):
                self.enable_sub_editing()
        logging.debug(f"{log_prefix} K·∫øt th√∫c c·∫≠p nh·∫≠t UI.")


# H√†m nh·∫≠n bi·∫øt sub th·ªß c√¥ng v√† AI
    def _handle_start_sub_button_action(self):
        """
        X·ª≠ l√Ω h√†nh ƒë·ªông c·ªßa n√∫t "B·∫Øt ƒë·∫ßu" ch√≠nh.
        ∆Øu ti√™n 1: N·∫øu c√≥ h√†ng ch·ªù AI, s·∫Ω b·∫Øt ƒë·∫ßu x·ª≠ l√Ω l√¥ AI.
        ∆Øu ti√™n 2: N·∫øu kh√¥ng, s·∫Ω x·ª≠ l√Ω theo ch·∫ø ƒë·ªô Th·ªß c√¥ng ho·∫∑c T·ª± ƒë·ªông (Whisper) nh∆∞ c≈©.
        """
        if self.ai_batch_queue:
            logging.info("N√∫t 'B·∫Øt ƒë·∫ßu' ƒë∆∞·ª£c nh·∫•n v√† ph√°t hi·ªán c√≥ h√†ng ch·ªù AI. B·∫Øt ƒë·∫ßu x·ª≠ l√Ω l√¥ AI.")
            # G·ªçi l·∫°i h√†m b·∫Øt ƒë·∫ßu l√¥ AI, truy·ªÅn v√†o h√†ng ch·ªù v√† prompt ƒë√£ l∆∞u
            self.start_ai_batch_processing(self.ai_batch_queue, self.ai_batch_current_prompt)
            return # K·∫øt th√∫c h√†m s·ªõm

        # Logic c≈© c·ªßa h√†m s·∫Ω n·∫±m b√™n d∆∞·ªõi
        if self.manual_merge_mode_var.get():
            logging.info("N√∫t 'B·∫Øt ƒë·∫ßu H√†ng lo·∫°t (Th·ªß c√¥ng)' ƒë∆∞·ª£c nh·∫•n.")
            self._start_manual_sub_batch() # G·ªçi h√†m x·ª≠ l√Ω h√†ng lo·∫°t th·ªß c√¥ng
        else:
            logging.info("N√∫t 'B·∫Øt ƒë·∫ßu SUB' (t·ª± ƒë·ªông) ƒë∆∞·ª£c nh·∫•n.")
            self.auto_sub_all()


# H√†m l·∫•y th√¥ng tin, x√°c th·ª±c v√† chu·∫©n b·ªã UI cho ch·∫ø ƒë·ªô gh√©p th·ªß c√¥ng.
    def _prepare_and_execute_manual_merge(self):
        logging.info("--- [CH·∫æ ƒê·ªò TH·ª¶ C√îNG] Chu·∫©n b·ªã v√† Th·ª±c thi Gh√©p Sub Th·ªß C√¥ng ---")

        # --- 1. L·∫•y v√† x√°c th·ª±c th√¥ng tin c∆° b·∫£n --- (Gi·ªØ nguy√™n ph·∫ßn n√†y)
        srt_content_to_merge = ""
        subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
        if subtitle_textbox and subtitle_textbox.winfo_exists() and subtitle_textbox.get("1.0", "end-1c").strip():
            srt_content_to_merge = subtitle_textbox.get("1.0", "end-1c").strip()
        
        if not srt_content_to_merge:
            messagebox.showwarning("Thi·∫øu Subtitle", "Kh√¥ng c√≥ n·ªôi dung subtitle trong textbox ƒë·ªÉ th·ª±c hi·ªán gh√©p.", parent=self)
            return

        media_to_merge_path = self.sub_pause_selected_media_path
        if not media_to_merge_path or not os.path.exists(media_to_merge_path):
            messagebox.showwarning("Thi·∫øu Media", "Vui l√≤ng ch·ªçn m·ªôt file Video, ·∫¢nh, ho·∫∑c Th∆∞ m·ª•c ·∫¢nh h·ª£p l·ªá ƒë·ªÉ gh√©p subtitle v√†o.", parent=self)
            return

        merge_mode = self.merge_sub_var.get().lower()
        if merge_mode == "kh√¥ng g·ªôp":
            messagebox.showwarning("Thi·∫øu Ki·ªÉu Gh√©p", "Vui l√≤ng ch·ªçn ki·ªÉu gh√©p (Hard-sub ho·∫∑c Soft-sub) tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.", parent=self)
            return

        output_directory_manual = self.output_path_var.get()
        if not output_directory_manual or not os.path.isdir(output_directory_manual):
            messagebox.showerror("L·ªói ƒê∆∞·ªùng d·∫´n Output", f"Vui l√≤ng ch·ªçn th∆∞ m·ª•c output h·ª£p l·ªá trong tab 'T·∫°o Ph·ª• ƒê·ªÅ'.\nƒê∆∞·ªùng d·∫´n hi·ªán t·∫°i: '{output_directory_manual}' kh√¥ng h·ª£p l·ªá.", parent=self)
            return

        logging.info(f"[ManualMergePrep] C√°c th√¥ng tin c∆° b·∫£n ƒë√£ h·ª£p l·ªá. Media: {media_to_merge_path}, Mode: {merge_mode}, Output: {output_directory_manual}")

        # --- X√ÅC ƒê·ªäNH T√äN FILE G·ªêC CHUNG CHO VIDEO V√Ä SRT ---
        # L·∫•y t√™n t·ª´ media ƒë·∫ßu v√†o, sau ƒë√≥ l√†m s·∫°ch c√°c h·∫≠u t·ªë t·∫°m th·ªùi n·∫øu c√≥
        base_name_for_outputs = os.path.splitext(os.path.basename(media_to_merge_path))[0]
        base_name_for_outputs = base_name_for_outputs.replace("_hardsub_manual", "").replace("_softsub_manual", "")
        base_name_for_outputs = re.sub(r'_slideshow_\d+$', '', base_name_for_outputs)
        base_name_for_outputs = re.sub(r'sub_pause_slideshow_\d+$', '', base_name_for_outputs)
        # X·ª≠ l√Ω tr∆∞·ªùng h·ª£p t√™n file media l√† t√™n file SRT t·∫°m t·ª´ c√°c b∆∞·ªõc tr∆∞·ªõc (n·∫øu c√≥ th·ªÉ x·∫£y ra)
        base_name_for_outputs = re.sub(r'^manual_merge_sub_\d+$', 'ghep_thu_cong', base_name_for_outputs)
        base_name_for_outputs = re.sub(r'^temp_sub_for_timing_\d+$', 'kich_ban_slideshow', base_name_for_outputs)
        
        # L√†m s·∫°ch t√™n file cu·ªëi c√πng b·∫±ng h√†m create_safe_filename
        # Ch√∫ng ta s·∫Ω d√πng remove_accents=False ƒë·ªÉ gi·ªØ l·∫°i d·∫•u n·∫øu c√≥ trong t√™n g·ªëc,
        # v√† max_length ƒë·ªÉ tr√°nh t√™n qu√° d√†i.
        safe_output_base_name = create_safe_filename(base_name_for_outputs, remove_accents=False, max_length=100)
        if not safe_output_base_name: # N·∫øu sau khi l√†m s·∫°ch m√† t√™n r·ªóng (do t√™n g·ªëc qu√° ƒë·∫∑c bi·ªát)
            safe_output_base_name = f"ghep_thu_cong_{int(time.time())}" # T·∫°o t√™n m·∫∑c ƒë·ªãnh an to√†n
        
        logging.info(f"[ManualMergePrep] T√™n file g·ªëc cho Video v√† SRT m·ªõi (n·∫øu c√≥): '{safe_output_base_name}'")


        # --- 2. T·ª± ƒë·ªông l∆∞u SRT t·ª´ Textbox ---
        path_to_srt_for_ffmpeg = ""
        temp_srt_file_created_for_this_merge = None 

        try:
            can_save_to_current_srt_path = False
            if self.current_srt_path:
                dir_of_current_srt = os.path.dirname(self.current_srt_path)
                if dir_of_current_srt and os.path.isdir(dir_of_current_srt):
                    can_save_to_current_srt_path = True
                else:
                    logging.warning(f"[ManualMergePrep] Th∆∞ m·ª•c c·ªßa self.current_srt_path ('{self.current_srt_path}') kh√¥ng h·ª£p l·ªá. S·∫Ω t·∫°o file SRT m·ªõi trong th∆∞ m·ª•c output.")

            if can_save_to_current_srt_path:
                with open(self.current_srt_path, "w", encoding="utf-8") as f_save:
                    f_save.write(srt_content_to_merge + "\n\n")
                path_to_srt_for_ffmpeg = self.current_srt_path
                self.current_srt_path = path_to_srt_for_ffmpeg 
                logging.info(f"[ManualMergePrep] ƒê√£ t·ª± ƒë·ªông c·∫≠p nh·∫≠t n·ªôi dung v√†o file SRT hi·ªán t·∫°i: {path_to_srt_for_ffmpeg}")
            else:
                # T·∫°o FILE SRT M·ªöI C·ªê ƒê·ªäNH trong th∆∞ m·ª•c output, s·ª≠ d·ª•ng safe_output_base_name
                new_persistent_srt_filename = f"{safe_output_base_name}.srt"
                new_persistent_srt_path = os.path.join(output_directory_manual, new_persistent_srt_filename)

                try:
                    with open(new_persistent_srt_path, "w", encoding="utf-8") as f_new_srt:
                        f_new_srt.write(srt_content_to_merge + "\n\n")
                    path_to_srt_for_ffmpeg = new_persistent_srt_path
                    self.current_srt_path = new_persistent_srt_path 
                    logging.info(f"[ManualMergePrep] N·ªôi dung textbox kh√¥ng c√≥ file SRT g·ªëc. ƒê√£ t·∫°o v√† l∆∞u v√†o file SRT c·ªë ƒë·ªãnh m·ªõi: {path_to_srt_for_ffmpeg}")
                    if hasattr(self, 'current_srt_path_label') and self.current_srt_path_label.winfo_exists():
                        display_path = os.path.basename(self.current_srt_path)
                        if len(self.current_srt_path) > 70:
                            display_path = "..." + self.current_srt_path[-67:]
                        self.current_srt_path_label.configure(text=f"{display_path}")
                
                except Exception as e_create_persistent_srt:
                    logging.error(f"[ManualMergePrep] L·ªói khi t·∫°o file SRT c·ªë ƒë·ªãnh m·ªõi '{new_persistent_srt_path}': {e_create_persistent_srt}. S·∫Ω d√πng file t·∫°m.", exc_info=True)
                    if not os.path.exists(self.temp_folder): os.makedirs(self.temp_folder, exist_ok=True)
                    temp_srt_filename = f"fallback_manual_merge_sub_{int(time.time())}.srt"
                    temp_srt_file_created_for_this_merge = os.path.join(self.temp_folder, temp_srt_filename)
                    with open(temp_srt_file_created_for_this_merge, "w", encoding="utf-8") as f_temp:
                        f_temp.write(srt_content_to_merge + "\n\n")
                    path_to_srt_for_ffmpeg = temp_srt_file_created_for_this_merge
                    logging.info(f"[ManualMergePrep] ƒê√£ l∆∞u n·ªôi dung v√†o file SRT t·∫°m (fallback): {path_to_srt_for_ffmpeg}")
        
        except Exception as e_save_srt_prep:
            logging.error(f"[ManualMergePrep] L·ªói nghi√™m tr·ªçng trong qu√° tr√¨nh chu·∫©n b·ªã v√† l∆∞u SRT: {e_save_srt_prep}", exc_info=True)
            messagebox.showerror("L·ªói L∆∞u Subtitle", f"Kh√¥ng th·ªÉ t·ª± ƒë·ªông l∆∞u n·ªôi dung subtitle.\nL·ªói: {e_save_srt_prep}", parent=self)
            # Kh√¥i ph·ª•c UI (gi·ªØ nguy√™n)
            sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
            if sub_button and sub_button.winfo_exists():
                sub_button.configure(state=ctk.NORMAL, text="üî® B·∫Øt ƒë·∫ßu Gh√©p Th·ªß C√¥ng")
            if hasattr(self, 'manual_merge_mode_checkbox') and self.manual_merge_mode_checkbox.winfo_exists(): self.manual_merge_mode_checkbox.configure(state=ctk.NORMAL)
            if hasattr(self, 'sub_and_dub_button') and self.sub_and_dub_button.winfo_exists(): self.sub_and_dub_button.configure(state=ctk.NORMAL)
            if hasattr(self, 'stop_button') and self.stop_button.winfo_exists(): self.stop_button.configure(state=ctk.DISABLED)
            return

        self.current_manual_merge_srt_path = path_to_srt_for_ffmpeg
        self.current_manual_merge_srt_path_temp_file_ref = temp_srt_file_created_for_this_merge

        # --- 3. V√¥ hi·ªáu h√≥a UI v√† B·∫Øt ƒë·∫ßu lu·ªìng x·ª≠ l√Ω ---
        # (Ph·∫ßn n√†y gi·ªØ nguy√™n)
        sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
        if sub_button and sub_button.winfo_exists():
            sub_button.configure(state=ctk.DISABLED, text="‚è≥ ƒêang gh√©p...")
        if hasattr(self, 'manual_merge_mode_checkbox') and self.manual_merge_mode_checkbox.winfo_exists(): self.manual_merge_mode_checkbox.configure(state=ctk.DISABLED)
        if hasattr(self, 'sub_and_dub_button') and self.sub_and_dub_button.winfo_exists(): self.sub_and_dub_button.configure(state=ctk.DISABLED)
        if hasattr(self, 'stop_button') and self.stop_button.winfo_exists(): self.stop_button.configure(state=ctk.NORMAL)

        self.is_subbing = True
        self.start_time = time.time()
        status_text_for_timer = f"üî® ƒêang {merge_mode} th·ªß c√¥ng: {os.path.basename(media_to_merge_path)}"
        self._last_status_text = status_text_for_timer
        self.update_status(status_text_for_timer)
        self.after(1000, self.update_time_realtime)

        self.stop_event.clear()
        logging.info("[ManualMergePrep] ƒê√£ clear self.stop_event tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu lu·ªìng gh√©p th·ªß c√¥ng m·ªõi.")        

        current_cfg_snapshot = self._get_config_snapshot()

        thread_args = (
            media_to_merge_path,
            path_to_srt_for_ffmpeg,
            output_directory_manual,
            merge_mode,
            current_cfg_snapshot,
            temp_srt_file_created_for_this_merge, # File t·∫°m n·∫øu c√≥
            safe_output_base_name # <<-- TRUY·ªÄN T√äN G·ªêC ƒê√É L√ÄM S·∫†CH V√ÄO LU·ªíNG
        )

        self.processing_thread = threading.Thread(
            target=self._execute_manual_merge_threaded,
            args=thread_args,
            daemon=True,
            name="ManualMergeThread"
        )
        self.processing_thread.start()
        logging.info(f"[ManualMergePrep] ƒê√£ b·∫Øt ƒë·∫ßu lu·ªìng _execute_manual_merge_threaded v·ªõi SRT path: {path_to_srt_for_ffmpeg}")


# H√†m n√†y s·∫Ω quy·∫øt ƒë·ªãnh h√†nh ƒë·ªông c·ªßa n√∫t "Sub & Dub" d·ª±a tr√™n vi·ªác ch·∫ø ƒë·ªô th·ªß c√¥ng c√≥ ƒëang b·∫≠t hay kh√¥ng.
    def _handle_sub_and_dub_button_action(self):
        logging.info("N√∫t 'Sub & Dub' ƒë∆∞·ª£c nh·∫•n (Dispatcher).")
        if self.is_subbing or self.is_downloading or self.dub_is_processing or self.is_creating_slideshow or self.is_gpt_processing_script:
            messagebox.showwarning("ƒêang B·∫≠n", "·ª®ng d·ª•ng ƒëang x·ª≠ l√Ω m·ªôt t√°c v·ª• kh√°c. Vui l√≤ng ƒë·ª£i.", parent=self)
            return

        if self.manual_merge_mode_var.get():
            # --- LOGIC M·ªöI CHO CH·∫æ ƒê·ªò TH·ª¶ C√îNG H√ÄNG LO·∫†T ---
            logging.info("[Sub & Dub Dispatcher] Ch·∫ø ƒë·ªô Th·ªß c√¥ng ƒëang B·∫¨T.")
            
            # Thay v√¨ ki·ªÉm tra file l·∫ª, ch√∫ng ta ki·ªÉm tra h√†ng ch·ªù
            if not self.manual_sub_queue:
                messagebox.showwarning("H√†ng ch·ªù tr·ªëng", "Vui l√≤ng th√™m √≠t nh·∫•t m·ªôt t√°c v·ª• v√†o h√†ng ch·ªù th·ªß c√¥ng tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu 'Sub & Dub'.", parent=self)
                return

            # V·∫´n ki·ªÉm tra th∆∞ m·ª•c output c·ªßa Dubbing v√¨ ƒë√¢y l√† b∆∞·ªõc cu·ªëi c√πng c·ªßa chu·ªói
            if not (self.dub_output_path_var.get() and os.path.isdir(self.dub_output_path_var.get())):
                messagebox.showerror("L·ªói ƒê∆∞·ªùng d·∫´n Output (Dub)", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c output h·ª£p l·ªá cho tab 'Thuy·∫øt Minh' tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu 'Sub & Dub'.", parent=self)
                return

            # ƒê·∫∑t c·ªù b√°o hi·ªáu chu·ªói Sub(Manual) & Dub
            self.manual_sub_then_dub_active = True
            logging.info("[Sub & Dub Dispatcher] ƒê√£ ƒë·∫∑t manual_sub_then_dub_active = True.")
            
            # V√¥ hi·ªáu h√≥a n√∫t ƒë·ªÉ tr√°nh nh·∫•n nhi·ªÅu l·∫ßn
            if hasattr(self, 'sub_and_dub_button'):
                self.sub_and_dub_button.configure(state=ctk.DISABLED)
            
            # B·∫Øt ƒë·∫ßu x·ª≠ l√Ω h√†ng lo·∫°t th·ªß c√¥ng
            self._start_manual_sub_batch()
            # ----------------------------------------
        
        else:
            # --- CH·∫æ ƒê·ªò T·ª∞ ƒê·ªòNG (LOGIC G·ªêC C·ª¶A B·∫†N ƒê∆Ø·ª¢C GI·ªÆ NGUY√äN) ---
            logging.info("[Sub & Dub Dispatcher] Ch·∫ø ƒë·ªô Th·ªß c√¥ng ƒëang T·∫ÆT. Ch·∫°y quy tr√¨nh Sub (Auto) & Dub.")
            if not self.file_queue:
                messagebox.showinfo("H√†ng ch·ªù Sub tr·ªëng", "Vui l√≤ng th√™m file video/audio v√†o h√†ng ch·ªù (Sub) tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu 'Sub & Dub' t·ª± ƒë·ªông.", parent=self)
                return
            if self.whisper_model is None and not self.is_loading_model:
                messagebox.showwarning("Model ch∆∞a s·∫µn s√†ng", "M√¥ h√¨nh Whisper ch∆∞a ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ƒë·ª£i ho·∫∑c ch·ªçn m·ªôt m√¥ h√¨nh.", parent=self)
                self.load_whisper_model_if_needed()
                return
            if self.is_loading_model:
                messagebox.showwarning("ƒêang t·∫£i Model", "M√¥ h√¨nh Whisper ƒëang ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ƒë·ª£i.", parent=self)
                return
            if not (self.dub_output_path_var.get() and os.path.isdir(self.dub_output_path_var.get())):
                 messagebox.showerror("L·ªói ƒê∆∞·ªùng d·∫´n Output (Dub)", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c output h·ª£p l·ªá cho tab 'Thuy·∫øt Minh' tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu 'Sub & Dub' t·ª± ƒë·ªông.", parent=self)
                 return

            self.start_sub_and_dub_process()
            

# H√†m n√†y s·∫Ω ch·ª©a logic ch√≠nh cho vi·ªác gh√©p sub th·ªß c√¥ng
    def _execute_manual_merge(self):
        logging.info("--- [CH·∫æ ƒê·ªò TH·ª¶ C√îNG] B·∫Øt ƒë·∫ßu Quy tr√¨nh Gh√©p Sub Th·ªß C√¥ng ---")

        # --- 1. L·∫•y v√† x√°c th·ª±c th√¥ng tin ---
        
        # L·∫•y n·ªôi dung sub
        srt_content_to_merge = ""
        source_of_srt_for_merge = ""

        subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
        if subtitle_textbox and subtitle_textbox.winfo_exists() and subtitle_textbox.get("1.0", "end-1c").strip():
            srt_content_to_merge = subtitle_textbox.get("1.0", "end-1c").strip()
            source_of_srt_for_merge = "Textbox"
            # N·∫øu current_srt_path c≈©ng t·ªìn t·∫°i, c√≥ th·ªÉ ∆∞u ti√™n textbox v√¨ n√≥ c√≥ th·ªÉ l√† b·∫£n ƒë√£ s·ª≠a
            if self.current_srt_path and os.path.exists(self.current_srt_path):
                # T√πy ch·ªçn: H·ªèi ng∆∞·ªùi d√πng mu·ªën d√πng sub t·ª´ file hay textbox n·∫øu c·∫£ hai ƒë·ªÅu c√≥
                # Ho·∫∑c m·∫∑c ƒë·ªãnh d√πng textbox n·∫øu c√≥ n·ªôi dung.
                logging.info(f"[ManualMerge] S·ª≠ d·ª•ng n·ªôi dung sub t·ª´ Textbox (c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c s·ª≠a).")
        elif self.current_srt_path and os.path.exists(self.current_srt_path):
            try:
                with open(self.current_srt_path, "r", encoding="utf-8") as f_srt_orig:
                    srt_content_to_merge = f_srt_orig.read().strip()
                source_of_srt_for_merge = f"File: {os.path.basename(self.current_srt_path)}"
            except Exception as e_read_srt:
                logging.error(f"[ManualMerge] L·ªói ƒë·ªçc file SRT '{self.current_srt_path}': {e_read_srt}")
                messagebox.showerror("L·ªói File Subtitle", f"Kh√¥ng th·ªÉ ƒë·ªçc file subtitle:\n{self.current_srt_path}", parent=self)
                return
        
        if not srt_content_to_merge:
            messagebox.showwarning("Thi·∫øu Subtitle", 
                                   "Kh√¥ng c√≥ n·ªôi dung subtitle ƒë·ªÉ th·ª±c hi·ªán gh√©p.", 
                                   parent=self)
            logging.warning("[ManualMerge] Thi·∫øu n·ªôi dung sub.")
            return

        # L·∫•y media ƒë√£ ch·ªçn
        media_to_merge_path = self.sub_pause_selected_media_path
        if not media_to_merge_path or not os.path.exists(media_to_merge_path):
            messagebox.showwarning("Thi·∫øu Media", 
                                   "Vui l√≤ng ch·ªçn m·ªôt file Video, ·∫¢nh, ho·∫∑c Th∆∞ m·ª•c ·∫¢nh h·ª£p l·ªá ƒë·ªÉ gh√©p subtitle v√†o.",
                                   parent=self)
            logging.warning("[ManualMerge] Thi·∫øu media ƒë√£ ch·ªçn ho·∫∑c file kh√¥ng t·ªìn t·∫°i.")
            return
            
        # L·∫•y ki·ªÉu gh√©p
        merge_mode = self.merge_sub_var.get().lower()
        if merge_mode == "kh√¥ng g·ªôp":
            messagebox.showwarning("Thi·∫øu Ki·ªÉu Gh√©p",
                                   "Vui l√≤ng ch·ªçn ki·ªÉu gh√©p (Hard-sub ho·∫∑c Soft-sub) tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.",
                                   parent=self)
            logging.warning("[ManualMerge] Ch∆∞a ch·ªçn ki·ªÉu gh√©p (Hard/Soft).")
            return

        # L·∫•y th∆∞ m·ª•c output (gi·ªëng nh∆∞ lu·ªìng t·ª± ƒë·ªông)
        output_directory_manual = self.output_path_var.get()
        if not output_directory_manual or not os.path.isdir(output_directory_manual):
            messagebox.showerror("L·ªói ƒê∆∞·ªùng d·∫´n Output", 
                                 f"Vui l√≤ng ch·ªçn th∆∞ m·ª•c output h·ª£p l·ªá trong tab 'T·∫°o Ph·ª• ƒê·ªÅ'.\nƒê∆∞·ªùng d·∫´n hi·ªán t·∫°i: '{output_directory_manual}' kh√¥ng h·ª£p l·ªá.", 
                                 parent=self)
            return

        logging.info(f"[ManualMerge] Chu·∫©n b·ªã gh√©p:")
        logging.info(f"  - Ngu·ªìn Sub: {source_of_srt_for_merge}")
        logging.info(f"  - Media: {media_to_merge_path}")
        logging.info(f"  - Ki·ªÉu gh√©p: {merge_mode}")
        logging.info(f"  - Th∆∞ m·ª•c Output: {output_directory_manual}")

        # --- 2. Chu·∫©n b·ªã file sub ƒë·ªÉ gh√©p (l∆∞u ra file t·∫°m n·∫øu c·∫ßn) ---
        # C√°c h√†m burn_sub_to_video v√† merge_sub_as_soft_sub c·∫ßn ƒë∆∞·ªùng d·∫´n file SRT.
        path_to_srt_for_ffmpeg = ""
        temp_srt_file_for_manual_merge = None

        if source_of_srt_for_merge == "Textbox" or \
           (self.current_srt_path and os.path.abspath(self.current_srt_path) != os.path.abspath(media_to_merge_path)): # ƒê·ªÅ ph√≤ng tr∆∞·ªùng h·ª£p l·∫°
            try:
                # ƒê·∫£m b·∫£o th∆∞ m·ª•c temp_folder t·ªìn t·∫°i
                if not os.path.exists(self.temp_folder):
                    os.makedirs(self.temp_folder, exist_ok=True)
                
                temp_srt_file_for_manual_merge = os.path.join(self.temp_folder, f"manual_merge_sub_{int(time.time())}.srt")
                with open(temp_srt_file_for_manual_merge, "w", encoding="utf-8") as f_temp:
                    f_temp.write(srt_content_to_merge)
                path_to_srt_for_ffmpeg = temp_srt_file_for_manual_merge
                logging.info(f"[ManualMerge] ƒê√£ l∆∞u n·ªôi dung sub t·ª´ Textbox v√†o file t·∫°m: {path_to_srt_for_ffmpeg}")
            except Exception as e_save_temp_srt:
                logging.error(f"[ManualMerge] L·ªói khi l∆∞u sub t·∫°m th·ªùi: {e_save_temp_srt}")
                messagebox.showerror("L·ªói L∆∞u Sub T·∫°m", f"Kh√¥ng th·ªÉ t·∫°o file sub t·∫°m th·ªùi ƒë·ªÉ gh√©p.\nL·ªói: {e_save_temp_srt}", parent=self)
                return
        elif self.current_srt_path and os.path.exists(self.current_srt_path):
            path_to_srt_for_ffmpeg = self.current_srt_path
            logging.info(f"[ManualMerge] S·ª≠ d·ª•ng file sub ƒë√£ t·∫£i: {path_to_srt_for_ffmpeg}")
        else: # Kh√¥ng th·ªÉ x√°c ƒë·ªãnh file SRT
            logging.error("[ManualMerge] Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n file SRT h·ª£p l·ªá ƒë·ªÉ gh√©p.")
            messagebox.showerror("L·ªói File Subtitle", "Kh√¥ng th·ªÉ x√°c ƒë·ªãnh file subtitle ƒë·ªÉ th·ª±c hi·ªán gh√©p.", parent=self)
            return

        # --- 3. Th·ª±c hi·ªán gh√©p trong lu·ªìng ri√™ng ---
        # V√¥ hi·ªáu h√≥a c√°c n√∫t quan tr·ªçng
        sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
        if sub_button and sub_button.winfo_exists():
            sub_button.configure(state=ctk.DISABLED, text="‚è≥ ƒêang gh√©p...")
        self.manual_merge_mode_checkbox.configure(state=ctk.DISABLED)
        if hasattr(self, 'stop_button') and self.stop_button.winfo_exists():
            self.stop_button.configure(state=ctk.NORMAL) # Cho ph√©p d·ª´ng n·∫øu qu√° tr√¨nh gh√©p l√¢u

        self.is_subbing = True 
        self.start_time = time.time()

        # L∆∞u text g·ªëc cho ƒë·ªìng h·ªì
        status_text_for_timer = f"üî® ƒêang {merge_mode} th·ªß c√¥ng: {os.path.basename(media_to_merge_path)}"
        self._last_status_text = status_text_for_timer 
        self.update_status(status_text_for_timer) 
        self.after(1000, self.update_time_realtime) 
                                                  
        # T·∫°o b·∫£n sao c√°c c·∫•u h√¨nh c·∫ßn thi·∫øt
        current_cfg_snapshot = self._get_config_snapshot() 

        thread_args = (
            media_to_merge_path, 
            path_to_srt_for_ffmpeg, 
            output_directory_manual, 
            merge_mode,
            current_cfg_snapshot, # Truy·ªÅn snapshot config
            temp_srt_file_for_manual_merge # ƒê·ªÉ c√≥ th·ªÉ x√≥a sau khi gh√©p
        )

        self.processing_thread = threading.Thread(
            target=self._execute_manual_merge_threaded, 
            args=thread_args,
            daemon=True, 
            name="ManualMergeThread"
        )
        self.processing_thread.start()
        

# ƒê√¢y l√† h√†m s·∫Ω ch·∫°y trong lu·ªìng ƒë·ªÉ th·ª±c hi·ªán vi·ªác gh√©p th·ªß c√¥ng
    def _execute_manual_merge_threaded(self, task):
        """
        H√†m worker (ch·∫°y trong lu·ªìng): Th·ª±c thi m·ªôt t√°c v·ª• gh√©p sub th·ªß c√¥ng.
        H√†m n√†y nh·∫≠n v√†o m·ªôt dictionary 'task' ƒë√£ ƒë∆∞·ª£c chu·∫©n b·ªã ƒë·∫ßy ƒë·ªß.
        """
        log_prefix = f"[{threading.current_thread().name}]"
        success = False
        merged_output_final_path = None
        error_message = None

        # Khai b√°o bi·∫øn ·ªü scope r·ªông h∆°n ƒë·ªÉ kh·ªëi except c√≥ th·ªÉ truy c·∫≠p
        merge_mode_for_log = "kh√¥ng x√°c ƒë·ªãnh"
        
        try:
            video_path = task.get('media_data')
            srt_path = task.get('srt_path_for_ffmpeg')
            output_dir = task.get('final_output_dir')
            cfg_snapshot = task.get('cfg_snapshot', {})
            
            # G√°n gi√° tr·ªã cho merge_mode_for_log ƒë·ªÉ s·ª≠ d·ª•ng trong c·∫£ try v√† except
            merge_mode_for_log = cfg_snapshot.get('merge_mode', 'kh√¥ng g·ªôp')

            # L·∫•y "key ƒë·ªãnh danh" ƒë√£ ƒë∆∞·ª£c quy·∫øt ƒë·ªãnh tr∆∞·ªõc t·ª´ task object
            safe_output_base_name = task.get('identifier')
            
            # Th√™m m·ªôt fallback m·∫°nh m·∫Ω ph√≤ng tr∆∞·ªùng h·ª£p 'identifier' b·ªã thi·∫øu ho·∫∑c r·ªóng
            if not safe_output_base_name:
                logging.warning(f"{log_prefix} Task object thi·∫øu 'identifier'. Fallback v·ªÅ t√™n media.")
                fallback_path = task.get('original_media_source_path') or task.get('media_data')
                base_name_fallback = os.path.splitext(os.path.basename(fallback_path))[0]
                safe_output_base_name = create_safe_filename(base_name_fallback, remove_accents=False)

            logging.info(f"{log_prefix} S·∫Ω s·ª≠ d·ª•ng identifier ƒë√£ ƒë∆∞·ª£c quy·∫øt ƒë·ªãnh tr∆∞·ªõc l√†m t√™n file: '{safe_output_base_name}'")
            
            temp_srt_to_delete = task.get('temp_srt_to_delete')

            if not all([video_path, srt_path, output_dir, merge_mode_for_log, safe_output_base_name]):
                raise ValueError("Worker nh·∫≠n ƒë∆∞·ª£c th√¥ng tin t√°c v·ª• kh√¥ng ƒë·∫ßy ƒë·ªß.")

            if self.stop_event.is_set():
                raise InterruptedError("Gh√©p th·ªß c√¥ng b·ªã d·ª´ng tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu FFmpeg.")

            def _update_status_thread_safe(msg):
                self.after(0, lambda m=msg: self.update_status(m))

            if merge_mode_for_log == "hard-sub":
                merged_output_final_path = os.path.join(output_dir, f"{safe_output_base_name}_hardsub_manual.mp4")
                _update_status_thread_safe(f"üî® ƒêang hardsub (th·ªß c√¥ng): {os.path.basename(video_path)}")
                self.burn_sub_to_video(video_path, srt_path, merged_output_final_path, cfg_snapshot)
            elif merge_mode_for_log == "soft-sub":
                merged_output_final_path = os.path.join(output_dir, f"{safe_output_base_name}_softsub_manual.mkv")
                _update_status_thread_safe(f"üî® ƒêang softsub (th·ªß c√¥ng): {os.path.basename(video_path)}")
                self.merge_sub_as_soft_sub(video_path, srt_path, merged_output_final_path)
            else:
                # N·∫øu kh√¥ng ph·∫£i hard-sub hay soft-sub, coi nh∆∞ th√†nh c√¥ng v√† kh√¥ng l√†m g√¨
                success = True
                merged_output_final_path = video_path
                # return kh√¥ng c·∫ßn thi·∫øt ·ªü ƒë√¢y, ƒë·ªÉ kh·ªëi finally ch·∫°y

            if not success: # Ch·ªâ ki·ªÉm tra n·∫øu ch∆∞a ƒë∆∞·ª£c ƒë·∫∑t l√† True
                if self.stop_event.is_set():
                    raise InterruptedError("Gh√©p th·ªß c√¥ng b·ªã d·ª´ng trong qu√° tr√¨nh FFmpeg.")

                if merged_output_final_path and os.path.exists(merged_output_final_path) and os.path.getsize(merged_output_final_path) > 1000:
                    success = True
                    logging.info(f"{log_prefix} Gh√©p {merge_mode_for_log} th·ªß c√¥ng th√†nh c√¥ng: {merged_output_final_path}")
                else:
                    error_message = f"FFmpeg kh√¥ng t·∫°o ƒë∆∞·ª£c file output ho·∫∑c file output r·ªóng ({merge_mode_for_log})."
                    logging.error(f"{log_prefix} {error_message}")
                    success = False

        except InterruptedError as ie:
            success = False
            error_message = f"Qu√° tr√¨nh gh√©p th·ªß c√¥ng ƒë√£ b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng."
            logging.warning(f"{log_prefix} {error_message} ({ie})")
        except Exception as e:
            success = False
            # S·ª≠ d·ª•ng bi·∫øn merge_mode_for_log ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü scope ngo√†i
            error_message = f"L·ªói trong qu√° tr√¨nh gh√©p {merge_mode_for_log} th·ªß c√¥ng: {e}"
            logging.error(f"{log_prefix} {error_message}", exc_info=True)

        finally:
            if temp_srt_to_delete and os.path.exists(temp_srt_to_delete):
                try:
                    os.remove(temp_srt_to_delete)
                    logging.info(f"{log_prefix} ƒê√£ x√≥a file sub t·∫°m: {temp_srt_to_delete}")
                except Exception as e_del_temp:
                    logging.warning(f"{log_prefix} L·ªói x√≥a file sub t·∫°m '{temp_srt_to_delete}': {e_del_temp}")

            self.after(0, self._handle_manual_task_completion, task.get('id'), success, merged_output_final_path, error_message)



# H√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi sau khi lu·ªìng gh√©p th·ªß c√¥ng ho√†n t·∫•t, ƒë·ªÉ c·∫≠p nh·∫≠t UI
    def _handle_manual_merge_completion(self, success, output_path_merged_video, error_message, merge_mode_used, original_context_data=None): # TH√äM original_context_data=None
        log_prefix_manual_merge_complete = "[ManualMergeComplete]"
        srt_file_that_was_merged = getattr(self, 'current_manual_merge_srt_path', None)
        is_srt_temp_after_merge = getattr(self, 'current_manual_merge_srt_path_temp_file_ref', None) == srt_file_that_was_merged
        
        logging.info(f"{log_prefix_manual_merge_complete} X·ª≠ l√Ω ho√†n th√†nh gh√©p th·ªß c√¥ng. Success: {success}, VideoOut: {output_path_merged_video}, "
                     f"SRTPathUsed: {srt_file_that_was_merged}, IsSRTTemp: {is_srt_temp_after_merge}, "
                     f"ManualSubThenDubActive: {self.manual_sub_then_dub_active}")

        temp_srt_ref_from_prep = getattr(self, 'current_manual_merge_srt_path_temp_file_ref', None)
        if temp_srt_ref_from_prep and os.path.exists(temp_srt_ref_from_prep):
            try:
                os.remove(temp_srt_ref_from_prep)
                logging.info(f"{log_prefix_manual_merge_complete} ƒê√£ x√≥a file SRT t·∫°m (t·ª´ prep): {temp_srt_ref_from_prep}")
            except Exception as e_del_temp_srt_final:
                logging.warning(f"{log_prefix_manual_merge_complete} L·ªói x√≥a file SRT t·∫°m (t·ª´ prep) '{temp_srt_ref_from_prep}': {e_del_temp_srt_final}")
            if hasattr(self, 'current_manual_merge_srt_path_temp_file_ref'):
                delattr(self, 'current_manual_merge_srt_path_temp_file_ref')

        branding_is_enabled_for_this_flow = (self.branding_intro_enabled_var.get() or \
                                             self.branding_logo_enabled_var.get() or \
                                             self.branding_outro_enabled_var.get())

        # --- THAY ƒê·ªîI LOGIC G·ªåI BRANDING CHO LU·ªíNG MANUAL SUB & DUB ---
        if success and output_path_merged_video and branding_is_enabled_for_this_flow and not self.manual_sub_then_dub_active:
            logging.info(f"{log_prefix_manual_merge_complete} Gh√©p sub th·ªß c√¥ng th√†nh c√¥ng (KH√îNG ch·ªù Dub). B·∫Øt ƒë·∫ßu b∆∞·ªõc Branding cho: {output_path_merged_video}")
            self.update_status(f"üé® Chu·∫©n b·ªã Branding cho: {os.path.basename(output_path_merged_video)}...")
            
            context_for_branding_callback = {
                "source_view": "subtitle_manual_merge_only_with_branding",
                "video_before_branding": output_path_merged_video,
                "original_srt_path_for_dub_chain": srt_file_that_was_merged,
                "merge_mode_used": merge_mode_used, # Gi·ªØ l·∫°i ho·∫∑c th√™m d√≤ng n√†y
                "is_softsub_input_for_branding": True if merge_mode_used == "soft-sub" else False, # D√íNG QUAN TR·ªåNG
                "callback_after_all_processing_for_this_file": self._handle_manual_merge_completion
            }
            
            self._start_branding_thread(
                video_path_from_previous_step=output_path_merged_video,
                callback_after_branding=self._handle_branding_completion, # Callback chung
                original_context_data=context_for_branding_callback
            )
            return # Branding s·∫Ω g·ªçi l·∫°i h√†m n√†y v·ªõi original_context_data

        elif success and output_path_merged_video and branding_is_enabled_for_this_flow and self.manual_sub_then_dub_active:
            logging.info(f"{log_prefix_manual_merge_complete} Gh√©p sub th·ªß c√¥ng th√†nh c√¥ng v√† CH·ªú DUB. Branding s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán SAU KHI DUB xong. Video hi·ªán t·∫°i (ch∆∞a brand): {output_path_merged_video}")
        elif success and output_path_merged_video:
            logging.info(f"{log_prefix_manual_merge_complete} Gh√©p sub th·ªß c√¥ng th√†nh c√¥ng. Branding kh√¥ng ƒë∆∞·ª£c b·∫≠t. Video: {output_path_merged_video}")
        # --- K·∫æT TH√öC THAY ƒê·ªîI LOGIC G·ªåI BRANDING ---

        # --- S·ª¨A L·ªñI NameError B·∫∞NG C√ÅCH KI·ªÇM TRA original_context_data ---
        current_source_view_for_manual = None
        if isinstance(original_context_data, dict): # Ch·ªâ l·∫•y source_view n·∫øu original_context_data l√† dict
            current_source_view_for_manual = original_context_data.get("source_view")
        # --- K·∫æT TH√öC S·ª¨A L·ªñI ---

        if current_source_view_for_manual == "subtitle_manual_merge_only_with_branding":
            # Tr∆∞·ªùng h·ª£p n√†y l√† callback *sau khi* branding cho t√°c v·ª• "ch·ªâ merge v√† brand" ho√†n t·∫•t.
            # `success` v√† `output_path_merged_video` l√∫c n√†y l√† k·∫øt qu·∫£ c·ªßa branding.
            logging.info(f"{log_prefix_manual_merge_complete} ƒê√£ ho√†n t·∫•t t√°c v·ª• 'Merge th·ªß c√¥ng v√† Brand'. Success c·ªßa Branding: {success}, Video cu·ªëi: {output_path_merged_video}")
            self.is_subbing = False
            if not self.is_downloading: self.start_time = None
            
            # Reset UI
            if hasattr(self, 'manual_merge_mode_checkbox') and self.manual_merge_mode_checkbox.winfo_exists(): self.manual_merge_mode_checkbox.configure(state=ctk.NORMAL)
            sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
            if sub_button and sub_button.winfo_exists():
                sub_button.configure(text="üî® B·∫Øt ƒë·∫ßu Gh√©p Th·ªß C√¥ng", state=ctk.NORMAL)
            if hasattr(self, 'sub_and_dub_button') and self.sub_and_dub_button.winfo_exists(): self.sub_and_dub_button.configure(state=ctk.NORMAL)
            if hasattr(self, 'stop_button') and self.stop_button.winfo_exists(): self.stop_button.configure(state=ctk.DISABLED)
            
            self.sub_pause_selected_media_path = None
            if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists(): self.sub_pause_selected_media_info_label.configure(text="")
            if hasattr(self, 'current_manual_merge_srt_path'): delattr(self, 'current_manual_merge_srt_path')
            if hasattr(self, '_update_manual_mode_ui_elements'): self._update_manual_mode_ui_elements()
            
            self._check_completion_and_shutdown()
            
            if success and output_path_merged_video: # ƒê√¢y l√† video ƒë√£ brand
                 messagebox.showinfo("Ho√†n Th√†nh", f"Gh√©p sub th·ªß c√¥ng v√† branding th√†nh c√¥ng!\nFile ƒë∆∞·ª£c l∆∞u t·∫°i:\n{output_path_merged_video}", parent=self)
            elif not success and error_message:
                 messagebox.showerror("L·ªói", f"L·ªói trong qu√° tr√¨nh gh√©p sub th·ªß c√¥ng v√† branding:\n{error_message}", parent=self)
            return

        # Ph·∫ßn c√≤n l·∫°i c·ªßa h√†m, x·ª≠ l√Ω khi KH√îNG c√≥ branding ·ªü b∆∞·ªõc merge n√†y, ho·∫∑c merge l·ªói
        self.is_subbing = False
        if not self.is_downloading: self.start_time = None

        if hasattr(self, 'manual_merge_mode_checkbox') and self.manual_merge_mode_checkbox.winfo_exists():
            self.manual_merge_mode_checkbox.configure(state=ctk.NORMAL)
        sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
        if sub_button and sub_button.winfo_exists():
             sub_button.configure(text="üî® B·∫Øt ƒë·∫ßu Gh√©p Th·ªß C√¥ng", state=ctk.NORMAL)
        
        can_reenable_sub_and_dub_button_now = True

        if hasattr(self, 'stop_button') and self.stop_button.winfo_exists():
            self.stop_button.configure(state=ctk.DISABLED)

        if success and output_path_merged_video:
            # output_path_merged_video ·ªü ƒë√¢y l√† video CH∆ØA BRAND (v√¨ ƒë√£ b·ªè qua if ·ªü tr√™n n·∫øu manual_sub_then_dub_active)
            if self.manual_sub_then_dub_active and srt_file_that_was_merged and os.path.exists(srt_file_that_was_merged):
                logging.info(f"{log_prefix_manual_merge_complete} Gh√©p th·ªß c√¥ng (ch∆∞a brand) th√†nh c√¥ng. Chu·∫©n b·ªã Dub.")
                self.update_status(f"‚úÖ Gh√©p Sub (Manual) xong! Chu·∫©n b·ªã Dub: {os.path.basename(output_path_merged_video)}...")
                
                dub_task_info_list_manual_no_brand = [{
                    'video_to_dub': output_path_merged_video, 
                    'script_content_type': 'srt_file',
                    'script_data': srt_file_that_was_merged,
                    'script_display_name_override': f"{os.path.basename(srt_file_that_was_merged)} (cho video Manual, ch∆∞a brand)",
                    'original_downloaded_video': output_path_merged_video 
                }]
                self.after(100, self._initiate_chained_dubbing, dub_task_info_list_manual_no_brand, False) 
                self.manual_sub_then_dub_active = False 
                can_reenable_sub_and_dub_button_now = False 
            else: 
                status_msg_no_brand = f"‚úÖ Gh√©p {merge_mode_used} th·ªß c√¥ng (kh√¥ng branding) th√†nh c√¥ng!"
                logging.info(f"{log_prefix_manual_merge_complete} {status_msg_no_brand} Video: {output_path_merged_video}")
                self.update_status(status_msg_no_brand)
                messagebox.showinfo("Gh√©p Th·ªß C√¥ng Ho√†n Th√†nh",
                                    f"{status_msg_no_brand}\nFile ƒë∆∞·ª£c l∆∞u t·∫°i:\n{output_path_merged_video}",
                                    parent=self)
                self.manual_sub_then_dub_active = False
        
        else: 
            status_msg_fail_no_brand = f"‚ùå L·ªói gh√©p {merge_mode_used} th·ªß c√¥ng."
            actual_error_to_show_no_brand = error_message if error_message else "L·ªói kh√¥ng x√°c ƒë·ªãnh."
            if error_message: status_msg_fail_no_brand += f" L√Ω do: {error_message.split(':')[0]}"
            
            logging.error(f"{log_prefix_manual_merge_complete} {status_msg_fail_no_brand} (Chi ti·∫øt: {actual_error_to_show_no_brand})")
            self.update_status(status_msg_fail_no_brand)
            messagebox.showerror("L·ªói Gh√©p Th·ªß C√¥ng",
                                 f"ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh gh√©p subtitle th·ªß c√¥ng (kh√¥ng branding).\n\n"
                                 f"{actual_error_to_show_no_brand}",
                                 parent=self)
            self.manual_sub_then_dub_active = False

        if can_reenable_sub_and_dub_button_now and hasattr(self, 'sub_and_dub_button') and self.sub_and_dub_button.winfo_exists():
            self.sub_and_dub_button.configure(state=ctk.NORMAL)
        
        self.sub_pause_selected_media_path = None
        if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists():
            self.sub_pause_selected_media_info_label.configure(text="")
        
        if hasattr(self, 'current_manual_merge_srt_path'):
             delattr(self, 'current_manual_merge_srt_path')

        if hasattr(self, '_update_manual_mode_ui_elements'):
            self._update_manual_mode_ui_elements()
        
        self._check_completion_and_shutdown()            


# H√†m t·ªëi ∆∞u gi·ªçng ƒë·ªçc cho whisper TTS
    def _on_toggle_optimize_whisper_tts_voice(self):
        logging.info(f"Checkbox 'T·ªëi ∆∞u gi·ªçng ƒë·ªçc cho TTS' thay ƒë·ªïi tr·∫°ng th√°i: {self.optimize_whisper_tts_voice_var.get()}")
        # TODO: Th√™m logic x·ª≠ l√Ω khi checkbox n√†y thay ƒë·ªïi (v√≠ d·ª•: l∆∞u config, c·∫≠p nh·∫≠t UI kh√°c n·∫øu c·∫ßn)
        self.save_current_config() # L∆∞u tr·∫°ng th√°i m·ªõi c·ªßa checkbox v√†o config
        # G·ªçi h√†m c·∫≠p nh·∫≠t UI chung c·ªßa tab Sub ƒë·ªÉ n√≥ c√≥ th·ªÉ v√¥ hi·ªáu h√≥a checkbox n√†y khi ·ªü Manual Mode
        if hasattr(self, '_set_subtitle_tab_ui_state'):
            self._set_subtitle_tab_ui_state(self.is_subbing)


# H√†m ti·ªán √≠ch l·ªõp: C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i (thread-safe)
    def update_status(self, text):
        """
        C·ªïng cu·ªëi c·∫≠p nh·∫≠t status:
        - N·∫øu CH∆ØA k√≠ch ho·∫°t m√† message c√≥ √Ω 's·∫µn s√†ng' => √©p v·ªÅ 'üîí ... C·∫ßn k√≠ch ho·∫°t.'
        - Kh√¥ng ƒë·ª•ng c√°c th√¥ng ƒëi·ªáp l·ªói/c·∫£nh b√°o/ti·∫øn tr√¨nh.
        - Ch·ªâ set label 1 l·∫ßn sau khi t√≠nh final_text_to_display.
        """
        import time, unicodedata

        # ---- Ngu·ªìn s·ª± th·∫≠t: k√≠ch ho·∫°t hay ch∆∞a ----
        try:
            is_active = self._is_app_fully_activated()
        except Exception:
            is_active = False

        current_view = getattr(self, "current_view", "")
        incoming = str(text or "")

        # ---- C·ªîNG B·∫¢O V·ªÜ 1: SPLASH ----
        if hasattr(self, 'splash') and self.splash and self.splash.winfo_exists():
            # Ch·ªâ coi l√† l·ªói nghi√™m tr·ªçng n·∫øu c√≥ t·ª´ kh√≥a
            critical_keywords = ("l·ªói", "th·∫•t b·∫°i", "kh√¥ng th·ªÉ", "error", "failed")
            if any(k in incoming.lower() for k in critical_keywords):
                logging.warning(f"Th√¥ng b√°o l·ªói nghi√™m tr·ªçng '{incoming}' ƒë√£ ng·∫Øt chu·ªói kh·ªüi ƒë·ªông.")
                if hasattr(self, 'startup_task_queue'):
                    self.startup_task_queue.clear()
                self.splash.update_status(incoming)
            # Kh√¥ng set label ch√≠nh khi splash c√≤n m·ªü
            return

        # ---- C·ªîNG B·∫¢O V·ªÜ 2: n·∫øu label kh√¥ng t·ªìn t·∫°i/th√°o r·ªìi ----
        if not getattr(self, "status_label", None) or not self.status_label.winfo_exists():
            return

        # ---- C·ªîNG B·∫¢O V·ªÜ 3: ch·∫ø ƒë·ªô ki·ªÉm tra c·∫≠p nh·∫≠t th·ªß c√¥ng / single task ----
        is_manually_checking_update_now = getattr(self, 'is_manual_update_checking', False)
        is_performing_single_task_now = getattr(self, 'is_performing_single_task', False)

        if is_manually_checking_update_now:
            allow = incoming.startswith(("üîé", "‚úÖ B·∫°n ƒëang d√πng b·∫£n m·ªõi nh·∫•t", "üîî C√≥ c·∫≠p nh·∫≠t m·ªõi:", "‚ö†Ô∏è L·ªói", "‚ùå L·ªói"))
            if not allow:
                logging.debug(f"[UpdateStatus_Guard] B·ªè qua status '{incoming}' do ƒëang ki·ªÉm tra c·∫≠p nh·∫≠t th·ªß c√¥ng.")
                return
        elif is_performing_single_task_now:
            allow = incoming.startswith((
                "Thuy·∫øt minh (", "üîä", "‚úÖ ƒê√£ l∆∞u audio", "‚úÖ Nghe th·ª≠ ho√†n t·∫•t",
                "‚ùå L·ªói t·∫°o audio", "‚ùå L·ªói khi nghe th·ª≠", "üõë T·∫°o audio",
                "‚ö†Ô∏è L·ªói", "‚ùå L·ªói", "‚ÑπÔ∏è Nghe th·ª≠ k·∫øt th√∫c"
            ))
            if not allow:
                logging.debug(f"[UpdateStatus_Guard] B·ªè qua status '{incoming}' do ƒëang th·ª±c hi·ªán t√°c v·ª• ƒë∆°n l·∫ª.")
                return

        # ---- C·∫≠p nh·∫≠t bi·∫øn tr·∫°ng th√°i h√†ng ch·ªù (gi·ªØ nguy√™n logic c·ªßa b·∫°n) ----
        is_any_batch_task_active = (
            getattr(self, 'is_ai_batch_processing', False) or getattr(self, 'dub_is_processing', False) or
            getattr(self, 'is_manual_sub_processing', False) or
            (getattr(self, 'is_subbing', False) and bool(getattr(self, 'file_queue', [])))
        )
        is_any_single_task_active = (
            getattr(self, 'is_loading_model_for_timer', False) or getattr(self, 'is_gemini_processing', False) or
            getattr(self, 'is_gpt_processing_script', False) or getattr(self, 'is_imagen_processing', False) or
            getattr(self, 'is_dalle_processing', False) or getattr(self, 'is_creating_slideshow', False) or
            (getattr(self, 'is_subbing', False) and not is_any_batch_task_active)
        )
        if is_any_single_task_active and not is_any_batch_task_active:
            self.current_single_task_status = incoming
            if hasattr(self, 'update_queue_display'):
                self.after(10, self.update_queue_display)
        else:
            if getattr(self, 'current_single_task_status', "") != "":
                self.current_single_task_status = ""
                if hasattr(self, 'update_queue_display'):
                    self.after(10, self.update_queue_display)

        # ---- LOGIC HI·ªÇN TH·ªä CH√çNH ----
        final_text_to_display = ""

        # 1) N·∫øu c√≥ t√°c v·ª• ƒëang ch·∫°y ‚Üí hi·ªÉn th·ªã ƒë·ªìng h·ªì
        any_timer_task_active = (
            getattr(self, 'is_manual_sub_processing', False) or getattr(self, 'is_subbing', False) or
            getattr(self, 'is_downloading', False) or getattr(self, 'is_loading_model_for_timer', False) or
            getattr(self, 'dub_is_processing', False) or getattr(self, 'is_creating_slideshow', False) or
            getattr(self, 'is_gpt_processing_script', False) or getattr(self, 'is_dalle_processing', False) or
            getattr(self, 'is_gemini_processing', False) or getattr(self, 'is_uploading_youtube', False) or
            getattr(self, 'is_ai_batch_processing', False) or getattr(self, 'is_imagen_processing', False) or
            is_manually_checking_update_now or is_performing_single_task_now
        )

        if any_timer_task_active and getattr(self, 'start_time', None):
            # Base text cho timer
            base_text = incoming if incoming else getattr(self, '_last_status_text', "ƒêang x·ª≠ l√Ω...")

            # Kh√¥ng cho 'S·∫µn s√†ng' l√†m base khi ch∆∞a k√≠ch ho·∫°t
            if (not is_active) and is_readyish(base_text):
                base_text = locked_msg_for_view(current_view)

            # Tr√°nh hi·ªÉn th·ªã 'S·∫µn s√†ng | 00:00:01'
            if "S·∫µn s√†ng" in base_text:
                base_text = getattr(self, '_last_status_text', "ƒêang x·ª≠ l√Ω...")

            elapsed = time.time() - self.start_time
            t_str = f"{int(elapsed // 3600):02d}:{int((elapsed % 3600) // 60):02d}:{int(elapsed % 60):02d}"
            self._last_status_text = base_text
            final_text_to_display = f"{base_text} | ‚è± {t_str}"

        else:
            # Kh√¥ng c√≥ timer ‚Üí quy·∫øt ƒë·ªãnh theo th√¥ng ƒëi·ªáp c·ª• th·ªÉ/ready/default
            # N·∫øu message 'ready-like' m√† CH∆ØA k√≠ch ho·∫°t ‚Üí √©p kho√°
            if (not is_active) and is_readyish(incoming):
                final_text_to_display = locked_msg_for_view(current_view)
            else:
                specific_icons = ("‚úÖ", "‚ÑπÔ∏è", "‚ùå", "‚ö†Ô∏è", "üõë", "üîä", "üîé", "üîî", "üì§", "‚úç")
                is_specific_message = incoming.startswith(specific_icons)
                if is_specific_message:
                    final_text_to_display = incoming
                else:
                    # Kh√¥ng ph·∫£i message c·ª• th·ªÉ ‚Üí d√πng m·∫∑c ƒë·ªãnh theo view
                    final_text_to_display = ready_msg_for_view(current_view) if is_active else locked_msg_for_view(current_view)

            self._last_status_text = final_text_to_display

        # ---- C·∫≠p nh·∫≠t giao di·ªán (set label 1 l·∫ßn) ----
        try:
            current_label = self.status_label.cget("text")
            if current_label != final_text_to_display:
                self.status_label.configure(text=final_text_to_display)
                logging.info(f"Status updated to: {final_text_to_display}")  # ch·ªâ log khi c√≥ thay ƒë·ªïi
            else:
                logging.debug(f"[status dedup] {final_text_to_display}")
        except Exception as e_update_status_final:
            logging.error(f"L·ªói trong update_status khi configure label: {e_update_status_final}")


# H√†m ti·ªán √≠ch l·ªõp: C·∫≠p nh·∫≠t ƒë·ªìng h·ªì tr√™n thanh tr·∫°ng th√°i theo th·ªùi gian th·ª±c
    def update_time_realtime(self):
        """ C·∫≠p nh·∫≠t ƒë·ªãnh k·ª≥ b·ªô ƒë·∫øm th·ªùi gian tr√™n thanh tr·∫°ng th√°i n·∫øu ƒëang x·ª≠ l√Ω """
        # Ki·ªÉm tra xem c√≥ t√°c v·ª• n√†o c·∫ßn ƒë·ªìng h·ªì ƒëang ch·∫°y kh√¥ng
        active_timer_task_exists = (
            self.is_manual_sub_processing or            
            self.is_subbing or 
            self.is_downloading or 
            self.is_loading_model_for_timer or
            self.dub_is_processing or 
            self.is_creating_slideshow or
            self.is_creating_slideshow or
            self.is_gpt_processing_script or
            self.is_dalle_processing or
            self.is_gemini_processing or
            self.is_imagen_processing or
            self.is_ai_batch_processing or
            self.is_uploading_youtube or
            getattr(self, 'is_performing_single_task', False) or
            getattr(self, 'is_manual_update_checking', False)
        )

        # Ch·ªâ th·ª±c hi·ªán n·∫øu c√≥ t√°c v·ª• ƒëang ch·∫°y v√† th·ªùi gian b·∫Øt ƒë·∫ßu ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p
        if active_timer_task_exists and self.start_time:
            # 1. T√≠nh to√°n th·ªùi gian ƒë√£ tr√¥i qua
            elapsed = time.time() - self.start_time
            t_str = f"{int(elapsed // 3600):02d}:{int((elapsed % 3600) // 60):02d}:{int(elapsed % 60):02d}"
            
            # 2. L·∫•y n·ªôi dung th√¥ng b√°o g·ªëc ƒë√£ ƒë∆∞·ª£c l∆∞u tr∆∞·ªõc ƒë√≥
            base_text = getattr(self, '_last_status_text', "ƒêang x·ª≠ l√Ω...")
            
            # 3. C·∫≠p nh·∫≠t tr·ª±c ti·∫øp l√™n label m√† kh√¥ng c·∫ßn g·ªçi l·∫°i update_status
            if self.status_label and self.status_label.winfo_exists():
                self.status_label.configure(text=f"{base_text} | ‚è± {t_str}")
            
            # 4. L√™n l·ªãch ƒë·ªÉ t·ª± g·ªçi l·∫°i ch√≠nh n√≥ sau 1 gi√¢y ƒë·ªÉ ti·∫øp t·ª•c v√≤ng l·∫∑p
            self.after(1000, self.update_time_realtime)
        else:
            # N·∫øu kh√¥ng c√≥ t√°c v·ª• n√†o ƒëang ch·∫°y, v√≤ng l·∫∑p s·∫Ω t·ª± ƒë·ªông d·ª´ng ·ªü ƒë√¢y
            # kh√¥ng c·∫ßn l√†m g√¨ th√™m.
            pass 


# H√ÄM update_queue_display PHI√äN B·∫¢N 5 (ƒê√É S·ª¨A L·ªñI TypeError)
# ====================================================================================
    def update_queue_display(self):
        """
        C·∫≠p nh·∫≠t hi·ªÉn th·ªã h√†ng ch·ªù.
        - PHI√äN B·∫¢N 5: ƒê√É S·ª¨A L·ªñI ƒë·ªÉ x·ª≠ l√Ω h√†ng ch·ªù ch·ª©a c√°c ƒë·ªëi t∆∞·ª£ng task (dict)
          thay v√¨ ch·ªâ c√°c chu·ªói ƒë∆∞·ªùng d·∫´n, gi√∫p t∆∞∆°ng th√≠ch v·ªõi chu·ªói D-S-D.
        - H·ªó tr·ª£ hi·ªÉn th·ªã c·∫£ h√†ng ch·ªù AI, h√†ng ch·ªù Sub v√† t√°c v·ª• ƒë∆°n l·∫ª.
        """
        queue_widget = getattr(self.subtitle_view_frame, 'queue_section', None) if hasattr(self, 'subtitle_view_frame') else None
        if not queue_widget or not hasattr(queue_widget, 'winfo_exists') or not queue_widget.winfo_exists():
            return

        for widget in queue_widget.winfo_children():
            widget.destroy()

        # --- ∆Øu ti√™n 1: Hi·ªÉn th·ªã h√†ng ch·ªù L√¥ AI ---
        if self.ai_batch_queue or self.ai_batch_current_file:
            logging.debug("[UpdateQueueDisplay] Ch·∫ø ƒë·ªô hi·ªÉn th·ªã: H√†ng ch·ªù L√¥ AI.")
            controls_state = ctk.DISABLED if self.is_ai_batch_processing else ctk.NORMAL
            
            if self.is_ai_batch_processing and self.ai_batch_current_file:
                frame = ctk.CTkFrame(queue_widget, fg_color="#9932CC")
                frame.pack(fill="x", pady=(2, 5), padx=2)
                label_text = f"ü§ñ L√î AI ƒêANG X·ª¨ L√ù:\n   {os.path.basename(self.ai_batch_current_file)}"
                ctk.CTkLabel(frame, text=label_text, font=("Poppins", 11, "bold"), justify="left", anchor='w', text_color="white").pack(side="left", padx=5, pady=3)
            
            if self.ai_batch_queue:
                queue_len = len(self.ai_batch_queue)
                for i, f_path in enumerate(self.ai_batch_queue):
                    item_frame = ctk.CTkFrame(queue_widget, fg_color="transparent")
                    item_frame.pack(fill="x", padx=2, pady=(1,2))
                    display_name = os.path.basename(f_path)
                    ctk.CTkLabel(item_frame, text=f"{i+1}. {display_name}", anchor="w", font=("Segoe UI", 11)).pack(side="left", padx=(5, 0), expand=True, fill="x")
                    
                    del_button = ctk.CTkButton(item_frame, text="‚úï", width=26, height=26, font=("Segoe UI", 12, "bold"), fg_color="#E74C3C", state=controls_state, command=lambda idx=i: self.remove_item_from_ai_queue(idx))
                    del_button.pack(side="right", padx=(3, 5))
                    down_button_state = controls_state if i < queue_len - 1 else ctk.DISABLED
                    down_button = ctk.CTkButton(item_frame, text="‚Üì", width=26, height=26, font=("Segoe UI", 14, "bold"), state=down_button_state, command=lambda idx=i: self.move_item_in_ai_queue(idx, "down"))
                    down_button.pack(side="right", padx=(3, 0))
                    up_button_state = controls_state if i > 0 else ctk.DISABLED
                    up_button = ctk.CTkButton(item_frame, text="‚Üë", width=26, height=26, font=("Segoe UI", 14, "bold"), state=up_button_state, command=lambda idx=i: self.move_item_in_ai_queue(idx, "up"))
                    up_button.pack(side="right", padx=(0, 0))
            return # Tho√°t s·ªõm sau khi ƒë√£ x·ª≠ l√Ω h√†ng ch·ªù AI
        
        # --- ∆Øu ti√™n 2: Hi·ªÉn th·ªã h√†ng ch·ªù Sub t·ª± ƒë·ªông ---
        if self.file_queue or self.current_file:
            logging.debug("[UpdateQueueDisplay] Ch·∫ø ƒë·ªô hi·ªÉn th·ªã: H√†ng ch·ªù Sub T·ª± ƒë·ªông.")
            
            # --- S·ª¨A L·ªñI HI·ªÇN TH·ªä "ƒêANG SUB" ---
            if self.current_file:
                frame = ctk.CTkFrame(queue_widget, fg_color="#007bff")
                frame.pack(fill="x", pady=(2, 5), padx=2)
                
                # KI·ªÇM TRA self.current_file l√† dict hay string
                path_for_basename = self.current_file
                if isinstance(self.current_file, dict):
                    path_for_basename = self.current_file.get('source', 'Task kh√¥ng c√≥ source')

                label_text = f"‚ñ∂ ƒêANG SUB:\n   {os.path.basename(str(path_for_basename))}"
                ctk.CTkLabel(frame, text=label_text, font=("Poppins", 11, "bold"), justify="left", anchor='w', text_color="white").pack(side="left", padx=5, pady=3)
            
            if self.file_queue:
                queue_len = len(self.file_queue)
                for i, item_in_queue in enumerate(self.file_queue):
                    item_frame = ctk.CTkFrame(queue_widget, fg_color="transparent")
                    item_frame.pack(fill="x", padx=2, pady=(1,2))
                    
                    # --- S·ª¨A L·ªñI CH√çNH ·ªû ƒê√ÇY ---
                    display_name = "L·ªói: M·ª•c kh√¥ng x√°c ƒë·ªãnh"
                    if isinstance(item_in_queue, dict):
                        # L·∫•y ƒë∆∞·ªùng d·∫´n file t·ª´ task object ƒë·ªÉ hi·ªÉn th·ªã
                        path_from_task = item_in_queue.get('downloaded_video_path') or item_in_queue.get('source', '')
                        base_name = os.path.basename(path_from_task)
                        display_name = base_name
                    elif isinstance(item_in_queue, str):
                        # Gi·ªØ l·∫°i logic c≈© ƒë·ªÉ t∆∞∆°ng th√≠ch
                        base_name = os.path.basename(item_in_queue)
                        display_name = base_name
                    # --- K·∫æT TH√öC S·ª¨A L·ªñI ---
                    
                    ctk.CTkLabel(item_frame, text=f"{i+1}. {display_name}", anchor="w", font=("Segoe UI", 11)).pack(side="left", padx=(5, 0), expand=True, fill="x")
                    del_button = ctk.CTkButton(item_frame, text="‚úï", width=26, height=26, font=("Segoe UI", 12, "bold"), command=lambda idx=i: self.remove_file_from_queue(idx), fg_color="#E74C3C", hover_color="#C0392B", text_color="white")
                    del_button.pack(side="right", padx=(3, 5))
                    down_button_state = ctk.NORMAL if i < queue_len - 1 else ctk.DISABLED
                    down_button = ctk.CTkButton(item_frame, text="‚Üì", width=26, height=26, font=("Segoe UI", 14, "bold"), command=lambda idx=i: self.move_item_in_subtitle_queue(idx, "down"), state=down_button_state)
                    down_button.pack(side="right", padx=(3, 0))
                    up_button_state = ctk.NORMAL if i > 0 else ctk.DISABLED
                    up_button = ctk.CTkButton(item_frame, text="‚Üë", width=26, height=26, font=("Segoe UI", 14, "bold"), command=lambda idx=i: self.move_item_in_subtitle_queue(idx, "up"), state=up_button_state)
                    up_button.pack(side="right", padx=(0, 0))
            
        # --- ∆Øu ti√™n 3: Hi·ªÉn th·ªã t√°c v·ª• ƒë∆°n l·∫ª ho·∫∑c placeholder ---
        else:
            if hasattr(self, 'current_single_task_status') and self.current_single_task_status:
                text = self.current_single_task_status
                color = "#5DADE2" #
                if "gemini" in text.lower(): color = "#00897B"
                elif "imagen" in text.lower(): color = "#AF7AC5"
                elif "t·∫°o slideshow" in text.lower(): color = "#F5B041"
                elif "t·∫£i model" in text.lower(): color = "#5DADE2"
                frame = ctk.CTkFrame(queue_widget, fg_color=color, corner_radius=5)
                frame.pack(fill="x", pady=(2, 5), padx=2)
                label = ctk.CTkLabel(frame, text=text, font=("Poppins", 11, "bold"), text_color="white", justify="center", anchor="center")
                label.pack(padx=10, pady=5, fill="x")
            else:
                ctk.CTkLabel(queue_widget, text="[H√†ng ch·ªù tr·ªëng]", font=("Segoe UI", 11), text_color="gray").pack(anchor="center", pady=20)



# H√†m 2 n√∫t x√≥a ho·∫∑c di chuy·ªÉn cho l√¥ AI t·ª± ƒë·ªông
    def remove_item_from_ai_queue(self, idx_to_remove):
        """X√≥a m·ªôt file kh·ªèi h√†ng ch·ªù x·ª≠ l√Ω l√¥ AI."""
        if self.is_ai_batch_processing:
            messagebox.showwarning("ƒêang x·ª≠ l√Ω", "Kh√¥ng th·ªÉ x√≥a file khi l√¥ AI ƒëang ch·∫°y.", parent=self)
            return
        try:
            if 0 <= idx_to_remove < len(self.ai_batch_queue):
                removed_file = os.path.basename(self.ai_batch_queue.pop(idx_to_remove))
                logging.info(f"ƒê√£ x√≥a kh·ªèi h√†ng ch·ªù L√¥ AI: {removed_file}")
                self.update_queue_display()
                self._set_subtitle_tab_ui_state(False) # C·∫≠p nh·∫≠t l·∫°i n√∫t Start
        except IndexError:
            logging.warning(f"Ch·ªâ s·ªë kh√¥ng h·ª£p l·ªá ƒë·ªÉ x√≥a kh·ªèi h√†ng ch·ªù L√¥ AI: {idx_to_remove}")

    def move_item_in_ai_queue(self, current_index, direction):
        """Di chuy·ªÉn m·ªôt m·ª•c trong h√†ng ch·ªù x·ª≠ l√Ω l√¥ AI."""
        if self.is_ai_batch_processing:
            messagebox.showwarning("ƒêang x·ª≠ l√Ω", "Kh√¥ng th·ªÉ s·∫Øp x·∫øp l·∫°i h√†ng ch·ªù khi l√¥ AI ƒëang ch·∫°y.", parent=self)
            return
        
        queue_len = len(self.ai_batch_queue)
        if not (0 <= current_index < queue_len):
            return

        new_index = -1
        if direction == "up" and current_index > 0:
            new_index = current_index - 1
        elif direction == "down" and current_index < queue_len - 1:
            new_index = current_index + 1
        
        if new_index != -1:
            try:
                item_to_move = self.ai_batch_queue.pop(current_index)
                self.ai_batch_queue.insert(new_index, item_to_move)
                self.update_queue_display()
                self._set_subtitle_tab_ui_state(False) # C·∫≠p nh·∫≠t l·∫°i n√∫t Start
            except IndexError:
                logging.error(f"L·ªói IndexError khi di chuy·ªÉn m·ª•c trong h√†ng ch·ªù L√¥ AI. Index: {current_index}, New Index: {new_index}")



# H√†m h√†nh ƒë·ªông: H·ªßy l·ªánh t·∫Øt m√°y t·ª´ popup th√¥ng b√°o
    def cancel_shutdown_from_popup(self, popup_window):
        """ X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n n√∫t H·ªßy tr√™n popup h·∫πn gi·ªù t·∫Øt m√°y """
        logging.info("Ng∆∞·ªùi d√πng y√™u c·∫ßu h·ªßy t·∫Øt m√°y t·ª´ popup.")
        was_cancelled = cancel_shutdown_system() # G·ªçi h√†m to√†n c·ª•c
        logging.info(f"cancel_shutdown_system() tr·∫£ v·ªÅ: {was_cancelled}")

        if was_cancelled:
            self.shutdown_scheduled = False
            # QUAN TR·ªåNG: C≈©ng n√™n reset c·ªù n√†y v√¨ y√™u c·∫ßu t·∫Øt m√°y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω (b·∫±ng c√°ch h·ªßy)
            self.shutdown_requested_by_task = False
            self.download_view_frame.log_download("   ‚úÖ ƒê√£ h·ªßy l·ªánh h·∫πn gi·ªù t·∫Øt m√°y th√†nh c√¥ng.")            

            # H·ª¶Y L·ªÜNH H·∫∏N GI·ªú N·ªòI B·ªò 
            if self._after_id_save_config_on_shutdown:
                self.after_cancel(self._after_id_save_config_on_shutdown)
                self._after_id_save_config_on_shutdown = None
                logging.info("ƒê√£ h·ªßy th√†nh c√¥ng l·ªánh h·∫πn gi·ªù L∆ØU CONFIG.")
            
            if self._after_id_quit_on_shutdown:
                self.after_cancel(self._after_id_quit_on_shutdown)
                self._after_id_quit_on_shutdown = None
                logging.info("ƒê√£ h·ªßy th√†nh c√¥ng l·ªánh h·∫πn gi·ªù THO√ÅT APP.")
            
            # --- TH√äM PH·∫¶N C·∫¨P NH·∫¨T THANH TR·∫†NG TH√ÅI ---
            # Ki·ªÉm tra xem c√≤n t√°c v·ª• n√†o kh√°c ƒëang ch·∫°y kh√¥ng ƒë·ªÉ quy·∫øt ƒë·ªãnh status
            # (logic n√†y t∆∞∆°ng t·ª± nh∆∞ trong _check_completion_and_shutdown ho·∫∑c check_if_fully_ready)
            all_main_tasks_stopped = not (
                self.is_downloading or
                self.is_subbing or
                self.is_loading_model_for_timer or # Bao g·ªìm c·∫£ khi ƒëang t·∫£i model
                self.dub_is_processing or
                self.is_creating_slideshow or
                self.is_gpt_processing_script or
                self.is_dalle_processing or
                getattr(self, 'is_manual_update_checking', False) # N·∫øu c√≥ c·ªù ki·ªÉm tra c·∫≠p nh·∫≠t th·ªß c√¥ng
            )
            
            if all_main_tasks_stopped:
                # ƒê·∫∑t tr·∫°ng th√°i S·∫µn s√†ng / C·∫ßn k√≠ch ho·∫°t theo ƒë√∫ng ngu·ªìn s·ª± th·∫≠t
                try:
                    is_active = self._is_app_fully_activated()
                except Exception:
                    is_active = False

                # (tu·ª≥ ch·ªçn) hi·ªÉn th·ªã theo tab hi·ªán t·∫°i cho th√¢n thi·ªán
                selected_value = getattr(self, 'current_view', '')
                ready_map = {
                    "‚Üì T·∫£i Xu·ªëng": "‚úÖ Download: S·∫µn s√†ng nh·∫≠n link.",
                    "‚â° T·∫°o Ph·ª• ƒê·ªÅ": "‚úÖ Subtitle: S·∫µn s√†ng x·ª≠ l√Ω file.",
                    "‚ô™ Thuy·∫øt Minh": "‚úÖ Dubbing: S·∫µn s√†ng l·ªìng ti·∫øng.",
                    "üì§ Upload YT": "‚úÖ Upload YT: S·∫µn s√†ng upload Video.",
                    "‚úç AI Bi√™n T·∫≠p": "‚úÖ AI Bi√™n T·∫≠p: S·∫µn s√†ng bi√™n t·∫≠p K·ªãch B·∫£n.",
                }
                locked_map = {
                    "‚Üì T·∫£i Xu·ªëng": "üîí Download: C·∫ßn k√≠ch ho·∫°t.",
                    "‚â° T·∫°o Ph·ª• ƒê·ªÅ": "üîí Subtitle: C·∫ßn k√≠ch ho·∫°t.",
                    "‚ô™ Thuy·∫øt Minh": "üîí Dubbing: C·∫ßn k√≠ch ho·∫°t.",
                    "üì§ Upload YT": "üîí Upload YT: C·∫ßn k√≠ch ho·∫°t.",
                    "‚úç AI Bi√™n T·∫≠p": "üîí AI Bi√™n T·∫≠p: C·∫ßn k√≠ch ho·∫°t.",
                }

                status_message_after_cancel = (
                    ready_map.get(selected_value, "‚úÖ S·∫µn s√†ng!")
                    if is_active else
                    locked_map.get(selected_value, "‚õî Y√™u c·∫ßu K√≠ch ho·∫°t")
                )
                self.update_status(status_message_after_cancel)
                logging.info(
                    f"H·∫πn gi·ªù t·∫Øt m√°y ƒë√£ h·ªßy. Kh√¥ng c√≤n t√°c v·ª• n√†o kh√°c, status ƒë·∫∑t th√†nh: '{status_message_after_cancel}'"
                )
            else:
                self.update_status("‚ÑπÔ∏è ƒê√£ h·ªßy h·∫πn gi·ªù t·∫Øt m√°y.")
                logging.info("H·∫πn gi·ªù t·∫Øt m√°y ƒë√£ h·ªßy. C√≥ th·ªÉ c√≤n t√°c v·ª• kh√°c ƒëang ch·∫°y ho·∫∑c tr·∫°ng th√°i s·∫Ω s·ªõm ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")

            if popup_window and hasattr(popup_window, 'winfo_exists') and popup_window.winfo_exists():
                logging.info("ƒêang th·ª≠ ƒë√≥ng popup h·∫πn gi·ªù t·∫Øt m√°y...")
                try:
                    popup_window.destroy()
                    logging.info("ƒê√£ ƒë√≥ng popup h·∫πn gi·ªù t·∫Øt m√°y th√†nh c√¥ng.")
                except Exception as destroy_err:
                    logging.error(f"L·ªói khi ƒë√≥ng popup h·∫πn gi·ªù t·∫Øt m√°y: {destroy_err}")
            else:
                logging.warning("Tham chi·∫øu c·ª≠a s·ªï popup kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ b·ªã ƒë√≥ng tr∆∞·ªõc khi x√°c nh·∫≠n h·ªßy.")
        else: # was_cancelled l√† False
            logging.warning("cancel_shutdown_system() th·∫•t b·∫°i (c√≥ th·ªÉ kh√¥ng c√≥ l·ªánh n√†o ƒëang ch·ªù ho·∫∑c l·ªói).")
            messagebox.showwarning("L·ªói ho·∫∑c Kh√¥ng c·∫ßn thi·∫øt", 
                                   "Kh√¥ng th·ªÉ h·ªßy l·ªánh t·∫Øt m√°y.\nC√≥ th·ªÉ ch∆∞a c√≥ l·ªánh n√†o ƒë∆∞·ª£c h·∫πn ho·∫∑c ƒë√£ x·∫£y ra l·ªói.", 
                                   parent=popup_window if popup_window and popup_window.winfo_exists() else self) # Th√™m parent an to√†n

            # ƒê√≥ng popup ngay c·∫£ khi h·ªßy th·∫•t b·∫°i ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n
            if popup_window and hasattr(popup_window, 'winfo_exists') and popup_window.winfo_exists():
                try:
                    popup_window.destroy()
                except Exception as destroy_err_fail:
                     logging.error(f"L·ªói khi ƒë√≥ng popup h·∫πn gi·ªù t·∫Øt m√°y sau khi h·ªßy th·∫•t b·∫°i: {destroy_err_fail}")


# H√†m UI: Hi·ªÉn th·ªã popup th√¥ng b√°o ƒë√£ h·∫πn gi·ªù t·∫Øt m√°y v√† cho ph√©p h·ªßy
    def show_shutdown_cancel_popup(self):
        """ Hi·ªÉn th·ªã c·ª≠a s·ªï popup th√¥ng b√°o h·∫πn gi·ªù t·∫Øt m√°y v√† cho ph√©p h·ªßy """
        # Tr√°nh t·∫°o nhi·ªÅu popup ch·ªìng ch√©o
        if hasattr(self, 'shutdown_popup') and self.shutdown_popup and self.shutdown_popup.winfo_exists():
            self.shutdown_popup.focus()
            logging.warning("Popup h·ªßy h·∫πn gi·ªù t·∫Øt m√°y ƒë√£ ƒë∆∞·ª£c hi·ªÉn th·ªã.")
            return

        try:
            popup = ctk.CTkToplevel(self)
            self.shutdown_popup = popup # L∆∞u tham chi·∫øu
            popup.title("‚è∞ H·∫πn gi·ªù t·∫Øt m√°y")
            popup.geometry("350x150")
            popup.resizable(False, False)
            popup.attributes("-topmost", True) # Lu√¥n hi·ªÉn th·ªã tr√™n c√πng

            # CƒÉn gi·ªØa popup (t√πy ch·ªçn)
            try:
                self.update_idletasks()
                popup.update_idletasks()
                x = self.winfo_x() + (self.winfo_width() // 2) - (350 // 2)
                y = self.winfo_y() + (self.winfo_height() // 2) - (150 // 2)
                popup.geometry(f"+{x}+{y}")
            except Exception: pass

            # N·ªôi dung popup
            label = ctk.CTkLabel(popup,
                                 text="‚úÖ ƒê√£ h·∫πn gi·ªù t·∫Øt m√°y sau kho·∫£ng 2 ph√∫t!\n"
                                      "(M·ªôt th√¥ng b√°o t·ª´ h·ªá th·ªëng c≈©ng c√≥ th·ªÉ xu·∫•t hi·ªán.)\n" 
                                      "B·∫°n c√≥ mu·ªën h·ªßy l·ªánh t·∫Øt m√°y n√†y kh√¥ng?",
                                 font=("Segoe UI", 13), justify="center")
            label.pack(pady=20, padx=10)

            # Khung ch·ª©a n√∫t
            button_frame = ctk.CTkFrame(popup, fg_color="transparent")
            button_frame.pack(pady=10)

            # N√∫t H·ªßy h·∫πn gi·ªù
            cancel_button = ctk.CTkButton(button_frame, text=" H·ªßy h·∫πn gi·ªù ",
                                        font=("Segoe UI", 12, "bold"),
                                        command=lambda p=popup: self.cancel_shutdown_from_popup(p), # G·ªçi h√†m h·ªßy
                                        fg_color="red", hover_color="darkred")
            cancel_button.grid(row=0, column=0, padx=10)

            # N√∫t ƒê√≥ng popup (kh√¥ng l√†m g√¨)
            close_button = ctk.CTkButton(button_frame, text=" ƒê·ªÉ sau ",
                                       font=("Segoe UI", 12),
                                       command=popup.destroy) # Ch·ªâ ƒë√≥ng popup
            close_button.grid(row=0, column=1, padx=10)

            popup.protocol("WM_DELETE_WINDOW", popup.destroy) # X·ª≠ l√Ω khi nh·∫•n n√∫t X

        except Exception as e:
            logging.error(f"L·ªói khi t·∫°o popup h·ªßy h·∫πn gi·ªù t·∫Øt m√°y: {e}", exc_info=True)


# H√†m s·ª± ki·ªán: X·ª≠ l√Ω khi ng∆∞·ªùi d√πng thay ƒë·ªïi l·ª±a ch·ªçn model Whisper
    def on_model_change(self, *args):
        """ X·ª≠ l√Ω khi ng∆∞·ªùi d√πng thay ƒë·ªïi l·ª±a ch·ªçn m√¥ h√¨nh Whisper """
        logging.info(f"Ng∆∞·ªùi d√πng ƒë√£ ch·ªçn model: {self.model_var.get()}")
        self.save_current_config()
        self.load_whisper_model_if_needed(force_reload=True)

# --------------------
# 4.4 Logic C·ªët l√µi - H√†nh ƒë·ªông N√∫t / X·ª≠ l√Ω File
# --------------------

    # H√†m h√†nh ƒë·ªông: Ch·ªçn th∆∞ m·ª•c output cho ph·ª• ƒë·ªÅ v√† video ƒë√£ g·ªôp
    def choose_output_dir(self):
        """ M·ªü h·ªôp tho·∫°i ƒë·ªÉ ch·ªçn th∆∞ m·ª•c output """
        path = filedialog.askdirectory(initialdir=self.output_path_var.get() or os.getcwd())
        if path:
            self.output_path_var.set(path) # T·ª± ƒë·ªông l∆∞u do trace


    # H√†m h√†nh ƒë·ªông: Th√™m file video/audio v√†o h√†ng ch·ªù x·ª≠ l√Ω ph·ª• ƒë·ªÅ
    def add_files_to_queue(self):
        """ Th√™m file video/audio v√†o h√†ng ch·ªù x·ª≠ l√Ω ph·ª• ƒë·ªÅ """
        
        logging.info("N√∫t 'Th√™m File (T·ª± ƒë·ªông)' ƒë∆∞·ª£c nh·∫•n, ki·ªÉm tra v√† t·∫£i model Whisper n·∫øu c·∫ßn.")
        self.load_whisper_model_if_needed()
        
        if self.is_subbing:
            messagebox.showwarning("ƒêang b·∫≠n", "ƒêang x·ª≠ l√Ω ph·ª• ƒë·ªÅ. Vui l√≤ng ƒë·ª£i.")
            return
        paths = filedialog.askopenfilenames(
            title="Ch·ªçn file Video ho·∫∑c Audio ƒë·ªÉ x·ª≠ l√Ω",
            filetypes=[
                ("T·∫•t c·∫£ file h·ªó tr·ª£", "*.mp4 *.mkv *.mov *.avi *.mp3 *.wav *.flac *.m4a"),
                ("Video Files", "*.mp4 *.mkv *.mov *.avi"),
                ("Audio Files", "*.mp3 *.wav *.flac *.m4a"),
                ("T·∫•t c·∫£ file", "*.*")
            ]
        )
        if not paths: return
        added_count = 0
        for p in paths:
            if os.path.exists(p):
                try:
                    # ƒê·ªãnh nghƒ©a c√°c ƒëu√¥i file audio
                    audio_extensions = ('.mp3', '.wav', '.flac', '.m4a', '.ogg', '.opus')
                    safe_path = ""

                    # Ki·ªÉm tra xem file ƒë∆∞·ª£c th√™m v√†o l√† audio hay video
                    if p.lower().endswith(audio_extensions):
                        # ƒê√¢y l√† file audio (d√†nh cho quy tr√¨nh Audio > Video) -> Gi·ªØ nguy√™n t√™n g·ªëc
                        safe_path = p 
                        logging.info(f"Ph√°t hi·ªán file audio, gi·ªØ nguy√™n t√™n g·ªëc c√≥ d·∫•u: {os.path.basename(p)}")
                    else:
                        # ƒê√¢y l√† file video (ho·∫∑c lo·∫°i kh√°c) -> √Åp d·ª•ng quy t·∫Øc c≈©, x√≥a d·∫•u
                        safe_path = remove_vietnamese_diacritics(p)
                        logging.info(f"Ph√°t hi·ªán file video, x√≥a d·∫•u nh∆∞ b√¨nh th∆∞·ªùng: {os.path.basename(safe_path)}")

                    # Ph·∫ßn logic c√≤n l·∫°i gi·ªØ nguy√™n
                    task_object =                     {
                        'source': safe_path,
                        'identifier': get_identifier_from_source(safe_path)
                    }

                    if not any(item.get('source') == safe_path for item in self.file_queue):
                         self.file_queue.append(task_object)
                         added_count += 1
                         logging.info(f"‚úÖ ƒê√£ th√™m v√†o h√†ng ch·ªù ph·ª• ƒë·ªÅ: {os.path.basename(safe_path)}")
                    else: 
                         logging.warning(f"File ph·ª• ƒë·ªÅ ƒë√£ c√≥ trong h√†ng ch·ªù: {os.path.basename(safe_path)}")

                except Exception as e:
                     logging.error(f"L·ªói khi x·ª≠ l√Ω ƒë∆∞·ªùng d·∫´n file '{p}': {e}")
                     messagebox.showerror("L·ªói ƒê∆∞·ªùng d·∫´n File", f"Kh√¥ng th·ªÉ x·ª≠ l√Ω t√™n file:\n{os.path.basename(p)}\n\nL·ªói: {e}")
            else: 
                logging.warning(f"Kh√¥ng t√¨m th·∫•y file, b·ªè qua: {p}")
        if added_count > 0:
             self.update_queue_display()
             self.update_status(f"ƒê√£ th√™m {added_count} file v√†o h√†ng ch·ªù ph·ª• ƒë·ªÅ.")


# H√†m qu·∫£n l√Ω h√†ng ch·ªù Subtitle: X√≥a m·ªôt file kh·ªèi h√†ng ch·ªù
    def remove_file_from_queue(self, idx):
        """ X√≥a m·ªôt file kh·ªèi h√†ng ch·ªù ph·ª• ƒë·ªÅ theo ch·ªâ s·ªë """
        if self.is_subbing:
            messagebox.showwarning("ƒêang b·∫≠n", "Kh√¥ng th·ªÉ x√≥a file khi ƒëang x·ª≠ l√Ω ph·ª• ƒë·ªÅ.")
            return
        try:
            if 0 <= idx < len(self.file_queue):                
                # 1. L·∫•y ra to√†n b·ªô task object dictionary
                removed_task_object = self.file_queue.pop(idx)
                
                # 2. L·∫•y ƒë∆∞·ªùng d·∫´n file t·ª´ key 'source' b√™n trong dictionary
                #    Th√™m .get('source', 'unknown_file') ƒë·ªÉ an to√†n n·∫øu key kh√¥ng t·ªìn t·∫°i
                removed_file_path = removed_task_object.get('source', 'unknown_file')
                
                # 3. B√¢y gi·ªù m·ªõi l·∫•y basename t·ª´ ƒë∆∞·ªùng d·∫´n ƒë√£ l·∫•y ƒë∆∞·ª£c
                removed_file_basename = os.path.basename(removed_file_path)                
                
                logging.info(f"ƒê√£ x√≥a kh·ªèi h√†ng ch·ªù ph·ª• ƒë·ªÅ: {removed_file_basename}")
                self.update_queue_display()
        except IndexError: 
            logging.warning(f"Ch·ªâ s·ªë kh√¥ng h·ª£p l·ªá ƒë·ªÉ x√≥a kh·ªèi h√†ng ch·ªù ph·ª• ƒë·ªÅ: {idx}")


# H√†m qu·∫£n l√Ω h√†ng ch·ªù Subtitle: Di chuy·ªÉn m·ªôt m·ª•c l√™n ho·∫∑c xu·ªëng
    def move_item_in_subtitle_queue(self, current_index, direction):
        """
        Di chuy·ªÉn m·ªôt m·ª•c trong h√†ng ch·ªù ph·ª• ƒë·ªÅ (self.file_queue) l√™n ho·∫∑c xu·ªëng.

        Args:
            current_index (int): V·ªã tr√≠ hi·ªán t·∫°i c·ªßa m·ª•c c·∫ßn di chuy·ªÉn.
            direction (str): "up" ƒë·ªÉ di chuy·ªÉn l√™n, "down" ƒë·ªÉ di chuy·ªÉn xu·ªëng.
        """
        if self.is_subbing:
            messagebox.showwarning("ƒêang b·∫≠n", "Kh√¥ng th·ªÉ s·∫Øp x·∫øp l·∫°i h√†ng ch·ªù khi ƒëang x·ª≠ l√Ω ph·ª• ƒë·ªÅ.", parent=self)
            return

        queue_len = len(self.file_queue)
        if not 0 <= current_index < queue_len:
            logging.warning(f"Y√™u c·∫ßu di chuy·ªÉn m·ª•c ·ªü v·ªã tr√≠ kh√¥ng h·ª£p l·ªá: {current_index}")
            return

        new_index = -1
        if direction == "up" and current_index > 0:
            new_index = current_index - 1
        elif direction == "down" and current_index < queue_len - 1:
            new_index = current_index + 1
        else:
            # Kh√¥ng th·ªÉ di chuy·ªÉn (ƒë√£ ·ªü ƒë·∫ßu/cu·ªëi ho·∫∑c h∆∞·ªõng kh√¥ng h·ª£p l·ªá)
            logging.debug(f"Kh√¥ng th·ªÉ di chuy·ªÉn m·ª•c {current_index} theo h∆∞·ªõng '{direction}'.")
            return

        if new_index != -1:
            try:
                # L·∫•y m·ª•c c·∫ßn di chuy·ªÉn
                item_to_move = self.file_queue.pop(current_index)
                # Ch√®n v√†o v·ªã tr√≠ m·ªõi
                self.file_queue.insert(new_index, item_to_move)
                
                logging.info(f"ƒê√£ di chuy·ªÉn m·ª•c '{os.path.basename(item_to_move)}' t·ª´ v·ªã tr√≠ {current_index} sang {new_index} trong h√†ng ch·ªù sub.")
                
                # C·∫≠p nh·∫≠t l·∫°i giao di·ªán h√†ng ch·ªù
                self.update_queue_display()
                self.update_status(f"‚ÑπÔ∏è ƒê√£ c·∫≠p nh·∫≠t th·ª© t·ª± h√†ng ch·ªù sub.")
            except IndexError:
                logging.error(f"L·ªói IndexError khi di chuy·ªÉn m·ª•c trong h√†ng ch·ªù sub. Index: {current_index}, New Index: {new_index}")
            except Exception as e:
                logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi di chuy·ªÉn m·ª•c trong h√†ng ch·ªù sub: {e}", exc_info=True)
                messagebox.showerror("L·ªói S·∫Øp x·∫øp", f"ƒê√£ x·∫£y ra l·ªói khi s·∫Øp x·∫øp l·∫°i h√†ng ch·ªù:\n{e}", parent=self)


# H√†m qu·∫£n l√Ω h√†ng ch·ªù cho ch·∫ø ƒë·ªô gh√©p sub th·ªß c√¥ng
    def _update_manual_sub_queue_display(self):
        """
        C·∫≠p nh·∫≠t giao di·ªán c·ªßa h√†ng ch·ªù gh√©p th·ªß c√¥ng.
        ƒê√É S·ª¨A: M√†u ch·ªØ t·ª± ƒë·ªông t∆∞∆°ng th√≠ch v·ªõi giao di·ªán S√°ng/T·ªëi.
        """
        queue_widget = getattr(self.subtitle_view_frame, 'manual_queue_section', None) if hasattr(self, 'subtitle_view_frame') else None
        if not queue_widget or not queue_widget.winfo_exists():
            return

        # X√≥a c√°c widget con c≈© trong h√†ng ch·ªù
        for widget_child in queue_widget.winfo_children():
            widget_child.destroy()

        if not self.manual_sub_queue:
            # Gi·ªØ nguy√™n ph·∫ßn hi·ªÉn th·ªã placeholder khi h√†ng ch·ªù tr·ªëng
            placeholder_text = (
                "H√†ng ch·ªù tr·ªëng.\n\n"
                "H∆∞·ªõng d·∫´n:\n"
                "1. Cung c·∫•p Ph·ª• ƒë·ªÅ (Nh·∫≠p v√†o √¥ b√™n ph·∫£i ho·∫∑c d√πng 'M·ªü Sub...').\n"
                "2. Ch·ªçn Media (Video/·∫¢nh) b·∫±ng n√∫t 'Ch·ªçn Video/·∫¢nh M·ªõi...'.\n"
                "3. Nh·∫•n '‚ûï Th√™m v√†o H√†ng ch·ªù' ƒë·ªÉ t·∫°o m·ªôt t√°c v·ª•."
            )
            ctk.CTkLabel(queue_widget, text=placeholder_text, text_color="gray", justify="left").pack(pady=20, padx=10)
        else:
            for index, task in enumerate(self.manual_sub_queue):
                is_processing = (task['status'] == 'ƒêang x·ª≠ l√Ω...')
                bg_color = "#006933" if is_processing else "transparent"
                
                # --- LOGIC M√ÄU CH·ªÆ ƒê√É S·ª¨A ---
                # B·∫±ng c√°ch kh√¥ng ch·ªâ ƒë·ªãnh m√†u (ƒë·ªÉ l√† None), CustomTkinter s·∫Ω t·ª± d√πng m√†u m·∫∑c ƒë·ªãnh c·ªßa theme
                item_text_color = None 
                status_color_display = None

                if is_processing:
                    item_text_color = "white"
                    status_color_display = "white"
                elif task.get('status') == 'Ho√†n th√†nh ‚úÖ':
                    item_text_color = "lightgreen"
                    status_color_display = "lightgreen"
                elif 'L·ªói' in task.get('status', ''):
                    item_text_color = "red"
                    status_color_display = "red"
                elif task.get('status') == 'Ch·ªù x·ª≠ l√Ω':
                    status_color_display = ("#E65100", "orange") # Cam ƒë·∫≠m cho n·ªÅn s√°ng, cam t∆∞∆°i cho n·ªÅn t·ªëi
                    item_text_color = None
                # ---------------------------

                item_frame = ctk.CTkFrame(queue_widget, fg_color=bg_color, corner_radius=3)
                item_frame.pack(fill="x", pady=2, padx=2)

                # ... c√°c frame con gi·ªØ nguy√™n ...
                info_frame = ctk.CTkFrame(item_frame, fg_color="transparent")
                info_frame.pack(side="left", fill="x", expand=True, padx=5, pady=2)
                
                status_text = task.get('status', 'N/A')
                info_line1 = f"{index + 1}. [{status_text}] Media: {task['media_display_name'][:25]}..."
                info_line2 = f"    Ph·ª• ƒë·ªÅ: {task['subtitle_display_name'][:40]}..."

                # S·ª¨A ·ªû ƒê√ÇY: D√πng bi·∫øn m√†u m·ªõi v√† b·ªè m√†u c·ªë ƒë·ªãnh
                # D√≤ng 1: Media
                ctk.CTkLabel(info_frame, text=info_line1, anchor="w", font=("Segoe UI", 10, "bold"), text_color=item_text_color).pack(fill="x")
                
                # D√≤ng 2: Ph·ª• ƒë·ªÅ - B·ªè ho√†n to√†n text_color="gray" ƒë·ªÉ d√πng m√†u m·∫∑c ƒë·ªãnh
                ctk.CTkLabel(info_frame, text=info_line2, anchor="w", font=("Segoe UI", 9)).pack(fill="x")
                
                # C√°c n√∫t ƒëi·ªÅu khi·ªÉn gi·ªØ nguy√™n
                button_state = ctk.DISABLED if self.is_manual_sub_processing else ctk.NORMAL
                del_button = ctk.CTkButton(item_frame, text="‚úï", width=26, height=26, command=lambda t_id=task['id']: self._remove_manual_sub_task(t_id), fg_color="#E74C3C", hover_color="#C0392B", state=button_state)
                del_button.pack(side="right", padx=(0, 5), pady=5)


# X√≥a m·ªôt t√°c v·ª• kh·ªèi h√†ng ch·ªù th·ªß c√¥ng
    def _remove_manual_sub_task(self, task_id_to_remove):
        """X√≥a m·ªôt t√°c v·ª• kh·ªèi h√†ng ch·ªù th·ªß c√¥ng."""
        if self.is_manual_sub_processing: return
        self.manual_sub_queue = [task for task in self.manual_sub_queue if task.get('id') != task_id_to_remove]
        self._update_manual_sub_queue_display()
        self.update_status("ƒê√£ x√≥a 1 t√°c v·ª• kh·ªèi h√†ng ch·ªù th·ªß c√¥ng.")



# H√†m Thu th·∫≠p th√¥ng tin t·ª´ UI, t·∫°o m·ªôt task th·ªß c√¥ng v√† th√™m v√†o h√†ng ch·ªù.
    def _add_manual_sub_task_to_queue(self):
        """
        (PHI√äN B·∫¢N 4.0 - L·∫§Y KEY T·ª™ SCRIPT/TEXTBOX/MEDIA)
        Thu th·∫≠p th√¥ng tin t·ª´ UI, t·∫°o m·ªôt task th·ªß c√¥ng v√† th√™m v√†o h√†ng ch·ªù.
        """
        log_prefix = "[AddManualTask_v4]"
        logging.info(f"{log_prefix} Y√™u c·∫ßu th√™m t√°c v·ª• v√†o h√†ng ch·ªù th·ªß c√¥ng.")

        # 1. L·∫•y v√† x√°c th·ª±c ngu·ªìn Subtitle (Logic c≈© gi·ªØ nguy√™n)
        subtitle_source_type = None
        subtitle_data = None
        subtitle_display_name = ""

        # Truy c·∫≠p subtitle_textbox qua SubtitleTab
        subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
        textbox_content = subtitle_textbox.get("1.0", "end-1c").strip() if subtitle_textbox and subtitle_textbox.winfo_exists() else ""
        # ∆Øu ti√™n d√πng file SRT n·∫øu c√≥
        if self.current_srt_path and os.path.exists(self.current_srt_path):
            subtitle_source_type = 'file'
            subtitle_data = self.current_srt_path
            subtitle_display_name = os.path.basename(self.current_srt_path)
        # N·∫øu kh√¥ng, d√πng n·ªôi dung t·ª´ textbox
        elif subtitle_textbox and subtitle_textbox.winfo_exists() and textbox_content and not self._is_textbox_content_invalid_for_script(textbox_content):
            subtitle_source_type = 'textbox'
            subtitle_data = textbox_content
            subtitle_display_name = "K·ªãch b·∫£n t·ª´ Textbox"
        else:
            messagebox.showwarning("Thi·∫øu Ph·ª• ƒê·ªÅ", "Vui l√≤ng nh·∫≠p n·ªôi dung v√†o √¥ k·ªãch b·∫£n ho·∫∑c t·∫£i m·ªôt file .SRT tr∆∞·ªõc.", parent=self)
            return

        # 2. L·∫•y v√† x√°c th·ª±c ngu·ªìn Media (Logic c≈© gi·ªØ nguy√™n)
        media_source_type = None
        media_data = self.sub_pause_selected_media_path
        media_display_name = ""

        if media_data and os.path.exists(media_data):
            if "sub_pause_slideshow_" in os.path.basename(media_data).lower():
                media_source_type = 'slideshow'
                media_display_name = "Video Slideshow (t·∫°m)"
            elif media_data.lower().endswith(('.mp4', '.mkv', '.mov', '.avi')):
                media_source_type = 'video'
                media_display_name = os.path.basename(media_data)
            else:
                messagebox.showerror("L·ªói Media", f"Lo·∫°i media '{os.path.basename(media_data)}' kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ ƒë·ªÉ th√™m tr·ª±c ti·∫øp v√†o h√†ng ch·ªù.", parent=self)
                return
        else:
            messagebox.showwarning("Thi·∫øu Media", "Vui l√≤ng ch·ªçn m·ªôt file Video/·∫¢nh ho·∫∑c t·∫°o Slideshow tr∆∞·ªõc khi th√™m v√†o h√†ng ch·ªù.", parent=self)
            return

        # <<< B·∫ÆT ƒê·∫¶U KH·ªêI LOGIC T·∫†O KEY V·ªöI 3 M·ª®C ∆ØU TI√äN 
        identifier_for_task = None
        log_source = "Kh√¥ng x√°c ƒë·ªãnh"

        # ∆Øu ti√™n 1 (M·ªõi): L·∫•y key t·ª´ file k·ªãch b·∫£n v·ª´a ƒë∆∞·ª£c t·∫£i l·∫ßn cu·ªëi
        if hasattr(self, 'last_loaded_script_path') and self.last_loaded_script_path:
            identifier_for_task = get_identifier_from_source(self.last_loaded_script_path)
            log_source = f"file k·ªãch b·∫£n v·ª´a t·∫£i '{os.path.basename(self.last_loaded_script_path)}'"
            # X√≥a ƒëi sau khi s·ª≠ d·ª•ng ƒë·ªÉ ƒë·∫£m b·∫£o l·∫ßn th√™m ti·∫øp theo kh√¥ng b·ªã d√πng l·∫°i t√™n c≈© m·ªôt c√°ch v√¥ t√¨nh
            self.last_loaded_script_path = None

        # ∆Øu ti√™n 2: L·∫•y key t·ª´ 50 k√Ω t·ª± ƒë·∫ßu c·ªßa textbox (n·∫øu kh√¥ng c√≥ file n√†o v·ª´a ƒë∆∞·ª£c t·∫£i)
        elif subtitle_source_type == 'textbox' and subtitle_data:
            pure_dialogue = extract_dialogue_from_srt_string(subtitle_data)
            text_snippet = pure_dialogue[:50]
            safe_snippet_key = create_safe_filename(text_snippet, remove_accents=False)
            if safe_snippet_key:
                identifier_for_task = safe_snippet_key
                log_source = "50 k√Ω t·ª± ƒë·∫ßu c·ªßa textbox"

        # ∆Øu ti√™n 3 (Fallback): N·∫øu v·∫´n ch∆∞a c√≥ key, fallback v·ªÅ t√™n file media
        if not identifier_for_task:
            if self.manual_sub_original_media_source_path:
                identifier_for_task = get_identifier_from_source(self.manual_sub_original_media_source_path)
                log_source = f"media g·ªëc '{os.path.basename(self.manual_sub_original_media_source_path)}' (fallback)"
            else:
                identifier_for_task = get_identifier_from_source(media_data)
                log_source = f"media t·∫°m '{os.path.basename(media_data)}' (fallback cu·ªëi c√πng)"

        logging.info(f"{log_prefix} ƒê√£ t·∫°o identifier t·ª´ ngu·ªìn: {log_source}. Key: '{identifier_for_task}'")
        
        # 3. T·∫°o Task v√† th√™m v√†o h√†ng ch·ªù (ƒë√£ c√≥ identifier)
        task_data = {
            'id': str(uuid.uuid4()),
            'identifier': identifier_for_task,
            'subtitle_source_type': subtitle_source_type,
            'subtitle_data': subtitle_data,
            'subtitle_display_name': subtitle_display_name,
            'media_source_type': media_source_type,
            'media_data': media_data,
            'media_display_name': media_display_name,
            'save_in_media_folder': self.save_in_media_folder_var.get(),
            'original_media_source_path': self.manual_sub_original_media_source_path,
            'status': 'Ch·ªù x·ª≠ l√Ω',
            'result_path': None,
            'error_message': None,
        }

        self.manual_sub_queue.append(task_data)
        logging.info(f"{log_prefix} ƒê√£ th√™m t√°c v·ª• m·ªõi. H√†ng ch·ªù c√≥ {len(self.manual_sub_queue)} m·ª•c.")

        # Reset ƒë∆∞·ªùng d·∫´n g·ªëc sau khi ƒë√£ th√™m v√†o h√†ng ch·ªù
        self.manual_sub_original_media_source_path = None

        # 4. Reset UI ƒë·ªÉ chu·∫©n b·ªã cho t√°c v·ª• ti·∫øp theo
        if subtitle_textbox and subtitle_textbox.winfo_exists():
            subtitle_textbox.configure(state="normal")
            subtitle_textbox.delete("1.0", "end")
        self.current_srt_path = None
        self.sub_pause_selected_media_path = None
        if hasattr(self, 'sub_pause_selected_media_info_label'):
            self.sub_pause_selected_media_info_label.configure(text="")

        self._update_manual_sub_queue_display()
        self.update_status(f"ƒê√£ th√™m '{media_display_name}' v√†o h√†ng ch·ªù th·ªß c√¥ng.")



# 5 H√†m X·ª≠ l√Ω t·ª´ng t√°c v·ª• trong h√†ng ch·ªù th·ªß c√¥ng
    def _start_manual_sub_batch(self):
        """B·∫Øt ƒë·∫ßu x·ª≠ l√Ω h√†ng lo·∫°t c√°c t√°c v·ª• trong h√†ng ch·ªù th·ªß c√¥ng."""
        if self.is_manual_sub_processing:
            messagebox.showwarning("ƒêang b·∫≠n", "ƒêang x·ª≠ l√Ω h√†ng ch·ªù gh√©p th·ªß c√¥ng.", parent=self)
            return
        if not self.manual_sub_queue:
            messagebox.showinfo("H√†ng ch·ªù tr·ªëng", "Vui l√≤ng th√™m √≠t nh·∫•t m·ªôt c·∫∑p [Ph·ª• ƒë·ªÅ + Media] v√†o h√†ng ch·ªù th·ªß c√¥ng tr∆∞·ªõc.", parent=self)
            return

        logging.info(f"--- B·∫ÆT ƒê·∫¶U X·ª¨ L√ù H√ÄNG LO·∫†T GH√âP TH·ª¶ C√îNG ({len(self.manual_sub_queue)} t√°c v·ª•) ---")
        # --- KI·ªÇM TRA T·∫ÆT M√ÅY ---
        if hasattr(self, 'download_shutdown_var') and self.download_shutdown_var.get():
            self.shutdown_requested_by_task = True
            logging.info(f"[ManualBatch] T√°c v·ª• Manual-Sub: 'H·∫πn gi·ªù t·∫Øt m√°y' ƒë∆∞·ª£c B·∫¨T. Ghi nh·∫≠n y√™u c·∫ßu.")
        else:
            self.shutdown_requested_by_task = False

        self.is_manual_sub_processing = True
        self.stop_event.clear()
        self._set_subtitle_tab_ui_state(True)
        
        self.start_time = time.time()
        self.update_time_realtime()

        self._process_next_manual_sub_task()


# H√†m L·∫•y t√°c v·ª• ti·∫øp theo t·ª´ h√†ng ch·ªù th·ªß c√¥ng
    def _process_next_manual_sub_task(self):
        """
        L·∫•y t√°c v·ª• ti·∫øp theo, chu·∫©n b·ªã ƒë·∫ßy ƒë·ªß th√¥ng tin (bao g·ªìm th∆∞ m·ª•c output cu·ªëi c√πng)
        v√† kh·ªüi ch·∫°y lu·ªìng worker.
        """
        if self.stop_event.is_set():
            logging.info("Y√™u c·∫ßu d·ª´ng h√†ng lo·∫°t th·ªß c√¥ng ƒë∆∞·ª£c ph√°t hi·ªán.")
            self._on_manual_batch_finished(stopped=True)
            return

        if not self.manual_sub_queue:
            logging.info("H√†ng ch·ªù th·ªß c√¥ng ƒë√£ x·ª≠ l√Ω h·∫øt.")
            self._on_manual_batch_finished(stopped=False)
            return

        current_task = self.manual_sub_queue[0]
        current_task['status'] = 'ƒêang x·ª≠ l√Ω...'

        # Hi·ªÉn th·ªã n·ªôi dung sub l√™n textbox
        try:
            content_to_show = ""
            if current_task.get('subtitle_source_type') == 'textbox':
                content_to_show = current_task.get('subtitle_data', '')
            elif current_task.get('subtitle_source_type') == 'file':
                with open(current_task.get('subtitle_data', ''), 'r', encoding='utf-8-sig') as f:
                    content_to_show = f.read()
            self.show_sub_in_textbox(content_to_show)
            logging.info(f"ƒê√£ hi·ªÉn th·ªã n·ªôi dung sub c·ªßa t√°c v·ª• '{current_task.get('id')}' l√™n textbox.")
        except Exception as e:
            logging.error(f"L·ªói khi hi·ªÉn th·ªã n·ªôi dung sub cho t√°c v·ª• '{current_task.get('id')}': {e}")
            self.show_sub_in_textbox(f"[L·ªñI HI·ªÇN TH·ªä SUBTITLE C·ª¶A T√ÅC V·ª§]\n\n{e}")

        self._update_manual_sub_queue_display()
        logging.info(f"ƒêang x·ª≠ l√Ω t√°c v·ª• th·ªß c√¥ng: {current_task.get('id')}")
        self.update_status(f"üî® Gh√©p th·ªß c√¥ng: {current_task.get('media_display_name', 'N/A')[:30]}...")

        # <<< S·ª¨A ƒê·ªîI L·ªöN: CHU·∫®N B·ªä ƒê·∫¶Y ƒê·ª¶ D·ªÆ LI·ªÜU CHO LU·ªíNG WORKER >>>
        try:
            # 1. Chu·∫©n b·ªã ƒë∆∞·ªùng d·∫´n SRT ƒë·ªÉ FFmpeg c√≥ th·ªÉ s·ª≠ d·ª•ng
            if current_task.get('subtitle_source_type') == 'textbox':
                temp_srt_filename = f"manual_task_sub_{current_task.get('id', 'temp')[:8]}.srt"
                temp_srt_path = os.path.join(self.temp_folder, temp_srt_filename)
                with open(temp_srt_path, "w", encoding="utf-8") as f:
                    f.write(current_task.get('subtitle_data', ''))
                current_task['srt_path_for_ffmpeg'] = temp_srt_path
                current_task['temp_srt_to_delete'] = temp_srt_path
            elif current_task.get('subtitle_source_type') == 'file':
                current_task['srt_path_for_ffmpeg'] = current_task.get('subtitle_data')
                current_task['temp_srt_to_delete'] = None

            # 2. L·∫•y snapshot c·ªßa c·∫•u h√¨nh UI
            current_task['cfg_snapshot'] = self._get_config_snapshot()

            # 3. X√°c ƒë·ªãnh t√™n file g·ªëc cho video v√† SRT output
            media_path = current_task.get('media_data')
            base_name_for_outputs = os.path.splitext(os.path.basename(media_path))[0] if media_path else f"piu_manual_task_{current_task.get('id', 'task')[:4]}"
            safe_base_name = create_safe_filename(base_name_for_outputs, remove_accents=False, max_length=100)
            current_task['safe_output_base_name'] = safe_base_name if safe_base_name else f"task_{current_task.get('id', 'task')[:4]}_output"

            # 4. <<< LOGIC M·ªöI: QUY·∫æT ƒê·ªäNH TH∆Ø M·ª§C OUTPUT CU·ªêI C√ôNG >>>
            should_save_in_media_folder = current_task.get('save_in_media_folder', False)
            final_output_dir_for_thread = self.output_path_var.get() # M·∫∑c ƒë·ªãnh l√† th∆∞ m·ª•c chung

            if should_save_in_media_folder:
                original_source_path = current_task.get('original_media_source_path')
                if original_source_path and os.path.exists(original_source_path):
                    if os.path.isdir(original_source_path):
                        final_output_dir_for_thread = original_source_path
                    else:
                        final_output_dir_for_thread = os.path.dirname(os.path.abspath(original_source_path))
                    logging.info(f"ƒê√£ x√°c ƒë·ªãnh th∆∞ m·ª•c output ri√™ng cho t√°c v·ª•: {final_output_dir_for_thread}")
                else:
                    logging.warning(f"Y√™u c·∫ßu l∆∞u v√†o th∆∞ m·ª•c media nh∆∞ng ƒë∆∞·ªùng d·∫´n g·ªëc kh√¥ng h·ª£p l·ªá. D√πng th∆∞ m·ª•c chung.")
            # Th√™m th∆∞ m·ª•c ƒë√£ quy·∫øt ƒë·ªãnh v√†o task
            current_task['final_output_dir'] = final_output_dir_for_thread
            # <<< K·∫æT TH√öC LOGIC M·ªöI >>>

        except Exception as e_prepare:
            logging.error(f"L·ªói khi chu·∫©n b·ªã d·ªØ li·ªáu cho t√°c v·ª• th·ªß c√¥ng {current_task.get('id')}: {e_prepare}", exc_info=True)
            current_task['status'] = 'L·ªói Chu·∫©n b·ªã'
            current_task['error_message'] = str(e_prepare)
            self.manual_sub_queue.pop(0)
            self._update_manual_sub_queue_display()
            self.after(50, self._process_next_manual_sub_task)
            return

        # Ch·∫°y t√°c v·ª• trong lu·ªìng ri√™ng v·ªõi dictionary 'current_task' ƒë√£ ƒë∆∞·ª£c b·ªï sung ƒë·∫ßy ƒë·ªß
        thread = threading.Thread(
            target=self._execute_manual_merge_threaded,
            args=(current_task,), # Truy·ªÅn to√†n b·ªô ƒë·ªëi t∆∞·ª£ng task ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
            daemon=True,
            name=f"ManualSubWorker_{current_task.get('id', 'task')[:6]}"
        )
        thread.start()

    def _execute_single_manual_task_threaded(self, task):
        """
        Worker thread: Th·ª±c thi m·ªôt t√°c v·ª• gh√©p sub th·ªß c√¥ng.
        """
        log_prefix = f"[{threading.current_thread().name}]"
        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu th·ª±c thi task ID: {task['id']}")
        success = False
        final_video_path = None
        error_message = None
        temp_srt_path = None

        try:
            # 1. Chu·∫©n b·ªã file SRT
            if task['subtitle_source_type'] == 'textbox':
                temp_srt_path = os.path.join(self.temp_folder, f"manual_task_{task['id']}.srt")
                with open(temp_srt_path, "w", encoding="utf-8") as f:
                    f.write(task['subtitle_data'])
                path_to_srt_for_ffmpeg = temp_srt_path
            else: # 'file'
                path_to_srt_for_ffmpeg = task['subtitle_data']
            
            if not os.path.exists(path_to_srt_for_ffmpeg):
                raise FileNotFoundError(f"File SRT kh√¥ng t√¨m th·∫•y: {path_to_srt_for_ffmpeg}")

            # 2. Chu·∫©n b·ªã file Video (hi·ªán t·∫°i gi·∫£ ƒë·ªãnh media_data ƒë√£ l√† video)
            media_path_for_ffmpeg = task['media_data']

            # 3. L·∫•y c·∫•u h√¨nh v√† th·ª±c hi·ªán gh√©p
            cfg_snapshot = self._get_config_snapshot()
            merge_mode = cfg_snapshot.get('merge_mode', 'hard-sub')
            
            # N·∫øu kh√¥ng ph·∫£i l√† ch·∫ø ƒë·ªô g·ªôp, kh√¥ng l√†m g√¨ c·∫£
            if merge_mode == "kh√¥ng g·ªôp":
                logging.warning(f"{log_prefix} Ch·∫ø ƒë·ªô 'Kh√¥ng g·ªôp' ƒë∆∞·ª£c ch·ªçn cho t√°c v·ª• th·ªß c√¥ng. T√°c v·ª• s·∫Ω ƒë∆∞·ª£c b·ªè qua.")
                # Tr·∫£ v·ªÅ th√†nh c√¥ng ƒë·ªÉ t√°c v·ª• ti·∫øp theo ƒë∆∞·ª£c x·ª≠ l√Ω, nh∆∞ng kh√¥ng t·∫°o file
                success = True
                final_video_path = media_path_for_ffmpeg # Tr·∫£ v·ªÅ media g·ªëc
            else:
                output_dir = self.output_path_var.get()
                base_name = create_safe_filename(f"{os.path.splitext(os.path.basename(media_path_for_ffmpeg))[0]}_manual", remove_accents=False)
                
                if merge_mode == "hard-sub":
                    final_video_path = os.path.join(output_dir, f"{base_name}_hardsub.mp4")
                    self.burn_sub_to_video(media_path_for_ffmpeg, path_to_srt_for_ffmpeg, final_video_path, cfg_snapshot)
                elif merge_mode == "soft-sub":
                    final_video_path = os.path.join(output_dir, f"{base_name}_softsub.mkv")
                    self.merge_sub_as_soft_sub(media_path_for_ffmpeg, path_to_srt_for_ffmpeg, final_video_path)
                
                if final_video_path and os.path.exists(final_video_path):
                    success = True
                else:
                    error_message = "FFmpeg kh√¥ng t·∫°o ƒë∆∞·ª£c file video cu·ªëi c√πng."

        except Exception as e:
            success = False
            error_message = str(e)
            logging.error(f"{log_prefix} L·ªói khi th·ª±c thi t√°c v·ª•: {e}", exc_info=True)
        finally:
            if temp_srt_path and os.path.exists(temp_srt_path):
                try: os.remove(temp_srt_path)
                except: pass
            
            self.after(0, self._handle_manual_task_completion, task['id'], success, final_video_path, error_message)


# H√†m Callback x·ª≠ l√Ω khi m·ªôt t√°c v·ª• th·ªß c√¥ng ho√†n th√†nh.
    def _handle_manual_task_completion(self, task_id, success, result_path, error_message):
        """
        Callback x·ª≠ l√Ω khi m·ªôt t√°c v·ª• th·ªß c√¥ng ho√†n th√†nh.
        >>> PHI√äN B·∫¢N 3.0: X·ª≠ l√Ω ƒë·∫ßy ƒë·ªß c√°c chu·ªói Sub&Dub, Sub&Brand&Upload, Sub&Upload.
        """
        log_prefix = f"[HandleManualTaskCompletion_v3.0_{str(task_id)[:6]}]"
        
        task_data = next((t for t in self.manual_sub_queue if t.get('id') == task_id), None)
        if not task_data:
            logging.error(f"{log_prefix} Kh√¥ng t√¨m th·∫•y task ID {task_id} ƒë·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£.")
            self.after(50, self._process_next_manual_sub_task)
            return

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i trong UI tr∆∞·ªõc ti√™n
        task_data['result_path'] = result_path
        task_data['error_message'] = error_message
        task_data['status'] = "Ho√†n th√†nh ‚úÖ" if success else f"L·ªói ‚ùå"
        self._update_manual_sub_queue_display()

        # N·∫øu t√°c v·ª• th·∫•t b·∫°i, ch·ªâ c·∫ßn chuy·ªÉn sang t√°c v·ª• ti·∫øp theo
        if not success:
            logging.error(f"{log_prefix} T√°c v·ª• th·∫•t b·∫°i. L·ªói: {error_message}. Chuy·ªÉn sang t√°c v·ª• ti·∫øp theo.")
            if self.manual_sub_queue and self.manual_sub_queue[0].get('id') == task_id:
                self.manual_sub_queue.pop(0)
            self.after(50, self._process_next_manual_sub_task)
            return

        # N·∫øu t√°c v·ª• th√†nh c√¥ng, x·ª≠ l√Ω c√°c chu·ªói ti·∫øp theo
        any_branding_enabled = self.branding_intro_enabled_var.get() or self.branding_outro_enabled_var.get() or self.branding_logo_enabled_var.get()

        # ∆ØU TI√äN 1: CHU·ªñI SUB & DUB
        if self.manual_sub_then_dub_active:
            logging.info(f"{log_prefix} T√°c v·ª• th√†nh c√¥ng v√† ƒëang trong chu·ªói Sub&Dub. Branding s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω sau Dub. Chu·∫©n b·ªã cho Dub.")
            
            srt_path_for_dub = None
            if task_data['subtitle_source_type'] == 'file':
                srt_path_for_dub = task_data['subtitle_data']
            else: # T·ª´ textbox, t·∫°o file SRT t·∫°m
                try:
                    # ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i v√† s·ª≠ d·ª•ng t√™n file c√≥ √Ω nghƒ©a h∆°n
                    output_dir_from_task = task_data.get('final_output_dir', self.temp_folder)
                    base_name_from_task = task_data.get('safe_output_base_name', f"task_{task_id[:6]}")
                    srt_path_for_dub = os.path.join(output_dir_from_task, f"{base_name_from_task}_script.srt")
                    with open(srt_path_for_dub, "w", encoding="utf-8") as f:
                        f.write(task_data['subtitle_data'])
                except Exception as e:
                    logging.error(f"{log_prefix} L·ªói t·∫°o file SRT t·∫°m cho dub: {e}")
                    srt_path_for_dub = None
            
            if result_path and srt_path_for_dub:
                output_dir_from_sub_step = os.path.dirname(result_path)
                
                self.files_for_chained_dubbing.append({
                    'video_to_dub': result_path,
                    'script_content_type': 'srt_file',
                    'script_data': srt_path_for_dub,
                    'chain_output_dir_override': output_dir_from_sub_step,
                    'identifier': task_data.get('identifier') # Truy·ªÅn identifier ƒëi ti·∫øp
                })
                logging.info(f"{log_prefix} ƒê√£ th√™m v√†o h√†ng ch·ªù Dub: Video: {os.path.basename(result_path)}, SRT: {os.path.basename(srt_path_for_dub)}")
            
            # X√≥a t√°c v·ª• sub ƒë√£ xong v√† x·ª≠ l√Ω c√°i ti·∫øp theo trong l√¥ th·ªß c√¥ng
            if self.manual_sub_queue and self.manual_sub_queue[0].get('id') == task_id: self.manual_sub_queue.pop(0)
            self.after(50, self._process_next_manual_sub_task)
            return # D·ª´ng h√†m ·ªü ƒë√¢y

        # ∆ØU TI√äN 2: CHU·ªñI SUB & BRANDING (& UPLOAD)
        elif any_branding_enabled:
            logging.info(f"{log_prefix} T√°c v·ª• th√†nh c√¥ng (ch·ªâ Sub). Branding ƒë∆∞·ª£c b·∫≠t. B·∫Øt ƒë·∫ßu branding cho: {os.path.basename(result_path)}")
            self.update_status(f"üé® Branding: {os.path.basename(result_path)}...")
            
            context_for_branding = {
                "source_view": "subtitle_manual_batch",
                "task_id": task_id,
                "video_before_branding": result_path,
                "is_softsub_input_for_branding": task_data.get('merge_mode', 'hard-sub') == "soft-sub"
            }
            # Lu·ªìng branding s·∫Ω ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu, v√† callback c·ªßa n√≥ (_handle_branding_completion) s·∫Ω x·ª≠ l√Ω c√°c b∆∞·ªõc ti·∫øp theo
            self._start_branding_thread(result_path, self._handle_branding_completion, context_for_branding)
            return # D·ª´ng h√†m ·ªü ƒë√¢y, ch·ªù branding xong

        # ∆ØU TI√äN 3: CHU·ªñI SUB & UPLOAD (KH√îNG C√ì BRANDING)
        elif self.auto_upload_to_youtube_var.get():
            logging.info(f"{log_prefix} T√°c v·ª• th√†nh c√¥ng (kh√¥ng branding). T·ª± ƒë·ªông th√™m v√†o h√†ng ch·ªù upload.")
            self._add_completed_video_to_upload_queue(task_data)
            
            # X√≥a t√°c v·ª• sub ƒë√£ xong v√† x·ª≠ l√Ω c√°i ti·∫øp theo
            if self.manual_sub_queue and self.manual_sub_queue[0].get('id') == task_id: self.manual_sub_queue.pop(0)
            self.after(50, self._process_next_manual_sub_task)
            return # D·ª´ng h√†m ·ªü ƒë√¢y

        # TR∆Ø·ªúNG H·ª¢P C√íN L·∫†I: CH·ªà SUB, KH√îNG L√ÄM G√å TI·∫æP THEO
        else:
            logging.info(f"{log_prefix} T√°c v·ª• th√†nh c√¥ng v√† kh√¥ng c√≥ b∆∞·ªõc t·ª± ƒë·ªông n√†o ti·∫øp theo. Chuy·ªÉn sang t√°c v·ª• k·∫ø ti·∫øp.")
            if self.manual_sub_queue and self.manual_sub_queue[0].get('id') == task_id: self.manual_sub_queue.pop(0)
            self.after(50, self._process_next_manual_sub_task)


# H√†m X·ª≠ l√Ω sau khi to√†n b·ªô h√†ng ch·ªù thuy·∫øt minh ho√†n t·∫•t
    def _on_manual_batch_finished(self, stopped=False):
        """
        (PHI√äN B·∫¢N 5.0 - ƒê√É S·ª¨A L·ªñI T·∫ÆT M√ÅY S·ªöM)
        X·ª≠ l√Ω sau khi to√†n b·ªô h√†ng ch·ªù thuy·∫øt minh ho√†n t·∫•t.
        """
        was_in_sub_dub_chain = self.manual_sub_then_dub_active
        logging.info(f"[ManualBatchFinished_v5] X·ª≠ l√Ω h√†ng lo·∫°t th·ªß c√¥ng k·∫øt th√∫c. D·ª´ng: {stopped}, WasInChain: {was_in_sub_dub_chain}")

        self._update_manual_sub_queue_display()
        self.is_manual_sub_processing = False
        self.start_time = None

        # --- ∆ØU TI√äN 1: KI·ªÇM TRA CHU·ªñI SUB & DUB ---
        if not stopped and self.manual_sub_then_dub_active:
            self.update_status("‚úÖ Gh√©p sub th·ªß c√¥ng xong! Chu·∫©n b·ªã thuy·∫øt minh...")

            files_to_dub = list(self.files_for_chained_dubbing)
            self.manual_sub_then_dub_active = False 
            self.files_for_chained_dubbing = []

            if files_to_dub:
                self.after(200, self._initiate_chained_dubbing, files_to_dub)
                return # Tho√°t h√†m, vi·ªác t·∫Øt m√°y s·∫Ω do chu·ªói dubbing x·ª≠ l√Ω
            else:
                logging.warning("Y√™u c·∫ßu Sub&Dub nh∆∞ng kh√¥ng c√≥ file n√†o h·ª£p l·ªá ƒë·ªÉ chuy·ªÉn sang l·ªìng ti·∫øng.")

        # --- ∆ØU TI√äN 2: KI·ªÇM TRA CHU·ªñI SUB & UPLOAD ---
        elif not stopped and self.auto_upload_to_youtube_var.get() and self.youtube_upload_queue:
            success_message = f"‚úÖ Gh√©p sub xong! Chu·∫©n b·ªã upload {len(self.youtube_upload_queue)} video..."
            logging.info(f"[ManualBatchFinished_v5] {success_message}")
            self.update_status(success_message)
            
            try:
                upload_tab_value = "üì§ Upload YT" 
                if hasattr(self, 'view_switcher') and self.view_switcher.get() != upload_tab_value:
                    self.view_switcher.set(upload_tab_value)
                    self.switch_view(upload_tab_value)
            except Exception as e_switch:
                logging.error(f"[ManualBatchFinished_v5] L·ªói khi t·ª± ƒë·ªông chuy·ªÉn sang tab Upload: {e_switch}")

            self.is_chain_handoff = True
            logging.info("[ManualBatchFinished_v5] ƒê√£ ƒë·∫∑t kh√≥a is_chain_handoff = True ƒë·ªÉ ch·ªù upload b·∫Øt ƒë·∫ßu.")
            self.after(500, self._start_youtube_batch_upload)

            return # Tho√°t h√†m, vi·ªác t·∫Øt m√°y s·∫Ω do chu·ªói upload x·ª≠ l√Ω

        # --- X·ª¨ L√ù KHI KH√îNG C√ì CHU·ªñI N√ÄO TI·∫æP THEO ---
        # Ch·ªâ ch·∫°y ƒë·∫øn ƒë√¢y n·∫øu kh√¥ng ph·∫£i l√† chu·ªói Sub&Dub ho·∫∑c Sub&Upload
        self._set_subtitle_tab_ui_state(False)

        if stopped:
            self.update_status("üõë H√†ng lo·∫°t th·ªß c√¥ng ƒë√£ d·ª´ng.")
        elif not was_in_sub_dub_chain:
            self.update_status("‚úÖ Ho√†n t·∫•t h√†ng lo·∫°t gh√©p th·ªß c√¥ng!")
            messagebox.showinfo("Ho√†n th√†nh", "ƒê√£ x·ª≠ l√Ω xong t·∫•t c·∫£ c√°c t√°c v·ª• trong h√†ng ch·ªù gh√©p th·ªß c√¥ng.", parent=self)
        
        self._check_completion_and_shutdown() # <-- Ch·ªâ g·ªçi khi ƒë√¢y l√† ƒëi·ªÉm k·∫øt th√∫c th·ª±c s·ª±



#------------------------------------------------------------------------------------------------------------------------------------------------------
    # H√†m qu·∫£n l√Ω h√†ng ch·ªù Download: Di chuy·ªÉn m·ªôt m·ª•c l√™n ho·∫∑c xu·ªëng
    def move_item_in_download_queue(self, current_index_in_display, direction):
        """
        Di chuy·ªÉn m·ªôt m·ª•c trong h√†ng ch·ªù t·∫£i xu·ªëng (self.download_urls_list) l√™n ho·∫∑c xu·ªëng.
        L∆∞u √Ω: current_index_in_display l√† ch·ªâ s·ªë trong danh s√°ch ƒëang hi·ªÉn th·ªã (ƒë√£ lo·∫°i tr·ª´ current_download_url).
        """
        if self.is_downloading and self.current_download_url is not None:
            # Ch·ªâ cho ph√©p s·∫Øp x·∫øp c√°c m·ª•c ch∆∞a ƒë∆∞·ª£c t·∫£i
            pass
        elif self.is_downloading:
            messagebox.showwarning("ƒêang b·∫≠n", "Kh√¥ng th·ªÉ s·∫Øp x·∫øp l·∫°i h√†ng ch·ªù khi ƒëang t·∫£i xu·ªëng v√† ch∆∞a c√≥ m·ª•c n√†o ƒë∆∞·ª£c x·ª≠ l√Ω.", parent=self)
            return
        
        waiting_urls_only = []
        if hasattr(self, 'download_urls_list') and self.download_urls_list:
            if self.current_download_url:
                waiting_urls_only = [url for url in self.download_urls_list if url != self.current_download_url]
            else:
                waiting_urls_only = list(self.download_urls_list)

        queue_len = len(waiting_urls_only)

        if not 0 <= current_index_in_display < queue_len:
            logging.warning(f"Y√™u c·∫ßu di chuy·ªÉn m·ª•c t·∫£i xu·ªëng ·ªü v·ªã tr√≠ hi·ªÉn th·ªã kh√¥ng h·ª£p l·ªá: {current_index_in_display} (ƒë·ªô d√†i h√†ng ch·ªù: {queue_len})")
            return

        actual_current_index_in_main_list = -1
        item_to_move_value = waiting_urls_only[current_index_in_display]

        # T√¨m v·ªã tr√≠ th·ª±c s·ª± c·ªßa item_to_move_value trong self.download_urls_list
        # (quan tr·ªçng n·∫øu self.download_urls_list c√≥ c·∫£ current_download_url)
        try:
            # T√¨m v·ªã tr√≠ c·ªßa item_to_move TRONG self.download_urls_list
            # ƒêi·ªÅu n√†y quan tr·ªçng v√¨ self.download_urls_list c√≥ th·ªÉ c√≥ current_download_url ·ªü ƒë·∫ßu
            # m√† kh√¥ng c√≥ trong waiting_urls_only.
            indices_in_main_list = [i for i, x in enumerate(self.download_urls_list) if x == item_to_move_value]
            if not indices_in_main_list:
                logging.error(f"Kh√¥ng t√¨m th·∫•y m·ª•c '{item_to_move_value}' trong self.download_urls_list ch√≠nh.")
                return
            
            # ∆Øu ti√™n index l·ªõn h∆°n n·∫øu current_download_url tr√πng v·ªõi item_to_move
            # (Tr∆∞·ªùng h·ª£p n√†y hi·∫øm khi x·∫£y ra n·∫øu logic ƒë√∫ng, nh∆∞ng ƒë·ªÉ ph√≤ng ng·ª´a)
            if self.current_download_url == item_to_move_value and len(indices_in_main_list) > 1:
                 actual_current_index_in_main_list = indices_in_main_list[-1] # L·∫•y index cu·ªëi n·∫øu c√≥ tr√πng
            else:
                 actual_current_index_in_main_list = indices_in_main_list[0]

        except ValueError:
            logging.error(f"L·ªói kh√¥ng t√¨m th·∫•y m·ª•c '{item_to_move_value}' trong self.download_urls_list ch√≠nh.")
            return


        new_actual_index_in_main_list = -1

        if direction == "up" and current_index_in_display > 0:
            # M·ª•c ti√™u l√† m·ª•c ·ªü v·ªã tr√≠ current_index_in_display - 1 trong waiting_urls_only
            target_item_value = waiting_urls_only[current_index_in_display - 1]
            # T√¨m v·ªã tr√≠ c·ªßa target_item_value trong self.download_urls_list
            try:
                target_indices_in_main = [i for i, x in enumerate(self.download_urls_list) if x == target_item_value]
                if not target_indices_in_main: return # Should not happen
                new_actual_index_in_main_list = target_indices_in_main[0]
            except ValueError: return
        elif direction == "down" and current_index_in_display < queue_len - 1:
            # M·ª•c ti√™u l√† m·ª•c ·ªü v·ªã tr√≠ current_index_in_display + 1 trong waiting_urls_only
            target_item_value = waiting_urls_only[current_index_in_display + 1]
            # T√¨m v·ªã tr√≠ c·ªßa target_item_value trong self.download_urls_list
            try:
                target_indices_in_main = [i for i, x in enumerate(self.download_urls_list) if x == target_item_value]
                if not target_indices_in_main: return
                new_actual_index_in_main_list = target_indices_in_main[0]
            except ValueError: return
        else:
            logging.debug(f"Kh√¥ng th·ªÉ di chuy·ªÉn m·ª•c t·∫£i xu·ªëng {current_index_in_display} theo h∆∞·ªõng '{direction}'.")
            return

        if new_actual_index_in_main_list != -1 and actual_current_index_in_main_list != -1 :
            try:
                # Di chuy·ªÉn trong self.download_urls_list
                item_value = self.download_urls_list.pop(actual_current_index_in_main_list)

                final_insert_position = new_actual_index_in_main_list
                if direction == "down" and new_actual_index_in_main_list < actual_current_index_in_main_list :
                     pass
                elif direction == "up" and new_actual_index_in_main_list > actual_current_index_in_main_list:
                    pass


                self.download_urls_list.insert(final_insert_position, item_value)
                
                logging.info(f"ƒê√£ di chuy·ªÉn URL trong h√†ng ch·ªù download t·ª´ v·ªã tr√≠ th·ª±c t·∫ø {actual_current_index_in_main_list} sang {final_insert_position}.")
                
                self.update_download_queue_display()
                self.update_status(f"‚ÑπÔ∏è ƒê√£ c·∫≠p nh·∫≠t th·ª© t·ª± h√†ng ch·ªù download.")
            except IndexError:
                logging.error(f"L·ªói IndexError khi di chuy·ªÉn m·ª•c trong h√†ng ch·ªù download. Actual Current: {actual_current_index_in_main_list}, New Actual Target: {new_actual_index_in_main_list}")
            except Exception as e:
                logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi di chuy·ªÉn m·ª•c trong h√†ng ch·ªù download: {e}", exc_info=True)
                messagebox.showerror("L·ªói S·∫Øp x·∫øp", f"ƒê√£ x·∫£y ra l·ªói khi s·∫Øp x·∫øp l·∫°i h√†ng ch·ªù download:\n{e}", parent=self)


    # H√†m qu·∫£n l√Ω h√†ng ch·ªù Download: X√≥a m·ªôt m·ª•c kh·ªèi h√†ng ch·ªù    
    def remove_item_from_download_queue(self, index_in_display):
        """
        X√≥a m·ªôt m·ª•c kh·ªèi h√†ng ch·ªù t·∫£i xu·ªëng (self.download_urls_list) d·ª±a tr√™n
        ch·ªâ s·ªë hi·ªÉn th·ªã c·ªßa n√≥ trong danh s√°ch c√°c link ƒëang ch·ªù.
        """
        if self.is_downloading and self.current_download_url is not None:
            # Ch·ªâ cho ph√©p x√≥a c√°c m·ª•c ch∆∞a ƒë∆∞·ª£c t·∫£i (ƒëang trong danh s√°ch ch·ªù)
            pass
        elif self.is_downloading:
            messagebox.showwarning("ƒêang b·∫≠n", "Kh√¥ng th·ªÉ x√≥a link kh·ªèi h√†ng ch·ªù khi ƒëang t·∫£i v√† ch∆∞a c√≥ m·ª•c n√†o ƒë∆∞·ª£c ch·ªçn x·ª≠ l√Ω.", parent=self)
            return

        # X√°c ƒë·ªãnh danh s√°ch c√°c URL ƒëang th·ª±c s·ª± "ch·ªù" (kh√¥ng bao g·ªìm URL ƒëang t·∫£i)
        waiting_urls_only = []
        if hasattr(self, 'download_urls_list') and self.download_urls_list:
            if self.current_download_url:
                waiting_urls_only = [url for url in self.download_urls_list if url != self.current_download_url]
            else:
                # N·∫øu kh√¥ng c√≥ current_download_url (ch∆∞a b·∫Øt ƒë·∫ßu t·∫£i ho·∫∑c ƒë√£ xong h·∫øt)
                waiting_urls_only = list(self.download_urls_list)
        
        if not 0 <= index_in_display < len(waiting_urls_only):
            logging.warning(f"Y√™u c·∫ßu x√≥a m·ª•c t·∫£i xu·ªëng ·ªü v·ªã tr√≠ hi·ªÉn th·ªã kh√¥ng h·ª£p l·ªá: {index_in_display}")
            return

        url_to_remove = waiting_urls_only[index_in_display]

        try:
            offset = 0
            if self.current_download_url:
                try:
                    pass # Logic t√¨m index th·ª±c s·ª± s·∫Ω ph·ª©c t·∫°p n·∫øu current_download_url tr√πng v·ªõi link trong waiting_urls_only
                except ValueError:
                    pass # current_download_url kh√¥ng c√≥ trong list (l·∫°)


            # C√°ch ƒë∆°n gi·∫£n v√† an to√†n h∆°n: d·ª±a v√†o gi√° tr·ªã c·ªßa url_to_remove
            if url_to_remove in self.download_urls_list:
                self.download_urls_list.remove(url_to_remove) # X√≥a l·∫ßn xu·∫•t hi·ªán ƒë·∫ßu ti√™n c·ªßa gi√° tr·ªã n√†y
                
                # C≈©ng x√≥a kh·ªèi b·ªô ƒë·∫øm l·ªói v√† danh s√°ch ho√†n th√†nh (n·∫øu c√≥ v√† n·∫øu c·∫ßn)
                self.download_retry_counts.pop(url_to_remove, None)
                # self.globally_completed_urls.discard(url_to_remove) # Th∆∞·ªùng th√¨ link l·ªói kh√¥ng n·∫±m trong ƒë√¢y
                                                                    # nh∆∞ng n·∫øu ng∆∞·ªùi d√πng mu·ªën x√≥a link ƒë√£ ho√†n th√†nh kh·ªèi danh s√°ch (n·∫øu hi·ªÉn th·ªã)

                logging.info(f"ƒê√£ x√≥a URL '{url_to_remove[:60]}...' kh·ªèi h√†ng ch·ªù download.")
                
                self.update_download_queue_display() # C·∫≠p nh·∫≠t giao di·ªán
                self.update_status(f"‚ÑπÔ∏è ƒê√£ x√≥a 1 link kh·ªèi h√†ng ch·ªù download.")
            else:
                logging.warning(f"Kh√¥ng t√¨m th·∫•y URL '{url_to_remove[:60]}...' trong self.download_urls_list ƒë·ªÉ x√≥a.")

        except ValueError: # X·∫£y ra n·∫øu url_to_remove kh√¥ng c√≥ trong self.download_urls_list (d√π ƒë√£ ki·ªÉm tra)
            logging.error(f"L·ªói ValueError khi c·ªë x√≥a '{url_to_remove[:60]}...' (kh√¥ng t√¨m th·∫•y).", exc_info=True)
        except Exception as e:
            logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi x√≥a m·ª•c kh·ªèi h√†ng ch·ªù download: {e}", exc_info=True)
            messagebox.showerror("L·ªói X√≥a Link", f"ƒê√£ x·∫£y ra l·ªói khi x√≥a link:\n{e}", parent=self)


# H√†m h√†nh ƒë·ªông: T·∫£i m·ªôt file ph·ª• ƒë·ªÅ ƒë√£ c√≥ v√†o tr√¨nh ch·ªânh s·ª≠a
    def load_old_sub_file(self):
        """ 
        T·∫£i m·ªôt file ph·ª• ƒë·ªÅ.
        N·∫æU checkbox "T·ª± ƒë·ªông ƒë·ªãnh d·∫°ng" ƒë∆∞·ª£c b·∫≠t, s·∫Ω t√°i t·∫°o timing v·ªõi ng·∫Øt ngh·ªâ ƒë·ªông.
        NG∆Ø·ª¢C L·∫†I, s·∫Ω hi·ªÉn th·ªã n·ªôi dung g·ªëc c·ªßa file.
        """
        if self.is_subbing and not self.is_actively_paused_for_edit: 
             messagebox.showwarning("ƒêang b·∫≠n", "Vui l√≤ng ƒë·ª£i x·ª≠ l√Ω ph·ª• ƒë·ªÅ hi·ªán t·∫°i ho√†n t·∫•t.")
             return
        path = filedialog.askopenfilename(
             title="Ch·ªçn file Ph·ª• ƒë·ªÅ ƒë·ªÉ xem/ch·ªânh s·ª≠a",
             filetypes=[
                ("T·∫•t c·∫£ file h·ªó tr·ª£", "*.srt *.vtt *.ass *.txt"),
                ("File ph·ª• ƒë·ªÅ (Subrip)", "*.srt"),
                ("File vƒÉn b·∫£n (Text)", "*.txt"),
                ("File ph·ª• ƒë·ªÅ (WebVTT)", "*.vtt"),
                ("File ph·ª• ƒë·ªÅ (Advanced)", "*.ass"),
                ("T·∫•t c·∫£ file", "*.*")
            ]
        )
        if path:
            try:
                with open(path, "r", encoding="utf-8-sig") as f: 
                    content = f.read()

                self.last_loaded_script_path = path
                self.current_srt_path = path # Lu√¥n c·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n file ƒë√£ m·ªü
                self.allow_edit_sub = True   # Lu√¥n cho ph√©p s·ª≠a sau khi t·∫£i file

                # === B·∫ÆT ƒê·∫¶U LOGIC M·ªöI KI·ªÇM TRA CHECKBOX ===
                if self.auto_format_plain_text_to_srt_var.get():
                    logging.info(f"ƒêang t·ª± ƒë·ªông ƒë·ªãnh d·∫°ng v√† t√°i t·∫°o timing cho file: {os.path.basename(path)}")
                    self.update_status(f"‚è≥ ƒêang ƒë·ªãnh d·∫°ng l·∫°i timing cho {os.path.basename(path)}...")
                    
                    # 1. Tr√≠ch xu·∫•t text thu·∫ßn, b·ªè qua timing c≈©
                    plain_text = extract_dialogue_from_srt_string(content)
                    
                    # 2. L·∫•y c·∫•u h√¨nh t·ª´ UI
                    split_cfg = {
                        "split_enabled": self.enable_split_var.get(),
                        "mode": self.split_mode_var.get(),
                        "max_chars": safe_int(self.max_chars_var.get(), 90),
                        "max_lines": safe_int(self.max_lines_var.get(), 1),
                        "DEFAULT_CPS_FOR_TIMING": safe_int(self.sub_cps_for_timing_var.get(), 17),
                        "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1, # S·∫Ω b·ªã logic ng·∫Øt ngh·ªâ ƒë·ªông ghi ƒë√®
                        "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
                    }
                    
                    # 3. T·∫°o l·∫°i d·ªØ li·ªáu SRT v·ªõi timing m·ªõi
                    retimed_data = self._parse_plain_text_to_srt_data(plain_text, True, split_cfg)
                    
                    if retimed_data:
                        final_content = format_srt_data_to_string(retimed_data)
                        self.current_srt_path = None # Reset v√¨ n·ªôi dung ƒë√£ kh√°c file g·ªëc
                        self.update_status("‚úÖ ƒê√£ t√°i t·∫°o timing th√†nh c√¥ng!")
                    else:
                        final_content = content # Fallback v·ªÅ n·ªôi dung g·ªëc n·∫øu l·ªói
                        self.update_status("‚ö†Ô∏è L·ªói t√°i t·∫°o timing, hi·ªÉn th·ªã file g·ªëc.")
                    
                    self.show_sub_in_textbox(final_content)

                else: # N·∫øu checkbox kh√¥ng ƒë∆∞·ª£c t√≠ch, ch·ªâ hi·ªÉn th·ªã n·ªôi dung g·ªëc
                    logging.info(f"Hi·ªÉn th·ªã n·ªôi dung g·ªëc c·ªßa file: {os.path.basename(path)}")
                    self.show_sub_in_textbox(content) 
                # === K·∫æT TH√öC LOGIC M·ªöI ===

                subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
                if subtitle_textbox and subtitle_textbox.winfo_exists():
                    subtitle_textbox.configure(state="normal")
                self.update_status(f"ƒê√£ m·ªü file: {os.path.basename(path)}")

            except Exception as e:
                logging.error(f"L·ªói khi t·∫£i file ph·ª• ƒë·ªÅ c≈© '{path}': {e}", exc_info=True)
                messagebox.showerror("L·ªói ƒê·ªçc", f"Kh√¥ng th·ªÉ ƒë·ªçc file:\n{path}\n\nL·ªói: {e}")
                self.current_srt_path = None
                self.last_loaded_script_path = None
                self.show_sub_in_textbox("")


    # H√†m h√†nh ƒë·ªông: Cho ph√©p ch·ªânh s·ª≠a √¥ textbox ph·ª• ƒë·ªÅ
    def enable_sub_editing(self):
        """ Cho ph√©p ch·ªânh s·ª≠a √¥ textbox ph·ª• ƒë·ªÅ """
        self.allow_edit_sub = True
        subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
        if subtitle_textbox and subtitle_textbox.winfo_exists():
            subtitle_textbox.configure(state="normal")
            logging.info("ƒê√£ b·∫≠t ch·∫ø ƒë·ªô ch·ªânh s·ª≠a ph·ª• ƒë·ªÅ.")


    # H√†m h√†nh ƒë·ªông: L∆∞u n·ªôi dung c·ªßa √¥ textbox ph·ª• ƒë·ªÅ
    def save_edited_sub(self):
        """ L∆∞u n·ªôi dung c·ªßa √¥ textbox ph·ª• ƒë·ªÅ """
        save_path = self.current_srt_path
        if not save_path: # N·∫øu ch∆∞a c√≥ file n√†o ƒë∆∞·ª£c t·∫£i/t·∫°o, h·ªèi n∆°i l∆∞u
            save_path = filedialog.asksaveasfilename(
                 title="L∆∞u File Ph·ª• ƒë·ªÅ",
                 defaultextension=".srt",
                 filetypes=[("SubRip", ".srt"), ("WebVTT", ".vtt"), ("ASS", ".ass"), ("VƒÉn b·∫£n", ".txt")],
                 initialdir=self.output_path_var.get() or os.getcwd()
            )
            if not save_path:
                logging.info("Ng∆∞·ªùi d√πng ƒë√£ h·ªßy thao t√°c l∆∞u.")
                return # Ng∆∞·ªùi d√πng h·ªßy
            self.current_srt_path = save_path
            # C·∫≠p nh·∫≠t bi·∫øn ƒë·ªãnh d·∫°ng d·ª±a tr√™n ƒëu√¥i file ƒë√£ ch·ªçn (t√πy ch·ªçn nh∆∞ng t·ªët)
            _, ext = os.path.splitext(save_path)
            new_fmt = ext.lstrip('.').lower()
            if new_fmt in ["srt", "vtt", "ass", "txt"]: self.format_var.set(new_fmt)
            else: # M·∫∑c ƒë·ªãnh v·ªÅ srt n·∫øu ƒëu√¥i file kh√¥ng x√°c ƒë·ªãnh
                 self.format_var.set("srt")
                 self.current_srt_path = os.path.splitext(save_path)[0] + ".srt"

        try:
            # 1. B·∫≠t state='normal' ƒë·ªÉ l·∫•y n·ªôi dung
            subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
            if subtitle_textbox and subtitle_textbox.winfo_exists():
                subtitle_textbox.configure(state="normal")
                new_text = subtitle_textbox.get("0.0", "end-1c") # L·∫•y t·∫•t c·∫£ text tr·ª´ d√≤ng m·ªõi cu·ªëi c√πng
            else:
                logging.error("Textbox ph·ª• ƒë·ªÅ kh√¥ng kh·∫£ d·ª•ng ƒë·ªÉ l·∫•y n·ªôi dung.")
                messagebox.showerror("L·ªói UI", "Kh√¥ng th·ªÉ truy c·∫≠p √¥ n·ªôi dung ph·ª• ƒë·ªÅ.")
                return

            # 2. Ki·ªÉm tra n·ªôi dung r·ªóng
            if not new_text.strip():
                 messagebox.showwarning("N·ªôi dung r·ªóng", "Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ l∆∞u.")
                 # N·∫øu kh√¥ng c√≥ n·ªôi dung v√† kh√¥ng cho ph√©p s·ª≠a, th√¨ disable l·∫°i
                 if not self.allow_edit_sub and subtitle_textbox:
                      subtitle_textbox.configure(state="disabled")
                 return

            # 3. L∆∞u file
            with open(self.current_srt_path, "w", encoding="utf-8") as f: f.write(new_text)
            self.update_status(f"üíæ ƒê√£ l∆∞u: {os.path.basename(self.current_srt_path)}")
            logging.info(f"L∆∞u th√†nh c√¥ng: {self.current_srt_path}")

            # 4. Lu√¥n t·∫Øt ch·∫ø ƒë·ªô ch·ªânh s·ª≠a sau khi l∆∞u th√†nh c√¥ng
            self.allow_edit_sub = False
            if subtitle_textbox and subtitle_textbox.winfo_exists():
                subtitle_textbox.configure(state="disabled")

            # N·∫øu n·ªôi dung ƒë√£ l∆∞u l√† r·ªóng (sau khi strip), hi·ªÉn th·ªã l·∫°i placeholder
            if not new_text.strip():
                self.show_sub_in_textbox("") # G·ªçi h√†m ƒë√£ s·ª≠a, n√≥ s·∫Ω t·ª± ch√®n placeholder

        except Exception as e:
            logging.error(f"L·ªói khi l∆∞u file ph·ª• ƒë·ªÅ '{self.current_srt_path}': {e}", exc_info=True)
            messagebox.showerror("L·ªói L∆∞u File", f"Kh√¥ng th·ªÉ l∆∞u file:\n{self.current_srt_path}\n\nL·ªói: {e}")
            # C·ªë g·∫Øng disable l·∫°i textbox n·∫øu c√≥ l·ªói x·∫£y ra v√† kh√¥ng cho ph√©p s·ª≠a
            try:
                subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
                if subtitle_textbox and subtitle_textbox.winfo_exists() and not self.allow_edit_sub:
                    subtitle_textbox.configure(state="disabled")
            except Exception: pass # B·ªè qua l·ªói ph·ª•


    # H√†m h√†nh ƒë·ªông: M·ªü m·ªôt file ph·ª• ƒë·ªÅ b·∫±ng ·ª©ng d·ª•ng m·∫∑c ƒë·ªãnh c·ªßa h·ªá ƒëi·ªÅu h√†nh
    def open_sub_file_externally(self):
        """ M·ªü m·ªôt file ph·ª• ƒë·ªÅ ƒë√£ ch·ªçn b·∫±ng ·ª©ng d·ª•ng m·∫∑c ƒë·ªãnh c·ªßa HƒêH """
        initial_dir = os.path.dirname(self.current_srt_path) if self.current_srt_path else (self.output_path_var.get() or os.getcwd())
        initial_file = os.path.basename(self.current_srt_path) if self.current_srt_path else ""
        sub_path = filedialog.askopenfilename(
            title="Ch·ªçn File Ph·ª• ƒë·ªÅ ƒë·ªÉ M·ªü", initialdir=initial_dir, initialfile=initial_file,
            filetypes=[("T·∫•t c·∫£ file", "*.*"), ("File Ph·ª• ƒë·ªÅ", "*.srt;*.vtt;*.ass"), ("File VƒÉn b·∫£n", "*.txt")]
        )
        if sub_path: open_file_with_default_app(sub_path) # G·ªçi h√†m h·ªó tr·ª£ to√†n c·ª•c


# --------------------
# 4.5 Logic C·ªët l√µi - B·∫Øt ƒë·∫ßu & D·ª´ng X·ª≠ l√Ω
# --------------------

# H√†m h√†nh ƒë·ªông: B·∫Øt ƒë·∫ßu x·ª≠ l√Ω to√†n b·ªô h√†ng ch·ªù t·∫°o ph·ª• ƒë·ªÅ
    def auto_sub_all(self):
        """ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω h√†ng ch·ªù ph·ª• ƒë·ªÅ """
        if self.is_subbing:
            messagebox.showwarning("ƒêang b·∫≠n", "ƒêang x·ª≠ l√Ω ph·ª• ƒë·ªÅ.")
            return
        if not self.file_queue:
            messagebox.showinfo("H√†ng ch·ªù tr·ªëng", "Vui l√≤ng th√™m file v√†o h√†ng ch·ªù ph·ª• ƒë·ªÅ tr∆∞·ªõc.")
            return
        if self.whisper_model is None and not self.is_loading_model:
             messagebox.showwarning("Model ch∆∞a s·∫µn s√†ng", "M√¥ h√¨nh Whisper ch∆∞a ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ƒë·ª£i ho·∫∑c ch·ªçn m·ªôt m√¥ h√¨nh.")
             self.load_whisper_model_if_needed() # Th·ª≠ t·∫£i
             return
        if self.is_loading_model:
             messagebox.showwarning("ƒêang t·∫£i Model", "M√¥ h√¨nh Whisper ƒëang ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ƒë·ª£i.")
             return

        out_dir = self.output_path_var.get()
        merge_mode = self.merge_sub_var.get().lower()
        if merge_mode != "kh√¥ng g·ªôp" or (out_dir and not os.path.isdir(out_dir)): # S·ª≠a ƒëi·ªÅu ki·ªán ki·ªÉm tra out_dir
             if not out_dir or not os.path.isdir(out_dir):
                  messagebox.showerror("L·ªói ƒê∆∞·ªùng d·∫´n Output", f"Vui l√≤ng ch·ªçn th∆∞ m·ª•c output h·ª£p l·ªá.\nC·∫ßn thi·∫øt cho vi·ªác g·ªôp ho·∫∑c n·∫øu ƒë∆∞·ªùng d·∫´n ƒë∆∞·ª£c ƒë·∫∑t.\nHi·ªán t·∫°i: '{out_dir}'")
                  return

        # --- TH√äM LOGIC KI·ªÇM TRA V√Ä ƒê·∫∂T Y√äU C·∫¶U T·∫ÆT M√ÅY CHO SUB ƒê∆†N L·∫∫ ---
        # Gi·∫£ s·ª≠ self.download_shutdown_var l√† checkbox chung cho vi·ªác t·∫Øt m√°y
        if hasattr(self, 'download_shutdown_var') and hasattr(self, 'shutdown_requested_by_task'):
            if self.download_shutdown_var.get():
                self.shutdown_requested_by_task = True
                logging.info(f"[AutoSubAll] T√°c v·ª• Sub-Only: 'H·∫πn gi·ªù t·∫Øt m√°y' ƒë∆∞·ª£c B·∫¨T. Ghi nh·∫≠n y√™u c·∫ßu.")
            else:
                self.shutdown_requested_by_task = False
                logging.info(f"[AutoSubAll] T√°c v·ª• Sub-Only: 'H·∫πn gi·ªù t·∫Øt m√°y' ƒë∆∞·ª£c T·∫ÆT.")
        else:
            logging.warning("[AutoSubAll] Kh√¥ng t√¨m th·∫•y 'download_shutdown_var' ho·∫∑c 'shutdown_requested_by_task'. Kh√¥ng th·ªÉ ƒë·∫∑t y√™u c·∫ßu t·∫Øt m√°y cho t√°c v·ª• Sub-Only.")
        # --- K·∫æT TH√öC TH√äM LOGIC ---

        self._set_subtitle_tab_ui_state(True)
        # Truy c·∫≠p sub_button qua SubtitleTab
        sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
        if sub_button and sub_button.winfo_exists():
            # X√°c ƒë·ªãnh text cho n√∫t sub d·ª±a tr√™n manual_mode
            sub_button_text_current_mode = "üî® ƒêang gh√©p th·ªß c√¥ng..." if self.manual_merge_mode_var.get() else "‚è≥ ƒêang Sub..."
            sub_button.configure(text=sub_button_text_current_mode)
                
        logging.info("ƒêang l∆∞u c·∫•u h√¨nh hi·ªán t·∫°i tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu t√°c v·ª• ph·ª• ƒë·ªÅ (auto_sub_all)...") # Log r√µ h∆°n
        self.save_current_config() # L∆∞u c·∫£ tr·∫°ng th√°i shutdown_requested_by_task (n·∫øu c√≥) v√† c√°c c√†i ƒë·∫∑t kh√°c
        self.stop_event.clear()
        logging.info("--- B·∫Øt ƒë·∫ßu X·ª≠ l√Ω H√†ng ch·ªù Ph·ª• ƒë·ªÅ (t·ª´ auto_sub_all) ---")
        self.is_subbing = True
        self.start_time = time.time()
        self._process_next_subtitle_file()


# H√†m logic: D·ª´ng qu√° tr√¨nh x·ª≠ l√Ω hi·ªán t·∫°i D-S-D-AI
    def stop_processing(self):
        """
        Y√™u c·∫ßu d·ª´ng t·∫•t c·∫£ c√°c t√°c v·ª• n·ªÅn ƒëang ch·∫°y.
        Phi√™n b·∫£n n√†y ki·ªÉm tra t·∫•t c·∫£ c√°c c·ªù x·ª≠ l√Ω ƒë·ªÉ h√†nh ƒë·ªông ch√≠nh x√°c.
        """
        log_prefix = f"[{threading.current_thread().name}_StopProcessing_v13_Final]"
        logging.info(f"{log_prefix} Y√™u c·∫ßu d·ª´ng x·ª≠ l√Ω ƒë∆∞·ª£c g·ªçi.")

        # 1. G·ª≠i t√≠n hi·ªáu d·ª´ng cho t·∫•t c·∫£ c√°c lu·ªìng
        self.stop_event.set()
        self.dub_stop_event.set()
        logging.warning(f"{log_prefix} >>> ƒê√É G·ª¨I T√çN HI·ªÜU D·ª™NG (stop_event/dub_stop_event) <<<")

        # 2. C·∫≠p nh·∫≠t giao di·ªán ngay l·∫≠p t·ª©c ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt l·ªánh ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n
        self.update_status("üõë ƒêang y√™u c·∫ßu d·ª´ng t√°c v·ª•...")
        if hasattr(self, 'stop_button'): self.stop_button.configure(state="disabled")
        if hasattr(self, 'dub_stop_button'): self.dub_stop_button.configure(state="disabled")

        # G·ªôp t·∫•t c·∫£ c√°c c·ªù x·ª≠ l√Ω v√†o m·ªôt l·∫ßn ki·ªÉm tra duy nh·∫•t.
        is_any_task_running = (
            self.is_ai_batch_processing or
            self.dub_is_processing or
            self.is_manual_sub_processing or
            self.is_subbing or
            self.is_downloading or
            # Th√™m t·∫•t c·∫£ c√°c c·ªù c·ªßa t√°c v·ª• AI ƒë∆°n l·∫ª v√†o ƒë√¢y
            self.is_gemini_processing or
            self.is_gpt_processing_script or
            self.is_imagen_processing or
            self.is_dalle_processing or
            self.is_creating_slideshow
        )

        if is_any_task_running:
            # N·∫øu c√≥ b·∫•t k·ª≥ t√°c v·ª• n√†o ƒëang ch·∫°y, ch·ªâ g·ª≠i t√≠n hi·ªáu v√† d·ª´ng ti·∫øn tr√¨nh con.
            # KH√îNG g·ªçi c√°c h√†m d·ªçn d·∫πp tr·ª±c ti·∫øp t·ª´ ƒë√¢y.
            # Lu·ªìng worker s·∫Ω t·ª± ph√°t hi·ªán stop_event v√† g·ªçi h√†m d·ªçn d·∫πp c·ªßa ri√™ng n√≥.
            logging.info(f"{log_prefix} ƒê√£ ph√°t hi·ªán t√°c v·ª• ƒëang ch·∫°y. T√≠n hi·ªáu d·ª´ng ƒë√£ ƒë∆∞·ª£c g·ª≠i. Ch·ªù lu·ªìng worker t·ª± d·ªçn d·∫πp.")
        else:
            # N·∫øu kh√¥ng c√≥ c·ªù n√†o b·∫≠t, ƒë√¢y l√† tr∆∞·ªùng h·ª£p ng∆∞·ªùi d√πng nh·∫•n Stop khi kh√¥ng c√≥ g√¨ ch·∫°y.
            # Reset l·∫°i UI m·ªôt c√°ch an to√†n.
            logging.info(f"{log_prefix} Kh√¥ng c√≥ t√°c v·ª• ch√≠nh n√†o ƒë∆∞·ª£c ghi nh·∫≠n l√† ƒëang ch·∫°y. Reset UI t·ªïng th·ªÉ.")
            self.stop_event.clear() # X√≥a c·ªù d·ª´ng v√¨ kh√¥ng c√≥ g√¨ ƒë·ªÉ d·ª´ng
            self.dub_stop_event.clear()
            
            self._set_subtitle_tab_ui_state(False)
            self.download_view_frame.set_download_ui_state(downloading=False)
            
            # Ch·ªâ reset tab dubbing n·∫øu app ƒë√£ active
            try:
                is_app_active = self._is_app_fully_activated()
            except Exception:
                is_app_active = False

            # H√†m t·ª± ki·ªÉm tra k√≠ch ho·∫°t r·ªìi, kh√¥ng c·∫ßn truy·ªÅn activated
            self._set_dubbing_tab_ui_state()

            # Reset ƒë·ªìng h·ªì n·∫øu n√≥ ƒëang ch·∫°y
            if self.start_time is not None:
                self.start_time = None
                self.update_status("‚úÖ S·∫µn s√†ng!")
            
            # B·∫≠t l·∫°i n√∫t Stop v√¨ kh√¥ng c√≥ g√¨ ch·∫°y c·∫£
            if hasattr(self, 'stop_button'): self.stop_button.configure(state="normal")
            if hasattr(self, 'dub_stop_button'): self.dub_stop_button.configure(state="normal")

        # 4. C·ªë g·∫Øng d·ª´ng c√°c ti·∫øn tr√¨nh con (ffmpeg, yt-dlp) n·∫øu c√≥ (logic n√†y gi·ªØ nguy√™n)
        proc_to_kill = self.current_process or self.dub_current_ffmpeg_process
        if proc_to_kill and proc_to_kill.poll() is None:
            logging.info(f"{log_prefix} ƒêang c·ªë g·∫Øng d·ª´ng ti·∫øn tr√¨nh con (PID: {proc_to_kill.pid})...")
            try:
                proc_to_kill.terminate()
                proc_to_kill.wait(timeout=1.0)
            except Exception:
                if proc_to_kill.poll() is None: proc_to_kill.kill()
            finally:
                self.current_process = None
                self.dub_current_ffmpeg_process = None


# H√†m logic n·ªôi b·ªô: X·ª≠ l√Ω file ti·∫øp theo trong h√†ng ch·ªù t·∫°o ph·ª• ƒë·ªÅ
    def _process_next_subtitle_file(self):
        """
        Ph∆∞∆°ng th·ª©c n·ªôi b·ªô ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo trong h√†ng ch·ªù ph·ª• ƒë·ªÅ.
        ƒê√£ c·∫≠p nh·∫≠t ƒë·ªÉ x·ª≠ l√Ω chuy·ªÉn sang dub v√† th√¥ng b√°o ho√†n th√†nh.
        ƒê√£ tinh ch·ªânh logic d·ª´ng, reset start_time v√† c·∫≠p nh·∫≠t status.
        """
        current_thread_name_pnf = threading.current_thread().name
        # S·ª≠ d·ª•ng lambda ƒë·ªÉ ƒë·∫£m b·∫£o log_pnf lu√¥n l·∫•y self.current_file m·ªõi nh·∫•t
        log_pnf = lambda level, msg, exc_info=False: logging.log(level, f"[{current_thread_name_pnf}_PrcNextSubFile_V3_TranslateErrorHandle]({os.path.basename(self.current_file) if self.current_file else 'NoFile'}) {msg}", exc_info=exc_info)

        if self.stop_event.is_set():
            log_pnf(logging.INFO, ">>> _process_next_subtitle_file: Ph√°t hi·ªán stop_event <<<")

            file_that_was_processing = self.current_file # L∆∞u l·∫°i file ƒëang x·ª≠ l√Ω ƒë·ªÉ log (n·∫øu c·∫ßn)

            self.is_actively_paused_for_edit = False
            
            if self.is_subbing:
                 log_pnf(logging.INFO, "   _process_next_subtitle_file (stop_event): ƒê·∫∑t self.is_subbing = False (n·∫øu ch∆∞a False).")
            self.is_subbing = False

            self.current_file = None # X√≥a file ƒëang x·ª≠ l√Ω hi·ªán t·∫°i

            # --- THAY ƒê·ªîI QUAN TR·ªåNG: KH√îNG TH√äM L·∫†I FILE V·ª™A D·ª™NG V√ÄO H√ÄNG CH·ªú ---
            if file_that_was_processing:
                log_pnf(logging.INFO, f"   _process_next_subtitle_file: T√°c v·ª• cho file '{os.path.basename(file_that_was_processing)}' ƒë√£ b·ªã d·ª´ng v√† s·∫Ω KH√îNG ƒë∆∞·ª£c t·ª± ƒë·ªông th√™m l·∫°i v√†o h√†ng ch·ªù.")

            self.update_queue_display() # C·∫≠p nh·∫≠t giao di·ªán h√†ng ch·ªù (s·∫Ω kh√¥ng c√≤n file current)
            
            # C·∫≠p nh·∫≠t th√¥ng b√°o tr·∫°ng th√°i cho r√µ r√†ng h∆°n
            self.update_status("üõë T√°c v·ª• Sub ƒë√£ d·ª´ng. File ƒëang x·ª≠ l√Ω s·∫Ω kh√¥ng t·ª± ƒë·ªông ch·∫°y l·∫°i.")
            
            if hasattr(self, 'reset_ui_after_pause_or_stop'):
                 self.reset_ui_after_pause_or_stop()
                 log_pnf(logging.DEBUG, "   _process_next_subtitle_file (stop_event): ƒê√£ g·ªçi reset_ui_after_pause_or_stop.")
            else:
                 log_pnf(logging.ERROR, "   _process_next_subtitle_file (stop_event): Kh√¥ng t√¨m th·∫•y h√†m reset_ui_after_pause_or_stop.")

            # Reset c√°c c·ªù li√™n quan ƒë·∫øn chu·ªói Sub & Dub (gi·ªØ nguy√™n logic n√†y)
            self.pending_auto_dub_after_current_sub_batch = False
            self.chain_download_sub_dub_active = False
            self.files_for_chained_dubbing = []
            log_pnf(logging.DEBUG, "   _process_next_subtitle_file (stop_event): ƒê√£ reset c√°c c·ªù chain dubbing.")

            # Logic reset start_time (gi·ªØ nguy√™n logic n√†y)
            any_other_timer_task_active = (
                self.is_downloading or self.is_loading_model_for_timer or
                self.dub_is_processing or self.is_creating_slideshow or
                self.is_gpt_processing_script or self.is_dalle_processing
            )
            if not any_other_timer_task_active:
                if self.start_time is not None:
                    self.start_time = None
                    log_pnf(logging.INFO, "   _process_next_subtitle_file (stop_event): Kh√¥ng c√≤n t√°c v·ª• n√†o kh√°c d√πng timer, ƒë√£ reset self.start_time = None.")

            else:
                active_flags_log_pn_stop = [ # [cite: 11]
                    flag_name for flag_name, flag_val in [
                        ("is_downloading", self.is_downloading),
                        ("is_loading_model_for_timer", self.is_loading_model_for_timer),
                        ("dub_is_processing", self.dub_is_processing),
                        ("is_creating_slideshow", self.is_creating_slideshow),
                        ("is_gpt_processing_script", self.is_gpt_processing_script),
                        ("is_dalle_processing", self.is_dalle_processing)
                    ] if flag_val
                ]
                log_pnf(logging.INFO, f"   _process_next_subtitle_file (stop_event): T√°c v·ª• Sub d·ª´ng, nh∆∞ng c√≤n t√°c v·ª• kh√°c d√πng timer ƒëang ch·∫°y: {active_flags_log_pn_stop}. self.start_time KH√îNG ƒë∆∞·ª£c reset ·ªü ƒë√¢y.") # [cite: 11]

            self.after(100, self._check_completion_and_shutdown) # [cite: 12]
            return

        if not self.file_queue: # H√†ng ch·ªù ph·ª• ƒë·ªÅ tr·ªëng
            self.current_file = None
            log_pnf(logging.INFO, f"‚úÖ H√†ng ch·ªù file_queue tr·ªëng. Ki·ªÉm tra pending_auto_dub ({self.pending_auto_dub_after_current_sub_batch}) v√† files_for_chained_dubbing ({len(self.files_for_chained_dubbing)} m·ª•c).")
            self.is_actively_paused_for_edit = False

            should_trigger_dubbing_now = False
            can_attempt_dub_trigger = False # C·ªù m·ªõi ƒë·ªÉ ki·ªÉm so√°t vi·ªác k√≠ch ho·∫°t thuy·∫øt minh

            # === B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI LOGIC KH√ìA ===
            if self.pending_auto_dub_after_current_sub_batch and self.files_for_chained_dubbing:
                if not self._dub_trigger_initiated_for_current_batch: # Ki·ªÉm tra c·ªù kh√≥a
                    self._dub_trigger_initiated_for_current_batch = True # ƒê·∫∑t c·ªù kh√≥a NGAY L·∫¨P T·ª®C
                    can_attempt_dub_trigger = True
                    log_pnf(logging.INFO, "   >>> Kh√≥a k√≠ch ho·∫°t thuy·∫øt minh (_dub_trigger_initiated_for_current_batch) ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t cho l√¥ n√†y.")
                else:
                    log_pnf(logging.WARNING, "   >>> K√≠ch ho·∫°t thuy·∫øt minh ƒë√£ ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu cho l√¥ n√†y (c·ªù kh√≥a ƒëang True), b·ªè qua g·ªçi l·∫°i t·ª´ instance _process_next_subtitle_file n√†y.")
            
            if can_attempt_dub_trigger: # Ch·ªâ th·ª±c hi·ªán n·∫øu kh√≥a ƒë∆∞·ª£c l·∫•y th√†nh c√¥ng ·ªü l·∫ßn g·ªçi n√†y
                log_pnf(logging.INFO, f"   >>> L√¥ ph·ª• ƒë·ªÅ ho√†n t·∫•t, c√≥ {len(self.files_for_chained_dubbing)} file s·∫µn s√†ng ƒë·ªÉ thuy·∫øt minh.")
                should_trigger_dubbing_now = True
            # === K·∫æT TH√öC THAY ƒê·ªîI LOGIC KH√ìA ===
            
            self.is_subbing = False 
            log_pnf(logging.INFO, "   H√†ng ch·ªù tr·ªëng, ƒë·∫∑t self.is_subbing = False.")

            self.current_file = None 
            self.update_queue_display() 
            if hasattr(self, 'reset_ui_after_pause_or_stop'): 
                 self.reset_ui_after_pause_or_stop()
            
            # Bi·∫øn ƒë·ªÉ l∆∞u th√¥ng b√°o cu·ªëi c√πng, ∆∞u ti√™n th√¥ng b√°o l·ªói d·ªãch n·∫øu c√≥
            final_batch_completion_message = ""
            show_final_messagebox = True # M·∫∑c ƒë·ªãnh l√† hi·ªán messagebox ho√†n th√†nh chung

            if self.translate_batch_first_api_error_msg_shown and self.translate_batch_accumulated_api_error_details:
                # N·∫øu c√≥ l·ªói API d·ªãch ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n trong batch n√†y
                error_detail_snippet = str(self.translate_batch_accumulated_api_error_details).split('\n')[0][:100] + "..."
                final_batch_completion_message = (
                    "Ho√†n th√†nh x·ª≠ l√Ω ph·ª• ƒë·ªÅ v·ªõi m·ªôt s·ªë l·ªói d·ªãch thu·∫≠t.\n"
                    f"L·ªói API d·ªãch ƒë·∫ßu ti√™n g·∫∑p ph·∫£i: {error_detail_snippet}\n"
                    "Vui l√≤ng ki·ªÉm tra log v√† c√°c file ph·ª• ƒë·ªÅ ƒë√£ t·∫°o."
                )
                # Khi c√≥ l·ªói d·ªãch, ch√∫ng ta c√≥ th·ªÉ hi·ªán warning thay v√¨ info
                self.after(10, lambda title="Ho√†n th√†nh Sub (C√≥ l·ªói d·ªãch)", msg=final_batch_completion_message:
                           messagebox.showwarning(title, msg, parent=self))
                self.update_status(f"‚ö†Ô∏è Ho√†n th√†nh Sub (l·ªói d·ªãch).")
                show_final_messagebox = False # ƒê√£ hi·ªán messagebox l·ªói d·ªãch, kh√¥ng c·∫ßn hi·ªán messagebox ho√†n th√†nh chung n·ªØa
            # === K·∫æT TH√öC TH√äM/S·ª¨A ƒê·ªîI LOGIC TH√îNG B√ÅO L·ªñI D·ªäCH ===                 

            if should_trigger_dubbing_now: # ƒêi·ªÅu n√†y c√≥ nghƒ©a l√† can_attempt_dub_trigger l√† True
                self.update_status(f"‚úÖ Sub xong! Chu·∫©n b·ªã {len(self.files_for_chained_dubbing)} file cho thuy·∫øt minh...") 
                list_for_dub_call = list(self.files_for_chained_dubbing) 
                
                # === THAY ƒê·ªîI: G·ªåI H√ÄM WRAPPER M·ªöI ===
                self.after(200, self._initiate_chained_dubbing_with_lock_reset, 
                           list_for_dub_call, 
                           self.chain_download_sub_dub_active)
                
                # D·ªçn d·∫πp c√°c danh s√°ch/c·ªù li√™n quan ƒë·∫øn l√¥ ph·ª• ƒë·ªÅ V·ª™A HO√ÄN TH√ÄNH
                self.files_for_chained_dubbing = [] 
                self.pending_auto_dub_after_current_sub_batch = False
                # self.chain_download_sub_dub_active s·∫Ω ƒë∆∞·ª£c qu·∫£n l√Ω b·ªüi logic c·ªßa lu·ªìng thuy·∫øt minh
            elif not can_attempt_dub_trigger and self.pending_auto_dub_after_current_sub_batch:
                log_pnf(logging.INFO, "   Kh√¥ng k√≠ch ho·∫°t thuy·∫øt minh l·∫ßn n·ªØa v√¨ c·ªù kh√≥a ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t b·ªüi l·∫ßn g·ªçi tr∆∞·ªõc.")

            # B·∫ÆT ƒê·∫¶U KH·ªêI CODE M·ªöI C·∫¶N TH√äM 
            elif self.auto_upload_to_youtube_var.get() and self.youtube_upload_queue:
                # N·∫øu kh√¥ng dub, nh∆∞ng c√≥ b·∫≠t auto-upload v√† h√†ng ch·ªù upload c√≥ m·ª•c
                logging.info(f"Ho√†n t·∫•t l√¥ Sub. Chu·∫©n b·ªã b·∫Øt ƒë·∫ßu Upload cho {len(self.youtube_upload_queue)} video.")
                self.update_status(f"‚úÖ Sub xong! Chu·∫©n b·ªã upload {len(self.youtube_upload_queue)} video...")

                self.is_subbing = False # B√°o hi·ªáu ph·∫ßn vi·ªác c·ªßa Sub/Audio ƒë√£ xong
                self.is_chain_handoff = True # B√°o hi·ªáu ƒëang trong qu√° tr√¨nh b√†n giao
                logging.info("[Handoff] ƒê√£ ƒë·∫∑t is_chain_handoff = True cho chu·ªói Sub/Audio -> Upload.")

                # Chuy·ªÉn sang tab Upload
                try:
                    upload_tab_value = "üì§ Upload YT" 
                    if hasattr(self, 'view_switcher') and self.view_switcher.get() != upload_tab_value:
                        self.view_switcher.set(upload_tab_value)
                        self.switch_view(upload_tab_value)
                except Exception as e_switch:
                    logging.error(f"L·ªói khi t·ª± ƒë·ªông chuy·ªÉn sang tab Upload: {e_switch}")

                # B·∫Øt ƒë·∫ßu qu√° tr√¨nh upload
                self.after(500, self._start_youtube_batch_upload)
            # K·∫æT TH√öC KH·ªêI CODE M·ªöI 

            else:
                # Tr∆∞·ªùng h·ª£p kh√¥ng c·∫ßn thuy·∫øt minh (v√≠ d·ª•: ch·ªâ Sub, ho·∫∑c pending_auto_dub = False)
                self.chain_download_sub_dub_active = False
                try:
                    is_active = self._is_app_fully_activated()
                except Exception:
                    is_active = False

                final_status_msg_sub_done = (
                    "‚úÖ X·ª≠ l√Ω ph·ª• ƒë·ªÅ ho√†n t·∫•t! S·∫µn s√†ng."
                    if is_active else
                    "‚úÖ X·ª≠ l√Ω ph·ª• ƒë·ªÅ ho√†n t·∫•t! (C·∫ßn k√≠ch ho·∫°t ƒë·ªÉ d√πng ti·∫øp)"
                )
                self.update_status(final_status_msg_sub_done)
                
                # ƒê·∫£m b·∫£o c√°c c·ªù n√†y ƒë∆∞·ª£c reset n·∫øu kh√¥ng c√≥ thuy·∫øt minh
                self.pending_auto_dub_after_current_sub_batch = False 
                self.chain_download_sub_dub_active = False  
                self.files_for_chained_dubbing = [] 

                try: 
                    sound_enabled = self.download_sound_var.get() 
                    sound_file_path = self.download_sound_path_var.get() 
                    if sound_enabled and sound_file_path and os.path.isfile(sound_file_path) and PLAYSOUND_AVAILABLE: 
                         play_sound_async(sound_file_path) 
                except Exception as sound_err: 
                    log_pnf(logging.ERROR, f"L·ªói khi th·ª≠ ph√°t √¢m thanh sau khi ho√†n th√†nh ph·ª• ƒë·ªÅ (kh√¥ng dub): {sound_err}") 
                
                self.after(100, lambda: messagebox.showinfo("Ho√†n th√†nh Sub", "ƒê√£ x·ª≠ l√Ω xong t·∫•t c·∫£ c√°c file trong h√†ng ch·ªù ph·ª• ƒë·ªÅ.", parent=self)) 

                # Reset c·ªù kh√≥a ·ªü ƒë√¢y n·∫øu n√≥ ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t nh∆∞ng kh√¥ng c√≥ thuy·∫øt minh n√†o ƒë∆∞·ª£c k√≠ch ho·∫°t
                # (M·∫∑c d√π logic ·ªü tr√™n n√™n ƒë√£ x·ª≠ l√Ω, nh∆∞ng ƒë·ªÉ an to√†n)
                if hasattr(self, '_dub_trigger_initiated_for_current_batch') and self._dub_trigger_initiated_for_current_batch:
                    self._dub_trigger_initiated_for_current_batch = False
                    log_pnf(logging.INFO, "   >>> Kh√≥a k√≠ch ho·∫°t thuy·∫øt minh ƒë√£ ƒë∆∞·ª£c reset (v√¨ kh√¥ng c√≥ thuy·∫øt minh n√†o ƒë∆∞·ª£c k√≠ch ho·∫°t trong nh√°nh n√†y).")
            
            # logic reset self.start_time v√† g·ªçi self._check_completion_and_shutdown()
            any_other_timer_task_active_empty_q = ( 
                self.is_downloading or self.is_loading_model_for_timer or
                self.dub_is_processing or self.is_creating_slideshow or
                self.is_gpt_processing_script or self.is_dalle_processing
            ) 
            if not any_other_timer_task_active_empty_q: 
                 if self.start_time is not None: 
                    self.start_time = None 
                    log_pnf(logging.INFO, "   H√†ng ch·ªù tr·ªëng, kh√¥ng dub, v√† kh√¥ng c√≤n t√°c v·ª• timer n√†o kh√°c, reset self.start_time.") 
            else: 
                 log_pnf(logging.INFO, "   H√†ng ch·ªù tr·ªëng, kh√¥ng dub, nh∆∞ng c√≤n t√°c v·ª• timer kh√°c, start_time kh√¥ng reset ·ªü ƒë√¢y.") 

            self.after(150, self._check_completion_and_shutdown) 
            return
        
        # L·∫•y to√†n b·ªô ƒë·ªëi t∆∞·ª£ng t√°c v·ª• t·ª´ ƒë·∫ßu h√†ng ch·ªù
        current_task_object = self.file_queue.pop(0)
        self.current_file = current_task_object

        # Ki·ªÉm tra xem c√≥ l·∫•y ƒë∆∞·ª£c task object h·ª£p l·ªá kh√¥ng
        if not isinstance(current_task_object, dict):
            log_pnf(logging.ERROR, f"L·ªói nghi√™m tr·ªçng: M·ª•c trong h√†ng ch·ªù kh√¥ng ph·∫£i l√† m·ªôt task object (dictionary). M·ª•c: {current_task_object}")
            self.after(50, self._process_next_subtitle_file) # Th·ª≠ x·ª≠ l√Ω m·ª•c ti·∫øp theo
            return

        # L·∫•y ƒë∆∞·ªùng d·∫´n file ƒë·ªÉ x·ª≠ l√Ω t·ª´ task object
        # ∆Øu ti√™n 'downloaded_video_path' r·ªìi m·ªõi ƒë·∫øn 'source'
        file_path_to_process = current_task_object.get('downloaded_video_path') or current_task_object.get('source')

        # --- B∆Ø·ªöC KI·ªÇM TRA LO·∫†I FILE (AUDIO HAY VIDEO) ---
        is_audio_file = False
        audio_extensions = ('.mp3', '.wav', '.flac', '.m4a', '.ogg', '.opus')
        if file_path_to_process and file_path_to_process.lower().endswith(audio_extensions):
            is_audio_file = True

        if is_audio_file:
            # ƒê√¢y l√† file audio, k√≠ch ho·∫°t lu·ªìng worker m·ªõi
            logging.info(f"[Audio-to-Video] Ph√°t hi·ªán file audio: {os.path.basename(file_path_to_process)}. B·∫Øt ƒë·∫ßu lu·ªìng x·ª≠ l√Ω audio-to-video.")

            self.current_file = current_task_object # G√°n t√°c v·ª• hi·ªán t·∫°i ƒë·ªÉ UI c√≥ th·ªÉ t√¥ s√°ng
            self.update_queue_display()          # C·∫≠p nh·∫≠t giao di·ªán ngay l·∫≠p t·ª©c

            # L·∫•y b·∫£n sao c√°c c√†i ƒë·∫∑t hi·ªán t·∫°i ƒë·ªÉ truy·ªÅn cho lu·ªìng
            current_cfg_snapshot = self._get_config_snapshot()

            # B·∫Øt ƒë·∫ßu lu·ªìng m·ªõi ƒë·ªÉ x·ª≠ l√Ω file audio n√†y
            self.processing_thread = threading.Thread(
                target=self._task_audio_to_video_threaded,
                args=(current_task_object, current_cfg_snapshot, self._process_next_subtitle_file),
                daemon=True,
                name=f"AudioToVideoWorker_{os.path.basename(file_path_to_process)}"
            )
            self.processing_thread.start()

            return # D·ª´ng h√†m n√†y, v√¨ lu·ªìng m·ªõi s·∫Ω t·ª± g·ªçi callback ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo

        if not file_path_to_process or not os.path.exists(file_path_to_process):
            log_pnf(logging.ERROR, f"L·ªói: ƒê∆∞·ªùng d·∫´n file trong task object kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i. Path: '{file_path_to_process}'. B·ªè qua t√°c v·ª• n√†y.")
            self.after(50, self._process_next_subtitle_file) # Th·ª≠ x·ª≠ l√Ω m·ª•c ti·∫øp theo
            return

        self.current_file = file_path_to_process # G√°n self.current_file ƒë·ªÉ UI hi·ªÉn th·ªã ƒë√∫ng

        # Ghi log identifier g·ªëc ƒë·ªÉ ki·ªÉm tra
        log_pnf(logging.INFO, f"ƒê√£ l·∫•y Task Object t·ª´ h√†ng ch·ªù. Identifier g·ªëc: '{current_task_object.get('identifier')}'")

        self.update_queue_display()
        self.update_status(f"üé¨ B·∫Øt ƒë·∫ßu Sub: {os.path.basename(self.current_file)}")
        log_pnf(logging.INFO, f"L·∫•y file '{os.path.basename(self.current_file)}' t·ª´ h√†ng ch·ªù sub. C√≤n l·∫°i: {len(self.file_queue)}")

        self.is_subbing = True
        log_pnf(logging.INFO, f"ƒê·∫∑t self.is_subbing = True tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu thread cho '{self.current_file}'.")

        if self.start_time is None:
            any_other_processing = (self.is_downloading or self.is_loading_model_for_timer or self.dub_is_processing or self.is_creating_slideshow or self.is_gpt_processing_script or self.is_dalle_processing)
            if not any_other_processing:
                self.start_time = time.time()
                log_pnf(logging.INFO, "   Kh√¥ng c√≥ t√°c v·ª• timer n√†o kh√°c, ƒë√£ ƒë·∫∑t self.start_time cho t√°c v·ª• sub m·ªõi.")
            else:
                log_pnf(logging.INFO, "   C√≥ t√°c v·ª• timer kh√°c ƒëang ch·∫°y, self.start_time kh√¥ng ƒë∆∞·ª£c ƒë·∫∑t l·∫°i b·ªüi t√°c v·ª• sub m·ªõi n√†y.")

        # L·∫•y snapshot c·ªßa c·∫•u h√¨nh UI hi·ªán t·∫°i
        current_cfg_snapshot_for_thread = self._get_config_snapshot()
        logging.info(f"[PrcNextSubFile_Debug] Chu·∫©n b·ªã ch·∫°y thread v·ªõi optimize_whisper_tts_voice = {current_cfg_snapshot_for_thread.get('optimize_whisper_tts_voice')}")

        # Truy·ªÅn task object g·ªëc v√†o lu·ªìng worker
        self.processing_thread = threading.Thread(
            target=self.task_subtitle_threaded,
            args=(current_task_object, current_cfg_snapshot_for_thread, self._process_next_subtitle_file),
            daemon=True,
            name=f"SubWorker_{os.path.basename(self.current_file)}"
        )
        self.processing_thread.start()

        self.after(1000, self.update_time_realtime)



# =================================================================
# H√ÄM T√åM GI·ªåNG N√ìI (PHI√äN B·∫¢N HO√ÄN CH·ªàNH)
    def _find_first_speech_timestamp_vad(self, audio_path):
        """
        (ƒê√É S·ª¨A L·ªñI NONETYPE)
        S·ª≠ d·ª•ng Silero VAD ƒë·ªÉ t√¨m th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa ƒëo·∫°n n√≥i ƒê·∫¶U TI√äN trong file audio.
        ƒê√£ th√™m x·ª≠ l√Ω chuy·ªÉn h∆∞·ªõng stdout/stderr ƒë·ªÉ tr√°nh l·ªói 'NoneType' trong GUI.
        """
        from contextlib import redirect_stdout, redirect_stderr # Th√™m import c·∫ßn thi·∫øt

        worker_log_prefix = f"[{threading.current_thread().name}_VAD_v2_Fixed]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu ph√¢n t√≠ch VAD cho: {os.path.basename(audio_path)}")

        try:
            # --- B·∫ÆT ƒê·∫¶U KH·ªêI S·ª¨A L·ªñI 'NONETYPE' ---
            # M·ªü m·ªôt "h·ªë ƒëen" ƒë·ªÉ ch·ª©a c√°c output kh√¥ng mong mu·ªën
            with open(os.devnull, "w", encoding="utf-8") as fnull:
                # L∆∞u l·∫°i stderr g·ªëc
                _orig_stderr = sys.stderr
                _patched_stderr = False
                # N·∫øu stderr l√† None (th∆∞·ªùng g·∫∑p trong GUI), t·∫°m th·ªùi tr·ªè n√≥ v√†o "h·ªë ƒëen"
                if _orig_stderr is None:
                    sys.stderr = fnull
                    _patched_stderr = True
                
                try:
                    # Ch·∫°y l·ªánh c√≥ th·ªÉ g√¢y l·ªói b√™n trong kh·ªëi redirect
                    with redirect_stdout(fnull), redirect_stderr(fnull):
                        logging.debug(f"{worker_log_prefix} ƒêang g·ªçi torch.hub.load() b√™n trong kh·ªëi redirect...")
                        model, utils = torch.hub.load(repo_or_dir='snakers4/silero-vad',
                                                      model='silero_vad',
                                                      force_reload=False,
                                                      trust_repo=True)
                finally:
                    # Lu√¥n kh√¥i ph·ª•c l·∫°i stderr g·ªëc sau khi xong
                    if _patched_stderr:
                        sys.stderr = _orig_stderr
            # --- K·∫æT TH√öC KH·ªêI S·ª¨A L·ªñI ---

            (get_speech_timestamps, _, read_audio, *_) = utils
            
            SAMPLING_RATE = 16000
            wav_tensor = read_audio(audio_path, sampling_rate=SAMPLING_RATE)

            speech_timestamps = get_speech_timestamps(wav_tensor, model, 
                                                      sampling_rate=SAMPLING_RATE, 
                                                      min_speech_duration_ms=250)

            if speech_timestamps:
                first_speech_start_sample = speech_timestamps[0]['start']
                first_speech_start_seconds = first_speech_start_sample / SAMPLING_RATE
                logging.info(f"{worker_log_prefix} T√¨m th·∫•y gi·ªçng n√≥i ƒë·∫ßu ti√™n l√∫c: {first_speech_start_seconds:.3f} gi√¢y")
                return first_speech_start_seconds
            else:
                logging.warning(f"{worker_log_prefix} Kh√¥ng t√¨m th·∫•y gi·ªçng n√≥i n√†o trong file: {os.path.basename(audio_path)}")
                return 0.0
                
        except Exception as e:
            # Gi·ªØ l·∫°i th√¥ng b√°o l·ªói g·ªëc c·ªßa b·∫°n, nh∆∞ng l√†m n√≥ linh ho·∫°t h∆°n m·ªôt ch√∫t
            error_message = f"ƒê√£ x·∫£y ra l·ªói khi ph√¢n t√≠ch gi·ªçng n√≥i:\n{e}\n\n·ª®ng d·ª•ng s·∫Ω ti·∫øp t·ª•c m√† kh√¥ng x·ª≠ l√Ω VAD."
            
            # Ki·ªÉm tra c·ª• th·ªÉ l·ªói 'NoneType' ƒë·ªÉ hi·ªÉn th·ªã th√¥ng b√°o th√¢n thi·ªán h∆°n n·∫øu c·∫ßn
            if "'NoneType' object has no attribute 'write'" in str(e):
                 error_message = f"ƒê√£ x·∫£y ra l·ªói khi ph√¢n t√≠ch gi·ªçng n√≥i:\nL·ªói giao ti·∫øp v·ªõi th∆∞ vi·ªán Torch (NoneType).\n\n·ª®ng d·ª•ng s·∫Ω ti·∫øp t·ª•c m√† kh√¥ng x·ª≠ l√Ω VAD."

            logging.error(f"{worker_log_prefix} L·ªói nghi√™m tr·ªçng khi x·ª≠ l√Ω VAD: {e}", exc_info=True)
            self.after(0, lambda msg=error_message: messagebox.showerror("L·ªói VAD", msg, parent=self))
            return None

# ---------------------------------------------------------------------------------------------------------------------------------------------
    # 4.6 Logic C·ªët l√µi - Lu·ªìng Worker (X·ª≠ l√Ω Ph·ª• ƒë·ªÅ)
# ---------------------------------------------------------------------------------------------------------------------------------------------

# H√†m logic (ch·∫°y trong lu·ªìng): Quy tr√¨nh x·ª≠ l√Ω t·∫°o ph·ª• ƒë·ªÅ cho m·ªôt file
    def task_subtitle_threaded(self, task_object, cfg_snapshot_from_caller, callback):
        """
        Lu·ªìng worker x·ª≠ l√Ω m·ªôt t√°c v·ª• t·∫°o ph·ª• ƒë·ªÅ duy nh·∫•t, ƒë√£ t√≠ch h·ª£p VAD ƒë·ªÉ x·ª≠ l√Ω timing ch√≠nh x√°c.
        """
        # --- Kh·ªüi t·∫°o c√°c bi·∫øn cho t√°c v·ª• ---
        input_file = task_object.get('downloaded_video_path') or task_object.get('source')
        identifier = task_object.get('identifier')
        
        success_for_this_file = False
        should_call_original_callback_directly = True 
        video_output_for_this_file = None   
        temp_sub_path = None
        path_to_original_whisper_srt_for_tts = None

        cfg_snapshot = cfg_snapshot_from_caller
        out_dir = cfg_snapshot.get("output_path") or os.path.dirname(input_file)

        # --- ƒê·ªãnh nghƒ©a c√°c h√†m helper n·ªôi b·ªô ---
        def _update_status(msg):
            try:
                if hasattr(self, 'update_status') and callable(self.update_status):
                    self.after(0, lambda m=msg: self.update_status(m))
            except Exception as e: logging.error(f"L·ªói g·ªçi self.after trong _update_status: {e}")

        def _show_error(title, msg):
            try:
                if hasattr(self, 'after') and callable(self.after):
                    self.after(0, lambda t=title, m=msg: messagebox.showerror(t, m, parent=self))
            except Exception as e: logging.error(f"L·ªói g·ªçi self.after trong _show_error: {e}")

        def _log_thread(level, msg, exc_info=False):
            current_thread_name = threading.current_thread().name
            if isinstance(level, int):
                logging.log(level, f"[Lu·ªìng {current_thread_name}] {msg}", exc_info=exc_info)
            else:
                logging.error(f"[Lu·ªìng {current_thread_name}] L·ªói g·ªçi log - level kh√¥ng h·ª£p l·ªá: {level}. N·ªôi dung log: {msg}", exc_info=exc_info)
        # --- K·∫øt th√∫c ƒë·ªãnh nghƒ©a helper ---

        # === TH√äM C√ÅC D√íNG RESET C·ªú ·ªû ƒê√ÇY ===
        self.translate_batch_first_api_error_msg_shown = False
        self.translate_batch_accumulated_api_error_details = None

        with keep_awake(f"Transcribing {os.path.basename(input_file)}"):

           # --- B·∫Øt ƒë·∫ßu kh·ªëi x·ª≠ l√Ω ch√≠nh ---
            try:
                os.makedirs(out_dir, exist_ok=True)
                self.translate_batch_first_api_error_msg_shown = False
                self.translate_batch_accumulated_api_error_details = None

                # >>> B·∫ÆT ƒê·∫¶U KH·ªêI LOGIC CHIA FILE M·ªöI <<<
                try:
                    MAX_DURATION_SECONDS = 1800  # Gi·ªõi h·∫°n 30 ph√∫t (30 * 60 = 1800)
                    file_duration_s = get_video_duration_s(input_file)

                    if file_duration_s > MAX_DURATION_SECONDS:
                        _log_thread(logging.INFO, f"File '{os.path.basename(input_file)}' d√†i ({file_duration_s:.0f}s), s·∫Ω t·ª± ƒë·ªông chia nh·ªè.")
                        _update_status(f"‚è≥ ƒêang chia file d√†i: {os.path.basename(input_file)}...")
                        
                        temp_split_folder = os.path.join(self.temp_folder, f"split_{identifier}")
                        os.makedirs(temp_split_folder, exist_ok=True)
                        
                        media_parts = ffmpeg_split_media(input_file, temp_split_folder, MAX_DURATION_SECONDS)
                        
                        if not media_parts:
                            raise RuntimeError("Kh√¥ng th·ªÉ chia file media th√†nh c√°c ph·∫ßn nh·ªè.")

                        srt_parts = []
                        for i, part_path in enumerate(media_parts):
                            if self.stop_event.is_set(): raise InterruptedError("D·ª´ng trong l√∫c x·ª≠ l√Ω c√°c file con.")
                            _update_status(f"‚è≥ ƒêang Sub ph·∫ßn {i+1}/{len(media_parts)}: {os.path.basename(part_path)}...")
                            
                            part_srt_path = self.run_whisper_engine(part_path, cfg_snapshot.get('model', 'medium'), 'srt', cfg_snapshot.get('language', 'auto'), temp_split_folder)
                            if not part_srt_path:
                                raise RuntimeError(f"Whisper th·∫•t b·∫°i khi x·ª≠ l√Ω file con: {os.path.basename(part_path)}")
                            srt_parts.append(part_srt_path)
                        
                        # Gh√©p c√°c file SRT l·∫°i
                        _update_status(f"‚è≥ ƒêang gh√©p {len(srt_parts)} file ph·ª• ƒë·ªÅ...")
                        merged_srt_filename = f"{identifier}_merged.srt"
                        temp_sub_path = os.path.join(self.temp_folder, merged_srt_filename)
                        
                        if not self._merge_srt_files(srt_parts, media_parts, temp_sub_path):
                            raise RuntimeError("Kh√¥ng th·ªÉ gh√©p c√°c file ph·ª• ƒë·ªÅ con.")
                        
                        # D·ªçn d·∫πp th∆∞ m·ª•c t·∫°m ch·ª©a c√°c file con
                        shutil.rmtree(temp_split_folder, ignore_errors=True)
                    
                    else: # File kh√¥ng qu√° d√†i, x·ª≠ l√Ω nh∆∞ b√¨nh th∆∞·ªùng
                        if self.stop_event.is_set(): raise InterruptedError("ƒê√£ d·ª´ng tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu Whisper")
                        _update_status(f"‚è≥ B·∫Øt ƒë·∫ßu Sub (Whisper): {os.path.basename(input_file)}")
                        _log_thread(logging.INFO, f"Ch·∫°y Whisper tr√™n file: {os.path.basename(input_file)}")
                        temp_sub_path = self.run_whisper_engine(input_file, cfg_snapshot.get('model', 'medium'), cfg_snapshot.get('format', 'srt'), cfg_snapshot.get('language', 'auto'), self.temp_folder)

                except Exception as e_main_process:
                    # B·∫Øt l·ªói ·ªü ƒë√¢y v√† chuy·ªÉn t·ªõi kh·ªëi finally ƒë·ªÉ d·ªçn d·∫πp
                    _log_thread(logging.ERROR, f"L·ªói trong kh·ªëi x·ª≠ l√Ω ch√≠nh c·ªßa task_subtitle_threaded: {e_main_process}", exc_info=True)
                    success_for_this_file = False # ƒê√°nh d·∫•u th·∫•t b·∫°i
                    # Chuy·ªÉn t·ªõi kh·ªëi finally ƒë·ªÉ g·ªçi callback

                # === B∆Ø·ªöC 1: TI·ªÄN X·ª¨ L√ù VAD ƒê·ªÇ T√åM ƒêI·ªÇM B·∫ÆT ƒê·∫¶U GI·ªåNG N√ìI ===
                start_time_offset = 0.0 
                video_path_for_whisper = input_file 
                temp_files_for_vad = []

                _log_thread(logging.INFO, "B·∫Øt ƒë·∫ßu b∆∞·ªõc ti·ªÅn x·ª≠ l√Ω VAD...")
                try:
                    # 1a. Tr√≠ch xu·∫•t audio ra file WAV t·∫°m th·ªùi
                    ffmpeg_executable_vad = find_ffmpeg()
                    if not ffmpeg_executable_vad:
                        raise RuntimeError("Kh√¥ng t√¨m th·∫•y FFmpeg ƒë·ªÉ tr√≠ch xu·∫•t audio cho VAD.")

                    temp_audio_for_vad = os.path.join(self.temp_folder, f"vad_audio_{uuid.uuid4().hex[:8]}.wav")
                    temp_files_for_vad.append(temp_audio_for_vad)
                    
                    cmd_extract_audio_params = [
                        "-y", "-i", os.path.abspath(input_file),
                        "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1",
                        os.path.abspath(temp_audio_for_vad)
                    ]
                    ffmpeg_run_command(
                        cmd_extract_audio_params,
                        process_name=f"{threading.current_thread().name}_VAD_ExtractAudio",
                        stop_event=self.stop_event if hasattr(self, 'stop_event') else None,
                        set_current_process=lambda p: setattr(self, 'current_process', p),
                        clear_current_process=lambda: setattr(self, 'current_process', None),
                        timeout_seconds=120,
                    )

                    # 1b. Ch·∫°y VAD tr√™n file audio t·∫°m
                    detected_start_time = self._find_first_speech_timestamp_vad(temp_audio_for_vad)

                    # 1c. N·∫øu t√¨m th·∫•y kho·∫£ng l·∫∑ng ƒë√°ng k·ªÉ, t·∫°o video t·∫°m ƒë√£ c·∫Øt
                    if detected_start_time is not None and detected_start_time > 0.5:
                        start_time_offset = detected_start_time
                        _log_thread(logging.INFO, f"VAD ph√°t hi·ªán gi·ªçng n√≥i b·∫Øt ƒë·∫ßu t·ª´ {start_time_offset:.3f}s. S·∫Ω c·∫Øt video.")
                        
                        cut_video_path = os.path.join(self.temp_folder, f"cut_video_{uuid.uuid4().hex[:8]}.mp4")
                        temp_files_for_vad.append(cut_video_path)
                        
                        cmd_cut_video_params = [
                            "-y", "-ss", str(start_time_offset),
                            "-i", os.path.abspath(input_file),
                            "-c", "copy",
                            os.path.abspath(cut_video_path)
                        ]
                        ffmpeg_run_command(
                            cmd_cut_video_params,
                            process_name=f"{threading.current_thread().name}_VAD_CutVideo",
                            stop_event=self.stop_event if hasattr(self, 'stop_event') else None,
                            set_current_process=lambda p: setattr(self, 'current_process', p),
                            clear_current_process=lambda: setattr(self, 'current_process', None),
                            timeout_seconds=180,
                        )
                        
                        if os.path.exists(cut_video_path):
                            video_path_for_whisper = cut_video_path
                        else:
                            _log_thread(logging.WARNING, "C·∫Øt video b·∫±ng FFmpeg th·∫•t b·∫°i. S·∫Ω d√πng video g·ªëc.")
                            start_time_offset = 0.0
                    else:
                        _log_thread(logging.INFO, "VAD kh√¥ng ph√°t hi·ªán kho·∫£ng l·∫∑ng ƒë√°ng k·ªÉ ·ªü ƒë·∫ßu ho·∫∑c c√≥ l·ªói. D√πng video g·ªëc.")
                except Exception as e_vad_prep:
                    _log_thread(logging.ERROR, f"L·ªói trong qu√° tr√¨nh ti·ªÅn x·ª≠ l√Ω VAD: {e_vad_prep}", exc_info=True)
                    start_time_offset = 0.0
                    video_path_for_whisper = input_file

                # === B∆Ø·ªöC 2: CH·∫†Y WHISPER TR√äN FILE ƒê√É CHU·∫®N B·ªä ===
                if self.stop_event.is_set(): raise InterruptedError("ƒê√£ d·ª´ng tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu Whisper")

                _update_status(f"‚è≥ B·∫Øt ƒë·∫ßu Sub (Whisper): {os.path.basename(video_path_for_whisper)}")
                _log_thread(logging.INFO, f"Ch·∫°y Whisper tr√™n file: {os.path.basename(video_path_for_whisper)}")
                temp_sub_path = self.run_whisper_engine(video_path_for_whisper, cfg_snapshot.get('model', 'medium'), cfg_snapshot.get('format', 'srt'), cfg_snapshot.get('language', 'auto'), self.temp_folder)
                
                if not temp_sub_path or not os.path.exists(temp_sub_path):
                    raise FileNotFoundError(f"Whisper kh√¥ng t·∫°o ƒë∆∞·ª£c file ph·ª• ƒë·ªÅ t·ª´ '{os.path.basename(video_path_for_whisper)}'.")
                _log_thread(logging.INFO, f"Whisper ho√†n th√†nh. Sub t·∫°m: {temp_sub_path}")

                # === B∆Ø·ªöC 3: D·ªäCH CHUY·ªÇN TIMING C·ª¶A SRT (N·∫æU C·∫¶N) ===
                if start_time_offset > 0.5:
                    _log_thread(logging.INFO, f"D·ªãch chuy·ªÉn timing c·ªßa SRT ƒëi {start_time_offset:.3f} gi√¢y...")
                    try:
                        subs = pysubs2.load(temp_sub_path, encoding="utf-8")
                        subs.shift(s=start_time_offset)
                        subs.save(temp_sub_path, encoding="utf-8")
                        _log_thread(logging.INFO, "D·ªãch chuy·ªÉn timing th√†nh c√¥ng!")
                    except Exception as e_shift:
                        _log_thread(logging.ERROR, f"L·ªói khi d·ªãch chuy·ªÉn timing SRT: {e_shift}", exc_info=True)

                if self.stop_event.is_set(): raise InterruptedError("ƒê√£ d·ª´ng tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu b∆∞·ªõc d·ªãch")
                selected_engine = cfg_snapshot.get("translation_engine", "Kh√¥ng d·ªãch")
                target_lang_code = cfg_snapshot.get('target_lang', 'vi')
                bilingual_flag = cfg_snapshot.get('bilingual', False)
                if selected_engine != "Kh√¥ng d·ªãch" and temp_sub_path and os.path.exists(temp_sub_path):
                    target_lang_name = LANGUAGE_MAP_VI.get(target_lang_code, target_lang_code)
                    _update_status(f"üåê ƒêang d·ªãch sang {target_lang_name}: {os.path.basename(input_file)}")
                    _log_thread(logging.INFO, f"Chu·∫©n b·ªã d·ªãch file '{os.path.basename(temp_sub_path)}' b·∫±ng engine '{selected_engine}'...")
                    translated_temp_path = temp_sub_path + ".translated"
                    try:
                        self.translate_subtitle_file(temp_sub_path, translated_temp_path, target_lang_code, bilingual_flag)
                        if os.path.exists(translated_temp_path):
                            shutil.move(translated_temp_path, temp_sub_path)
                            _log_thread(logging.INFO, f"D·ªãch b·∫±ng {selected_engine} th√†nh c√¥ng. ƒê√£ c·∫≠p nh·∫≠t file sub t·∫°m: {temp_sub_path}")
                        else:
                            _log_thread(logging.error, f"H√†m d·ªãch {selected_engine} ho√†n th√†nh nh∆∞ng kh√¥ng t·∫°o file output '{translated_temp_path}'. Gi·ªØ nguy√™n file sub g·ªëc.")
                            _update_status(f"‚ö†Ô∏è L·ªói kh√¥ng mong mu·ªën khi d·ªãch: Kh√¥ng t·∫°o ƒë∆∞·ª£c file k·∫øt qu·∫£.")
                    except ValueError as ve:
                        _log_thread(logging.error, f"L·ªói ƒëi·ªÅu ki·ªán/API khi d·ªãch b·∫±ng {selected_engine}: {ve}. B·ªè qua b∆∞·ªõc d·ªãch.")
                        _update_status(f"‚ö†Ô∏è L·ªói: {ve}. B·ªè qua d·ªãch.")
                    except InterruptedError:
                        _log_thread(logging.warning,f"Qu√° tr√¨nh d·ªãch b·∫±ng {selected_engine} b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
                        raise
                    except Exception as trans_e:
                        _log_thread(logging.error, f"L·ªói kh√¥ng mong mu·ªën trong qu√° tr√¨nh d·ªãch b·∫±ng {selected_engine}: {trans_e}", exc_info=True)
                        _update_status(f"‚ùå L·ªói d·ªãch kh√¥ng x√°c ƒë·ªãnh: {os.path.basename(input_file)}")
                    finally:
                        if os.path.exists(translated_temp_path):
                            try: os.remove(translated_temp_path); _log_thread(logging.debug, f"ƒê√£ d·ªçn d·∫πp file t·∫°m d·ªãch: {translated_temp_path}")
                            except OSError as del_err: _log_thread(logging.warning, f"Kh√¥ng th·ªÉ x√≥a file t·∫°m d·ªãch '{translated_temp_path}': {del_err}")
                elif selected_engine == "Kh√¥ng d·ªãch":
                    _log_thread(logging.INFO, "Kh√¥ng y√™u c·∫ßu d·ªãch (Engine='Kh√¥ng d·ªãch'). B·ªè qua b∆∞·ªõc d·ªãch.")

                # --- L∆ØU FILE SRT G·ªêC WHISPER N·∫æU T√ôY CH·ªåN ƒê∆Ø·ª¢C B·∫¨T ---
                optimize_voice_enabled_in_thread = cfg_snapshot.get("optimize_whisper_tts_voice", False)
                _log_thread(logging.INFO, f"Ki·ªÉm tra l∆∞u SRT g·ªëc Whisper. C·ªù b·∫≠t: {optimize_voice_enabled_in_thread}. File t·∫°m hi·ªán t·∫°i: {temp_sub_path}")

                if optimize_voice_enabled_in_thread: # path_to_original_whisper_srt_for_tts s·∫Ω ƒë∆∞·ª£c g√°n ·ªü ƒë√¢y
                    if temp_sub_path and os.path.exists(temp_sub_path):
                        _log_thread(logging.INFO, f"ƒêi·ªÅu ki·ªán l∆∞u SRT g·ªëc Whisper ƒë∆∞·ª£c ƒë√°p ·ª©ng. ƒêang ti·∫øn h√†nh l∆∞u...")
                        try:
                            base_name_no_ext_original = os.path.splitext(os.path.basename(input_file))[0]
                            original_whisper_srt_filename = f"{base_name_no_ext_original}.original_whisper_tts.srt"
                            path_to_original_whisper_srt_for_tts = os.path.join(out_dir, original_whisper_srt_filename)
                            shutil.copy2(temp_sub_path, path_to_original_whisper_srt_for_tts)
                            _log_thread(logging.INFO, f"ƒê√É L∆ØU file SRT g·ªëc Whisper (cho TTS): {original_whisper_srt_filename} t·∫°i {path_to_original_whisper_srt_for_tts}")
                        except Exception as e_save_orig_srt:
                            _log_thread(logging.ERROR, f"L·ªñI khi l∆∞u file SRT g·ªëc Whisper: {e_save_orig_srt}", exc_info=True)
                            path_to_original_whisper_srt_for_tts = None # G√°n l·∫°i None n·∫øu l·ªói
                    else:
                        _log_thread(logging.WARNING, f"Kh√¥ng th·ªÉ l∆∞u file SRT g·ªëc Whisper: temp_sub_path ('{temp_sub_path}') kh√¥ng h·ª£p l·ªá ho·∫∑c file kh√¥ng t·ªìn t·∫°i.")
                        path_to_original_whisper_srt_for_tts = None # G√°n None n·∫øu kh√¥ng l∆∞u
                else: # optimize_voice_enabled_in_thread is False
                    _log_thread(logging.INFO, "T√πy ch·ªçn 'T·ªëi ∆∞u gi·ªçng ƒë·ªçc cho TTS' kh√¥ng ƒë∆∞·ª£c b·∫≠t, b·ªè qua l∆∞u file SRT g·ªëc Whisper ri√™ng.")
                    path_to_original_whisper_srt_for_tts = None # ƒê·∫£m b·∫£o l√† None n·∫øu kh√¥ng b·∫≠t

                # --- C√°c b∆∞·ªõc x·ª≠ l√Ω ti·∫øp theo (G·ªôp kh·ªëi, Chia d√≤ng) s·∫Ω th·ª±c hi·ªán tr√™n temp_sub_path ---
                # ... (code G·ªôp kh·ªëi, Chia d√≤ng c·ªßa b·∫°n gi·ªØ nguy√™n) ...
                if self.stop_event.is_set(): raise InterruptedError("ƒê√£ d·ª´ng tr∆∞·ªõc khi G·ªôp Kh·ªëi")
                if self.enable_block_merging_var.get() and temp_sub_path and os.path.exists(temp_sub_path):
                    _update_status(f"üß± ƒêang chu·∫©n b·ªã g·ªôp kh·ªëi: {os.path.basename(input_file)}")
                    _log_thread(logging.INFO, f"B·∫Øt ƒë·∫ßu ti·ªÅn x·ª≠ l√Ω g·ªôp kh·ªëi cho file: {os.path.basename(temp_sub_path)}")
                    try:
                        content_before_merging = ""
                        with open(temp_sub_path, "r", encoding="utf-8") as f:
                            content_before_merging = f.read()
                        if content_before_merging.strip():
                            merged_srt_content = self.preprocess_and_merge_srt_blocks(content_before_merging)
                            with open(temp_sub_path, "w", encoding="utf-8") as f:
                                f.write(merged_srt_content)
                            _log_thread(logging.INFO, f"G·ªôp kh·ªëi SRT ho√†n th√†nh. File t·∫°m ƒë∆∞·ª£c c·∫≠p nh·∫≠t: {os.path.basename(temp_sub_path)}")
                        else:
                            _log_thread(logging.INFO, f"N·ªôi dung file {os.path.basename(temp_sub_path)} r·ªóng, b·ªè qua b∆∞·ªõc g·ªôp kh·ªëi.")
                    except Exception as merge_block_e:
                        _log_thread(logging.error, f"L·ªói trong qu√° tr√¨nh g·ªôp kh·ªëi SRT: {merge_block_e}", exc_info=True)
                        _update_status(f"‚ö†Ô∏è L·ªói g·ªôp kh·ªëi: {os.path.basename(input_file)}")
                else:
                    if not (temp_sub_path and os.path.exists(temp_sub_path)):
                        _log_thread(logging.WARNING, f"Kh√¥ng t√¨m th·∫•y file sub t·∫°m ({temp_sub_path}) ho·∫∑c file r·ªóng ƒë·ªÉ th·ª±c hi·ªán g·ªôp kh·ªëi.")
                    elif not self.enable_block_merging_var.get():
                         _log_thread(logging.INFO, "G·ªôp kh·ªëi t·ª± ƒë·ªông kh√¥ng ƒë∆∞·ª£c b·∫≠t.")

                if not bilingual_flag and cfg_snapshot.get("split") and temp_sub_path and os.path.exists(temp_sub_path) and cfg_snapshot.get('format') in ('srt', 'vtt'):
                    _update_status(f"‚úÇÔ∏è ƒêang chia d√≤ng: {os.path.basename(input_file)}")
                    _log_thread(logging.INFO, "B·∫Øt ƒë·∫ßu chia d√≤ng ph·ª• ƒë·ªÅ...")
                    try:
                        self.post_process_srt_time_split(temp_sub_path, cfg_snapshot)
                        _log_thread(logging.INFO, "Chia d√≤ng ho√†n th√†nh (ƒë√£ c·∫≠p nh·∫≠t file sub t·∫°m).")
                    except Exception as split_e:
                        _log_thread(logging.warning, f"L·ªói trong qu√° tr√¨nh chia d√≤ng: {split_e}. ƒêang ti·∫øp t·ª•c v·ªõi file ch∆∞a chia...")
                elif bilingual_flag and cfg_snapshot.get("split"):
                    _log_thread(logging.INFO, f"Ch·∫ø ƒë·ªô song ng·ªØ ƒëang b·∫≠t, t·∫°m th·ªùi b·ªè qua b∆∞·ªõc chia d√≤ng t·ª± ƒë·ªông cho file: {os.path.basename(temp_sub_path)}")
                elif cfg_snapshot.get("split"):
                     _log_thread(logging.INFO, f"B·ªè qua chia d√≤ng (do file t·∫°m kh√¥ng t·ªìn t·∫°i, ƒë·ªãnh d·∫°ng kh√¥ng h·ªó tr·ª£, ho·∫∑c song ng·ªØ ƒëang t·∫Øt). File: {os.path.basename(temp_sub_path if temp_sub_path else 'N/A')}")

                # --- L∆∞u file ph·ª• ƒë·ªÅ hi·ªÉn th·ªã cu·ªëi c√πng ---
                # final_sub_path_for_display s·∫Ω ƒë∆∞·ª£c g√°n gi√° tr·ªã ·ªü ƒë√¢y
                if temp_sub_path and os.path.exists(temp_sub_path):
                    try:
                        base_name_no_ext_display = os.path.splitext(os.path.basename(input_file))[0]
                        final_format_display = cfg_snapshot.get('format', 'srt')
                        final_sub_filename_display = f"{base_name_no_ext_display}.{final_format_display}"
                        final_sub_path_for_display = os.path.join(out_dir, final_sub_filename_display)
                        shutil.copy2(temp_sub_path, final_sub_path_for_display)
                        _log_thread(logging.INFO, f"ƒê√£ l∆∞u ph·ª• ƒë·ªÅ HI·ªÇN TH·ªä (sau x·ª≠ l√Ω): {final_sub_filename_display}")
                        self.after(0, lambda p=final_sub_path_for_display: setattr(self, 'current_srt_path', p))
                    except Exception as save_e_display:
                        _log_thread(logging.ERROR, f"L·ªói khi l∆∞u ph·ª• ƒë·ªÅ HI·ªÇN TH·ªä '{final_sub_filename_display if 'final_sub_filename_display' in locals() else 'N/A'}': {save_e_display}", exc_info=True)
                        final_sub_path_for_display = None # ƒê·∫£m b·∫£o None n·∫øu l·ªói
                else:
                    _log_thread(logging.error,"Kh√¥ng t√¨m th·∫•y file sub t·∫°m th·ªùi ƒë·ªÉ l∆∞u l√†m file hi·ªÉn th·ªã cu·ªëi c√πng.")
                    final_sub_path_for_display = None # ƒê·∫£m b·∫£o None n·∫øu kh√¥ng c√≥ file t·∫°m

                # --- T·∫°m d·ª´ng ƒë·ªÉ ch·ªânh s·ª≠a (n·∫øu c√≥) ---
                if cfg_snapshot.get("pause_for_edit", False):
                    self.current_paused_display_srt_path = final_sub_path_for_display
                    # path_to_original_whisper_srt_for_tts ƒë√£ ƒë∆∞·ª£c khai b√°o ·ªü ƒë·∫ßu h√†m v√† g√°n gi√° tr·ªã
                    self.current_paused_tts_srt_path = path_to_original_whisper_srt_for_tts 

                    _log_thread(logging.INFO, f"Chu·∫©n b·ªã t·∫°m d·ª´ng. Display SRT: {self.current_paused_display_srt_path}, TTS SRT: {self.current_paused_tts_srt_path}")
                    self.after(0, self.set_ui_for_paused_state, final_sub_path_for_display)
                    if hasattr(self, 'continue_merge_event'):
                        self.is_actively_paused_for_edit = True
                        self.continue_merge_event.clear()
                        _log_thread(logging.INFO, "ƒê√£ clear continue_merge_event. B·∫Øt ƒë·∫ßu wait()...")
                        self.continue_merge_event.wait()
                        self.is_actively_paused_for_edit = False
                        _log_thread(logging.INFO, "Tho√°t kh·ªèi continue_merge_event.wait(). Ki·ªÉm tra stop_event...")
                    else:
                        _log_thread(logging.ERROR,"L·ªói: Thu·ªôc t√≠nh 'continue_merge_event' kh√¥ng t·ªìn t·∫°i.")
                    if self.stop_event.is_set():
                        _log_thread(logging.INFO, "Ph√°t hi·ªán stop_event sau khi resume t·ª´ pause_for_edit.")
                        raise InterruptedError("ƒê√£ d·ª´ng sau khi t·∫°m d·ª´ng ch·ªù s·ª≠a")
                    else:
                        _log_thread(logging.INFO, "Ti·∫øp t·ª•c th·ª±c hi·ªán b∆∞·ªõc G·ªôp Ph·ª• ƒë·ªÅ sau khi ng∆∞·ªùi d√πng nh·∫•n Ti·∫øp t·ª•c.")
                        _update_status(f"‚ñ∂Ô∏è ƒêang ti·∫øp t·ª•c (G·ªôp): {os.path.basename(input_file)}")

                # --- G·ªôp ph·ª• ƒë·ªÅ v√†o video ---
                if self.stop_event.is_set(): raise InterruptedError("ƒê√£ d·ª´ng tr∆∞·ªõc khi G·ªôp")
                sub_to_merge = final_sub_path_for_display 
                merge_mode = cfg_snapshot.get("merge_mode", "kh√¥ng g·ªôp")
                video_to_use_for_actual_merging = input_file 
                if hasattr(self, 'sub_pause_selected_media_path') and \
                   self.sub_pause_selected_media_path and \
                   os.path.exists(self.sub_pause_selected_media_path):
                    video_to_use_for_actual_merging = self.sub_pause_selected_media_path
                    _log_thread(logging.INFO, f"S·∫Ω s·ª≠ d·ª•ng media m·ªõi ƒë∆∞·ª£c ch·ªçn khi t·∫°m d·ª´ng ƒë·ªÉ g·ªôp: {os.path.basename(video_to_use_for_actual_merging)}")
                else:
                    _log_thread(logging.INFO, f"S·∫Ω s·ª≠ d·ª•ng video g·ªëc ƒë·ªÉ g·ªôp: {os.path.basename(video_to_use_for_actual_merging)}")

                # video_after_sub_merge_path_temp ƒë√£ ƒë∆∞·ª£c ƒë·ªïi t√™n th√†nh video_output_for_this_file
                # merged_output_path l√† bi·∫øn c·ª•c b·ªô trong kh·ªëi n√†y
                merged_output_path_local = None 

                if merge_mode != "kh√¥ng g·ªôp" and sub_to_merge and os.path.exists(sub_to_merge):
                    merge_type = merge_mode
                    _update_status(f"üé¨ ƒêang g·ªôp {merge_type}: {os.path.basename(input_file)}")
                    _log_thread(logging.INFO, f"B·∫Øt ƒë·∫ßu g·ªôp {merge_type}...")
                    try:
                        lang_for_metadata = 'und'; source_lang_detected = cfg_snapshot.get('language', 'auto'); target_lang_selected = cfg_snapshot.get('target_lang', 'vi'); current_selected_engine = cfg_snapshot.get("translation_engine", "Kh√¥ng d·ªãch")
                        if current_selected_engine != "Kh√¥ng d·ªãch": lang_code_base = target_lang_selected.split('-')[0]; lang_map_3char = {'en': 'eng', 'vi': 'vie', 'ja': 'jpn', 'ko': 'kor', 'zh': 'zho', 'fr':'fra', 'de':'ger', 'es':'spa'}; lang_for_metadata = lang_map_3char.get(lang_code_base, lang_code_base[:3])
                        elif source_lang_detected != 'auto': lang_code_base = source_lang_detected.split('-')[0]; lang_map_3char = {'en': 'eng', 'vi': 'vie', 'ja': 'jpn', 'ko': 'kor', 'zh': 'zho', 'fr':'fra', 'de':'ger', 'es':'spa'}; lang_for_metadata = lang_map_3char.get(lang_code_base, lang_code_base[:3])
                        _log_thread(logging.DEBUG, f"Merge: D√πng m√£ ng√¥n ng·ªØ metadata '{lang_for_metadata}'")
                        base_name_no_ext_for_output = os.path.splitext(os.path.basename(video_to_use_for_actual_merging))[0]
                        suffix = "_hardsub.mp4" if merge_type == "hard-sub" else "_softsub.mkv"
                        safe_output_base_name = create_safe_filename(base_name_no_ext_for_output, remove_accents=False)
                        if "slideshow" in safe_output_base_name.lower() or "sub_pause" in safe_output_base_name.lower():
                            original_srt_base_name = os.path.splitext(os.path.basename(input_file))[0]
                            safe_output_base_name = create_safe_filename(f"{original_srt_base_name}_slideshow", remove_accents=False)
                        merged_output_path_local = os.path.join(out_dir, f"{safe_output_base_name}{suffix}")
                        if merge_type == "hard-sub":
                            self.burn_sub_to_video(video_to_use_for_actual_merging, sub_to_merge, merged_output_path_local, cfg_snapshot)
                        elif merge_type == "soft-sub":
                            self.merge_sub_as_soft_sub(video_to_use_for_actual_merging, sub_to_merge, merged_output_path_local, lang_code=lang_for_metadata)
                        _log_thread(logging.INFO, f"G·ªôp {merge_type} ho√†n th√†nh: {merged_output_path_local}")
                        video_output_for_this_file = merged_output_path_local 
                    except Exception as merge_e:
                        _log_thread(logging.ERROR, f"L·ªói trong qu√° tr√¨nh g·ªôp {merge_type}: {merge_e}", exc_info=True)
                        _update_status(f"‚ö†Ô∏è L·ªói g·ªôp sub: {os.path.basename(input_file)}")
                        _show_error(f"L·ªói G·ªôp ({merge_type})", f"Kh√¥ng th·ªÉ g·ªôp ph·ª• ƒë·ªÅ cho:\n{os.path.basename(input_file)}\n\nL·ªói: {merge_e}")
                elif merge_mode != "kh√¥ng g·ªôp" and (not sub_to_merge or not os.path.exists(sub_to_merge)):
                    _log_thread(logging.warning, f"Y√™u c·∫ßu g·ªôp {merge_type if 'merge_type' in locals() else merge_mode} nh∆∞ng kh√¥ng t√¨m th·∫•y file ph·ª• ƒë·ªÅ '{sub_to_merge}' ƒë·ªÉ g·ªôp.")


                # --- Logic Branding ---
                branding_enabled_for_this_task = (
                    hasattr(self, 'branding_intro_enabled_var') and self.branding_intro_enabled_var.get() or
                    hasattr(self, 'branding_logo_enabled_var') and self.branding_logo_enabled_var.get() or
                    hasattr(self, 'branding_outro_enabled_var') and self.branding_outro_enabled_var.get()
                )
                video_path_for_dub_if_no_branding_in_sub_step = None # S·∫Ω d√πng cho dub chain

                if video_output_for_this_file and os.path.exists(video_output_for_this_file): # Video sau khi g·ªôp sub
                    video_path_for_dub_if_no_branding_in_sub_step = video_output_for_this_file
                elif merge_mode == "kh√¥ng g·ªôp": # Kh√¥ng g·ªôp sub, video g·ªëc ƒë∆∞·ª£c d√πng
                    video_path_for_dub_if_no_branding_in_sub_step = video_to_use_for_actual_merging


                if branding_enabled_for_this_task and not self.pending_auto_dub_after_current_sub_batch:
                    _log_thread(logging.INFO, "Branding ƒë∆∞·ª£c b·∫≠t v√† KH√îNG ch·ªù dub. S·∫Ω √°p d·ª•ng branding ngay sau sub.")
                    video_to_brand_this_sub_task = video_path_for_dub_if_no_branding_in_sub_step # D√πng video ƒë√£ x√°c ƒë·ªãnh ·ªü tr√™n

                    if video_to_brand_this_sub_task and os.path.exists(video_to_brand_this_sub_task):
                        _update_status(f"üé® Chu·∫©n b·ªã Branding cho: {os.path.basename(video_to_brand_this_sub_task)}")
                        context_for_branding = {
                            "task_object": task_object,
                            "source_view": "subtitle_auto_processing_with_brand_then_done",
                            "video_before_branding": video_to_brand_this_sub_task,
                            "original_input_file_of_sub_task": input_file,
                            "srt_file_generated_for_sub_task": final_sub_path_for_display,
                            "callback_after_all_processing_for_this_file": callback,
                            "merge_mode_used": merge_mode, 
                            "is_softsub_input_for_branding": True if merge_mode == "soft-sub" else False 
                        }
                        self._start_branding_thread(
                            video_path_from_previous_step=video_to_brand_this_sub_task,
                            callback_after_branding=self._handle_branding_completion,
                            original_context_data=context_for_branding
                        )
                        should_call_original_callback_directly = False # Branding s·∫Ω g·ªçi callback
                    else:
                        _log_thread(logging.WARNING, "Branding ƒë∆∞·ª£c b·∫≠t (ch·ªâ sub) nh∆∞ng kh√¥ng c√≥ video h·ª£p l·ªá ƒë·ªÉ √°p d·ª•ng.")
                elif branding_enabled_for_this_task and self.pending_auto_dub_after_current_sub_batch:
                     _log_thread(logging.INFO, "Branding ƒë∆∞·ª£c b·∫≠t NH∆ØNG ƒëang ch·ªù dub. S·∫Ω KH√îNG √°p d·ª•ng branding ·ªü b∆∞·ªõc sub n√†y.")


                # C·∫≠p nh·∫≠t final_sub_path_for_this_file (cho logic ·ªü finally)
                final_sub_path_for_this_file = final_sub_path_for_display
                # video_output_for_this_file ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t n·∫øu c√≥ merge/brand
                success_for_this_file = True # N·∫øu ƒë·∫øn ƒë√¢y m√† kh√¥ng c√≥ l·ªói nghi√™m tr·ªçng th√¨ coi nh∆∞ th√†nh c√¥ng ph·∫ßn sub

            except ValueError as ve:
                if "NoAudioStreamError" in str(ve):
                    _log_thread(logging.WARNING, f"X·ª≠ l√Ω file '{os.path.basename(input_file)}' b·ªã b·ªè qua do kh√¥ng c√≥ audio.")
                else:
                    _log_thread(logging.ERROR, f"L·ªói gi√° tr·ªã trong qu√° tr√¨nh x·ª≠ l√Ω '{os.path.basename(input_file)}': {ve}", exc_info=True)
                    _show_error("L·ªói Gi√° Tr·ªã", f"L·ªói x·ª≠ l√Ω file {os.path.basename(input_file)}:\n{ve}")
                    _update_status(f"‚ùå L·ªói (Gi√° tr·ªã): {os.path.basename(input_file)}")
                success_for_this_file = False
            except InterruptedError as stop_e:
                _log_thread(logging.WARNING, f"T√°c v·ª• b·ªã gi√°n ƒëo·∫°n cho {input_file}: {stop_e}")
                _update_status(f"üõë ƒê√£ d·ª´ng: {os.path.basename(input_file)}")
                if temp_sub_path and os.path.exists(temp_sub_path):
                     if final_sub_path_for_display and os.path.exists(final_sub_path_for_display):
                        success_for_this_file = True
                        final_sub_path_for_this_file = final_sub_path_for_display
                elif temp_sub_path and os.path.exists(temp_sub_path):
                     logging.info(f"D·ª´ng t√°c v·ª•, nh∆∞ng file t·∫°m Whisper '{temp_sub_path}' t·ªìn t·∫°i. Xem x√©t l∆∞u l·∫°i.")
                success_for_this_file = False # N·∫øu b·ªã d·ª´ng gi·ªØa ch·ª´ng th√¨ coi nh∆∞ ch∆∞a th√†nh c√¥ng ho√†n to√†n
            except FileNotFoundError as fnf_e:
                _log_thread(logging.ERROR, f"L·ªói kh√¥ng t√¨m th·∫•y file trong qu√° tr√¨nh x·ª≠ l√Ω '{os.path.basename(input_file)}': {fnf_e}")
                _show_error("L·ªói File", f"L·ªói x·ª≠ l√Ω file {os.path.basename(input_file)}:\n{fnf_e}")
                _update_status(f"‚ùå L·ªói (File): {os.path.basename(input_file)}")
                success_for_this_file = False
            except Exception as e:
                _log_thread(logging.ERROR, f"üí• L·ªói nghi√™m tr·ªçng khi x·ª≠ l√Ω {input_file}: {e}", exc_info=True)
                _show_error("L·ªói X·ª≠ l√Ω Nghi√™m tr·ªçng", f"L·ªói kh√¥ng mong mu·ªën khi x·ª≠ l√Ω file:\n{os.path.basename(input_file)}\n\nL·ªói chi ti·∫øt: {str(e)[:100]}...")
                _update_status(f"‚ùå L·ªói nghi√™m tr·ªçng: {os.path.basename(input_file)}")
                success_for_this_file = False
            finally:
                # === B∆Ø·ªöC D·ªåN D·∫∏P FILE T·∫†M C·ª¶A VAD ===
                # Bi·∫øn temp_files_for_vad ƒë√£ ƒë∆∞·ª£c t·∫°o v√† th√™m file ·ªü B∆∞·ªõc 3
                if 'temp_files_for_vad' in locals() and temp_files_for_vad:
                    _log_thread(logging.INFO, f"B·∫Øt ƒë·∫ßu d·ªçn d·∫πp {len(temp_files_for_vad)} file t·∫°m c·ªßa VAD...")
                    for temp_file in temp_files_for_vad:
                        if temp_file and os.path.exists(temp_file):
                            try:
                                os.remove(temp_file)
                                _log_thread(logging.DEBUG, f"ƒê√£ x√≥a file t·∫°m VAD: {os.path.basename(temp_file)}")
                            except Exception as e_del:
                                _log_thread(logging.warning, f"L·ªói khi x√≥a file t·∫°m VAD '{os.path.basename(temp_file)}': {e_del}")
                # === K·∫æT TH√öC B∆Ø·ªöC D·ªåN D·∫∏P ===
                
                _log_thread(logging.DEBUG, f"V√†o kh·ªëi finally c·ªßa t√°c v·ª• cho {os.path.basename(input_file)}")

                if temp_sub_path and os.path.exists(temp_sub_path) and os.path.dirname(temp_sub_path) == self.temp_folder:
                    try:
                        os.remove(temp_sub_path)
                        _log_thread(logging.INFO, f"ƒê√£ x√≥a file sub t·∫°m (t·ª´ Whisper): {temp_sub_path}")
                    except OSError as del_e:
                        _log_thread(logging.warning, f"Kh√¥ng th·ªÉ x√≥a file sub t·∫°m '{temp_sub_path}': {del_e}")

                if hasattr(self, 'sub_pause_selected_media_path') and self.sub_pause_selected_media_path: 
                    path_to_check_and_delete = self.sub_pause_selected_media_path 
                    is_temp_slideshow = False 
                    if "sub_pause_slideshow_" in os.path.basename(path_to_check_and_delete).lower() or \
                       (hasattr(self, 'temp_folder') and os.path.dirname(path_to_check_and_delete) == self.temp_folder): 
                        is_temp_slideshow = True 
                    should_delete_slideshow_now = True 
                    if self.pending_auto_dub_after_current_sub_batch and is_temp_slideshow: 
                        should_delete_slideshow_now = False 
                    if is_temp_slideshow and os.path.exists(path_to_check_and_delete) and should_delete_slideshow_now: 
                        try: os.remove(path_to_check_and_delete) 
                        except Exception: pass
                    self.sub_pause_selected_media_path = None

                if success_for_this_file and final_sub_path_for_this_file and \
                   os.path.exists(final_sub_path_for_this_file) and not self.stop_event.is_set():
                    try:
                        with open(final_sub_path_for_this_file, "r", encoding="utf-8") as f_final_read: content = f_final_read.read()
                        self.after(0, lambda c=content: self.show_sub_in_textbox(c))
                    except Exception as read_e_final:
                        _log_thread(logging.warning, f"Kh√¥ng th·ªÉ ƒë·ªçc/hi·ªÉn th·ªã sub cu·ªëi c√πng '{final_sub_path_for_this_file}': {read_e_final}")
                
                # === PH·∫¶N C·∫¨P NH·∫¨T LOGIC TRUY·ªÄN D·ªÆ LI·ªÜU CHO DUBBING ===
                if self.pending_auto_dub_after_current_sub_batch and \
                   success_for_this_file and \
                   final_sub_path_for_this_file and os.path.exists(final_sub_path_for_this_file):

                    video_to_add_to_dub_chain = None
                    # X√°c ƒë·ªãnh video ƒë√£ qua b∆∞·ªõc merge/brand (n·∫øu c√≥), ho·∫∑c video g·ªëc
                    if video_path_for_dub_if_no_branding_in_sub_step and os.path.exists(video_path_for_dub_if_no_branding_in_sub_step):
                        video_to_add_to_dub_chain = video_path_for_dub_if_no_branding_in_sub_step
                    elif video_output_for_this_file and os.path.exists(video_output_for_this_file): # Video sau merge
                        video_to_add_to_dub_chain = video_output_for_this_file
                    elif os.path.exists(input_file): # Fallback
                        video_to_add_to_dub_chain = input_file
                    
                    _log_thread(logging.INFO, f"DEBUG_PENDING_DUB (finally): final_sub_path_for_this_file = {final_sub_path_for_this_file}")
                    _log_thread(logging.INFO, f"DEBUG_PENDING_DUB (finally): path_to_original_whisper_srt_for_tts = {path_to_original_whisper_srt_for_tts if path_to_original_whisper_srt_for_tts is not None else 'Kh√¥ng c√≥ ho·∫∑c None'}")

                    if video_to_add_to_dub_chain:
                        is_optimize_voice_enabled_for_this_task = cfg_snapshot.get("optimize_whisper_tts_voice", False)
                        _log_thread(logging.INFO, f"DEBUG_PENDING_DUB (finally): is_optimize_voice_enabled_for_this_task = {is_optimize_voice_enabled_for_this_task}")
                        
                        srt_for_tts_actual_path = None
                        if is_optimize_voice_enabled_for_this_task and \
                           path_to_original_whisper_srt_for_tts and \
                           os.path.exists(path_to_original_whisper_srt_for_tts):
                            srt_for_tts_actual_path = path_to_original_whisper_srt_for_tts
                            _log_thread(logging.INFO, f"   S·∫Ω d√πng file G·ªêC WHISPER cho TTS: '{os.path.basename(srt_for_tts_actual_path)}'")
                        else:
                            srt_for_tts_actual_path = final_sub_path_for_this_file 
                            _log_thread(logging.INFO, f"   S·∫Ω d√πng file HI·ªÇN TH·ªä cho TTS: '{os.path.basename(srt_for_tts_actual_path)}' (L√Ω do: optimize_flag={is_optimize_voice_enabled_for_this_task}, original_tts_path_valid={(path_to_original_whisper_srt_for_tts and os.path.exists(path_to_original_whisper_srt_for_tts))})")

                        script_data_for_dub_item = {
                            'display_srt_path': final_sub_path_for_this_file,
                            'tts_srt_path': srt_for_tts_actual_path,
                        }

                        display_name_for_queue = os.path.basename(final_sub_path_for_this_file)
                        if is_optimize_voice_enabled_for_this_task and \
                           script_data_for_dub_item.get('tts_srt_path') != script_data_for_dub_item.get('display_srt_path'):
                            display_name_for_queue += " (TTS t·ªëi ∆∞u)"

                        self.files_for_chained_dubbing.append({
                            'identifier': identifier,
                            'video_to_dub': video_to_add_to_dub_chain,
                            'script_content_type': 'dual_srt_paths', 
                            'script_data': script_data_for_dub_item,
                            'script_display_name_override': display_name_for_queue,
                            'original_downloaded_video': input_file, 
                            'optimize_whisper_tts_voice_enabled': is_optimize_voice_enabled_for_this_task
                        })
                        
                        _log_thread(logging.INFO, f"Chain D-S-D/S-D: ƒê√£ th√™m v√†o h√†ng ch·ªù dub. "
                                                  f"Video: '{os.path.basename(video_to_add_to_dub_chain)}', "
                                                  f"ScriptData: {script_data_for_dub_item}, " 
                                                  f"OptimizeFlagForThisTask: {is_optimize_voice_enabled_for_this_task}")
                    else:
                        _log_thread(logging.warning, f"Chain D-S-D/S-D: Kh√¥ng th·ªÉ th√™m v√†o h√†ng ch·ªù dub do thi·∫øu video h·ª£p l·ªá "
                                                     f"cho file sub '{os.path.basename(final_sub_path_for_this_file if final_sub_path_for_this_file else 'N/A')}'.")

                if success_for_this_file and task_object:
                    task_object['final_video_path'] = video_output_for_this_file 
                    task_object['final_srt_path'] = final_sub_path_for_this_file   
                    logging.info(f"ƒê√£ c·∫≠p nh·∫≠t Task Object (ID: {identifier}) v·ªõi k·∫øt qu·∫£ c·ªßa b∆∞·ªõc Sub.")

                    is_dub_pending = self.pending_auto_dub_after_current_sub_batch
                    
                    # We need to know if branding will be triggered for this file.
                    branding_will_be_triggered = (
                        branding_enabled_for_this_task and not is_dub_pending
                    )

                    # Ch·ªâ th√™m v√†o h√†ng ch·ªù upload ·ªû B∆Ø·ªöC N√ÄY n·∫øu ƒë√¢y l√† b∆∞·ªõc cu·ªëi c√πng 
                    # (t·ª©c l√† kh√¥ng c√≥ dubbing V√Ä c≈©ng kh√¥ng c√≥ branding theo sau).
                    if not is_dub_pending and not branding_will_be_triggered:
                        logging.info(f"Kh√¥ng c√≥ b∆∞·ªõc Dub/Brand n√†o ch·ªù. Th√™m Task Object v√†o h√†ng ch·ªù Upload ngay.")
                        # H√†m n√†y s·∫Ω t·ª± ki·ªÉm tra xem checkbox "T·ª± ƒë·ªông Upload" c√≥ ƒë∆∞·ª£c b·∫≠t hay kh√¥ng
                        self._add_completed_video_to_upload_queue(task_object)
                    else:
                        reason = "ƒêang ch·ªù b∆∞·ªõc Dubbing" if is_dub_pending else "ƒêang ch·ªù b∆∞·ªõc Branding"
                        logging.info(f"{reason}. S·∫Ω KH√îNG th√™m v√†o h√†ng ch·ªù Upload ·ªü b∆∞·ªõc Sub n√†y.")

                if should_call_original_callback_directly:
                    if not self.stop_event.is_set():
                        if success_for_this_file:
                            _update_status(f"‚úÖ Ho√†n th√†nh (Sub): {os.path.basename(input_file)}")
                    self.after(10, callback) 
                
                _log_thread(logging.INFO, f"K·∫øt th√∫c x·ª≠ l√Ω task_subtitle_threaded cho {os.path.basename(input_file)}. "
                                          f"Success for this file: {success_for_this_file}. "
                                          f"Branding ƒë∆∞·ª£c g·ªçi cho b∆∞·ªõc sub n√†y: {not should_call_original_callback_directly}.")


#----------------
# H√†m logic (ch·∫°y trong lu·ªìng): Quy tr√¨nh x·ª≠ l√Ω audio th√†nh video
    def _task_audio_to_video_threaded(self, task_object, cfg_snapshot_from_caller, callback):
        """
        (PHI√äN B·∫¢N N√ÇNG C·∫§P)
        Lu·ªìng worker x·ª≠ l√Ω to√†n b·ªô quy tr√¨nh t·ª´ audio -> video.
        - T√≠ch h·ª£p logic retry m·∫°nh m·∫Ω v√† timeout cho Gemini.
        - T·ª∞ ƒê·ªòNG FALLBACK v·ªÅ k·ªãch b·∫£n Whisper g·ªëc n·∫øu Gemini l·ªói, ƒë·∫£m b·∫£o quy tr√¨nh kh√¥ng b·ªã ch·∫∑n.
        - Hi·ªÉn th·ªã th√¥ng b√°o l·ªói kh√¥ng ch·∫∑n (non-blocking) khi fallback.
        """
        thread_name = threading.current_thread().name
        log_prefix = f"[{thread_name}_AudioToVideo_v2.0]" # TƒÉng version log
        logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu quy tr√¨nh Audio-to-Video...")

        input_audio_file = task_object.get('source')
        
        try:
            # B∆∞·ªõc 1.5: Kh·ªüi ƒë·ªông timer v√† tr·∫°ng th√°i "b·∫≠n"
            self.is_subbing = True 
            self.start_time = time.time()
            self.after(1000, self.update_time_realtime)            
            self.current_audio_for_muxing = input_audio_file 
            self.current_audio_to_video_task = task_object

            # B∆∞·ªõc 2: Ch·∫°y Whisper (v·ªõi logic chia file t·ª± ƒë·ªông)
            MAX_DURATION_SECONDS_AUDIO = 1800 # 30 ph√∫t
            file_duration_s_audio = (self.dub_get_audio_duration_ms(input_audio_file) or 0) / 1000.0

            whisper_srt_path = None

            if file_duration_s_audio > MAX_DURATION_SECONDS_AUDIO:
                logging.info(f"{log_prefix} File audio '{os.path.basename(input_audio_file)}' d√†i ({file_duration_s_audio:.0f}s), s·∫Ω t·ª± ƒë·ªông chia nh·ªè.")
                self.after(0, lambda: self.update_status(f"‚è≥ ƒêang chia file audio d√†i: {os.path.basename(input_audio_file)}..."))
                
                temp_split_folder_audio = os.path.join(self.temp_folder, f"split_{task_object.get('identifier', 'audio_task')}")
                os.makedirs(temp_split_folder_audio, exist_ok=True)
                
                audio_parts = ffmpeg_split_media(input_audio_file, temp_split_folder_audio, MAX_DURATION_SECONDS_AUDIO)
                
                if not audio_parts: raise RuntimeError("Kh√¥ng th·ªÉ chia file audio th√†nh c√°c ph·∫ßn nh·ªè.")

                srt_parts_audio = []
                for i, part_path_audio in enumerate(audio_parts):
                    if self.stop_event.is_set(): raise InterruptedError("D·ª´ng trong l√∫c x·ª≠ l√Ω c√°c file audio con.")
                    self.after(0, lambda i=i, total=len(audio_parts), name=os.path.basename(part_path_audio): self.update_status(f"‚è≥ Sub (audio) ph·∫ßn {i+1}/{total}: {name}..."))
                    
                    part_srt_path_audio = self.run_whisper_engine(part_path_audio, cfg_snapshot_from_caller.get('model', 'medium'), 'srt', cfg_snapshot_from_caller.get('language', 'auto'), temp_split_folder_audio)
                    if not part_srt_path_audio: raise RuntimeError(f"Whisper th·∫•t b·∫°i khi x·ª≠ l√Ω file audio con: {os.path.basename(part_path_audio)}")
                    srt_parts_audio.append(part_srt_path_audio)
                
                self.after(0, lambda: self.update_status(f"‚è≥ ƒêang gh√©p {len(srt_parts_audio)} file ph·ª• ƒë·ªÅ..."))
                merged_srt_filename_audio = f"{task_object.get('identifier', 'audio_task')}_merged.srt"
                whisper_srt_path = os.path.join(self.temp_folder, merged_srt_filename_audio)
                
                if not self._merge_srt_files(srt_parts_audio, audio_parts, whisper_srt_path): raise RuntimeError("Kh√¥ng th·ªÉ gh√©p c√°c file ph·ª• ƒë·ªÅ con (t·ª´ audio).")
                shutil.rmtree(temp_split_folder_audio, ignore_errors=True)
            else:
                if self.stop_event.is_set(): raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng tr∆∞·ªõc Whisper.")
                self.after(0, lambda: self.update_status(f"‚è≥ ƒêang Sub (Whisper): {os.path.basename(input_audio_file)}"))
                whisper_srt_path = self.run_whisper_engine(input_audio_file, cfg_snapshot_from_caller.get('model', 'medium'), 'srt', cfg_snapshot_from_caller.get('language', 'auto'), self.temp_folder)

            if not whisper_srt_path or not os.path.exists(whisper_srt_path): raise FileNotFoundError("Whisper kh√¥ng t·∫°o ƒë∆∞·ª£c file ph·ª• ƒë·ªÅ.")
            
            logging.info(f"{log_prefix} Whisper ho√†n th√†nh. SRT cu·ªëi c√πng (t·ª´ file g·ªëc ho·∫∑c gh√©p): {whisper_srt_path}")
            with open(whisper_srt_path, "r", encoding="utf-8-sig") as f: content_whisper = f.read()
            self.after(0, self.show_sub_in_textbox, content_whisper)

            # B∆∞·ªõc 3: Bi√™n t·∫≠p b·∫±ng Gemini (ƒê√É N√ÇNG C·∫§P V·ªöI RETRY V√Ä FALLBACK)
            logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu b∆∞·ªõc bi√™n t·∫≠p k·ªãch b·∫£n b·∫±ng Gemini cho file: {os.path.basename(input_audio_file)}")
            
            plain_text_for_editing = extract_dialogue_from_srt_string(content_whisper)
            if not plain_text_for_editing: raise ValueError("Kh√¥ng tr√≠ch xu·∫•t ƒë∆∞·ª£c l·ªùi tho·∫°i t·ª´ SRT.")
            
            # --- B·∫ÆT ƒê·∫¶U KH·ªêI LOGIC GEMINI M·ªöI ---
            final_content_for_chain = None # S·∫Ω ch·ª©a k·ªãch b·∫£n cu·ªëi c√πng ƒë·ªÉ ƒë∆∞a v√†o chu·ªói
            
            try:
                import google.generativeai as genai
                from google.api_core import exceptions as google_api_exceptions

                editing_prompt = AIEditorTab.DEFAULT_AI_EDITOR_PROMPT
                genai.configure(api_key=self.gemini_key_var.get())
                model = genai.GenerativeModel(self.gemini_model_for_script_editing_var.get())
                full_prompt_for_editing = (f"{editing_prompt}\n\nN·ªôi dung k·ªãch b·∫£n g·ªëc ƒë·ªÉ bi√™n t·∫≠p:\n---\n{plain_text_for_editing}\n---")

                max_retries = 2
                retry_delay_seconds = 10
                gemini_edited_content = None
                
                for attempt in range(max_retries + 1):
                    if self.stop_event.is_set(): raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
                    self.after(0, lambda a=attempt+1, b=max_retries+1: self.update_status(f"‚úç Gemini: Bi√™n t·∫≠p '{os.path.basename(input_audio_file)}' (Th·ª≠ {a}/{b})..."))
                    
                    try:
                        response = model.generate_content(
                            full_prompt_for_editing,
                            request_options={"timeout": 300} # Timeout 5 ph√∫t
                        )
                        if response.parts:
                            self._track_api_call(service_name="gemini_calls", units=1)
                            parsed_parts = parse_ai_response(response.text)
                            gemini_edited_content = parsed_parts.get("content")
                            if not gemini_edited_content: 
                                raise ValueError("Gemini kh√¥ng tr·∫£ v·ªÅ n·ªôi dung bi√™n t·∫≠p sau khi parse.")
                            logging.info(f"[{thread_name}] Gemini bi√™n t·∫≠p th√†nh c√¥ng ·ªü l·∫ßn th·ª≠ {attempt + 1}.")
                            break 
                        else:
                            block_reason = "Kh√¥ng r√µ"
                            if hasattr(response, 'prompt_feedback') and hasattr(response.prompt_feedback, 'block_reason') and response.prompt_feedback.block_reason:
                                block_reason = response.prompt_feedback.block_reason.name
                            raise RuntimeError(f"Y√™u c·∫ßu bi√™n t·∫≠p k·ªãch b·∫£n ƒë√£ b·ªã Gemini ch·∫∑n (L√Ω do: {block_reason})")
                    except (google_api_exceptions.InternalServerError, google_api_exceptions.ResourceExhausted, google_api_exceptions.ServiceUnavailable) as e_retryable:
                        logging.warning(f"[{thread_name}] G·∫∑p l·ªói c√≥ th·ªÉ th·ª≠ l·∫°i ({type(e_retryable).__name__}) ·ªü l·∫ßn th·ª≠ {attempt + 1}. L·ªói: {e_retryable}")
                        if attempt < max_retries:
                            self.after(0, lambda d=retry_delay_seconds: self.update_status(f"‚ö†Ô∏è L·ªói Gemini t·∫°m th·ªùi, th·ª≠ l·∫°i sau {d}s..."))
                            time.sleep(retry_delay_seconds)
                            retry_delay_seconds *= 2 
                        else:
                            logging.error(f"[{thread_name}] V·∫´n g·∫∑p l·ªói sau {max_retries + 1} l·∫ßn th·ª≠. S·∫Ω fallback.")
                            break
                
                if gemini_edited_content:
                    final_content_for_chain = gemini_edited_content
                    logging.info(f"{log_prefix} S·ª≠ d·ª•ng k·ªãch b·∫£n ƒë√£ ƒë∆∞·ª£c Gemini bi√™n t·∫≠p.")
                else:
                    raise RuntimeError("Kh√¥ng th·ªÉ l·∫•y k·∫øt qu·∫£ bi√™n t·∫≠p t·ª´ Gemini sau t·∫•t c·∫£ c√°c l·∫ßn th·ª≠.")

            except Exception as e_gemini_block:
                logging.warning(f"{log_prefix} To√†n b·ªô kh·ªëi bi√™n t·∫≠p Gemini th·∫•t b·∫°i: {e_gemini_block}. S·∫º FALLBACK V·ªÄ K·ªäCH B·∫¢N WHISPER G·ªêC.")
                
                # Hi·ªÉn th·ªã th√¥ng b√°o kh√¥ng ch·∫∑n cho ng∆∞·ªùi d√πng
                fallback_error_msg = f"L·ªói bi√™n t·∫≠p Gemini cho '{os.path.basename(input_audio_file)}':\n\n{str(e_gemini_block)[:200]}\n\nS·∫Ω ti·∫øp t·ª•c v·ªõi k·ªãch b·∫£n g·ªëc t·ª´ Whisper."
                self.after(0, self._show_non_blocking_error_popup, "L·ªói Bi√™n t·∫≠p Gemini (Fallback)", fallback_error_msg, failed_item_identifier=input_audio_file)
                
                # S·ª≠ d·ª•ng k·ªãch b·∫£n g·ªëc t·ª´ Whisper
                final_content_for_chain = plain_text_for_editing
            
            # --- K·∫æT TH√öC KH·ªêI LOGIC GEMINI M·ªöI ---

            # B∆∞·ªõc 4: Chuy·ªÉn giao cho chu·ªói t·∫°o ·∫£nh
            logging.info(f"{log_prefix} B·∫Øt ƒë·∫ßu chuy·ªÉn giao sang chu·ªói t·∫°o ·∫£nh.")
            base_filename_for_chain = get_identifier_from_source(input_audio_file)
            character_sheet_text = self.cfg.get("imagen_last_character_sheet", "")
            
            self._handle_gemini_script_editing_result_for_chain(
                processed_script=final_content_for_chain, # D√πng k·ªãch b·∫£n cu·ªëi c√πng (ƒë√£ bi√™n t·∫≠p ho·∫∑c fallback)
                error_message=None, # Lu√¥n l√† None v√¨ ƒë√£ x·ª≠ l√Ω l·ªói v√† fallback
                target_widget=self.subtitle_textbox,
                context="audio_to_video_chain",
                trigger_imagen_chain_flag=True,
                trigger_dub_chain_flag=False,
                selected_model=self.gemini_model_for_script_editing_var.get(),
                original_input_script=content_whisper,
                character_sheet_text=character_sheet_text,
                base_filename_for_chain=base_filename_for_chain
            )
            task_object['handoff_successful'] = True

        except Exception as e:
            logging.error(f"[{thread_name}] L·ªói trong quy tr√¨nh Audio-to-Video cho file '{input_audio_file}': {e}", exc_info=True)
            self.after(0, lambda: self.update_status(f"‚ùå L·ªói x·ª≠ l√Ω audio: {os.path.basename(input_audio_file)}"))
            self.after(0, self._show_non_blocking_error_popup, "L·ªói Quy tr√¨nh Audio > Video", f"ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω file:\n'{os.path.basename(input_audio_file)}'\n\nL·ªói: {str(e)[:200]}...", failed_item_identifier=input_audio_file)
        
        finally:
            if not task_object.get('handoff_successful', False):
                logging.info(f"[{thread_name}] Ho√†n t·∫•t x·ª≠ l√Ω (nh∆∞ng kh√¥ng chuy·ªÉn giao) cho file: {os.path.basename(input_audio_file)}. G·ªçi callback.")
                if callback: self.after(0, callback)
            else:
                logging.info(f"[{thread_name}] ƒê√£ chuy·ªÉn giao th√†nh c√¥ng cho chu·ªói AI, kh√¥ng g·ªçi callback tr·ª±c ti·∫øp t·ª´ ƒë√¢y.")


# Th·ª±c hi·ªán c√°c b∆∞·ªõc cu·ªëi c√πng cho quy tr√¨nh Audio > Video:
    def _execute_final_mux_and_branding_thread(self, task_object, hardsubbed_video_path):
        """
        (Lu·ªìng Worker) Th·ª±c hi·ªán c√°c b∆∞·ªõc cu·ªëi c√πng cho quy tr√¨nh Audio > Video:
        1. Gh√©p audio g·ªëc v√†o video ƒë√£ hardsub.
        2. √Åp d·ª•ng branding (n·∫øu c√≥).
        3. Th√™m v√†o h√†ng ch·ªù upload (n·∫øu c√≥).
        4. G·ªçi callback ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo trong h√†ng ch·ªù ch√≠nh.
        """
        thread_name_mux = threading.current_thread().name
        log_prefix_mux = f"[{thread_name_mux}]"
        logging.info(f"{log_prefix_mux} B·∫Øt ƒë·∫ßu lu·ªìng gh√©p audio cu·ªëi c√πng v√† branding...")

        final_video_path_for_next_step = None
        
        try:
            # === B∆∞·ªõc 1: Gh√©p Audio ===
            original_audio_path = task_object.get('source')
            if not (hardsubbed_video_path and os.path.exists(hardsubbed_video_path) and original_audio_path and os.path.exists(original_audio_path)):
                raise ValueError("Thi·∫øu file video hardsub ho·∫∑c audio g·ªëc ƒë·ªÉ gh√©p.")

            self.after(0, lambda: self.update_status(f"üéß ƒêang gh√©p √¢m thanh v√† nh·∫°c n·ªÅn (n·∫øu c√≥)..."))
            
            bgm_action = self.dub_background_audio_option_var.get()
            mix_level = self.dub_background_mix_level_var.get()
            custom_bgm_path = self._get_bgm_path_for_task()
            custom_bgm_level = self.get_validated_custom_bg_volume_float()
            
            base_filename = task_object.get('identifier', 'audio_video_output')
            output_dir = os.path.dirname(hardsubbed_video_path)
            final_filename_with_audio = f"{base_filename}.mp4"
            final_output_path_with_audio = os.path.join(output_dir, final_filename_with_audio)

            mux_success = self.dub_ffmpeg_mux_video_audio(
                video_input_path=hardsubbed_video_path,
                dub_audio_path=original_audio_path,
                output_video_path=final_output_path_with_audio,
                action=bgm_action,
                original_audio_mix_level=mix_level,
                custom_bgm_path=custom_bgm_path,
                custom_bgm_level=custom_bgm_level,
                external_audio_path=None
            )

            if not mux_success:
                raise RuntimeError("Gh√©p √¢m thanh cu·ªëi c√πng th·∫•t b·∫°i.")
            
            logging.info(f"{log_prefix_mux} Gh√©p √¢m thanh th√†nh c√¥ng! Video t·∫°m th·ªùi: {final_output_path_with_audio}")
            task_object['final_video_path'] = final_output_path_with_audio
            final_video_path_for_next_step = final_output_path_with_audio

            # X√≥a file video hardsub kh√¥ng c√≥ ti·∫øng
            try:
                os.remove(hardsubbed_video_path)
                logging.info(f"{log_prefix_mux} ƒê√£ x√≥a file video trung gian (im l·∫∑ng): {os.path.basename(hardsubbed_video_path)}")
            except Exception as e_del:
                logging.warning(f"{log_prefix_mux} L·ªói khi x√≥a video trung gian: {e_del}")
            
            # === B∆∞·ªõc 2: X·ª≠ l√Ω Branding ===
            any_branding_enabled = self.branding_intro_enabled_var.get() or self.branding_outro_enabled_var.get() or self.branding_logo_enabled_var.get()
            if any_branding_enabled:
                logging.info(f"{log_prefix_mux} Branding ƒë∆∞·ª£c b·∫≠t. B·∫Øt ƒë·∫ßu lu·ªìng branding...")
                self.after(0, lambda: self.update_status(f"üé® Branding: {os.path.basename(final_output_path_with_audio)}..."))
                
                # T·∫°o m·ªôt Event ƒë·ªÉ ch·ªù branding ho√†n t·∫•t
                branding_done_event = threading.Event()
                branding_result = {} # Dictionary ƒë·ªÉ l∆∞u k·∫øt qu·∫£ t·ª´ callback

                def _callback_after_branding_sync(success, branded_path, error_msg, context_data):
                    branding_result['success'] = success
                    branding_result['path'] = branded_path
                    branding_result['error'] = error_msg
                    branding_done_event.set()

                context_for_branding = {
                    "source_view": "audio_to_video_final_brand",
                    "task_object": task_object,
                    "output_dir_override": os.path.dirname(hardsubbed_video_path) # <<< TH√äM D√íNG N√ÄY
                }
                
                self._start_branding_thread(
                    video_path_from_previous_step=final_output_path_with_audio,
                    callback_after_branding=_callback_after_branding_sync,
                    original_context_data=context_for_branding
                )
                
                # Ch·ªù cho ƒë·∫øn khi branding ho√†n t·∫•t
                branding_done_event.wait() 
                
                if branding_result.get('success'):
                    final_video_path_for_next_step = branding_result['path']
                    task_object['final_video_path'] = final_video_path_for_next_step # C·∫≠p nh·∫≠t l·∫°i ƒë∆∞·ªùng d·∫´n cu·ªëi
                else:
                    logging.warning(f"{log_prefix_mux} Branding th·∫•t b·∫°i: {branding_result.get('error')}. S·∫Ω d√πng video ch∆∞a branding.")
                    # final_video_path_for_next_step v·∫´n l√† video ƒë√£ gh√©p audio
            
            # === B∆∞·ªõc 3: Th√™m v√†o h√†ng ch·ªù Upload ===
            self._add_completed_video_to_upload_queue(task_object)
            
        except Exception as e:
            logging.error(f"{log_prefix_mux} L·ªói trong lu·ªìng gh√©p audio cu·ªëi c√πng: {e}", exc_info=True)
            self.after(0, lambda: self.update_status(f"‚ùå L·ªói gh√©p audio cu·ªëi: {str(e)[:50]}..."))
        finally:
            # === B∆∞·ªõc 4: G·ªçi callback ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo trong h√†ng ch·ªù ch√≠nh ===
            if hasattr(self, '_process_next_subtitle_file'):
                self.after(50, self._process_next_subtitle_file)
            
            # D·ªçn d·∫πp bi·∫øn t·∫°m
            self.current_audio_for_muxing = None
            self.current_audio_to_video_task = None



# √Ånh x·∫° l·∫°i vƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c bi√™n t·∫≠p v√†o timing c·ªßa file SRT g·ªëc. Audio > video
    def _map_new_text_to_old_srt(self, edited_plain_text, original_srt_path):
        """
        √Ånh x·∫° l·∫°i vƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c bi√™n t·∫≠p v√†o timing c·ªßa file SRT g·ªëc.
        S·ª≠ d·ª•ng pysubs2 ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh ch√≠nh x√°c.
        """
        try:
            # T·∫£i file SRT g·ªëc ƒë·ªÉ l·∫•y c·∫•u tr√∫c v√† timing
            subs = pysubs2.load(original_srt_path, encoding="utf-8")
            
            # T√°ch vƒÉn b·∫£n ƒë√£ bi√™n t·∫≠p th√†nh t·ª´ng d√≤ng
            edited_lines = [line.strip() for line in edited_plain_text.split('\n') if line.strip()]
            
            num_original_events = len(subs)
            num_edited_lines = len(edited_lines)

            if num_original_events == 0:
                logging.warning("[MapTiming] File SRT g·ªëc kh√¥ng c√≥ s·ª± ki·ªán n√†o ƒë·ªÉ √°nh x·∫°.")
                return "" # Tr·∫£ v·ªÅ chu·ªói r·ªóng

            logging.info(f"[MapTiming] B·∫Øt ƒë·∫ßu √°nh x·∫°. S·ªë s·ª± ki·ªán g·ªëc: {num_original_events}, S·ªë d√≤ng ƒë√£ bi√™n t·∫≠p: {num_edited_lines}.")

            # Logic √°nh x·∫°:
            # N·∫øu s·ªë d√≤ng m·ªõi v√† c≈© b·∫±ng nhau, thay th·∫ø 1:1.
            # N·∫øu kh√°c, gh√©p c√°c d√≤ng m·ªõi l·∫°i v√† ph√¢n b·ªï v√†o c√°c s·ª± ki·ªán c≈©.
            if num_edited_lines == num_original_events:
                logging.info("[MapTiming] S·ªë d√≤ng kh·ªõp, th·ª±c hi·ªán thay th·∫ø 1:1.")
                for i, event in enumerate(subs):
                    if not event.is_comment:
                        event.text = edited_lines[i]
            else:
                logging.warning(f"[MapTiming] S·ªë d√≤ng kh√¥ng kh·ªõp. S·∫Ω gh√©p {num_edited_lines} d√≤ng m·ªõi v√†o {num_original_events} s·ª± ki·ªán c≈©.")
                # Gh√©p t·∫•t c·∫£ c√°c d√≤ng ƒë√£ s·ª≠a th√†nh m·ªôt chu·ªói duy nh·∫•t
                full_edited_text = " ".join(edited_lines)
                
                # T√≠nh t·ªïng s·ªë k√Ω t·ª± ƒë·ªÉ ph√¢n b·ªï
                total_chars = len(full_edited_text)
                if total_chars == 0: return "" # Tr·∫£ v·ªÅ r·ªóng n·∫øu text sau khi s·ª≠a b·ªã r·ªóng

                start_index = 0
                for i, event in enumerate(subs):
                    if not event.is_comment:
                        # T√≠nh t·ª∑ l·ªá k√Ω t·ª± c·ªßa kh·ªëi g·ªëc so v·ªõi t·ªïng th·ªÉ
                        original_char_count = len(event.text)
                        
                        # ∆Ø·ªõc t√≠nh s·ªë k√Ω t·ª± c·∫ßn l·∫•y cho kh·ªëi n√†y t·ª´ vƒÉn b·∫£n ƒë√£ s·ª≠a
                        # (ƒê√¢y l√† m·ªôt c√°ch ∆∞·ªõc t√≠nh ƒë∆°n gi·∫£n, c√≥ th·ªÉ c·∫£i ti·∫øn sau)
                        estimated_chars_for_this_event = int((original_char_count / total_chars) * len(full_edited_text)) if total_chars > 0 else 0
                        
                        # ·ªû kh·ªëi cu·ªëi c√πng, l·∫•y h·∫øt ph·∫ßn c√≤n l·∫°i
                        if i == num_original_events - 1:
                            end_index = len(full_edited_text)
                        else:
                            end_index = start_index + estimated_chars_for_this_event
                            # T√¨m kho·∫£ng tr·∫Øng g·∫ßn nh·∫•t ƒë·ªÉ c·∫Øt cho ƒë·∫πp
                            end_index = full_edited_text.rfind(" ", start_index, end_index) + 1
                            if end_index == 0: # N·∫øu kh√¥ng t√¨m th·∫•y kho·∫£ng tr·∫Øng
                                end_index = start_index + estimated_chars_for_this_event

                        event.text = full_edited_text[start_index:end_index].strip()
                        start_index = end_index

            # Chuy·ªÉn ƒë·ªïi ƒë·ªëi t∆∞·ª£ng pysubs2 ƒë√£ c·∫≠p nh·∫≠t th√†nh chu·ªói SRT
            return subs.to_string(format_="srt")

        except Exception as e:
            logging.error(f"L·ªói nghi√™m tr·ªçng trong qu√° tr√¨nh √°nh x·∫° timing: {e}", exc_info=True)
            return None # Tr·∫£ v·ªÅ None ƒë·ªÉ b√°o hi·ªáu l·ªói


# S·ª≠ d·ª•ng FFmpeg ƒë·ªÉ gh√©p m·ªôt lu·ªìng video v√† m·ªôt lu·ªìng audio th√†nh file cu·ªëi c√πng.
    def _get_bgm_path_for_task(self):
        """
        Ki·ªÉm tra c√†i ƒë·∫∑t nh·∫°c n·ªÅn hi·ªán t·∫°i v√† tr·∫£ v·ªÅ m·ªôt ƒë∆∞·ªùng d·∫´n file nh·∫°c n·ªÅn
        c·ª• th·ªÉ ƒë·ªÉ s·ª≠ d·ª•ng cho t√°c v·ª•. X·ª≠ l√Ω c·∫£ tr∆∞·ªùng h·ª£p file ƒë∆°n v√† th∆∞ m·ª•c.
        """
        if not self.dub_use_custom_bg_music_var.get():
            return None

        # ∆Øu ti√™n th∆∞ m·ª•c n·∫øu ƒë∆∞·ª£c ch·ªçn
        folder_path = self.dub_custom_bg_music_folder_path_var.get()
        if folder_path and os.path.isdir(folder_path):
            music_files = self._prepare_bgm_list_from_folder(folder_path, self.dub_randomize_bg_music_var.get())
            if music_files:
                import random
                return random.choice(music_files) # Ch·ªçn ng·∫´u nhi√™n 1 file t·ª´ danh s√°ch ƒë√£ chu·∫©n b·ªã
            else:
                logging.warning("[GetBGM] Th∆∞ m·ª•c nh·∫°c n·ªÅn ƒë√£ ch·ªçn nh∆∞ng kh√¥ng c√≥ file h·ª£p l·ªá.")
                return None
        
        # N·∫øu kh√¥ng c√≥ th∆∞ m·ª•c, ki·ªÉm tra file ƒë∆°n l·∫ª
        single_file_path = self.dub_custom_bg_music_path_var.get()
        if single_file_path and os.path.exists(single_file_path):
            return single_file_path

        logging.warning("[GetBGM] ƒê√£ b·∫≠t nh·∫°c n·ªÅn t√πy ch·ªânh nh∆∞ng kh√¥ng c√≥ file hay th∆∞ m·ª•c h·ª£p l·ªá n√†o ƒë∆∞·ª£c ch·ªçn.")
        return None

        

# H√ÄM M·ªöI 2: Gh√©p nhi·ªÅu file SRT l·∫°i th√†nh m·ªôt, ƒëi·ªÅu ch·ªânh timing ch√≠nh x√°c

    def _merge_srt_files(self, list_of_srt_paths, list_of_media_part_paths, final_merged_srt_path):
        """
        Gh√©p nhi·ªÅu file SRT l·∫°i th√†nh m·ªôt, ƒëi·ªÅu ch·ªânh timing ch√≠nh x√°c.
        """
        log_prefix = f"[{threading.current_thread().name}_MergeSRTs]"
        if not list_of_srt_paths:
            logging.error(f"{log_prefix} Danh s√°ch file SRT r·ªóng, kh√¥ng th·ªÉ gh√©p.")
            return False
            
        try:
            # T·∫£i file SRT ƒë·∫ßu ti√™n l√†m file c∆° s·ªü
            final_subs = pysubs2.load(list_of_srt_paths[0])
            
            time_offset_seconds = 0.0
            
            # L·∫∑p t·ª´ file media th·ª© hai tr·ªü ƒëi ƒë·ªÉ t√≠nh to√°n offset
            for i in range(len(list_of_media_part_paths) - 1):
                # L·∫•y th·ªùi l∆∞·ª£ng c·ªßa ph·∫ßn media hi·ªán t·∫°i ƒë·ªÉ l√†m offset cho ph·∫ßn ti·∫øp theo
                duration_of_current_part = get_video_duration_s(list_of_media_part_paths[i])
                if duration_of_current_part > 0:
                    time_offset_seconds += duration_of_current_part
                else:
                    logging.warning(f"{log_prefix} Kh√¥ng l·∫•y ƒë∆∞·ª£c th·ªùi l∆∞·ª£ng c·ªßa '{os.path.basename(list_of_media_part_paths[i])}'. Timing c√≥ th·ªÉ kh√¥ng ch√≠nh x√°c.")

                # T·∫£i file SRT ti·∫øp theo v√† d·ªãch chuy·ªÉn timing
                if i + 1 < len(list_of_srt_paths):
                    subs_to_append = pysubs2.load(list_of_srt_paths[i + 1])
                    subs_to_append.shift(s=time_offset_seconds)
                    final_subs.extend(subs_to_append)

            # S·∫Øp x·∫øp l·∫°i t·∫•t c·∫£ c√°c s·ª± ki·ªán v√† l∆∞u file cu·ªëi c√πng
            final_subs.sort()
            final_subs.save(final_merged_srt_path, encoding="utf-8", format_="srt")
            logging.info(f"{log_prefix} ƒê√£ gh√©p {len(list_of_srt_paths)} file SRT th√†nh c√¥ng -> {os.path.basename(final_merged_srt_path)}")
            return True
            
        except Exception as e:
            logging.error(f"{log_prefix} L·ªói nghi√™m tr·ªçng khi gh√©p file SRT: {e}", exc_info=True)
            return False
            
# --------------------
# 4.7 Logic C·ªët l√µi - H√†m H·ªó tr·ª£ X·ª≠ l√Ω Subtitle (Whisper, Chia, D·ªãch, G·ªôp)
# --------------------

    # H√†m logic: Ch·∫°y model Whisper ƒë·ªÉ t·∫°o ph·ª• ƒë·ªÅ t·ª´ file media    
    def run_whisper_engine(self, input_file, model_name, fmt, lang, output_dir):
        """
        Ch·∫°y Whisper transcription b·∫±ng model ƒë√£ ƒë∆∞·ª£c load l√™n device c·ª• th·ªÉ.
        H√†m n√†y kh√¥ng t·ª± quy·∫øt ƒë·ªãnh device n·ªØa m√† d·ª±a v√†o self.loaded_model_device.
        """
        # Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán c·∫ßn thi·∫øt
        if self.whisper_model is None:
            # Ghi log r√µ h∆°n t√™n model ƒëang ƒë∆∞·ª£c mong ƒë·ª£i nh∆∞ng ch∆∞a load
            current_expected_model = self.model_var.get()
            logging.error(f"Model Whisper '{current_expected_model}' ch∆∞a ƒë∆∞·ª£c load v√†o self.whisper_model.")
            raise RuntimeError(f"Model Whisper '{current_expected_model}' ch∆∞a ƒë∆∞·ª£c load.")
        if not HAS_WHISPER:
             logging.error("Th∆∞ vi·ªán Whisper ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t.")
             raise RuntimeError("Th∆∞ vi·ªán Whisper ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t.")
        if self.loaded_model_device is None:
             logging.error("Ch∆∞a x√°c ƒë·ªãnh ƒë∆∞·ª£c device m√† model ƒëang ch·∫°y tr√™n ƒë√≥ (self.loaded_model_device is None).")
             raise RuntimeError("Ch∆∞a x√°c ƒë·ªãnh ƒë∆∞·ª£c device model ƒëang ch·∫°y.")

        # --- ƒê·∫∑t transcribe_options d·ª±a tr√™n device model ƒëang ch·∫°y ---
        # N·∫øu model ƒëang ch·∫°y tr√™n CUDA, th√¨ b·∫≠t fp16
        use_fp16 = (self.loaded_model_device == 'cuda')

        transcribe_options = {
            'fp16': use_fp16,
            'patience': 2.0,
            'beam_size': 5,             
            'no_speech_threshold': 0.45, # Gi·ªØ nguy√™n ƒë·ªÉ t·∫°o kho·∫£ng ngh·ªâ
            'logprob_threshold': -0.8,  # Gi·ªØ nguy√™n ƒë·ªÉ tƒÉng ƒë·ªô ·ªïn ƒë·ªãnh
        }

        if lang != "auto":
            transcribe_options['language'] = lang
            
        # Ghi log chi ti·∫øt v·ªÅ t√°c v·ª• s·∫Øp th·ª±c hi·ªán
        logging.info(
            f"[{threading.current_thread().name}] "
            f"ƒêang ch·∫°y Whisper transcribe (Model: '{self.loaded_model_name}' "
            f"tr√™n Device: {self.loaded_model_device}, "
            f"fp16: {use_fp16}, lang: {lang}) "
            f"tr√™n file: {os.path.basename(input_file)}"
        )
        # --- Th·ª±c hi·ªán transcribe (Kh√¥ng truy·ªÅn device=...) ---
        try:
            # Model ƒë√£ n·∫±m tr√™n device ƒë√∫ng (do logic load model x·ª≠ l√Ω), ch·ªâ c·∫ßn g·ªçi transcribe
            # v·ªõi c√°c t√πy ch·ªçn decoding (nh∆∞ fp16, language)
            result = self.whisper_model.transcribe(input_file, **transcribe_options)
            logging.info(f"[{threading.current_thread().name}] Ho√†n t·∫•t t·∫°o ph·ª• ƒë·ªÅ. T√¨m th·∫•y {len(result.get('segments', []))} ƒëo·∫°n.")
        except Exception as transcribe_e:
             # B·∫Øt l·ªói c√≥ th·ªÉ x·∫£y ra trong qu√° tr√¨nh transcribe
             logging.error(f"[{threading.current_thread().name}] L·ªói trong qu√° tr√¨nh transcribe tr√™n device '{self.loaded_model_device}': {transcribe_e}", exc_info=True)
             # N√©m l·∫°i l·ªói ƒë·ªÉ lu·ªìng x·ª≠ l√Ω b√™n ngo√†i (task_subtitle_threaded) b·∫Øt ƒë∆∞·ª£c
             raise transcribe_e
        # --- K·∫øt th√∫c transcribe ---

        # --- ƒê·ªãnh d·∫°ng v√† l∆∞u file output (Gi·ªØ nguy√™n logic c≈©) ---
        base_name = os.path.splitext(os.path.basename(input_file))[0]
        sub_name = f"{base_name}.{fmt}"
        sub_path = os.path.join(output_dir, sub_name)
        # ƒê·∫£m b·∫£o th∆∞ m·ª•c output t·ªìn t·∫°i
        try:
             os.makedirs(output_dir, exist_ok=True)
        except OSError as mkdir_err:
             logging.error(f"Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c output '{output_dir}': {mkdir_err}")
             raise # Kh√¥ng th·ªÉ ti·∫øp t·ª•c n·∫øu kh√¥ng t·∫°o ƒë∆∞·ª£c th∆∞ m·ª•c

        # Ghi file output
        try:
            with open(sub_path, "w", encoding="utf-8") as f:
                if fmt == 'txt':
                    f.write(result["text"])
                elif fmt == 'srt':
                    write_srt(f, result['segments'])
                elif fmt == 'vtt':
                    write_vtt(f, result['segments'])
                else:
                    logging.warning(f"ƒê·ªãnh d·∫°ng '{fmt}' kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ ghi tr·ª±c ti·∫øp. ƒêang l∆∞u d∆∞·ªõi d·∫°ng TXT.")
                    f.write(result["text"])
            logging.info(f"[{threading.current_thread().name}] ƒê√£ ghi file ph·ª• ƒë·ªÅ: {sub_path}")
            return sub_path # Tr·∫£ v·ªÅ ƒë∆∞·ªùng d·∫´n file ƒë√£ t·∫°o
        except Exception as write_e:
            logging.error(f"[{threading.current_thread().name}] L·ªói khi ghi file ph·ª• ƒë·ªÅ '{sub_path}': {write_e}", exc_info=True)
            raise # N√©m l·∫°i l·ªói ghi file


#--------------------------
 # H√†m ti·ªán √≠ch UI Subtitle: B·∫≠t/t·∫Øt c√°c √¥ nh·∫≠p li·ªáu t√πy ch·ªçn g·ªôp kh·ªëi
    def _toggle_block_merge_options_state(self): # ƒê·∫£m b·∫£o c√≥ self
        """B·∫≠t ho·∫∑c t·∫Øt c√°c √¥ nh·∫≠p li·ªáu t√πy ch·ªçn g·ªôp kh·ªëi d·ª±a tr√™n checkbox."""
        try:
            entry_state = ctk.NORMAL if self.enable_block_merging_var.get() else ctk.DISABLED

            # Ki·ªÉm tra xem widget ƒë√£ ƒë∆∞·ª£c t·∫°o v√† g√°n cho self ch∆∞a
            if hasattr(self, 'merge_time_gap_entry') and self.merge_time_gap_entry and hasattr(self.merge_time_gap_entry, 'winfo_exists') and self.merge_time_gap_entry.winfo_exists():
                self.merge_time_gap_entry.configure(state=entry_state)
            # else: # Th√™m log ƒë·ªÉ debug n·∫øu c·∫ßn
            #     logging.warning("merge_time_gap_entry ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o ho·∫∑c kh√¥ng t·ªìn t·∫°i khi g·ªçi _toggle_block_merge_options_state")

            if hasattr(self, 'merge_max_len_entry') and self.merge_max_len_entry and hasattr(self.merge_max_len_entry, 'winfo_exists') and self.merge_max_len_entry.winfo_exists():
                self.merge_max_len_entry.configure(state=entry_state)
            # else: # Th√™m log ƒë·ªÉ debug n·∫øu c·∫ßn
            #     logging.warning("merge_max_len_entry ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o ho·∫∑c kh√¥ng t·ªìn t·∫°i khi g·ªçi _toggle_block_merge_options_state")

        except Exception as e:
            logging.error(f"L·ªói khi thay ƒë·ªïi tr·∫°ng th√°i t√πy ch·ªçn g·ªôp kh·ªëi: {e}", exc_info=True) # Th√™m exc_info=True


    # H√†m logic: Ti·ªÅn x·ª≠ l√Ω v√† g·ªôp c√°c kh·ªëi ph·ª• ƒë·ªÅ SRT li·ªÅn k·ªÅ m·ªôt c√°ch h·ª£p l√Ω
    def preprocess_and_merge_srt_blocks(self, srt_content_string):
        """
        Ph√¢n t√≠ch n·ªôi dung SRT, c·ªë g·∫Øng g·ªôp c√°c kh·ªëi li·ªÅn k·ªÅ h·ª£p l√Ω,
        v√† tr·∫£ v·ªÅ m·ªôt chu·ªói SRT m·ªõi ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω.
        (S·ª≠ d·ª•ng c√†i ƒë·∫∑t t·ª´ UI ƒë·ªÉ ƒëi·ªÅu khi·ªÉn vi·ªác g·ªôp v√† c√°c ng∆∞·ª°ng)
        """
        current_thread_name = threading.current_thread().name
        logging.debug(f"[{current_thread_name}] --- B·∫Øt ƒë·∫ßu SubtitleApp.preprocess_and_merge_srt_blocks (ƒê·ªçc c√†i ƒë·∫∑t t·ª´ UI) ---")

        # --- ƒê·ªçc c√†i ƒë·∫∑t g·ªôp kh·ªëi t·ª´ c√°c bi·∫øn c·ªßa UI ---
        try:
            enable_merging = self.enable_block_merging_var.get()
            
            user_max_time_gap_ms = safe_int(self.merge_max_time_gap_var.get(), 369)
            user_curr_max_len_normal = safe_int(self.merge_curr_max_len_normal_var.get(), 36)
            cfg_time_gap_short_next = self.cfg.get("merge_max_time_gap_short_next_ms", 400)
            cfg_curr_max_len_short_next = self.cfg.get("merge_curr_max_len_short_next", 100)
            cfg_next_very_short_len = self.cfg.get("merge_next_very_short_len", 9)

        except Exception as e_cfg_read:
            logging.error(f"[{current_thread_name}] L·ªói ƒë·ªçc c·∫•u h√¨nh g·ªôp kh·ªëi t·ª´ bi·∫øn UI: {e_cfg_read}. S·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh.")
            enable_merging = True # M·∫∑c ƒë·ªãnh b·∫≠t n·∫øu l·ªói ƒë·ªçc config
            user_max_time_gap_ms = 369
            user_curr_max_len_normal = 36
            cfg_time_gap_short_next = 400
            cfg_curr_max_len_short_next = 100
            cfg_next_very_short_len = 9

        if not enable_merging:
            logging.info(f"[{current_thread_name}] T√≠nh nƒÉng g·ªôp kh·ªëi ƒëang t·∫Øt (theo c√†i ƒë·∫∑t UI). B·ªè qua b∆∞·ªõc g·ªôp kh·ªëi.")
            return srt_content_string # Tr·∫£ v·ªÅ n·ªôi dung g·ªëc n·∫øu kh√¥ng b·∫≠t g·ªôp
        
        logging.info(f"[{current_thread_name}] B·∫≠t g·ªôp kh·ªëi. Ng∆∞·ª°ng t·ª´ UI/cfg: Gap_Normal={user_max_time_gap_ms}ms, Len_Normal={user_curr_max_len_normal} chars.")
        logging.debug(f"   Ng∆∞·ª°ng cho Chi·∫øn l∆∞·ª£c 0 (t·ª´ cfg/m·∫∑c ƒë·ªãnh): Gap_ShortNext={cfg_time_gap_short_next}ms, Len_ShortNext={cfg_curr_max_len_short_next} chars, NextVeryShortLen={cfg_next_very_short_len} chars.")

        subtitle_blocks = [] 
        normalized_content = srt_content_string.replace('\r\n', '\n').strip()

        srt_block_pattern = re.compile(
            r"(\d+)\s*\n"                                                       
            r"(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})\s*\n"  
            r"([\s\S]*?)"                                                       
            r"(?=\n\n|\n\d+\s*\n\d{2}:\d{2}:\d{2},\d{3}\s*-->|\Z)",             
            re.MULTILINE
        )

        logging.debug(f"[{current_thread_name}] ƒêang ph√¢n t√≠ch c√°c kh·ªëi SRT g·ªëc b·∫±ng finditer...")
        for match_idx, match in enumerate(srt_block_pattern.finditer(normalized_content)):
            try:
                index_str = match.group(1)
                start_tc_str = match.group(2)
                end_tc_str = match.group(3)
                text_content = match.group(4).strip() 
                if not text_content: continue
                start_ms = parse_timecode(start_tc_str) 
                end_ms = parse_timecode(end_tc_str)     
                if end_ms <= start_ms:
                    logging.warning(f"[{current_thread_name}]   B·ªè qua kh·ªëi (idx g·ªëc {index_str}) do th·ªùi gian kh√¥ng h·ª£p l·ªá.")
                    continue
                subtitle_blocks.append({
                    "original_index": int(index_str), "start_ms": start_ms,
                    "end_ms": end_ms, "text": text_content
                })
            except Exception as e:
                logging.error(f"[{current_thread_name}]   L·ªói ph√¢n t√≠ch kh·ªëi #{match_idx+1}: {e}")
                continue
                
        if not subtitle_blocks:
            logging.warning(f"[{current_thread_name}] Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c kh·ªëi n√†o.")
            return srt_content_string 

        subtitle_blocks.sort(key=lambda x: x["start_ms"])
        logging.info(f"[{current_thread_name}] ƒê√£ ph√¢n t√≠ch v√† s·∫Øp x·∫øp {len(subtitle_blocks)} kh·ªëi SRT ban ƒë·∫ßu.")

        merged_blocks = []
        i = 0
        logging.debug(f"[{current_thread_name}] --- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p g·ªôp kh·ªëi (s·ª≠ d·ª•ng gi√° tr·ªã t·ª´ UI/cfg) ---")
        
        # S·ª≠ d·ª•ng c√°c gi√° tr·ªã ng∆∞·ª°ng ƒë√£ ƒë·ªçc t·ª´ UI/Config
        MERGE_MAX_TIME_GAP_MS = user_max_time_gap_ms
        MERGE_MAX_TIME_GAP_SHORT_NEXT_MS = cfg_time_gap_short_next
        MERGE_CURRENT_BLOCK_MAX_LEN_NORMAL = user_curr_max_len_normal
        MERGE_CURRENT_BLOCK_MAX_LEN_FOR_SHORT_NEXT = cfg_curr_max_len_short_next
        MERGE_NEXT_BLOCK_VERY_SHORT_LEN = cfg_next_very_short_len

        while i < len(subtitle_blocks):
            current_block = subtitle_blocks[i].copy() 
            logging.debug(f"[{current_thread_name}]\nX√©t current_block (idx g·ªëc {current_block.get('original_index')}, text: '{current_block['text'][:40].replace(os.linesep, ' // ')}...')")
            
            j = i + 1 
            while j < len(subtitle_blocks):
                next_block = subtitle_blocks[j]
                logging.debug(f"[{current_thread_name}]   ƒêang so s√°nh v·ªõi next_block (idx g·ªëc {next_block.get('original_index')}, text: '{next_block['text'][:40].replace(os.linesep, ' // ')}...')")

                time_gap_ms = next_block['start_ms'] - current_block['end_ms']
                current_text_stripped = current_block['text'].strip()
                current_block_text_len = len(current_block['text'])
                next_block_text_len = len(next_block['text'].strip())

                c_time_ok_normal = (time_gap_ms >= 0 and time_gap_ms <= MERGE_MAX_TIME_GAP_MS) 
                c_time_ok_for_short_next = (time_gap_ms >= 0 and time_gap_ms <= MERGE_MAX_TIME_GAP_SHORT_NEXT_MS)
                c_not_strong_punct_curr = not current_text_stripped.endswith(('.', '?', '!', '‚Ä¶', '„ÄÇ‚Äù', 'Ôºü‚Äù', 'ÔºÅ‚Äù'))
                c_ends_with_comma_curr = current_text_stripped.endswith(',')
                c_curr_len_ok_normal = current_block_text_len < MERGE_CURRENT_BLOCK_MAX_LEN_NORMAL
                c_curr_len_ok_for_short_next = current_block_text_len < MERGE_CURRENT_BLOCK_MAX_LEN_FOR_SHORT_NEXT
                c_next_is_very_short = next_block_text_len < MERGE_NEXT_BLOCK_VERY_SHORT_LEN

                logging.debug(f"    time_gap_ms: {time_gap_ms}ms")
                logging.debug(f"    => time_ok_normal (<= {MERGE_MAX_TIME_GAP_MS}ms): {c_time_ok_normal}")
                logging.debug(f"    => time_ok_for_short_next (<= {MERGE_MAX_TIME_GAP_SHORT_NEXT_MS}ms): {c_time_ok_for_short_next}")
                logging.debug(f"    current_block ends with: '{current_text_stripped[-5:]}'")
                logging.debug(f"    => not_strong_punct_curr: {c_not_strong_punct_curr}")
                logging.debug(f"    => ends_with_comma_curr: {c_ends_with_comma_curr}")
                logging.debug(f"    len(current_block['text']): {current_block_text_len}")
                logging.debug(f"    => curr_len_ok_normal (<{MERGE_CURRENT_BLOCK_MAX_LEN_NORMAL}): {c_curr_len_ok_normal}")
                logging.debug(f"    => curr_len_ok_for_short_next (<{MERGE_CURRENT_BLOCK_MAX_LEN_FOR_SHORT_NEXT}): {c_curr_len_ok_for_short_next}")
                logging.debug(f"    len(next_block['text']): {next_block_text_len}")
                logging.debug(f"    => next_is_very_short (<{MERGE_NEXT_BLOCK_VERY_SHORT_LEN}): {c_next_is_very_short}")
                
                should_merge = False
                reason_for_merge = "Kh√¥ng c√≥"

                strategy0_met = c_time_ok_for_short_next and c_not_strong_punct_curr and c_next_is_very_short and c_curr_len_ok_for_short_next
                if strategy0_met:
                    logging.debug(f"[{current_thread_name}]     ƒê√°nh gi√° Chi·∫øn l∆∞·ª£c 0 (next_block r·∫•t ng·∫Øn): ƒê·∫°t.")
                    should_merge = True
                    reason_for_merge = "Chi·∫øn l∆∞·ª£c 0 (next_block ng·∫Øn)"
                
                elif c_time_ok_normal and c_ends_with_comma_curr and c_curr_len_ok_normal:
                    logging.debug(f"[{current_thread_name}]     ƒê√°nh gi√° Chi·∫øn l∆∞·ª£c 1 (d·∫•u ph·∫©y): ƒê·∫°t.")
                    should_merge = True
                    reason_for_merge = "Chi·∫øn l∆∞·ª£c 1 (d·∫•u ph·∫©y)"

                elif c_time_ok_normal and c_not_strong_punct_curr and c_curr_len_ok_normal:
                    logging.debug(f"[{current_thread_name}]     ƒê√°nh gi√° Chi·∫øn l∆∞·ª£c 2 (chung): ƒê·∫°t.")
                    should_merge = True
                    reason_for_merge = "Chi·∫øn l∆∞·ª£c 2 (chung)"
                else:
                    logging.debug(f"[{current_thread_name}]     Kh√¥ng chi·∫øn l∆∞·ª£c n√†o ƒë∆∞·ª£c th·ªèa m√£n ƒë·ªÉ g·ªôp.")
                
                if should_merge:
                    logging.info(f"[{current_thread_name}]     ==> G·ªòP current (idx {current_block.get('original_index')}) V·ªöI next (idx {next_block.get('original_index')}) THEO '{reason_for_merge}'")
                    current_block['text'] = (current_block['text'] + " " + next_block['text']).strip()
                    current_block['end_ms'] = next_block['end_ms'] 
                    j += 1 
                else:
                    logging.debug(f"[{current_thread_name}]     xxx KH√îNG G·ªòP current v·ªõi next (idx {next_block.get('original_index')}). D·ª´ng v√≤ng l·∫∑p j.")
                    break 
            
            merged_blocks.append(current_block)
            i = j 
        logging.info(f"[{current_thread_name}] --- K·∫øt th√∫c v√≤ng l·∫∑p g·ªôp kh·ªëi. S·ªë kh·ªëi sau g·ªôp: {len(merged_blocks)} ---")
        
        new_srt_lines = []
        for k, block in enumerate(merged_blocks): 
            new_index = k + 1
            new_srt_lines.append(str(new_index)) 
            new_srt_lines.append(f"{ms_to_tc(block['start_ms'])} --> {ms_to_tc(block['end_ms'])}")
            new_srt_lines.append(block['text'] if isinstance(block['text'], str) else str(block.get('text','')))
            new_srt_lines.append("") 

        final_srt_string = "\n".join(new_srt_lines).strip() + "\n\n"
        logging.info(f"[{current_thread_name}] --- K·∫øt th√∫c SubtitleApp.preprocess_and_merge_srt_blocks. Output c√≥ {len(merged_blocks)} kh·ªëi. ---")
        return final_srt_string

    
# --- H√ÄM chia c√¢u theo sentence ---

# H√†m logic: H·∫≠u x·ª≠ l√Ω file SRT ƒë·ªÉ chia c√°c d√≤ng qu√° d√†i v√† ph√¢n b·ªï l·∫°i th·ªùi gian
    def post_process_srt_time_split(self, srt_path, cfg_snapshot):
        """
        Chia c√°c d√≤ng ph·ª• ƒë·ªÅ d√†i v√† ph√¢n b·ªï l·∫°i th·ªùi gian.
        H·ªó tr·ª£ chia theo k√Ω t·ª±, c√¢u (regex) v√† underthesea cho Ti·∫øng Vi·ªát.
        Ghi ƒë√® file SRT ƒë·∫ßu v√†o.
        """
        current_thread_name = threading.current_thread().name
        logging.info(f"[{current_thread_name}] --- B·∫Øt ƒë·∫ßu post_process_srt_time_split ---")
        logging.debug(f"[{current_thread_name}] File SRT ƒë·∫ßu v√†o: {srt_path}")
        logging.debug(f"[{current_thread_name}] C·∫•u h√¨nh nh·∫≠n ƒë∆∞·ª£c: {cfg_snapshot}")

        enable_split = cfg_snapshot.get("split", False)
        max_chars_config = safe_int(cfg_snapshot.get("max_chars", 90), 90)
        max_lines = safe_int(cfg_snapshot.get("max_lines", 1), 1)
        split_mode_from_config = cfg_snapshot.get("split_mode", "char") # L·ª±a ch·ªçn g·ªëc t·ª´ config

        MIN_DURATION_PER_CHAR_MS = 35
        ABSOLUTE_MIN_DURATION_PER_CHUNK_MS = 1000
        DEFAULT_WRAP_WIDTH_SENTENCE_MODE = 369
        DEFAULT_WRAP_WIDTH_UNDERTHESEA = 369

        actual_split_mode = split_mode_from_config # Ch·∫ø ƒë·ªô s·∫Ω th·ª±c s·ª± d√πng, c√≥ th·ªÉ b·ªã fallback
        internal_max_chars = max_chars_config    # S·ªë k√Ω t·ª± t·ªëi ƒëa n·ªôi b·ªô, c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh

        # --- B∆∞·ªõc 1: X√°c ƒë·ªãnh actual_split_mode v√† internal_max_chars d·ª±a tr√™n l·ª±a ch·ªçn v√† kh·∫£ nƒÉng c·ªßa th∆∞ vi·ªán ---
        # ∆Øu ti√™n ki·ªÉm tra l·ª±a ch·ªçn g·ªëc c·ªßa ng∆∞·ªùi d√πng tr∆∞·ªõc khi fallback
        if split_mode_from_config == "underthesea (Ti·∫øng Vi·ªát)":
            if not HAS_UNDERTHESEA or sent_tokenize is None:
                logging.error(f"[{current_thread_name}] Y√™u c·∫ßu chia b·∫±ng 'underthesea' nh∆∞ng th∆∞ vi·ªán kh√¥ng kh·∫£ d·ª•ng. Fallback v·ªÅ 'sentence'.")
                actual_split_mode = "sentence" # Fallback gi√° tr·ªã c·ªßa actual_split_mode
                # internal_max_chars s·∫Ω ƒë∆∞·ª£c set ·ªü kh·ªëi ƒëi·ªÅu ki·ªán cho "sentence" b√™n d∆∞·ªõi
            elif max_chars_config == 0 or max_chars_config > DEFAULT_WRAP_WIDTH_UNDERTHESEA:
                internal_max_chars = DEFAULT_WRAP_WIDTH_UNDERTHESEA
            # else: internal_max_chars gi·ªØ nguy√™n t·ª´ config n·∫øu underthesea ƒë∆∞·ª£c ch·ªçn v√† h·ª£p l·ªá
        
        # S·ª≠ d·ª•ng if/elif/else ·ªü ƒë√¢y ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ m·ªôt kh·ªëi set internal_max_chars ƒë∆∞·ª£c ch·∫°y
        # d·ª±a tr√™n actual_split_mode (sau khi ƒë√£ c√≥ th·ªÉ b·ªã fallback t·ª´ underthesea)
        if actual_split_mode == "sentence": 
            if max_chars_config == 0 or max_chars_config > DEFAULT_WRAP_WIDTH_SENTENCE_MODE:
                internal_max_chars = DEFAULT_WRAP_WIDTH_SENTENCE_MODE
            # else: internal_max_chars gi·ªØ nguy√™n t·ª´ config n·∫øu sentence ƒë∆∞·ª£c ch·ªçn v√† h·ª£p l·ªá
        elif actual_split_mode == "char": 
            if max_chars_config == 0:
                internal_max_chars = 90

        # --- C√°c ki·ªÉm tra ƒëi·ªÅu ki·ªán ban ƒë·∫ßu ---
        if not enable_split or internal_max_chars <= 0 or max_lines <= 0:
            log_msg = f"[{current_thread_name}] T√≠nh nƒÉng chia d√≤ng "
            if not enable_split: log_msg += "kh√¥ng ƒë∆∞·ª£c b·∫≠t."
            else: log_msg += f"b·ªè qua do internal_max_chars ({internal_max_chars}) ho·∫∑c max_lines ({max_lines}) kh√¥ng h·ª£p l·ªá."
            logging.info(log_msg)
            return

        if not os.path.exists(srt_path):
            logging.warning(f"[{current_thread_name}] Kh√¥ng t√¨m th·∫•y file SRT ƒë·ªÉ chia d√≤ng: {srt_path}")
            return

        logging.info(f"[{current_thread_name}] ƒêang chia d√≤ng SRT: \"{os.path.basename(srt_path)}\" (Ch·∫ø ƒë·ªô c·∫•u h√¨nh g·ªëc={split_mode_from_config}, Ch·∫ø ƒë·ªô th·ª±c t·∫ø sau fallback/ƒëi·ªÅu ch·ªânh={actual_split_mode}, UI max_chars={max_chars_config}, internal_max_chars={internal_max_chars}, max_lines={max_lines})")

        try:
            with open(srt_path, "r", encoding="utf-8") as f: content = f.read()
        except Exception as e:
            logging.error(f"[{current_thread_name}] Kh√¥ng th·ªÉ ƒë·ªçc SRT ƒë·ªÉ chia d√≤ng: {srt_path} - {e}", exc_info=True)
            return
        if not content.strip():
            logging.info(f"[{current_thread_name}] N·ªôi dung file SRT r·ªóng, kh√¥ng c√≥ g√¨ ƒë·ªÉ chia: {srt_path}")
            return

        processed_srt_blocks = []
        block_regex = re.compile(
            r"\d+\s*\n"  # <-- B·ªè d·∫•u ngo·∫∑c ƒë∆°n ·ªü ƒë√¢y: KH√îNG B·∫ÆT L√ÄM GROUP
            r"(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})\s*\n" # Group 1 (start_tc), Group 2 (end_tc)
            r"([\s\S]*?)" # Group 3 (text)
            r"(?=\n\n|\n\d+\s*\n\d{2}:\d{2}:\d{2},\d{3}\s*-->|\Z)", 
            re.MULTILINE
        )
        original_blocks = block_regex.finditer(content)

        for block_idx, block_match in enumerate(original_blocks):
            start_tc_str, end_tc_str, text_block_raw = block_match.groups()

            
            # --- B·∫ÆT ƒê·∫¶U TH√äM LOGIC L√ÄM S·∫†CH text_block_raw ---
            lines_of_raw_text = text_block_raw.strip().splitlines()
            cleaned_lines_for_current_block = []
            for line_in_raw in lines_of_raw_text:
                stripped_line_in_raw = line_in_raw.strip()
                # Ki·ªÉm tra xem d√≤ng c√≥ ph·∫£i l√† m·ªôt d√≤ng index (ch·ªâ s·ªë) c·ªßa kh·ªëi SRT kh√°c kh√¥ng
                is_another_srt_index = re.fullmatch(r"\d+", stripped_line_in_raw) is not None
                # Ki·ªÉm tra xem d√≤ng c√≥ ph·∫£i l√† m·ªôt d√≤ng timecode c·ªßa kh·ªëi SRT kh√°c kh√¥ng
                is_another_srt_timecode = re.fullmatch(r"\d{2}:\d{2}:\d{2}[,.]\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}[,.]\d{3}", stripped_line_in_raw) is not None

                if not is_another_srt_index and not is_another_srt_timecode and stripped_line_in_raw:
                    cleaned_lines_for_current_block.append(stripped_line_in_raw)
            
            current_block_text_cleaned = "\n".join(cleaned_lines_for_current_block).strip()
            
            logging.info(f"[{current_thread_name}] === X·ª≠ l√Ω kh·ªëi g·ªëc #{block_idx+1} ({start_tc_str} --> {end_tc_str}) ===") 
            logging.debug(f"[{current_thread_name}]   Text g·ªëc (sau l√†m s·∫°ch): \"{current_block_text_cleaned.replace(os.linesep, ' // ')}\"")

            if not current_block_text_cleaned: 
                logging.debug(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1} r·ªóng (sau l√†m s·∫°ch), gi·ªØ nguy√™n timing.") 
                processed_srt_blocks.append({"start_ms": parse_timecode(start_tc_str), "end_ms": parse_timecode(end_tc_str), "text": ""}) 
                continue

            start_ms_original_block = parse_timecode(start_tc_str)
            end_ms_original_block = parse_timecode(end_tc_str)
            duration_ms_original_block = end_ms_original_block - start_ms_original_block

            if duration_ms_original_block <= 0:
                logging.warning(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1} c√≥ th·ªùi gian kh√¥ng h·ª£p l·ªá ({duration_ms_original_block}ms). Gi·ªØ nguy√™n text v√† timing.")
                processed_srt_blocks.append({"start_ms": start_ms_original_block, "end_ms": end_ms_original_block, "text": current_block_text_cleaned})
                continue

            text_for_splitting = ' '.join(current_block_text_cleaned.split())
            logging.debug(f"[{current_thread_name}]   DEBUG: Input cho t√°ch c√¢u (text_for_splitting) c·ªßa kh·ªëi #{block_idx+1}: \"{text_for_splitting}\"")
            
            actual_split_mode_for_this_block = "" # Reset cho m·ªói kh·ªëi, l∆∞u mode th·ª±c s·ª± d√πng cho kh·ªëi n√†y n·∫øu c√≥ fallback
            final_candidate_lines_for_wrap = []   # Danh s√°ch c√°c c√¢u/c·ª•m sau khi t√°ch
            mode_used_for_candidate_lines = ""    # T√™n mode ƒë√£ d√πng ƒë·ªÉ t·∫°o ra final_candidate_lines_for_wrap

            # === KH·ªêI IF/ELIF/ELSE TH·ª∞C HI·ªÜN CHIA C√ÇU THEO TH·ª® T·ª∞ ∆ØU TI√äN M·ªöI ===

            if actual_split_mode == "underthesea (Ti·∫øng Vi·ªát)":
                if HAS_UNDERTHESEA and sent_tokenize: 
                    try:
                        candidate_lines_uts = sent_tokenize(text_for_splitting)
                        logging.info(f"[{current_thread_name}]     MODE '{actual_split_mode}': CANDIDATE_LINES (Underthesea) cho kh·ªëi #{block_idx+1}: {candidate_lines_uts}")
                        final_candidate_lines_for_wrap = candidate_lines_uts
                        mode_used_for_candidate_lines = actual_split_mode
                        actual_split_mode_for_this_block = actual_split_mode # Ghi nh·∫≠n mode ƒë√£ d√πng th√†nh c√¥ng
                    except Exception as e_uts_runtime:
                        logging.error(f"[{current_thread_name}]     L·ªói runtime khi d√πng underthesea.sent_tokenize cho kh·ªëi #{block_idx+1}: {e_uts_runtime}. Fallback v·ªÅ chia theo k√Ω t·ª± cho kh·ªëi n√†y.")
                        final_candidate_lines_for_wrap = [text_for_splitting] 
                        mode_used_for_candidate_lines = "char (fallback t·ª´ underthesea l·ªói)"
                        actual_split_mode_for_this_block = "char" 
                        # ƒêi·ªÅu ch·ªânh internal_max_chars cho ph√π h·ª£p v·ªõi 'char' mode khi fallback
                        current_internal_max_chars_for_fallback = max_chars_config if max_chars_config > 0 else 90
                        if internal_max_chars != current_internal_max_chars_for_fallback :
                            logging.info(f"[{current_thread_name}]     Fallback v·ªÅ char, c·∫≠p nh·∫≠t internal_max_chars t·ª´ {internal_max_chars} th√†nh {current_internal_max_chars_for_fallback}")
                            internal_max_chars = current_internal_max_chars_for_fallback
                else: 
                    # Tr∆∞·ªùng h·ª£p n√†y x·∫£y ra n·∫øu `actual_split_mode` v·∫´n l√† "underthesea..." nh∆∞ng th∆∞ vi·ªán l·∫°i kh√¥ng c√≥ 
                    # (√≠t kh·∫£ nƒÉng n·∫øu logic fallback ·ªü B∆∞·ªõc 1 ƒë√£ ch·∫°y ƒë√∫ng v√† ƒë·ªïi `actual_split_mode` sang "sentence")
                    logging.warning(f"[{current_thread_name}]     Ch·∫ø ƒë·ªô l√† 'underthesea (Ti·∫øng Vi·ªát)' nh∆∞ng th∆∞ vi·ªán kh√¥ng kh·∫£ d·ª•ng/l·ªói init (trong kh·ªëi chia c√¢u th·ª±c t·∫ø). Fallback v·ªÅ chia theo k√Ω t·ª± cho kh·ªëi #{block_idx+1}.")
                    final_candidate_lines_for_wrap = [text_for_splitting] 
                    mode_used_for_candidate_lines = "char (fallback do th∆∞ vi·ªán uts thi·∫øu/l·ªói init)"
                    actual_split_mode_for_this_block = "char" 
                    current_internal_max_chars_for_fallback = max_chars_config if max_chars_config > 0 else 90
                    if internal_max_chars != current_internal_max_chars_for_fallback :
                        logging.info(f"[{current_thread_name}]     Fallback v·ªÅ char, c·∫≠p nh·∫≠t internal_max_chars t·ª´ {internal_max_chars} th√†nh {current_internal_max_chars_for_fallback}")
                        internal_max_chars = current_internal_max_chars_for_fallback
            
            elif actual_split_mode == "sentence":
                titles_plain = [
                    "Mr", "Ms", "Mrs", "Dr", "Prof", "Rev", "Gen", "Sen", "Rep", "St",
                    "Messrs", "Mmes", "Capt", "Cmdr", "Lt", "Sgt", "Col", "Gov", "Pres", "Hon",
                    "Fr", "Sr", "Jr", "Esq", "PhD", "MD", "BA", "BSc", "MA", "MSc",
                    "ThS", "TS", "PGS", "GS", "BS", "KS", "CN", "C√¥", "Th·∫ßy", "Cha", "S∆∞", "√îng", "B√†",
                    "No", "Nos", "Art", "vs", "etc", "Co", "Corp", "Inc", "Ltd",
                    "eg", "ie", "viz", "cf", "et al",
                ]
                escaped_titles = [re.escape(title) for title in titles_plain]
                titles_pattern_for_lookbehind = "|".join(escaped_titles)

                delimiter_regex_str = (
                    r"[?!‚Ä¶](?=\s|$)|"  # D·∫•u ?, !, ‚Ä¶ (kh√¥ng c·∫ßn capturing group con ·ªü ƒë√¢y)
                    r"(?<!\b(?:{titles_pattern_for_lookbehind}))"
                    r"(?<!\b[A-Z])" 
                    r"\."   
                    r"(?!\d)"  
                    r"(?![a-z])" 
                    r"(?=\s|$)" 
                )
                
                sentence_parts = re.split(f'({delimiter_regex_str})', text_for_splitting)
                
                candidate_lines_sentence_regex = []
                current_sentence_buffer = ""
                if sentence_parts:
                    # logging.debug(f"[{current_thread_name}] DEBUG SPLIT: sentence_parts = {sentence_parts}") 
                    for i, part in enumerate(sentence_parts):
                        if part is None: 
                            # logging.debug(f"[{current_thread_name}] DEBUG SPLIT: part {i} is None, skipping.")
                            continue
                        # logging.debug(f"[{current_thread_name}] DEBUG SPLIT: part {i} = '{part}', buffer BEFORE = '{current_sentence_buffer}'")
                        current_sentence_buffer += part 
                        # logging.debug(f"[{current_thread_name}] DEBUG SPLIT: buffer AFTER = '{current_sentence_buffer}'")
                        
                        is_delimiter_captured_and_valid = (i % 2 == 1 and part.strip()) 
                        is_last_part_of_split = (i == len(sentence_parts) - 1)

                        if is_delimiter_captured_and_valid or is_last_part_of_split:
                            trimmed_sentence = current_sentence_buffer.strip()
                            # logging.debug(f"[{current_thread_name}] DEBUG SPLIT: Adding to candidates: '{trimmed_sentence}' (from buffer: '{current_sentence_buffer}')")
                            if trimmed_sentence: 
                                candidate_lines_sentence_regex.append(trimmed_sentence)
                            current_sentence_buffer = "" 
                    
                    if not candidate_lines_sentence_regex and text_for_splitting.strip():
                        candidate_lines_sentence_regex = [text_for_splitting.strip()]
                
                logging.info(f"[{current_thread_name}]     MODE '{actual_split_mode}': CANDIDATE_LINES (Sentence Regex Optimized) cho kh·ªëi #{block_idx+1}: {candidate_lines_sentence_regex}")
                final_candidate_lines_for_wrap = candidate_lines_sentence_regex
                mode_used_for_candidate_lines = actual_split_mode
                actual_split_mode_for_this_block = actual_split_mode 
            
            else: 
                                 
                # N·∫øu ch∆∞a c√≥ fallback n√†o set final_candidate_lines_for_wrap, th√¨ ƒë√¢y l√† l·ª±a ch·ªçn 'char' g·ªëc
                if not actual_split_mode_for_this_block: 
                    final_candidate_lines_for_wrap = [text_for_splitting]
                    mode_used_for_candidate_lines = "char" 
                    actual_split_mode_for_this_block = "char"
                    logging.info(f"[{current_thread_name}]     MODE '{actual_split_mode_for_this_block}': CANDIDATE_LINES (To√†n b·ªô kh·ªëi) cho kh·ªëi #{block_idx+1}: {[text_for_splitting]}")

                if actual_split_mode_for_this_block == "char":
                    current_internal_max_chars_for_char = max_chars_config if max_chars_config > 0 else 45
                    if internal_max_chars != current_internal_max_chars_for_char and split_mode_from_config == "char":
                        # Ch·ªâ c·∫≠p nh·∫≠t n·∫øu l·ª±a ch·ªçn g·ªëc l√† 'char' v√† internal_max_chars hi·ªán t·∫°i kh√¥ng ƒë√∫ng
                        logging.info(f"[{current_thread_name}]     ƒê·∫£m b·∫£o internal_max_chars cho 'char' mode: {current_internal_max_chars_for_char}")
                        internal_max_chars = current_internal_max_chars_for_char


            # === K·∫æT TH√öC KH·ªêI IF/ELIF/ELSE CHIA C√ÇU ===

            # Ghi log cu·ªëi c√πng v·ªÅ c√°c c√¢u/c·ª•m ·ª©ng vi√™n v√† mode ƒë√£ d√πng
            logging.info(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1}: C√°c c√¢u/c·ª•m ·ª©ng vi√™n (s·ª≠ d·ª•ng mode: '{mode_used_for_candidate_lines}') ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ textwrap: {len(final_candidate_lines_for_wrap)} ph·∫ßn t·ª≠.")
            if actual_split_mode_for_this_block and actual_split_mode_for_this_block != split_mode_from_config : 
                 logging.info(f"[{current_thread_name}]   L∆∞u √Ω: Ch·∫ø ƒë·ªô chia th·ª±c t·∫ø cho kh·ªëi n√†y l√† '{actual_split_mode_for_this_block}' (internal_max_chars={internal_max_chars}). L·ª±a ch·ªçn g·ªëc t·ª´ UI: '{split_mode_from_config}'")
            elif actual_split_mode_for_this_block: 
                 logging.info(f"[{current_thread_name}]   L∆∞u √Ω: Ch·∫ø ƒë·ªô chia th·ª±c t·∫ø cho kh·ªëi n√†y l√† '{actual_split_mode_for_this_block}' (internal_max_chars={internal_max_chars}).")


            # --- B∆∞·ªõc 2: Textwrap c√°c final_candidate_lines_for_wrap v√† t·∫°o chunks ---
            all_wrapped_lines = []
            for line_text_candidate in final_candidate_lines_for_wrap: # S·ª≠ d·ª•ng final_candidate_lines_for_wrap
                if not line_text_candidate.strip(): continue
                # S·ª≠ d·ª•ng internal_max_chars ƒë√£ ƒë∆∞·ª£c x√°c ƒë·ªãnh/ƒëi·ªÅu ch·ªânh ·ªü tr√™n
                wrapped_lines = textwrap.wrap(line_text_candidate, width=internal_max_chars,
                                              break_long_words=True, replace_whitespace=False,
                                              drop_whitespace=True, break_on_hyphens=True,
                                              fix_sentence_endings=False) # fix_sentence_endings=False l√† t·ªët
                all_wrapped_lines.extend(wl.strip() for wl in wrapped_lines if wl.strip())
                        
            if not all_wrapped_lines:
                logging.warning(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1}: Kh√¥ng t·∫°o ƒë∆∞·ª£c d√≤ng n√†o sau textwrap. Gi·ªØ nguy√™n kh·ªëi g·ªëc.")
                processed_srt_blocks.append({"start_ms": start_ms_original_block, "end_ms": end_ms_original_block, "text": current_block_text_cleaned})
                continue
            logging.debug(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1}: Sau textwrap (width={internal_max_chars}), c√≥ {len(all_wrapped_lines)} d√≤ng con: {all_wrapped_lines}")

            final_chunks_of_lines = []
            current_chunk_build = []
            for line_wrapped in all_wrapped_lines:
                if len(current_chunk_build) < max_lines:
                    current_chunk_build.append(line_wrapped)
                else:
                    final_chunks_of_lines.append(current_chunk_build)
                    current_chunk_build = [line_wrapped]
            if current_chunk_build: final_chunks_of_lines.append(current_chunk_build)

            num_chunks = len(final_chunks_of_lines)
            if num_chunks == 0:
                logging.warning(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1}: Kh√¥ng t·∫°o ƒë∆∞·ª£c chunk n√†o. Gi·ªØ nguy√™n kh·ªëi g·ªëc.")
                processed_srt_blocks.append({"start_ms": start_ms_original_block, "end_ms": end_ms_original_block, "text": current_block_text_cleaned})
                continue
            logging.info(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1}: Chia th√†nh {num_chunks} chunk m·ªõi (m·ªói chunk t·ªëi ƒëa {max_lines} d√≤ng).")
            for i_c, c_lines in enumerate(final_chunks_of_lines):
                logging.debug(f"[{current_thread_name}]     Chunk #{i_c+1} g·ªìm c√°c d√≤ng: {c_lines}")

            # --- B∆∞·ªõc 3 & 4: Ph√¢n b·ªï th·ªùi gian v√† ƒëi·ªÅu ch·ªânh ---
            total_effective_chars_for_timing = 0
            chars_per_chunk_for_timing = []
            for chunk_lns in final_chunks_of_lines: # S·ª≠ d·ª•ng bi·∫øn m·ªõi
                chunk_txt = "\n".join(chunk_lns)
                effective_chars = len("".join(chunk_txt.split()))
                chars_per_chunk_for_timing.append(max(1, effective_chars))
                total_effective_chars_for_timing += max(1, effective_chars)
            if total_effective_chars_for_timing == 0: total_effective_chars_for_timing = num_chunks
            logging.debug(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1}: T·ªïng k√Ω t·ª± hi·ªáu d·ª•ng cho ph√¢n b·ªï: {total_effective_chars_for_timing}")

            temp_sub_blocks_for_this_original_block = []
            for i_chunk, chunk_lns_loop in enumerate(final_chunks_of_lines): # S·ª≠ d·ª•ng bi·∫øn m·ªõi
                chunk_text_content_loop = "\n".join(chunk_lns_loop).strip()
                if not chunk_text_content_loop: continue
                proportion = chars_per_chunk_for_timing[i_chunk] / total_effective_chars_for_timing
                expected_duration_this_chunk = duration_ms_original_block * proportion
                min_duration_based_on_text = len(chunk_text_content_loop) * MIN_DURATION_PER_CHAR_MS
                adjusted_min_duration_text = min(min_duration_based_on_text, expected_duration_this_chunk * 1.5 if expected_duration_this_chunk > ABSOLUTE_MIN_DURATION_PER_CHUNK_MS else min_duration_based_on_text)
                final_min_duration_this_chunk = max(ABSOLUTE_MIN_DURATION_PER_CHUNK_MS, adjusted_min_duration_text)
                current_chunk_duration = max(expected_duration_this_chunk, final_min_duration_this_chunk)
                temp_sub_blocks_for_this_original_block.append({"duration_raw": current_chunk_duration, "text": chunk_text_content_loop})

            if temp_sub_blocks_for_this_original_block:
                total_raw_duration_of_sub_blocks = sum(b['duration_raw'] for b in temp_sub_blocks_for_this_original_block)
                scaling_factor_final = 1.0
                if total_raw_duration_of_sub_blocks > 0:
                    scaling_factor_final = duration_ms_original_block / total_raw_duration_of_sub_blocks
                else:
                    if num_chunks > 0:
                        for b_data in temp_sub_blocks_for_this_original_block: b_data['duration_raw'] = duration_ms_original_block / num_chunks
                        total_raw_duration_of_sub_blocks = duration_ms_original_block 
                logging.debug(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1}: ƒêi·ªÅu ch·ªânh cu·ªëi c√πng. Total raw_duration: {total_raw_duration_of_sub_blocks:.0f}ms, Original_block_duration: {duration_ms_original_block:.0f}ms, Scaling factor: {scaling_factor_final:.4f}")

                current_adjusted_start_ms = float(start_ms_original_block)
                for i_sb, sub_block_data_item in enumerate(temp_sub_blocks_for_this_original_block):
                    adjusted_duration = sub_block_data_item['duration_raw'] * scaling_factor_final
                    final_start_ms = current_adjusted_start_ms
                    final_end_ms = current_adjusted_start_ms + adjusted_duration
                    if i_sb == len(temp_sub_blocks_for_this_original_block) - 1:
                        final_end_ms = float(end_ms_original_block)
                        if final_end_ms < final_start_ms + (ABSOLUTE_MIN_DURATION_PER_CHUNK_MS / 2):
                             final_start_ms = final_end_ms - (ABSOLUTE_MIN_DURATION_PER_CHUNK_MS / 2)
                             if final_start_ms < start_ms_original_block:
                                 final_start_ms = float(start_ms_original_block)
                                 final_end_ms = float(end_ms_original_block)
                    processed_srt_blocks.append({"start_ms": final_start_ms, "end_ms": final_end_ms, "text": sub_block_data_item['text']})
                    current_adjusted_start_ms = final_end_ms
                    logging.debug(f"[{current_thread_name}]     Kh·ªëi #{block_idx+1}, Sub-block #{i_sb+1} (ƒê√£ ƒëi·ªÅu ch·ªânh): {final_start_ms:.0f}ms --> {final_end_ms:.0f}ms (Dur: {(final_end_ms - final_start_ms):.0f}ms) Text: \"{sub_block_data_item['text'].replace(os.linesep, ' // ')}\"")
            else:
                 logging.warning(f"[{current_thread_name}]   Kh·ªëi #{block_idx+1}: Kh√¥ng c√≥ sub-block n√†o ƒë∆∞·ª£c t·∫°o ƒë·ªÉ ƒëi·ªÅu ch·ªânh timing. Gi·ªØ nguy√™n kh·ªëi g·ªëc.")
                 processed_srt_blocks.append({"start_ms": start_ms_original_block, "end_ms": end_ms_original_block, "text": current_block_text_cleaned})
            logging.debug(f"[{current_thread_name}] --- K·∫øt th√∫c x·ª≠ l√Ω Kh·ªëi g·ªëc #{block_idx+1} ---")


        # --- B∆∞·ªõc 5: T·∫°o l·∫°i n·ªôi dung file SRT ---
        final_srt_output_lines = []
        srt_block_counter = 1
        for block_data_final in processed_srt_blocks:
            start_ms = int(round(block_data_final['start_ms']))
            end_ms = int(round(block_data_final['end_ms']))
            text_final = block_data_final['text']
            if end_ms <= start_ms: # ƒê·∫£m b·∫£o end > start
                end_ms = start_ms + ABSOLUTE_MIN_DURATION_PER_CHUNK_MS
                logging.warning(f"[{current_thread_name}] Kh·ªëi ghi ra #{srt_block_counter} c√≥ end_ms <= start_ms. ƒê√£ ƒëi·ªÅu ch·ªânh: {start_ms}ms -> {end_ms}ms")
            final_srt_output_lines.append(str(srt_block_counter))
            final_srt_output_lines.append(f"{ms_to_tc(start_ms)} --> {ms_to_tc(end_ms)}")
            final_srt_output_lines.append(text_final)
            final_srt_output_lines.append("")
            srt_block_counter += 1
        
        try:
            final_output_srt_string = "\n".join(final_srt_output_lines).strip()
            if final_output_srt_string:
                with open(srt_path, "w", encoding="utf-8") as f:
                    f.write(final_output_srt_string + "\n\n")
                logging.info(f"[{current_thread_name}] ƒê√£ ghi ƒë√® file SRT ƒë√£ chia d√≤ng (LOG DEBUG): \"{os.path.basename(srt_path)}\"")
            elif content.strip():
                 logging.warning(f"[{current_thread_name}] N·ªôi dung SRT tr·ªü th√†nh r·ªóng sau khi chia d√≤ng (LOG DEBUG) cho file \"{srt_path}\" (file g·ªëc c√≥ n·ªôi dung). Gi·ªØ nguy√™n file g·ªëc.")
            else:
                logging.debug(f"[{current_thread_name}] File SRT g·ªëc v√† output (LOG DEBUG) ƒë·ªÅu r·ªóng: \"{srt_path}\"")
        except Exception as write_e:
            logging.error(f"[{current_thread_name}] Kh√¥ng th·ªÉ ghi ƒë√® file SRT ƒë√£ chia d√≤ng (LOG DEBUG): {srt_path} - {write_e}", exc_info=True)

        logging.info(f"[{current_thread_name}] --- K·∫øt th√∫c post_process_srt_time_split (LOG DEBUG CHI TI·∫æT) ---")


# H√†m logic: D·ªãch vƒÉn b·∫£n b·∫±ng Google Cloud Translate API
    def translate_google_cloud(self, text_list, target_lang_code, source_lang_code=None):
        """
        D·ªãch m·ªôt danh s√°ch c√°c chu·ªói vƒÉn b·∫£n b·∫±ng Google Cloud Translate API v2.

        Args:
            text_list (list): Danh s√°ch c√°c chu·ªói c·∫ßn d·ªãch.
            target_lang_code (str): M√£ ng√¥n ng·ªØ ƒë√≠ch (v√≠ d·ª•: 'en', 'vi').
            source_lang_code (str, optional): M√£ ng√¥n ng·ªØ ngu·ªìn. M·∫∑c ƒë·ªãnh l√† None (t·ª± ƒë·ªông ph√°t hi·ªán).

        Returns:
            list or None: Danh s√°ch c√°c chu·ªói ƒë√£ d·ªãch, ho·∫∑c None n·∫øu c√≥ l·ªói nghi√™m tr·ªçng.
                          N·∫øu l·ªói x·∫£y ra v·ªõi m·ªôt v√†i d√≤ng, c√≥ th·ªÉ tr·∫£ v·ªÅ list ch·ª©a d√≤ng l·ªói ƒë√≥.
        """
        # Ki·ªÉm tra xem th∆∞ vi·ªán c√≥ t·ªìn t·∫°i kh√¥ng
        if not HAS_GOOGLE_CLOUD_TRANSLATE or google_translate is None or service_account is None:
            logging.error("Th∆∞ vi·ªán Google Cloud Translate kh√¥ng kh·∫£ d·ª•ng ƒë·ªÉ g·ªçi API.")
            # Kh√¥ng c·∫ßn hi·ªán messagebox ·ªü ƒë√¢y v√¨ ƒë√£ c√≥ ki·ªÉm tra tr∆∞·ªõc khi g·ªçi
            return None

        # L·∫•y ƒë∆∞·ªùng d·∫´n file key t·ª´ bi·∫øn c·∫•u h√¨nh
        key_path = self.google_key_path_var.get()
        if not key_path or not os.path.exists(key_path):
            logging.error("ƒê∆∞·ªùng d·∫´n file key Google Cloud kh√¥ng h·ª£p l·ªá ho·∫∑c b·ªã thi·∫øu trong c·∫•u h√¨nh.")
            # Th√¥ng b√°o l·ªói cho ng∆∞·ªùi d√πng m·ªôt l·∫ßn duy nh·∫•t n·∫øu h·ªç c·ªë d·ªãch m√† thi·∫øu key
            self.after(0, lambda: messagebox.showerror("Thi·∫øu Key Google Cloud",
                                                       "Vui l√≤ng c·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n ƒë·∫øn file JSON key c·ªßa Google Service Account trong 'C√†i ƒë·∫∑t API Keys' tr∆∞·ªõc khi s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.",
                                                       parent=self))
            return None # Tr·∫£ v·ªÅ None ƒë·ªÉ h√†m g·ªçi bi·∫øt l√† l·ªói

        try:
            # Load credentials t·ª´ file JSON ƒë√£ c·∫•u h√¨nh
            credentials = service_account.Credentials.from_service_account_file(key_path)
            # Kh·ªüi t·∫°o Google Translate client
            translate_client = google_translate.Client(credentials=credentials)

            # Ghi log v·ªÅ y√™u c·∫ßu d·ªãch
            logging.info(f"ƒêang g·ª≠i {len(text_list)} d√≤ng t·ªõi Google Cloud API ƒë·ªÉ d·ªãch sang '{target_lang_code}'...")
            if source_lang_code:
                logging.info(f"  (Ng√¥n ng·ªØ ngu·ªìn ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh: '{source_lang_code}')")
            else:
                logging.info("  (Ng√¥n ng·ªØ ngu·ªìn: T·ª± ƒë·ªông ph√°t hi·ªán)")

            results = translate_client.translate(
                values=text_list, # Tham s·ªë values thay v√¨ text_list ·ªü m·ªôt s·ªë phi√™n b·∫£n
                target_language=target_lang_code,
                source_language=source_lang_code if source_lang_code and source_lang_code != 'auto' else None
            )

            # Tr√≠ch xu·∫•t k·∫øt qu·∫£
            translated_texts = [result['translatedText'] for result in results]
            logging.info(f"Google Cloud API ƒë√£ d·ªãch th√†nh c√¥ng {len(translated_texts)} d√≤ng.")
            # <-- B·∫ÆT ƒê·∫¶U TH√äM M·ªöI -->
            total_chars_translated = sum(len(text) for text in text_list)
            self._track_api_call(service_name="google_translate_chars", units=total_chars_translated)

            # Ki·ªÉm tra xem s·ªë l∆∞·ª£ng k·∫øt qu·∫£ c√≥ kh·ªõp kh√¥ng (ph√≤ng tr∆∞·ªùng h·ª£p l·∫°)
            if len(translated_texts) != len(text_list):
                 logging.warning(f"S·ªë l∆∞·ª£ng d√≤ng tr·∫£ v·ªÅ ({len(translated_texts)}) t·ª´ Google Cloud kh√¥ng kh·ªõp v·ªõi s·ªë l∆∞·ª£ng g·ª≠i ƒëi ({len(text_list)})!")
                 return None

            return translated_texts # Tr·∫£ v·ªÅ danh s√°ch c√°c d√≤ng ƒë√£ d·ªãch

        except Exception as e:
            # X·ª≠ l√Ω c√°c l·ªói c√≥ th·ªÉ x·∫£y ra khi g·ªçi API
            logging.error(f"L·ªói khi g·ªçi Google Cloud Translate API: {e}", exc_info=True)

            # === B·∫ÆT ƒê·∫¶U LOGIC KI·ªÇM SO√ÅT POPUP L·ªñI API D·ªäCH ===
            should_show_translate_popup_now = False
            # Ki·ªÉm tra xem c√≥ ph·∫£i ƒëang trong qu√° tr√¨nh subbing kh√¥ng (ƒë·ªÉ bi·∫øt l√† batch hay kh√¥ng)
            is_batch_subbing = hasattr(self, 'is_subbing') and self.is_subbing

            if not is_batch_subbing: # N·∫øu kh√¥ng ph·∫£i batch (v√≠ d·ª•: m·ªôt l·ªánh g·ªçi API ƒë∆°n l·∫ª kh√¥ng r√µ ng·ªØ c·∫£nh)
                should_show_translate_popup_now = True
            elif is_batch_subbing: # N·∫øu ƒëang x·ª≠ l√Ω batch sub
                if not self.translate_batch_first_api_error_msg_shown:
                    self.translate_batch_first_api_error_msg_shown = True
                    self.translate_batch_accumulated_api_error_details = error_text
                    should_show_translate_popup_now = True
                else:
                    logging.warning(f"L·ªói API Google Translate ti·∫øp theo, popup ƒë√£ b·ªã ch·∫∑n cho batch n√†y: {e}")
            
            if should_show_translate_popup_now:
                 parent_window = self # V√¨ ƒë√¢y l√† method c·ªßa SubtitleApp
                 self.after(0, lambda err=str(e), p=parent_window: messagebox.showerror("L·ªói Google API (D·ªãch)",
                                                                       f"ƒê√£ x·∫£y ra l·ªói khi li√™n l·∫°c v·ªõi Google Cloud Translation:\n{err}",
                                                                       parent=p))
            # === K·∫æT TH√öC LOGIC KI·ªÇM SO√ÅT POPUP L·ªñI API D·ªäCH ===
            return None # Tr·∫£ v·ªÅ None ƒë·ªÉ b√°o hi·ªáu l·ªói d·ªãch
            
            # Hi·ªÉn th·ªã l·ªói cho ng∆∞·ªùi d√πng qua lu·ªìng ch√≠nh
            self.after(0, lambda err=str(e): messagebox.showerror("L·ªói Google API",
                                                                   f"ƒê√£ x·∫£y ra l·ªói khi li√™n l·∫°c v·ªõi Google Cloud Translation:\n{err}",
                                                                   parent=self))
            return None # Tr·∫£ v·ªÅ None ƒë·ªÉ b√°o hi·ªáu l·ªói


# H√†m logic: D·ªãch vƒÉn b·∫£n b·∫±ng OpenAI (ChatGPT) API
    def translate_openai(self, text_list, target_lang, source_lang=None):
        """
        D·ªãch m·ªôt danh s√°ch c√°c chu·ªói vƒÉn b·∫£n b·∫±ng OpenAI API (ChatGPT),
        c√≥ h·ªó tr·ª£ l·ª±a ch·ªçn phong c√°ch d·ªãch.

        Args:
            text_list (list): Danh s√°ch c√°c chu·ªói c·∫ßn d·ªãch.
            target_lang (str): T√™n ng√¥n ng·ªØ ƒë√≠ch (v√≠ d·ª•: 'Vietnamese', 'English').
            source_lang (str, optional): T√™n/M√£ ng√¥n ng·ªØ ngu·ªìn. M·∫∑c ƒë·ªãnh l√† None (kh√¥ng ch·ªâ ƒë·ªãnh).

        Returns:
            list or None: Danh s√°ch c√°c chu·ªói ƒë√£ d·ªãch (ho·∫∑c g·ªëc n·∫øu l·ªói),
                          ho·∫∑c None n·∫øu c√≥ l·ªói nghi√™m tr·ªçng (thi·∫øu key/th∆∞ vi·ªán).
        """
        # --- Ki·ªÉm tra th∆∞ vi·ªán v√† API Key (Gi·ªØ nguy√™n) ---
        if not HAS_OPENAI or OpenAI is None:
            logging.error("Th∆∞ vi·ªán OpenAI kh√¥ng kh·∫£ d·ª•ng ƒë·ªÉ g·ªçi API.")
            # C√≥ th·ªÉ raise l·ªói ·ªü ƒë√¢y ƒë·ªÉ h√†m g·ªçi x·ª≠ l√Ω r√µ r√†ng h∆°n thay v√¨ tr·∫£ v·ªÅ None √¢m th·∫ßm
            # raise ImportError("Th∆∞ vi·ªán OpenAI ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t.") 
            return None # Ho·∫∑c gi·ªØ nguy√™n tr·∫£ v·ªÅ None

        api_key = self.openai_key_var.get()
        if not api_key:
            logging.error("OpenAI API Key b·ªã thi·∫øu trong c·∫•u h√¨nh.")
            self.after(0, lambda: messagebox.showerror("Thi·∫øu Key OpenAI",
                                                       "Vui l√≤ng c·∫•u h√¨nh OpenAI API Key trong 'C√†i ƒë·∫∑t API Keys'.",
                                                       parent=self))
            # raise ValueError("Thi·∫øu OpenAI API Key.") # C√≥ th·ªÉ raise l·ªói
            return None # Ho·∫∑c gi·ªØ nguy√™n tr·∫£ v·ªÅ None

        # --- L·∫•y phong c√°ch d·ªãch ƒë√£ ch·ªçn ---
        # ƒê·ªçc tr·ª±c ti·∫øp t·ª´ bi·∫øn StringVar c·ªßa l·ªõp SubtitleApp
        selected_style = "M·∫∑c ƒë·ªãnh (trung t√≠nh)" # Gi√° tr·ªã m·∫∑c ƒë·ªãnh an to√†n
        try:
             if hasattr(self, 'openai_translation_style_var'):
                 selected_style = self.openai_translation_style_var.get()
                 # L·∫•y ph·∫ßn ch√≠nh c·ªßa phong c√°ch (v√≠ d·ª•: "C·ªï trang" t·ª´ "C·ªï trang (historical/ancient)")
                 # ƒë·ªÉ ƒë∆∞a v√†o prompt cho g·ªçn, ho·∫∑c d√πng c·∫£ chu·ªói n·∫øu mu·ªën r√µ r√†ng h∆°n v·ªõi AI
                 # T·∫°m th·ªùi d√πng c·∫£ chu·ªói ƒë·ªÉ AI d·ªÖ hi·ªÉu ng·ªØ c·∫£nh h∆°n
                 style_for_prompt = selected_style 
                 logging.info(f"S·∫Ω y√™u c·∫ßu d·ªãch OpenAI v·ªõi phong c√°ch: '{style_for_prompt}'")
             else:
                 logging.warning("Kh√¥ng t√¨m th·∫•y bi·∫øn openai_translation_style_var. S·ª≠ d·ª•ng phong c√°ch m·∫∑c ƒë·ªãnh.")
                 style_for_prompt = "neutral" # M·∫∑c ƒë·ªãnh n·∫øu bi·∫øn kh√¥ng t·ªìn t·∫°i
        except Exception as e_get_style:
            logging.error(f"L·ªói khi l·∫•y phong c√°ch d·ªãch OpenAI: {e_get_style}. S·ª≠ d·ª•ng phong c√°ch m·∫∑c ƒë·ªãnh.")
            style_for_prompt = "neutral"

        # --- Kh·ªüi t·∫°o OpenAI client (Gi·ªØ nguy√™n) ---
        try:
            client = OpenAI(api_key=api_key, timeout=60.0) # timeout=60 gi√¢y
        except Exception as e_client:
            logging.error(f"L·ªói khi kh·ªüi t·∫°o OpenAI client: {e_client}", exc_info=True)
            self.after(0, lambda err=str(e_client): messagebox.showerror("L·ªói Kh·ªüi t·∫°o OpenAI",
                                                                       f"Kh√¥ng th·ªÉ kh·ªüi t·∫°o k·∫øt n·ªëi ƒë·∫øn OpenAI:\n{err}",
                                                                       parent=self))
            return None

        # --- V√≤ng l·∫∑p d·ªãch t·ª´ng d√≤ng (Gi·ªØ nguy√™n c·∫•u tr√∫c) ---
        translated_texts = []
        num_lines = len(text_list)
        source_lang_name = source_lang if source_lang and source_lang != 'auto' else "the original language"
        logging.info(f"ƒêang g·ª≠i {num_lines} d√≤ng t·ªõi OpenAI API ƒë·ªÉ d·ªãch sang '{target_lang}' (Phong c√°ch: {style_for_prompt})...")

        for i, text_to_translate in enumerate(text_list):
            if self.stop_event.is_set():
                logging.warning("Y√™u c·∫ßu d·ª´ng trong qu√° tr√¨nh d·ªãch OpenAI.")
                return translated_texts 

            if not text_to_translate.strip():
                translated_texts.append("")
                continue

            # === X√ÇY D·ª∞NG PROMPT (ƒê√É TH√äM Y√äU C·∫¶U PHONG C√ÅCH) ===
            # X√°c ƒë·ªãnh ph·∫ßn m√¥ t·∫£ phong c√°ch cho prompt
            style_instruction = f"in a '{style_for_prompt}' style"
            # N·∫øu l√† m·∫∑c ƒë·ªãnh, c√≥ th·ªÉ kh√¥ng c·∫ßn th√™m g√¨ ho·∫∑c n√≥i r√µ l√† neutral
            if "M·∫∑c ƒë·ªãnh" in style_for_prompt or style_for_prompt.lower() == "neutral":
                 style_instruction = "in a neutral style" 
            # N·∫øu l√† c·ªï trang, c√≥ th·ªÉ c·∫ßn h∆∞·ªõng d·∫´n chi ti·∫øt h∆°n? (T√πy ch·ªçn)
            elif "C·ªï trang" in style_for_prompt:
                 style_instruction = "in a style suitable for historical or ancient contexts (e.g., historical drama, classic literature)"
            # B·∫°n c√≥ th·ªÉ th√™m c√°c elif kh√°c cho c√°c phong c√°ch ƒë·∫∑c bi·ªát c·∫ßn h∆∞·ªõng d·∫´n r√µ h∆°n

            prompt_message = (
                f"You are a highly skilled translator. Translate the following text "
                f"from {source_lang_name} to {target_lang} {style_instruction}. " # <== TH√äM Y√äU C·∫¶U PHONG C√ÅCH
                f"IMPORTANT: Respond ONLY with the translated text itself, without any introductory phrases, explanations, quotation marks, or markdown formatting."
                f"\n\nText to translate:\n---\n{text_to_translate}\n---"
                f"\n\nTranslated text:"
            )
            # Log prompt ƒë·ªÉ debug n·∫øu c·∫ßn (c√≥ th·ªÉ ch·ª©a n·ªôi dung nh·∫°y c·∫£m, c√¢n nh·∫Øc khi b·∫≠t)
            # logging.debug(f"Prompt g·ª≠i ƒë·∫øn OpenAI (d√≤ng {i+1}):\n{prompt_message}")

            # === G·ªçi API (Gi·ªØ nguy√™n c·∫•u tr√∫c g·ªçi) ===
            try:
                response = client.chat.completions.create(
                    model="gpt-3.5-turbo", # Ho·∫∑c model b·∫°n mu·ªën d√πng
                    messages=[
                        {"role": "user", "content": prompt_message}
                    ],
                    temperature=0.2, 
                    max_tokens=int(len(text_to_translate) * 2.5) + 60, # TƒÉng nh·∫π max_tokens d·ª± ph√≤ng
                )
                
                translated_line = response.choices[0].message.content.strip()

                # X·ª≠ l√Ω th√™m n·∫øu AI tr·∫£ v·ªÅ trong d·∫•u ngo·∫∑c k√©p ho·∫∑c markdown
                if translated_line.startswith('"') and translated_line.endswith('"'):
                   translated_line = translated_line[1:-1].strip()
                # C√≥ th·ªÉ th√™m x·ª≠ l√Ω markdown kh√°c n·∫øu c·∫ßn

                translated_texts.append(translated_line)
                # logging.debug(f"  -> D√≤ng {i+1} OK: '{translated_line[:50]}...'")

                time.sleep(0.3) # Gi·ªØ ƒë·ªô tr·ªÖ nh·ªè

            except Exception as api_call_error:
                logging.error(f"L·ªói khi g·ªçi API OpenAI cho d√≤ng {i+1}: {api_call_error}", exc_info=False)
                # Gi·ªØ l·∫°i d√≤ng g·ªëc n·∫øu c√≥ l·ªói API cho d√≤ng ƒë√≥
                translated_texts.append(text_to_translate) 
                time.sleep(1) 

        logging.info(f"OpenAI API ƒë√£ x·ª≠ l√Ω xong {len(translated_texts)} d√≤ng.")
        return translated_texts

        # except Exception as e:
        #     logging.error(f"L·ªói nghi√™m tr·ªçng khi s·ª≠ d·ª•ng OpenAI API: {e}", exc_info=True)
        #     self.after(0, lambda err=str(e): messagebox.showerror("L·ªói OpenAI API",
        #                                                            f"ƒê√£ x·∫£y ra l·ªói khi li√™n l·∫°c v·ªõi OpenAI:\n{err}",
        #                                                            parent=self))
        #     return None
        


# H√†m logic: D·ªãch m·ªôt file ph·ª• ƒë·ªÅ (SRT/VTT)
    def translate_subtitle_file(self, input_srt, output_srt, target_lang="vi", bilingual=False):
        """
        D·ªãch file ph·ª• ƒë·ªÅ s·ª≠ d·ª•ng engine ƒë∆∞·ª£c ch·ªçn, bao g·ªìm ki·ªÉm tra ƒëi·ªÅu ki·ªán.
        H√†m n√†y s·∫Ω raise ValueError n·∫øu engine ƒë∆∞·ª£c ch·ªçn kh√¥ng s·∫µn s√†ng.
        """
        selected_engine = self.translation_engine_var.get()
        base_input_name = os.path.basename(input_srt) # L·∫•y t√™n file ƒë·ªÉ log
        logging.info(f"B·∫Øt ƒë·∫ßu ki·ªÉm tra v√† d·ªãch file '{base_input_name}' b·∫±ng engine: {selected_engine}")

        # --- KI·ªÇM TRA ƒêI·ªÄU KI·ªÜN TI√äN QUY·∫æT CHO ENGINE ---
        if selected_engine == "Kh√¥ng d·ªãch":
            logging.info("Ng∆∞·ªùi d√πng ch·ªçn 'Kh√¥ng d·ªãch', b·ªè qua b∆∞·ªõc d·ªãch.")
            return 

        elif "Google Cloud API" in selected_engine:
            key_path = self.google_key_path_var.get()
            if not HAS_GOOGLE_CLOUD_TRANSLATE:
                msg = "Th∆∞ vi·ªán Google Cloud Translate ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t.\nVui l√≤ng c√†i ƒë·∫∑t: pip install google-cloud-translate"
                logging.error(msg)
                messagebox.showerror("L·ªói Th∆∞ vi·ªán", msg, parent=self)
                raise ValueError("Thi·∫øu th∆∞ vi·ªán Google Cloud Translate")
            if not key_path or not os.path.exists(key_path):
                msg = "Vui l√≤ng c·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n file JSON Key cho Google Cloud trong 'C√†i ƒë·∫∑t API Keys'."
                logging.error(msg)
                messagebox.showerror("Thi·∫øu C·∫•u h√¨nh Google Key", msg, parent=self)
                raise ValueError("Thi·∫øu ho·∫∑c sai c·∫•u h√¨nh Google Cloud Key")
            logging.info("ƒêi·ªÅu ki·ªán Google Cloud API h·ª£p l·ªá.")

        elif "ChatGPT API" in selected_engine:
            api_key = self.openai_key_var.get()
            if not HAS_OPENAI:
                msg = "Th∆∞ vi·ªán OpenAI ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t.\nVui l√≤ng c√†i ƒë·∫∑t: pip install openai"
                logging.error(msg)
                messagebox.showerror("L·ªói Th∆∞ vi·ªán", msg, parent=self)
                raise ValueError("Thi·∫øu th∆∞ vi·ªán OpenAI")
            if not api_key:
                msg = "Vui l√≤ng c·∫•u h√¨nh OpenAI API Key trong 'C√†i ƒë·∫∑t API Keys'."
                logging.error(msg)
                messagebox.showerror("Thi·∫øu C·∫•u h√¨nh OpenAI Key", msg, parent=self)
                raise ValueError("Thi·∫øu c·∫•u h√¨nh OpenAI Key")
            logging.info("ƒêi·ªÅu ki·ªán OpenAI API h·ª£p l·ªá.")

        else: # Tr∆∞·ªùng h·ª£p engine kh√¥ng x√°c ƒë·ªãnh (l·ªói logic ƒë√¢u ƒë√≥)
             msg = f"Engine d·ªãch kh√¥ng x√°c ƒë·ªãnh: '{selected_engine}'. Kh√¥ng th·ªÉ d·ªãch."
             logging.error(msg)
             messagebox.showerror("L·ªói Engine", msg, parent=self)
             raise ValueError("Engine d·ªãch kh√¥ng x√°c ƒë·ªãnh")

        # --- K·∫æT TH√öC KI·ªÇM TRA ƒêI·ªÄU KI·ªÜN ---

        # --- N·∫øu v∆∞·ª£t qua ki·ªÉm tra, ti·∫øn h√†nh ƒë·ªçc v√† d·ªãch file ---
        logging.info(f"B·∫Øt ƒë·∫ßu ƒë·ªçc v√† x·ª≠ l√Ω file '{base_input_name}'...")
        try:
            with open(input_srt, "r", encoding="utf-8") as f:
                lines = f.readlines()
            logging.debug(f"ƒê√£ ƒë·ªçc {len(lines)} d√≤ng t·ª´ file input.")
        except Exception as e:
            logging.error(f"L·ªói ƒë·ªçc file ph·ª• ƒë·ªÅ ƒë·ªÉ d·ªãch '{input_srt}': {e}", exc_info=True)
            # N√©m l·∫°i l·ªói ƒë·ªÉ lu·ªìng cha x·ª≠ l√Ω
            raise IOError(f"L·ªói ƒë·ªçc file ph·ª• ƒë·ªÅ ƒë·ªÉ d·ªãch: {e}")

        output_lines = []
        block = []
        processed_blocks = 0
        # L·∫∑p qua c√°c d√≤ng ƒë·ªÉ x·ª≠ l√Ω t·ª´ng kh·ªëi
        for line in lines:
            # Ki·ªÉm tra d·ª´ng gi·ªØa c√°c kh·ªëi
            if self.stop_event.is_set():
                logging.warning("Y√™u c·∫ßu d·ª´ng trong qu√° tr√¨nh x·ª≠ l√Ω kh·ªëi ph·ª• ƒë·ªÅ.")
                raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng khi ƒëang d·ªãch file.")

            if line.strip() == "": # K·∫øt th√∫c m·ªôt kh·ªëi
                if block:
                    # G·ªçi _translate_block ƒë√£ s·ª≠a (kh√¥ng c·∫ßn truy·ªÅn translator n·ªØa)
                    translated_block_lines = self._translate_block(block, target_lang, bilingual)
                    output_lines.extend(translated_block_lines)
                    processed_blocks += 1
                    logging.debug(f"ƒê√£ x·ª≠ l√Ω xong kh·ªëi {processed_blocks}")
                # output_lines.append("\n") # Kh√¥ng c·∫ßn th√™m d√≤ng tr·ªëng ·ªü ƒë√¢y v√¨ _translate_block ƒë√£ x·ª≠ l√Ω
                block = [] # B·∫Øt ƒë·∫ßu kh·ªëi m·ªõi
            else:
                block.append(line.strip() + "\n") # Th√™m l·∫°i k√Ω t·ª± xu·ªëng d√≤ng chu·∫©n

        # X·ª≠ l√Ω kh·ªëi cu·ªëi c√πng n·∫øu file kh√¥ng k·∫øt th√∫c b·∫±ng d√≤ng tr·ªëng
        if block:
            logging.debug("ƒêang x·ª≠ l√Ω kh·ªëi cu·ªëi c√πng...")
            translated_block_lines = self._translate_block(block, target_lang, bilingual)
            output_lines.extend(translated_block_lines)
            processed_blocks += 1
            logging.debug(f"ƒê√£ x·ª≠ l√Ω xong kh·ªëi cu·ªëi c√πng (T·ªïng c·ªông: {processed_blocks}).")

        # --- Ghi k·∫øt qu·∫£ ra file output ---
        try:
            # ƒê·∫£m b·∫£o file output k·∫øt th√∫c b·∫±ng m·ªôt d√≤ng tr·ªëng (theo chu·∫©n SRT/VTT)
            final_output_content = "".join(output_lines)
            # X√≥a c√°c d√≤ng tr·ªëng th·ª´a ·ªü cu·ªëi v√† ƒë·∫£m b·∫£o c√≥ 1 d√≤ng tr·ªëng cu·ªëi
            final_output_content = final_output_content.rstrip() + "\n\n"

            with open(output_srt, "w", encoding="utf-8") as f:
                f.write(final_output_content)
            logging.info(f"ƒê√£ l∆∞u ph·ª• ƒë·ªÅ ƒë√£ d·ªãch th√†nh c√¥ng v√†o: {output_srt}")
        except Exception as e:
            logging.error(f"L·ªói ghi file ph·ª• ƒë·ªÅ ƒë√£ d·ªãch '{output_srt}': {e}", exc_info=True)
            # N√©m l·∫°i l·ªói ƒë·ªÉ lu·ªìng cha x·ª≠ l√Ω
            raise IOError(f"L·ªói ghi file ph·ª• ƒë·ªÅ ƒë√£ d·ªãch: {e}")


# H√†m h·ªó tr·ª£ n·ªôi b·ªô: D·ªãch c√°c d√≤ng text trong m·ªôt kh·ªëi ph·ª• ƒë·ªÅ
    def _translate_block(self, block_lines, target_lang, bilingual):
        """
        H√†m h·ªó tr·ª£ d·ªãch c√°c d√≤ng text trong m·ªôt kh·ªëi ph·ª• ƒë·ªÅ,
        s·ª≠ d·ª•ng engine d·ªãch ƒë∆∞·ª£c ch·ªçn trong self.translation_engine_var.
        """
        out = []
        # ƒê·∫£m b·∫£o kh·ªëi c√≥ ƒë·ªß d√≤ng t·ªëi thi·ªÉu (index, timecode, text)
        if len(block_lines) < 3:
            logging.warning("Kh·ªëi ph·ª• ƒë·ªÅ kh√¥ng h·ª£p l·ªá, b·ªè qua d·ªãch.")
            return block_lines # Tr·∫£ v·ªÅ kh·ªëi g·ªëc n·∫øu kh√¥ng h·ª£p l·ªá

        # Gi·ªØ l·∫°i d√≤ng index v√† timecode
        out.append(block_lines[0])
        out.append(block_lines[1])

        # Tr√≠ch xu·∫•t c√°c d√≤ng vƒÉn b·∫£n c·∫ßn d·ªãch
        text_lines = [line.strip() for line in block_lines[2:] if line.strip()]

        # N·∫øu kh√¥ng c√≥ d√≤ng text n√†o th√¨ tr·∫£ v·ªÅ lu√¥n
        if not text_lines:
            # Th√™m d√≤ng tr·ªëng cu·ªëi n·∫øu kh·ªëi g·ªëc c√≥ (ƒë·ªÉ gi·ªØ ƒë·ªãnh d·∫°ng)
            if len(block_lines) > 2 and not block_lines[-1].strip():
                 out.append("\n")
            return out

        translated_lines_texts = None # Kh·ªüi t·∫°o l√† None
        selected_engine = self.translation_engine_var.get() # L·∫•y engine ng∆∞·ªùi d√πng ch·ªçn

        logging.debug(f"ƒêang x·ª≠ l√Ω kh·ªëi sub b·∫±ng engine: {selected_engine}")

        if "Google Cloud API" in selected_engine:
            # G·ªçi h√†m ƒë√£ vi·∫øt ·ªü B∆∞·ªõc 6
            # X√°c ƒë·ªãnh source_lang n·∫øu c√≥ th·ªÉ (v√≠ d·ª• t·ª´ l·ª±a ch·ªçn Whisper)
            source_lang_whisper = self.source_lang_var.get()
            source_param = source_lang_whisper if source_lang_whisper != 'auto' else None
            translated_lines_texts = self.translate_google_cloud(text_lines,
                                                                 target_lang_code=target_lang,
                                                                 source_lang_code=source_param)
            # H√†m n√†y tr·∫£ v·ªÅ None n·∫øu l·ªói nghi√™m tr·ªçng

        elif "ChatGPT API" in selected_engine:
            # G·ªçi h√†m ƒë√£ vi·∫øt ·ªü B∆∞·ªõc 7
            # X√°c ƒë·ªãnh source_lang n·∫øu c√≥ th·ªÉ
            source_lang_whisper = self.source_lang_var.get()
            source_param_name = LANGUAGE_MAP_VI.get(source_lang_whisper, source_lang_whisper) # L·∫•y t√™n ƒë·∫ßy ƒë·ªß cho prompt
            target_lang_name = LANGUAGE_MAP_VI.get(target_lang, target_lang) # L·∫•y t√™n ƒë·∫ßy ƒë·ªß
            translated_lines_texts = self.translate_openai(text_lines,
                                                           target_lang=target_lang_name,
                                                           source_lang=source_param_name if source_lang_whisper != 'auto' else None)
            # H√†m n√†y tr·∫£ v·ªÅ list (c√≥ th·ªÉ ch·ª©a d√≤ng g·ªëc n·∫øu l·ªói d√≤ng ƒë√≥) ho·∫∑c None n·∫øu l·ªói nghi√™m tr·ªçng

        # --- X·ª≠ l√Ω k·∫øt qu·∫£ v√† gh√©p kh·ªëi ---
        final_translated_lines = []
        use_original_text = False

        if translated_lines_texts is None:
            # L·ªói nghi√™m tr·ªçng x·∫£y ra trong qu√° tr√¨nh g·ªçi API (v√≠ d·ª•: thi·∫øu key)
            if selected_engine != "Kh√¥ng d·ªãch":
                 logging.error(f"D·ªãch b·∫±ng {selected_engine} th·∫•t b·∫°i ho√†n to√†n cho kh·ªëi. S·ª≠ d·ª•ng vƒÉn b·∫£n g·ªëc.")
            use_original_text = True
        elif len(translated_lines_texts) != len(text_lines):
            # S·ªë l∆∞·ª£ng d√≤ng tr·∫£ v·ªÅ kh√¥ng kh·ªõp (l·ªói kh√¥ng mong mu·ªën)
            logging.error(f"S·ªë d√≤ng d·ªãch tr·∫£ v·ªÅ ({len(translated_lines_texts)}) kh√¥ng kh·ªõp s·ªë d√≤ng g·ªëc ({len(text_lines)}) cho engine {selected_engine}. S·ª≠ d·ª•ng vƒÉn b·∫£n g·ªëc.")
            use_original_text = True
        else:
            # D·ªãch th√†nh c√¥ng (ho·∫∑c c√≥ l·ªói t·ª´ng d√≤ng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω b√™n trong h√†m API)
            final_translated_lines = translated_lines_texts

        # Gh√©p c√°c d√≤ng text v√†o kh·ªëi output
        for i, original_line in enumerate(text_lines):
            translated_line = original_line if use_original_text else final_translated_lines[i]

            if bilingual:
                # ƒê·∫£m b·∫£o kh√¥ng c√≥ d√≤ng tr·ªëng th·ª´a khi gh√©p song ng·ªØ
                out_line = f"{original_line.strip()}\n{translated_line.strip()}\n"
                out.append(out_line)
            else:
                out_line = f"{translated_line.strip()}\n"
                out.append(out_line)

        # ƒê·∫£m b·∫£o c√≥ d√≤ng tr·ªëng cu·ªëi c√πng n·∫øu kh·ªëi g·ªëc c√≥ (quan tr·ªçng cho ƒë·ªãnh d·∫°ng SRT/VTT)
        if len(block_lines) > 2 and not block_lines[-1].strip() and (not out or out[-1].strip()):
             out.append("\n")
        # Ho·∫∑c x√≥a b·ªõt d√≤ng tr·ªëng n·∫øu output th·ª´a ra
        elif out and not out[-1].strip() and (len(block_lines) <=2 or block_lines[-1].strip()):
             while out and not out[-1].strip(): out.pop()
             if out: out[-1] = out[-1].strip() + "\n\n" # ƒê·∫£m b·∫£o c√≥ 2 d√≤ng tr·ªëng cu·ªëi n·∫øu n√≥ l√† kh·ªëi cu·ªëi

        return out



# H√†m logic: G·∫Øn c·ª©ng (hardsub) ph·ª• ƒë·ªÅ v√†o video b·∫±ng FFmpeg
    def burn_sub_to_video(self, input_video, input_sub_path_srt, output_video, cfg_snapshot):
        logging.info(f"[HardsubBurning] B·∫Øt ƒë·∫ßu Hardsub cho: {os.path.basename(input_video)}")
        logging.info(f"[HardsubBurning] cfg_snapshot nh·∫≠n ƒë∆∞·ª£c: {json.dumps(cfg_snapshot, indent=2, ensure_ascii=False)}")

        # H·∫∞NG S·ªê THAM CHI·∫æU
        REFERENCE_VIDEO_HEIGHT_FOR_SCALING = 1080
        logging.info(f"[HardsubStyleDebug] S·ª≠ d·ª•ng REFERENCE_VIDEO_HEIGHT_FOR_SCALING: {REFERENCE_VIDEO_HEIGHT_FOR_SCALING}px")


        temp_ass_file_path = None
        try:
            subs_srt = pysubs2.load(input_sub_path_srt, encoding="utf-8")
            config_source = cfg_snapshot

            # --- L·∫•y th√¥ng tin k√≠ch th∆∞·ªõc video cho PlayRes v√† t√≠nh to√°n font ---
            video_width_for_ass = 1920  # M·∫∑c ƒë·ªãnh
            video_height_for_ass = 1080 # M·∫∑c ƒë·ªãnh
            ffprobe_exec_ass = find_ffprobe() # H√†m find_ffprobe() c·ªßa b·∫°n
            if ffprobe_exec_ass:
                try:
                    cmd_probe_res_ass = [ffprobe_exec_ass, "-v", "error", "-select_streams", "v:0",
                                         "-show_entries", "stream=width,height", "-of", "csv=s=x:p=0",
                                         os.path.abspath(input_video)]
                    startupinfo_probe = None; creationflags_probe = 0
                    if sys.platform == "win32":
                        startupinfo_probe = subprocess.STARTUPINFO(); startupinfo_probe.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                        startupinfo_probe.wShowWindow = subprocess.SW_HIDE; creationflags_probe = subprocess.CREATE_NO_WINDOW
                    probe_res_ass = subprocess.run(cmd_probe_res_ass, capture_output=True, text=True, timeout=10,
                                                   startupinfo=startupinfo_probe, creationflags=creationflags_probe, check=False)
                    if probe_res_ass.returncode == 0 and probe_res_ass.stdout.strip():
                        w_h_ass = probe_res_ass.stdout.strip().split('x')
                        if len(w_h_ass) == 2 and w_h_ass[0].isdigit() and w_h_ass[1].isdigit():
                            video_width_for_ass = int(w_h_ass[0]); video_height_for_ass = int(w_h_ass[1])
                            logging.info(f"[HardsubASSInfo] L·∫•y ƒë∆∞·ª£c k√≠ch th∆∞·ªõc video cho PlayRes: {video_width_for_ass}x{video_height_for_ass}")
                        else: logging.warning(f"[HardsubASSInfo] ffprobe tr·∫£ v·ªÅ ƒë·ªãnh d·∫°ng kh√¥ng mong mu·ªën: '{probe_res_ass.stdout.strip()}'.")
                    else: logging.warning(f"[HardsubASSInfo] ffprobe kh√¥ng l·∫•y ƒë∆∞·ª£c k√≠ch th∆∞·ªõc (Code: {probe_res_ass.returncode}).")
                except Exception as e_probe_ass: logging.warning(f"[HardsubASSInfo] L·ªói ffprobe: {e_probe_ass}.")
            else: logging.warning("[HardsubASSInfo] Kh√¥ng t√¨m th·∫•y ffprobe cho PlayRes.")

            # --- T√≠nh to√°n scaled_font_size ---
            config_font_size = float(config_source.get("sub_style_font_size", 60))
            reference_height = float(REFERENCE_VIDEO_HEIGHT_FOR_SCALING) # S·ª≠ d·ª•ng h·∫±ng s·ªë ƒë√£ ƒë·ªãnh nghƒ©a
            actual_video_height_for_scaling = float(video_height_for_ass)

            if reference_height > 0 and actual_video_height_for_scaling > 0:
                scaled_font_size = (config_font_size / reference_height) * actual_video_height_for_scaling
            else:
                scaled_font_size = config_font_size # Fallback
                logging.warning(f"[HardsubStyleDebug] L·ªói reference_height ({reference_height}) ho·∫∑c actual_video_height ({actual_video_height_for_scaling}) kh√¥ng h·ª£p l·ªá. D√πng config_font_size.")

            logging.info(f"[HardsubStyleDebug] ConfigFontSize: {config_font_size}, RefHeight: {reference_height}, ActualVidHeight: {actual_video_height_for_scaling}, ScaledFontSize for SSAStyle: {scaled_font_size:.2f}")
            # --- K·∫øt th√∫c t√≠nh to√°n scaled_font_size ---

            piu_style = pysubs2.SSAStyle()
            piu_style.fontname = config_source.get("sub_style_font_name", "Arial")
            piu_style.fontsize = scaled_font_size # <<<< S·ª¨ D·ª§NG FONT SIZE ƒê√É T√çNH TO√ÅN >>>>
            piu_style.bold = config_source.get("sub_style_font_bold", True)

            text_color_str = config_source.get("sub_style_text_color_rgb_str", "255,255,255")
            style_primary_color_rgb = parse_color_string_to_tuple(text_color_str, (255,255,255))
            primary_color_opacity_percent = config_source.get("sub_style_text_opacity_percent", 100)
            primary_transparency_decimal = (100.0 - primary_color_opacity_percent) / 100.0
            style_primary_color_alpha_pysubs2 = int(round(255 * primary_transparency_decimal))

            piu_style.primarycolor = pysubs2.Color(r=style_primary_color_rgb[0], g=style_primary_color_rgb[1], b=style_primary_color_rgb[2], a=style_primary_color_alpha_pysubs2)

            enable_outline_cfg = config_source.get("sub_style_outline_enabled", False)
            enable_background_box_cfg = config_source.get("sub_style_bg_box_enabled", False)

            logging.info(f"[HardsubStyleDebug] Style t·ª´ cfg_snapshot cho '{os.path.basename(input_video)}':")
            logging.info(f"[HardsubStyleDebug]   FontName: {piu_style.fontname}, ScaledFontSize: {piu_style.fontsize:.2f}, Bold: {piu_style.bold}") # Log scaled font size
            logging.info(f"[HardsubStyleDebug]   TextColorRGB: {style_primary_color_rgb}, TextAlphaPysubs2: {style_primary_color_alpha_pysubs2}")
            logging.info(f"[HardsubStyleDebug]   EnableOutline Checkbox: {enable_outline_cfg}")
            logging.info(f"[HardsubStyleDebug]   EnableBackgroundBox Checkbox: {enable_background_box_cfg}")


    # L·∫•y ch·∫ø ƒë·ªô n·ªÅn t·ª´ config
            background_mode = config_source.get("sub_style_background_mode", "ƒê·ªï B√≥ng")

            # --- B·∫ÆT ƒê·∫¶U KH·ªêI LOGIC ƒê√É S·ª¨A L·ªñI (V2 - HO√ÄN CH·ªàNH) ---
            
            # Thi·∫øt l·∫≠p m·∫∑c ƒë·ªãnh an to√†n: Ch·ªâ c√≥ ch·ªØ, kh√¥ng vi·ªÅn, kh√¥ng b√≥ng, kh√¥ng box.
            piu_style.borderstyle = 1 
            piu_style.outline = 0.0
            piu_style.shadow = 0.0

            if background_mode == "Box N·ªÅn":
                logging.info("[HardsubStyleLogic] √Åp d·ª•ng BOX N·ªÄN (borderstyle=3).")
                piu_style.borderstyle = 3 # B·∫≠t ch·∫ø ƒë·ªô box n·ªÅn
                
                # L·∫•y c√°c gi√° tr·ªã m√†u s·∫Øc v√† ƒë·ªô m·ªù cho box t·ª´ config
                bg_opacity_percent = config_source.get("sub_style_bg_box_actual_opacity_percent", 75)
                bg_color_str = config_source.get("sub_style_bg_color_rgb_str", "0,0,0")
                bg_rgb = parse_color_string_to_tuple(bg_color_str, (0,0,0))
                bg_alpha = int(round(255 * (100.0 - bg_opacity_percent) / 100.0))
                
                piu_style.backcolor = pysubs2.Color(r=bg_rgb[0], g=bg_rgb[1], b=bg_rgb[2], a=bg_alpha)
                # ƒê·∫∑t outline b·∫±ng 1 v·ªõi m√†u tr√πng m√†u n·ªÅn ƒë·ªÉ c√≥ vi·ªÅn box s·∫Øc n√©t
                piu_style.outline = 1.0 
                piu_style.outlinecolor = piu_style.backcolor

            elif background_mode == "ƒê·ªï B√≥ng":
                logging.info("[HardsubStyleLogic] √Åp d·ª•ng HI·ªÜU ·ª®NG ƒê·ªî B√ìNG (shadow=2.0).")
                piu_style.shadow = 2.0 # ƒê·∫∑t ƒë·ªô m·ªù c·ªßa b√≥ng
                
                # L·∫•y m√†u s·∫Øc v√† ƒë·ªô m·ªù c·ªßa b√≥ng t·ª´ config (d√πng chung bi·∫øn v·ªõi box n·ªÅn)
                shadow_opacity_percent = config_source.get("sub_style_bg_box_actual_opacity_percent", 75)
                shadow_color_str = config_source.get("sub_style_bg_color_rgb_str", "0,0,0")
                shadow_rgb = parse_color_string_to_tuple(shadow_color_str, (0,0,0))
                shadow_alpha = int(round(255 * (100.0 - shadow_opacity_percent) / 100.0))
                
                piu_style.backcolor = pysubs2.Color(r=shadow_rgb[0], g=shadow_rgb[1], b=shadow_rgb[2], a=shadow_alpha)
                
                # N·∫øu ng∆∞·ªùi d√πng c≈©ng b·∫≠t vi·ªÅn ch·ªØ, th√¨ √°p d·ª•ng c·∫£ vi·ªÅn ch·ªØ
                if config_source.get("sub_style_outline_enabled", False):
                    logging.info("[HardsubStyleLogic]   -> K√®m c·∫£ VI·ªÄN CH·ªÆ.")
                    outline_size = config_source.get("sub_style_outline_size", 2.0)
                    outline_color_str = config_source.get("sub_style_outline_color_rgb_str", "0,0,0")
                    outline_rgb = parse_color_string_to_tuple(outline_color_str, (0,0,0))
                    outline_opacity = config_source.get("sub_style_outline_opacity_percent", 100)
                    outline_alpha = int(round(255 * (100.0 - outline_opacity) / 100.0))
                    
                    piu_style.outline = float(outline_size)
                    piu_style.outlinecolor = pysubs2.Color(r=outline_rgb[0], g=outline_rgb[1], b=outline_rgb[2], a=outline_alpha)

            elif background_mode == "Kh√¥ng N·ªÅn":
                # shadow ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t v·ªÅ 0.0 ·ªü ph·∫ßn m·∫∑c ƒë·ªãnh.
                if config_source.get("sub_style_outline_enabled", False):
                    logging.info("[HardsubStyleLogic] √Åp d·ª•ng VI·ªÄN CH·ªÆ (Kh√¥ng N·ªÅn).")
                    outline_size = config_source.get("sub_style_outline_size", 2.0)
                    outline_color_str = config_source.get("sub_style_outline_color_rgb_str", "0,0,0")
                    outline_rgb = parse_color_string_to_tuple(outline_color_str, (0,0,0))
                    outline_opacity = config_source.get("sub_style_outline_opacity_percent", 100)
                    outline_alpha = int(round(255 * (100.0 - outline_opacity) / 100.0))

                    piu_style.outline = float(outline_size)
                    piu_style.outlinecolor = pysubs2.Color(r=outline_rgb[0], g=outline_rgb[1], b=outline_rgb[2], a=outline_alpha)
                else:
                    logging.info("[HardsubStyleLogic] Ch·∫ø ƒë·ªô Kh√¥ng N·ªÅn v√† kh√¥ng c√≥ vi·ªÅn.")

            # --- K·∫æT TH√öC KH·ªêI LOGIC ƒê√É S·ª¨A L·ªñI ---

            piu_style.alignment = 2
            piu_style.marginv = config_source.get("margin_v", 60)
            logging.info(f"[HardsubStyleDebug]   Alignment: {piu_style.alignment}, MarginV: {piu_style.marginv}")

            style_name_in_ass = "PiuCustomStyle"
            subs_srt.styles[style_name_in_ass] = piu_style
            for event in subs_srt:
                event.style = style_name_in_ass

            # ƒê·∫∑t PlayResX v√† PlayResY d·ª±a tr√™n k√≠ch th∆∞·ªõc video th·ª±c t·∫ø
            if not hasattr(subs_srt, 'info') or subs_srt.info is None: subs_srt.info = {}
            subs_srt.info["PlayResX"] = str(video_width_for_ass)
            subs_srt.info["PlayResY"] = str(video_height_for_ass)
            subs_srt.info["WrapStyle"] = "0" # Ho·∫∑c gi√° tr·ªã wrap style mong mu·ªën
            logging.info(f"[HardsubASSInfo] ƒê√£ ƒë·∫∑t PlayResX={subs_srt.info['PlayResX']}, PlayResY={subs_srt.info['PlayResY']}")

            temp_ass_filename = f"styled_subs_playres_{uuid.uuid4().hex[:8]}.ass"
            temp_ass_file_path = os.path.join(self.temp_folder, temp_ass_filename)
            subs_srt.save(temp_ass_file_path, encoding="utf-8", format_="ass")
            logging.info(f"ƒê√£ t·∫°o file .ass (c√≥ PlayRes): {temp_ass_file_path}")

            try:
                with open(temp_ass_file_path, "r", encoding="utf-8") as f_ass_check:
                    ass_content_log = f_ass_check.read()
                logging.debug(f"[HardsubStyleDebug] N·ªôi dung file ASS ({os.path.basename(temp_ass_file_path)}):\n{ass_content_log[:2000]}")
            except Exception as e_log_ass_content:
                logging.warning(f"[HardsubStyleDebug] Kh√¥ng th·ªÉ ƒë·ªçc file ASS ƒë·ªÉ log: {e_log_ass_content}")

            posix_path = Path(os.path.abspath(temp_ass_file_path)).as_posix()
            escaped_path = posix_path.replace('\\', '\\\\').replace("'", "\\'").replace(":", "\\:").replace(",", "\\,").replace("[", "\\[").replace("]", "\\]")
            filter_complex_str = f"[0:v]ass=filename='{escaped_path}'[video_out]"
            cmd_params = [
                "-y", 
                "-i", os.path.abspath(input_video), 
                "-filter_complex", filter_complex_str,
                "-map", "[video_out]", "-map", "0:a?", 
                "-c:v", "libx264",
                "-preset", config_source.get("ffmpeg_preset", "medium"),
                "-crf", str(config_source.get("ffmpeg_crf", 22)),
                # Th√™m c√°c c·ªù t∆∞∆°ng th√≠ch cho iPhone/mobile
                "-profile:v", "main",   # <-- TH√äM D√íNG N√ÄY: Profile t∆∞∆°ng th√≠ch r·ªông
                "-level", "4.0",        # <-- TH√äM D√íNG N√ÄY: Level cho FullHD, r·∫•t an to√†n
                "-pix_fmt", "yuv420p",   # <-- TH√äM D√íNG N√ÄY: ƒê·ªãnh d·∫°ng pixel b·∫Øt bu·ªôc cho nhi·ªÅu thi·∫øt b·ªã
                "-movflags", "+faststart", # <-- TH√äM D√íNG N√ÄY: T·ªëi ∆∞u cho streaming
                "-c:a", "copy", 
                os.path.abspath(output_video)
            ]
            ffmpeg_run_command(
                cmd_params,
                "Hardsub",
                stop_event=self.stop_event,
                set_current_process=lambda p: setattr(self, 'current_process', p),
                clear_current_process=lambda: setattr(self, 'current_process', None),
            )
            logging.info(f"Hardsub ho√†n t·∫•t cho: {os.path.basename(output_video)}")
        except Exception as e_burn:
            logging.error(f"L·ªói nghi√™m tr·ªçng trong burn_sub_to_video: {e_burn}", exc_info=True)
            raise RuntimeError(f"L·ªói t·∫°o ho·∫∑c burn file ASS/video: {e_burn}")
        finally:
            if temp_ass_file_path and os.path.exists(temp_ass_file_path):
                try:
                    os.remove(temp_ass_file_path) # X√≥a file ASS t·∫°m sau khi d√πng
                    logging.info(f"ƒê√£ x√≥a file .ass t·∫°m: {temp_ass_file_path}")
                except Exception as e_del:
                    logging.warning(f"L·ªói x√≥a file .ass t·∫°m '{temp_ass_file_path}': {e_del}")


# H√†m logic: G·∫Øn m·ªÅm (softsub) ph·ª• ƒë·ªÅ v√†o container video b·∫±ng FFmpeg
    def merge_sub_as_soft_sub(self, video_path, sub_path, output_path, lang_code='und'):
        """ G·∫Øn m·ªÅm (softsub) ph·ª• ƒë·ªÅ v√†o container video b·∫±ng FFmpeg """
        logging.info(f"B·∫Øt ƒë·∫ßu Softsub: Video='{os.path.basename(video_path)}', Sub='{os.path.basename(sub_path)}'")
        sub_ext = os.path.splitext(sub_path)[1].lower()
        output_ext = os.path.splitext(output_path)[1].lower()

        # X√°c ƒë·ªãnh codec ph·ª• ƒë·ªÅ d·ª±a tr√™n container output
        if output_ext == ".mkv":
            sub_codec = {".srt": "srt", ".ass": "ass", ".vtt": "webvtt"}.get(sub_ext)
            if not sub_codec: raise ValueError(f"ƒê·ªãnh d·∫°ng ph·ª• ƒë·ªÅ '{sub_ext}' kh√¥ng h·ªó tr·ª£ MKV Softsub.")
        elif output_ext == ".mp4":
            if sub_ext not in [".srt", ".vtt"]:
                 # T·ª± ƒë·ªông chuy·ªÉn sang MKV n·∫øu ƒë·ªãnh d·∫°ng kh√¥ng t∆∞∆°ng th√≠ch MP4 (nh∆∞ ASS)
                 output_path = os.path.splitext(output_path)[0] + ".mkv"
                 logging.warning(f"ƒê√£ chuy·ªÉn output sang MKV ƒë·ªÉ t∆∞∆°ng th√≠ch softsub '{sub_ext}': {os.path.basename(output_path)}")
                 sub_codec = {".srt": "srt", ".ass": "ass", ".vtt": "webvtt"}.get(sub_ext) # Ki·ªÉm tra l·∫°i codec cho MKV
            else: sub_codec = "mov_text" # S·ª≠ d·ª•ng mov_text cho SRT/VTT trong MP4
        else: raise ValueError(f"Container output '{output_ext}' kh√¥ng h·ªó tr·ª£ Softsub.")
        if not sub_codec: raise ValueError(f"Kh√¥ng th·ªÉ x√°c ƒë·ªãnh codec ph·ª• ƒë·ªÅ cho '{sub_ext}' trong '{output_ext}'.")


        cmd_params = [
            "-y", "-i", os.path.abspath(video_path), "-i", os.path.abspath(sub_path),
            "-map", "0:v", "-map", "0:a", "-map", "1:s", # Map c√°c lu·ªìng
            "-c:v", "copy", "-c:a", "copy", "-c:s", sub_codec, # Sao ch√©p video/audio, ƒë·∫∑t codec sub
            "-metadata:s:s:0", f"language={lang_code}", # ƒê·∫∑t metadata ng√¥n ng·ªØ cho lu·ªìng sub
            os.path.abspath(output_path).replace("\\", "/")
        ]
        ffmpeg_run_command(
            cmd_params,
            "Softsub",
            stop_event=self.stop_event,
            set_current_process=lambda p: setattr(self, 'current_process', p),
            clear_current_process=lambda: setattr(self, 'current_process', None),
        )


                
# --------------------
# 4.8 Logic C·ªët l√µi - Qu·∫£n l√Ω Model Whisper
# --------------------

# H√†m logic: X√°c ƒë·ªãnh thi·∫øt b·ªã (device) n√™n d√πng ƒë·ªÉ t·∫£i model Whisper
    def _determine_target_device(self):
        """
        X√°c ƒë·ªãnh device n√™n d√πng ('cuda' ho·∫∑c 'cpu').
        PHI√äN B·∫¢N S·ª¨A L·ªñI: ∆Øu ti√™n ki·ªÉm tra torch.cuda.is_available() tr∆∞·ªõc ti√™n.
        """
        try:
            import torch # Import torch ƒë·ªÉ th·ª±c hi·ªán ki·ªÉm tra
            
            # --- KI·ªÇM TRA QUAN TR·ªåNG NH·∫§T: PyTorch c√≥ th·∫•y CUDA kh√¥ng? ---
            if not torch.cuda.is_available():
                logging.warning("torch.cuda.is_available() is False. B·∫ÆT BU·ªòC s·ª≠ d·ª•ng CPU.")
                return "cpu"
            # --- K·∫æT TH√öC KI·ªÇM TRA ---

            # N·∫øu PyTorch th·∫•y CUDA, ti·∫øp t·ª•c v·ªõi logic c≈© ƒë·ªÉ ki·ªÉm tra VRAM
            if self.cuda_status != 'AVAILABLE':
                logging.debug("X√°c ƒë·ªãnh device: CPU (do CUDA status t·ª´ nvidia-smi kh√¥ng ph·∫£i AVAILABLE, d√π torch th·∫•y CUDA?)") # L·∫° nh∆∞ng ƒë·ªÉ an to√†n
                return "cpu"

            selected_model = self.model_var.get()
            required_vram = WHISPER_VRAM_REQ_MB.get(selected_model, 0)

            if self.gpu_vram_mb > 0 and required_vram > 0:
                if self.gpu_vram_mb < required_vram:
                    logging.warning(f"VRAM GPU ({self.gpu_vram_mb / 1024:.1f}GB) kh√¥ng ƒë·ªß cho model '{selected_model}' (~{required_vram / 1024:.1f}GB). S·∫Ω t·ª± ƒë·ªông d√πng CPU.")
                    return "cpu"
                else:
                    logging.debug(f"X√°c ƒë·ªãnh device: CUDA (torch th·∫•y CUDA v√† VRAM ƒë·ªß: {self.gpu_vram_mb}MB >= {required_vram}MB)")
                    return "cuda"
            else:
                logging.debug("X√°c ƒë·ªãnh device: CUDA (torch th·∫•y CUDA, kh√¥ng c√≥ th√¥ng tin VRAM ho·∫∑c model kh√¥ng y√™u c·∫ßu)")
                return "cuda"

        except ImportError:
            logging.error("L·ªói: Kh√¥ng th·ªÉ import th∆∞ vi·ªán 'torch'. S·∫Ω d√πng CPU.")
            return "cpu"
        except Exception as e:
            logging.error(f"L·ªói kh√¥ng mong mu·ªën trong _determine_target_device: {e}. S·∫Ω d√πng CPU.")
            return "cpu"
    

# H√†m T·∫£i model Whisper n·∫øu c·∫ßn, d·ª±a tr√™n t√™n model V√Ä thi·∫øt b·ªã ƒë√≠ch. ---
    def load_whisper_model_if_needed(self, force_reload=False, callback=None):
        """
        T·∫£i model Whisper n·∫øu c·∫ßn, d·ª±a tr√™n t√™n model V√Ä thi·∫øt b·ªã ƒë√≠ch.
        PHI√äN B·∫¢N HO√ÄN CH·ªàNH: T√≠ch h·ª£p v·ªõi chu·ªói kh·ªüi ƒë·ªông tu·∫ßn t·ª± v√† c√≥ th√¥ng b√°o chi ti·∫øt.
        """
        if not HAS_WHISPER:
            logging.error("Kh√¥ng th·ªÉ t·∫£i model Whisper: th∆∞ vi·ªán whisper ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t.")
            if callback: callback() # Ph·∫£i g·ªçi callback ƒë·ªÉ kh√¥ng l√†m k·∫πt chu·ªói kh·ªüi ƒë·ªông
            return

        if self.is_loading_model:
            logging.info("ƒêang trong qu√° tr√¨nh t·∫£i model Whisper kh√°c. B·ªè qua y√™u c·∫ßu m·ªõi.")
            # Kh√¥ng g·ªçi callback ·ªü ƒë√¢y v√¨ m·ªôt lu·ªìng kh√°c ƒëang ch·∫°y v√† s·∫Ω ch·ªãu tr√°ch nhi·ªám g·ªçi callback c·ªßa n√≥.
            return

        target_model = self.model_var.get()
        target_device = self._determine_target_device()

        should_load = (
            force_reload or
            self.whisper_model is None or
            self.loaded_model_name != target_model or
            self.loaded_model_device != target_device
        )

        if should_load:
            logging.info(f"C·∫ßn t·∫£i/load l·∫°i model '{target_model}' l√™n device '{target_device}'.")

            self.is_loading_model = True
            self.is_loading_model_for_timer = True
            if self.start_time is None: # Ch·ªâ ƒë·∫∑t start_time n·∫øu ch∆∞a c√≥ t√°c v·ª• n√†o kh√°c ƒëang ch·∫°y
                self.start_time = time.time()

            # --- Logic hi·ªÉn th·ªã th√¥ng b√°o chi ti·∫øt ---
            whisper_model_sizes = {
                "tiny": "~72MB", "base": "~142MB", "small": "~466MB",
                "medium": "~1.42GB", "large": "~2.85GB", 
                "large-v1": "~2.85GB", "large-v2": "~2.85GB", "large-v3": "~2.85GB"
            }
            size_estimate = whisper_model_sizes.get(target_model, "")

            # T·∫°o th√¥ng b√°o ng·∫Øn g·ªçn cho thanh status ch√≠nh sau n√†y
            status_message_for_timer = f"‚è≥ T·∫£i model: {target_model} ({size_estimate})..."
            self._last_status_text = status_message_for_timer # L∆∞u l·∫°i ƒë·ªÉ ƒë·ªìng h·ªì s·ª≠ d·ª•ng

            # T·∫°o th√¥ng b√°o ƒë·∫ßy ƒë·ªß cho m√†n h√¨nh ch·ªù
            status_message_for_splash = (
                f"üß† ƒêang chu·∫©n b·ªã m√¥ h√¨nh Tr√≠ tu·ªá nh√¢n t·∫°o...\n"
                f"T·∫£i model: {target_model} ({size_estimate})\n"
                f"(Vi·ªác n√†y c√≥ th·ªÉ m·∫•t v√†i ph√∫t ·ªü l·∫ßn ƒë·∫ßu)"
            )
            
            # C·∫≠p nh·∫≠t tr·ª±c ti·∫øp l√™n m√†n h√¨nh ch·ªù n·∫øu n√≥ v·∫´n c√≤n
            if hasattr(self, 'splash') and self.splash and self.splash.winfo_exists():
                # H√†m update_status trong SplashScreen ƒë√£ c√≥ hi·ªáu ·ª©ng fade
                self.splash.update_status(status_message_for_timer) 
            
            logging.info(status_message_for_splash.replace('\n', ' '))
            # --- K·∫øt th√∫c logic th√¥ng b√°o ---

            self.after(1000, self.update_time_realtime)

            sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
            if sub_button and sub_button.winfo_exists():
                try:
                    sub_button.configure(state="disabled", text=f"ƒêang t·∫£i {target_model}...")
                except Exception as e:
                    logging.warning(f"Kh√¥ng th·ªÉ v√¥ hi·ªáu h√≥a n√∫t Sub: {e}")

            thread = threading.Thread(
                target=self._load_whisper_model_thread,
                args=(target_model, target_device, callback), # Truy·ªÅn callback v√†o lu·ªìng
                daemon=True,
                name=f"WhisperLoad_{target_model}_{target_device}"
            )
            thread.start()
        
        elif callback:
            # R·∫•t quan tr·ªçng: N·∫øu kh√¥ng c·∫ßn t·∫£i, v·∫´n ph·∫£i g·ªçi callback ƒë·ªÉ chu·ªói kh·ªüi ƒë·ªông ti·∫øp t·ª•c!
            logging.info(f"Model '{target_model}' tr√™n device '{target_device}' ƒë√£ s·∫µn s√†ng. B·ªè qua t·∫£i v√† ti·∫øp t·ª•c chu·ªói.")
            self.mark_startup_task_done('ai_model')
            callback()


# H√†m logic (ch·∫°y trong lu·ªìng): T·∫£i model Whisper l√™n thi·∫øt b·ªã c·ª• th·ªÉ
    def _load_whisper_model_thread(self, target_model, target_device, callback=None):
        """(ƒê√É C·∫¨P NH·∫¨T) T·∫£i model Whisper an to√†n cho GUI: v√¥ hi·ªáu tqdm, redirect stdout/stderr, v√† kh√¥i ph·ª•c tr·∫°ng th√°i sau khi load.
           + Fallback: n·∫øu load CUDA l·ªói -> t·ª± chuy·ªÉn sang CPU."""
        import os, sys, gc
        from contextlib import redirect_stdout, redirect_stderr

        with keep_awake(f"Loading Whisper model {target_model}"):
            try:
                # B√°o UI
                self.after(0, lambda tm=target_model, td=target_device:
                           self.update_status(f"‚è≥ ƒêang t·∫£i/n·∫°p model: {tm} ({td})... (C√≥ th·ªÉ m·∫•t v√†i ph√∫t)"))
                logging.info(f"B·∫Øt ƒë·∫ßu t·∫£i/n·∫°p model Whisper: {target_model} l√™n device {target_device}")

                # Ki·ªÉm tra th∆∞ vi·ªán
                if not HAS_WHISPER:
                    raise ImportError("Kh√¥ng t√¨m th·∫•y th∆∞ vi·ªán Whisper ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t.")

                # D·ªçn model c≈© ƒë·ªÉ gi·∫£i ph√≥ng VRAM/RAM
                if getattr(self, "whisper_model", None) is not None:
                    logging.debug("ƒêang d·ªçn d·∫πp model Whisper c≈© kh·ªèi b·ªô nh·ªõ...")
                    del self.whisper_model
                    self.whisper_model = None
                    gc.collect()
                    if str(target_device).lower() == "cuda":
                        try:
                            import torch
                            if torch.cuda.is_available():
                                torch.cuda.empty_cache()
                        except Exception:
                            pass
                    logging.debug("D·ªçn d·∫πp model c≈© ho√†n t·∫•t.")

                # ------------------ FIX tqdm / sys.stderr ------------------
                # L∆∞u l·∫°i tr·∫°ng th√°i bi·∫øn m√¥i tr∆∞·ªùng ƒë·ªÉ kh√¥i ph·ª•c v·ªÅ sau
                _old_tqdm_disable = os.environ.get("TQDM_DISABLE", None)

                # M·ªü /dev/null (Windows c≈©ng OK v√¨ os.devnull)
                with open(os.devnull, "w", encoding="utf-8") as fnull:
                    # N·∫øu sys.stderr hi·ªán l√† None (th∆∞·ªùng g·∫∑p trong GUI), t·∫°m g√°n v·ªÅ fnull
                    _orig_stderr = sys.stderr
                    _patched_stderr = False
                    if _orig_stderr is None:
                        sys.stderr = fnull
                        _patched_stderr = True

                    try:
                        # T·∫Øt progress bar c·ªßa tqdm trong l√∫c load
                        os.environ["TQDM_DISABLE"] = "1"
                        logging.debug("ƒê√£ ƒë·∫∑t TQDM_DISABLE=1 trong l√∫c g·ªçi whisper.load_model().")

                        # Chuy·ªÉn h∆∞·ªõng c·∫£ stdout & stderr v·ªÅ fnull ƒë·ªÉ m·ªçi th∆∞ vi·ªán con kh√¥ng in/ghi ra console
                        with redirect_stdout(fnull), redirect_stderr(fnull):
                            logging.debug(f"G·ªçi whisper.load_model('{target_model}', device='{target_device}')...")

                            # >>> Fallback CUDA -> CPU
                            try:
                                loaded_model = whisper.load_model(target_model, device=target_device)
                            except Exception as e1:
                                if str(target_device).lower() == 'cuda':
                                    logging.warning(f"CUDA load th·∫•t b·∫°i: {e1}. Fallback v·ªÅ CPU...")
                                    # B√°o nh·∫π l√™n status (kh√¥ng popup)
                                    self.after(0, lambda: self.update_status("‚ö†Ô∏è CUDA l·ªói, ƒëang chuy·ªÉn sang CPU..."))
                                    try:
                                        loaded_model = whisper.load_model(target_model, device="cpu")
                                        target_device = "cpu"  # c·∫≠p nh·∫≠t device th·ª±c t·∫ø ƒë√£ d√πng
                                    except Exception as e2:
                                        # N√©m l·∫°i l·ªói g·ªëc + l·ªói fallback cho kh·ªëi except ngo√†i x·ª≠ l√Ω
                                        raise RuntimeError(f"CUDA error: {e1}; CPU fallback error: {e2}") from e2
                                else:
                                    # Kh√¥ng ph·∫£i CUDA th√¨ ƒë·ªÉ kh·ªëi except ngo√†i x·ª≠ l√Ω
                                    raise
                            # <<< Fallback end

                    finally:
                        # Kh√¥i ph·ª•c bi·∫øn m√¥i tr∆∞·ªùng TQDM_DISABLE nh∆∞ c≈©
                        if _old_tqdm_disable is None:
                            os.environ.pop("TQDM_DISABLE", None)
                        else:
                            os.environ["TQDM_DISABLE"] = _old_tqdm_disable

                        # Tr·∫£ l·∫°i sys.stderr n·∫øu m√¨nh c√≥ ‚Äúv√° t·∫°m‚Äù
                        if _patched_stderr:
                            sys.stderr = _orig_stderr
                # ---------------- K·∫æT TH√öC FIX tqdm / sys.stderr ------------

                logging.info(f"whisper.load_model('{target_model}', device='{target_device}') ho√†n t·∫•t.")

                # Th√†nh c√¥ng ‚Üí c·∫≠p nh·∫≠t v·ªÅ lu·ªìng ch√≠nh
                self.after(0, self._update_loaded_model, loaded_model, target_model, target_device, callback)

            except ImportError as e:
                logging.error(f"L·ªói import th∆∞ vi·ªán whisper khi ƒëang t·∫£i model: {e}")
                self.after(0, lambda: messagebox.showerror(
                    "L·ªói Import",
                    "Kh√¥ng t√¨m th·∫•y th∆∞ vi·ªán Whisper. Vui l√≤ng c√†i ƒë·∫∑t:\n\npip install -U openai-whisper"
                ))
                self.after(0, self._update_loaded_model, None, None, None, callback)

            except Exception as e:
                logging.error(f"L·ªói t·∫£i model Whisper '{target_model}' l√™n '{target_device}': {e}", exc_info=True)
                self.after(0, lambda err=e, tm=target_model, td=target_device: messagebox.showerror(
                    "L·ªói T·∫£i Model",
                    f"ƒê√£ x·∫£y ra l·ªói khi t·∫£i model '{tm}' l√™n thi·∫øt b·ªã '{td}':\n{err}"
                ))
                self.after(0, self._update_loaded_model, None, None, None, callback)

            finally:
                # Lu√¥n tr·∫£ UI v·ªÅ tr·∫°ng th√°i b√¨nh th∆∞·ªùng
                self.after(0, self._reset_model_loading_ui)
                self.after(0, lambda: setattr(self, "is_loading_model", False))
                logging.debug(f"Ho√†n t·∫•t lu·ªìng t·∫£i cho model '{target_model}' device '{target_device}'.")


# H√†m callback: C·∫≠p nh·∫≠t tr·∫°ng th√°i model Whisper ƒë√£ ƒë∆∞·ª£c t·∫£i (ch·∫°y tr√™n lu·ªìng ch√≠nh)
    def _update_loaded_model(self, model_object, model_name, loaded_device, callback=None):
        """
        (ƒê√É S·ª¨A L·ªñI) Callback ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i model, device,
        v√† quan tr·ªçng l√† G·ªåI H√ÄM RESET UI T·ªîNG TH·ªÇ.
        """
        self.whisper_model = model_object
        self.loaded_model_name = model_name
        self.loaded_model_device = loaded_device
        
        # T·∫Øt c·ªù timer ngay khi c√≥ k·∫øt qu·∫£
        self.is_loading_model_for_timer = False
        logging.debug("ƒê√£ ƒë·∫∑t is_loading_model_for_timer = False trong _update_loaded_model.")

        if model_object and loaded_device:
            logging.info(f"ƒê√£ t·∫£i th√†nh c√¥ng model Whisper '{model_name}' l√™n device '{loaded_device}'.")
            self.update_status(f"‚úÖ Model '{model_name}' ({loaded_device}) ƒë√£ s·∫µn s√†ng.")
            self.mark_startup_task_done('model')
        else:
            # X·ª≠ l√Ω khi load l·ªói
            logging.warning("Model Whisper ch∆∞a ƒë∆∞·ª£c t·∫£i ho·∫∑c c√≥ l·ªói.")
            self.update_status("‚ö†Ô∏è Model ch∆∞a ƒë∆∞·ª£c t·∫£i ho·∫∑c c√≥ l·ªói khi t·∫£i.")
            self.whisper_model = None
            self.loaded_model_name = None
            self.loaded_model_device = None

        # --- THAY ƒê·ªîI QUAN TR·ªåNG NH·∫§T ---
        # Thay v√¨ g·ªçi _reset_model_loading_ui, g·ªçi h√†m qu·∫£n l√Ω UI ch√≠nh c·ªßa tab
        if hasattr(self, '_set_subtitle_tab_ui_state'):
            # G·ªçi sau m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o c√°c thay ƒë·ªïi bi·∫øn ·ªü tr√™n ƒë√£ ho√†n t·∫•t
            self.after(50, lambda: self._set_subtitle_tab_ui_state(subbing_active=False))
            logging.info("ƒê√£ l√™n l·ªãch _set_subtitle_tab_ui_state(False) ƒë·ªÉ kh√¥i ph·ª•c to√†n b·ªô UI tab Sub.")
        else:
            # Fallback n·∫øu h√†m ch√≠nh kh√¥ng t·ªìn t·∫°i (hi·∫øm)
            logging.error("Kh√¥ng t√¨m th·∫•y h√†m _set_subtitle_tab_ui_state ƒë·ªÉ kh√¥i ph·ª•c UI.")
            if hasattr(self, '_reset_model_loading_ui'):
                self.after(50, self._reset_model_loading_ui)

        # G·ªçi callback (n·∫øu c√≥) ƒë·ªÉ ti·∫øp t·ª•c chu·ªói kh·ªüi ƒë·ªông
        if callback:
            callback()



# H√†m Sub & Dub B·∫Øt ƒë·∫ßu quy tr√¨nh T·∫°o Ph·ª• ƒë·ªÅ v√† sau ƒë√≥ t·ª± ƒë·ªông Thuy·∫øt minh.
    def start_sub_and_dub_process(self):
        """
        B·∫Øt ƒë·∫ßu quy tr√¨nh T·∫°o Ph·ª• ƒë·ªÅ v√† sau ƒë√≥ t·ª± ƒë·ªông Thuy·∫øt minh.
        S·ª≠ d·ª•ng file t·ª´ h√†ng ch·ªù c·ªßa tab Sub.
        """

        with keep_awake("Dubbing/TTS pipeline"):

            self.files_for_chained_dubbing = []
            logging.info("--- [Sub & Dub] N√∫t 'Sub & Dub' ƒë∆∞·ª£c nh·∫•n ---")

            # 1. Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán ti√™n quy·∫øt gi·ªëng nh∆∞ khi b·∫Øt ƒë·∫ßu auto_sub_all
            if self.is_subbing:
                messagebox.showwarning("ƒêang b·∫≠n", "ƒêang x·ª≠ l√Ω ph·ª• ƒë·ªÅ. Vui l√≤ng ƒë·ª£i.", parent=self)
                return
            if not self.file_queue: # Ki·ªÉm tra h√†ng ch·ªù file c·ªßa tab Sub
                messagebox.showinfo("H√†ng ch·ªù tr·ªëng", "Vui l√≤ng th√™m file video/audio v√†o h√†ng ch·ªù (Sub) tr∆∞·ªõc.", parent=self)
                return
            if self.whisper_model is None and not self.is_loading_model:
                messagebox.showwarning("Model ch∆∞a s·∫µn s√†ng", "M√¥ h√¨nh Whisper ch∆∞a ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ƒë·ª£i ho·∫∑c ch·ªçn m·ªôt m√¥ h√¨nh.", parent=self)
                self.load_whisper_model_if_needed()
                return
            if self.is_loading_model:
                messagebox.showwarning("ƒêang t·∫£i Model", "M√¥ h√¨nh Whisper ƒëang ƒë∆∞·ª£c t·∫£i. Vui l√≤ng ƒë·ª£i.", parent=self)
                return

            out_dir_check = self.output_path_var.get()
            merge_mode_check = self.merge_sub_var.get().lower()
            # Ki·ªÉm tra th∆∞ m·ª•c output n·∫øu c√≥ g·ªôp ho·∫∑c n·∫øu output_path ƒë∆∞·ª£c ƒë·∫∑t (logic nh∆∞ trong auto_sub_all)
            if merge_mode_check != "kh√¥ng g·ªôp" or (out_dir_check and not os.path.isdir(out_dir_check)):
                 if not out_dir_check or not os.path.isdir(out_dir_check):
                      messagebox.showerror("L·ªói ƒê∆∞·ªùng d·∫´n Output", f"Vui l√≤ng ch·ªçn th∆∞ m·ª•c output h·ª£p l·ªá cho tab Sub.\nC·∫ßn thi·∫øt cho vi·ªác g·ªôp ho·∫∑c n·∫øu ƒë∆∞·ªùng d·∫´n ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t.\nHi·ªán t·∫°i: '{out_dir_check}'", parent=self)
                      return

            # 2. Thi·∫øt l·∫≠p c√°c c·ªù b√°o hi·ªáu cho chu·ªói t·ª± ƒë·ªông
            # C·ªù n√†y b√°o cho task_subtitle_threaded bi·∫øt r·∫±ng sau khi sub xong, c·∫ßn chu·∫©n b·ªã cho dub
            self.pending_auto_dub_after_current_sub_batch = True
            # C·ªù n√†y b√°o cho _initiate_chained_dubbing bi·∫øt n√≥ ƒë∆∞·ª£c g·ªçi t·ª´ m·ªôt chu·ªói c√≥ th·ªÉ bao g·ªìm c·∫£ Download tr∆∞·ªõc ƒë√≥ (·ªü ƒë√¢y l√† kh√¥ng)
            # Ho·∫∑c c√≥ th·ªÉ d√πng m·ªôt c·ªù m·ªõi r√µ r√†ng h∆°n, v√≠ d·ª•: self.is_direct_sub_to_dub_chain = True
            self.chain_download_sub_dub_active = True # T·∫°m d√πng c·ªù n√†y, √Ω nghƒ©a l√† c√≥ chu·ªói Sub -> Dub

            self.files_for_chained_dubbing = [] # Reset danh s√°ch file s·∫Ω ƒë∆∞·ª£c chuy·ªÉn cho b∆∞·ªõc Dub

            logging.info("[Sub & Dub] ƒê√£ ƒë·∫∑t c·ªù pending_auto_dub v√† chain_download_sub_dub_active. B·∫Øt ƒë·∫ßu auto_sub_all.")

            # 3. G·ªçi h√†m b·∫Øt ƒë·∫ßu t·∫°o ph·ª• ƒë·ªÅ (gi·ªëng nh∆∞ n√∫t "B·∫Øt ƒë·∫ßu SUB")
            self.auto_sub_all()


# --------------------
# 4.9 Logic C·ªët l√µi - C·∫•p ph√©p & C·∫≠p nh·∫≠t
# --------------------

# H√†m qu·∫£n l√Ω kh·ªüi ƒë·ªông: Ki·ªÉm tra c√°c th∆∞ vi·ªán v√† c√¥ng c·ª• ph·ª• thu·ªôc
    def check_dependencies(self, callback=None):
        """
        Ki·ªÉm tra c√°c ph·ª• thu·ªôc b√™n ngo√†i, l∆∞u l·∫°i danh s√°ch thi·∫øu ƒë·ªÉ b√°o l·ªói sau,
        v√† kh√¥ng hi·ªÉn th·ªã messagebox ƒë·ªÉ tr√°nh treo ·ª©ng d·ª•ng khi c√≥ splash screen.
        """
        # Kh·ªüi t·∫°o m·ªôt thu·ªôc t√≠nh m·ªõi ƒë·ªÉ l∆∞u danh s√°ch c√°c file thi·∫øu
        self.missing_dependencies_list = []

        # Kh√¥ng ki·ªÉm tra l·∫°i n·∫øu config ƒë√£ ƒë√°nh d·∫•u OK
        if self.cfg.get("dependency_checked_ok", False):
            logging.info("Ki·ªÉm tra ph·ª• thu·ªôc ƒë√£ th√†nh c√¥ng tr∆∞·ªõc ƒë√≥. B·ªè qua.")
            self.mark_startup_task_done('dependencies')
            if callback:
                callback()
            return

        # B·∫Øt ƒë·∫ßu ki·ªÉm tra
        missing = []
        if find_ffmpeg() is None:
            missing.append("ffmpeg.exe (c·∫ßn cho vi·ªác g·ªôp video, x·ª≠ l√Ω audio)")
        
        # Th√™m ki·ªÉm tra cho ffprobe v√¨ n√≥ c≈©ng quan tr·ªçng
        if find_ffprobe() is None:
            missing.append("ffprobe.exe (c·∫ßn ƒë·ªÉ ƒë·ªçc th√¥ng tin video/audio)")

        # Ki·ªÉm tra yt-dlp
        ytdlp_found = os.path.exists(YTDLP_PATH) or shutil.which(_YTDLP_DEFAULT_COMMAND)
        if not ytdlp_found:
            missing.append(f"{_YTDLP_DEFAULT_COMMAND} (c·∫ßn cho vi·ªác t·∫£i video)")
        
        # Ki·ªÉm tra th∆∞ vi·ªán Python
        if not HAS_WHISPER:
            missing.append("Th∆∞ vi·ªán openai-whisper (c·∫ßn c√†i ƒë·∫∑t l·∫°i)")

        # L∆∞u l·∫°i danh s√°ch c√°c file b·ªã thi·∫øu v√†o thu·ªôc t√≠nh c·ªßa app
        self.missing_dependencies_list = missing
        
        # N·∫øu kh√¥ng thi·∫øu g√¨ c·∫£, ƒë√°nh d·∫•u v√†o config ƒë·ªÉ l·∫ßn sau kh√¥ng c·∫ßn ki·ªÉm tra l·∫°i
        if not missing:
            logging.info("Ki·ªÉm tra ph·ª• thu·ªôc th√†nh c√¥ng (kh√¥ng thi·∫øu file).")
            self.cfg["dependency_checked_ok"] = True
            # Kh√¥ng hi·ªÉn th·ªã popup th√†nh c√¥ng ·ªü ƒë√¢y ƒë·ªÉ kh·ªüi ƒë·ªông m∆∞·ª£t m√† h∆°n
        else:
            logging.warning(f"Ph√°t hi·ªán thi·∫øu c√°c ph·ª• thu·ªôc: {missing}")

        # Lu√¥n ƒë√°nh d·∫•u t√°c v·ª• n√†y l√† ho√†n th√†nh ƒë·ªÉ kh√¥ng l√†m k·∫πt qu√° tr√¨nh kh·ªüi ƒë·ªông
        self.mark_startup_task_done('dependencies')

        if callback:
            callback()        


# 3 H√†m logic: Ki·ªÉm tra tr·∫°ng th√°i k√≠ch ho·∫°t b·∫£n quy·ªÅn c·ªßa ·ª©ng d·ª•ng
    def _perform_online_license_verification(self, license_key_to_verify, callback=None):
        current_thread_name_polv = threading.current_thread().name
        log_prefix_polv = f"[{current_thread_name_polv}_OnlineVerifyV3]" # Gi·ªØ nguy√™n ho·∫∑c tƒÉng version log

        # --- L·∫•y HWID b√™n trong lu·ªìng ---
        hwid_to_verify = self.cfg.get('hardware_id') or self.get_hardware_id()
        if hwid_to_verify == "UNKNOWN_HWID":
            logging.error(f"{log_prefix_polv} Kh√¥ng th·ªÉ l·∫•y Hardware ID. K√≠ch ho·∫°t th·∫•t b·∫°i.")
            # G·ªçi callback v·ªÅ lu·ªìng ch√≠nh ƒë·ªÉ x·ª≠ l√Ω l·ªói UI n√†y
            self.after(0, self._handle_online_verification_result,
                       'HWID_ERROR_CLIENT_THREAD', # M√£ l·ªói t√πy ch·ªânh
                       {}, # server_data r·ªóng
                       "L·ªói: Kh√¥ng th·ªÉ l·∫•y Hardware ID trong lu·ªìng x√°c minh.", # server_message
                       license_key_to_verify, # original_key_sent
                       "UNKNOWN_HWID_FROM_THREAD") # original_hwid_sent
            return
        # --- K·∫øt th√∫c l·∫•y HWID ---

        key_param_for_server = license_key_to_verify if license_key_to_verify else ""

        logging.info(f"{log_prefix_polv} B·∫Øt ƒë·∫ßu. Key g·ª≠i ƒëi: '{key_param_for_server[:5]}...{key_param_for_server[-4:] if len(key_param_for_server) > 8 else key_param_for_server}', HWID (l·∫•y trong lu·ªìng): {hwid_to_verify}")


        # C·∫≠p nh·∫≠t status UI (ch·ªâ n√™n g·ªçi self.after m·ªôt l·∫ßn ·ªü ƒë·∫ßu n·∫øu c√≥ th·ªÉ)
        self.after(0, lambda: self.update_status("üì° ƒêang x√°c minh b·∫£n quy·ªÅn tr·ª±c tuy·∫øn..."))

        params = {'key': key_param_for_server, 'hwid': hwid_to_verify}

        server_returned_activation_status = "UNKNOWN_ERROR_CLIENT"
        server_data_payload = {}
        server_message_payload = "L·ªói client kh√¥ng x√°c ƒë·ªãnh khi chu·∫©n b·ªã g·ªçi server."
        response_text_debug = ""

        try:
            result = licensing_verify_status(params.get('key', ''), params.get('hwid', ''))
            response_text_debug = result.get('raw', '')
            logging.info(f"{log_prefix_polv} Ph·∫£n h·ªìi t·ª´ server: {result}")
            if result.get('status') in ("success", "error"):
                server_returned_activation_status = result.get("activation_status", "INACTIVE")
                server_data_payload = result.get('data', {})
                server_message_payload = result.get("message", "") or server_message_payload
                if result.get('status') == 'error':
                    pass
                logging.warning(f"{log_prefix_polv} Server b√°o l·ªói logic: {server_message_payload} (Code tr·∫°ng th√°i t·ª´ server: {server_returned_activation_status})")
            else:
                server_returned_activation_status = "INVALID_SERVER_RESPONSE_STRUCTURE"
                server_message_payload = "Ph·∫£n h·ªìi t·ª´ server kh√¥ng c√≥ tr∆∞·ªùng 'status' h·ª£p l·ªá."
                logging.error(f"{log_prefix_polv} {server_message_payload}. Response th√¥: {response_text_debug[:500]}")

        except requests.exceptions.Timeout:
            logging.error(f"{log_prefix_polv} Timeout khi k·∫øt n·ªëi server.")
            server_returned_activation_status = "NETWORK_TIMEOUT"
            server_message_payload = "Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server x√°c minh (timeout)."
        except requests.exceptions.RequestException as e_req:
            logging.error(f"{log_prefix_polv} L·ªói m·∫°ng/HTTP: {e_req}")
            server_returned_activation_status = "NETWORK_ERROR"
            server_message_payload = f"L·ªói k·∫øt n·ªëi m·∫°ng: {type(e_req).__name__}"
        except json.JSONDecodeError:
            logging.error(f"{log_prefix_polv} Ph·∫£n h·ªìi JSON kh√¥ng h·ª£p l·ªá. Response th√¥: {response_text_debug[:500]}...")
            server_returned_activation_status = "INVALID_SERVER_JSON_RESPONSE"
            server_message_payload = "Server x√°c minh tr·∫£ v·ªÅ d·ªØ li·ªáu JSON kh√¥ng h·ª£p l·ªá."
        except Exception as e_generic:
            logging.error(f"{log_prefix_polv} L·ªói kh√¥ng mong mu·ªën: {e_generic}", exc_info=True)
            server_returned_activation_status = "UNEXPECTED_CLIENT_VERIFICATION_ERROR"
            server_message_payload = f"L·ªói client kh√¥ng mong mu·ªën: {type(e_generic).__name__}"

        if self.stop_event.is_set():
            logging.warning(f"{log_prefix_polv} ·ª®ng d·ª•ng ƒëang ƒë√≥ng. H·ªßy b·ªè vi·ªác x·ª≠ l√Ω k·∫øt qu·∫£ t·ª´ server.")
            return # Tho√°t kh·ªèi h√†m ngay l·∫≠p t·ª©c, kh√¥ng l√†m g√¨ th√™m

        self.after(0, self._handle_online_verification_result,
                   server_returned_activation_status,
                   server_data_payload,
                   server_message_payload,
                   license_key_to_verify,
                   hwid_to_verify,
                   callback)


# X·ª≠ l√Ω k·∫øt qu·∫£ x√°c minh online (phi√™n b·∫£n ƒë·ªìng b·ªô ho√° v·ªõi _is_app_fully_activated + _apply_activation_ui_state)
    def _handle_online_verification_result(
        self,
        server_activation_status_code,
        server_data,
        server_message,
        original_key_sent,
        original_hwid_sent,
        callback=None
    ):
        """
        X·ª≠ l√Ω k·∫øt qu·∫£ x√°c minh online (phi√™n b·∫£n ƒë·ªìng b·ªô ho√° v·ªõi _is_app_fully_activated + _apply_activation_ui_state):
        - Kh√¥ng set final_activation_state tr·ª±c ti·∫øp n·ªØa.
        - C·∫≠p nh·∫≠t self.cfg theo ph·∫£n h·ªìi server.
        - √Åp d·ª•ng UI qua self._apply_activation_ui_state() (main thread).
        - N·∫øu NOT_FOUND v√† kh√¥ng c√≥ key, s·∫Ω g·ªçi start_trial().
        """
        import threading, time, json

        current_thread_name_hor = threading.current_thread().name
        log_prefix_hor = f"[{current_thread_name_hor}_HandleOnlineResult_v5]"  # bump version for logs

        # Chu·∫©n ho√° d·ªØ li·ªáu server_data -> dict
        payload = {}
        try:
            if isinstance(server_data, dict):
                payload = server_data
            elif isinstance(server_data, str):
                try:
                    payload = json.loads(server_data)
                except Exception:
                    payload = {}
            else:
                payload = {}
        except Exception:
            payload = {}

        logging.info(
            f"{log_prefix_hor} X·ª≠ l√Ω KQ t·ª´ server: "
            f"ServerActivationStatusCode='{server_activation_status_code}', "
            f"ServerMsg='{server_message}', ServerData={payload!r}"
        )

        # C√°c nh√≥m tr·∫°ng th√°i
        valid_license_states_from_server = ['ACTIVE', 'TRIAL', 'LIFETIME', 'MONTHLY', '3_MONTH', 'ACTIVE_TEST']
        server_indicates_no_license_found = ["INACTIVE", "KEY_NOT_FOUND", "NOT_FOUND", "TRIAL_NOT_FOUND"]
        network_or_severe_client_errors = [
            "NETWORK_TIMEOUT", "NETWORK_ERROR",
            "INVALID_SERVER_JSON_RESPONSE", "INVALID_SERVER_RESPONSE_STRUCTURE",
            "UNEXPECTED_CLIENT_VERIFICATION_ERROR", "UNKNOWN_ERROR_CLIENT",
            "OFFLINE_CHECK_FAILED"
        ]

        needs_prompt_for_new_key = False
        prompt_message_for_ui_dialog = ""
        final_status_bar_message = ""
        attempt_new_trial = False

        code = (server_activation_status_code or "").strip().upper()

        try:
            # ===== 1) L·ªói l·∫•y HWID trong lu·ªìng =====
            if code == 'HWID_ERROR_CLIENT_THREAD':
                logging.error(f"{log_prefix_hor} Kh√¥ng th·ªÉ l·∫•y Hardware ID trong lu·ªìng x√°c minh.")
                self.cfg['activation_status'] = 'HWID_ERROR_CLIENT'
                try:
                    save_config(self.cfg)
                except Exception as e:
                    logging.warning(f"{log_prefix_hor} L·ªói l∆∞u config: {e}")

                final_status_bar_message = "‚õî L·ªói: Kh√¥ng th·ªÉ l·∫•y HWID (trong lu·ªìng)."
                try:
                    messagebox.showerror(
                        "L·ªói License (Client)",
                        f"Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ID m√°y (trong lu·ªìng).\nKh√¥ng th·ªÉ x√°c minh b·∫£n quy·ªÅn.\n\nChi ti·∫øt: {server_message}",
                        parent=self
                    )
                except Exception:
                    pass

                # √Åp d·ª•ng UI theo ngu·ªìn s·ª± th·∫≠t
                self.after(0, self._apply_activation_ui_state)

            # ===== 2) Server tr·∫£ tr·∫°ng th√°i h·ª£p l·ªá (nh∆∞ng c√≥ th·ªÉ ƒë√£ h·∫øt h·∫°n) =====
            elif code in valid_license_states_from_server:
                logging.info(f"{log_prefix_hor} B·∫£n quy·ªÅn h·ª£p l·ªá theo server (status th√¥): {code}")

                # C·∫≠p nh·∫≠t cfg t·ª´ server
                self.cfg['license_key'] = original_key_sent if original_key_sent else self.cfg.get('license_key', "")
                self.cfg['activation_status'] = code
                self.cfg['expiry_date'] = payload.get('expiry_date') or self.cfg.get('expiry_date', "")
                self.cfg['hardware_id'] = original_hwid_sent or self.cfg.get('hardware_id', "")
                self.cfg['license_type'] = payload.get('type', code)

                try:
                    save_config(self.cfg)
                except Exception as e:
                    logging.warning(f"{log_prefix_hor} L·ªói l∆∞u config: {e}")

                final_status_bar_message = f"‚úÖ B·∫£n quy·ªÅn ƒë√£ x√°c minh ({code})."

                # D√ô server n√≥i h·ª£p l·ªá, vi·ªác c√≤n h·∫°n hay kh√¥ng s·∫Ω do _is_app_fully_activated() quy·∫øt
                self.after(0, self._apply_activation_ui_state)

            # ===== 3) L·ªói m·∫°ng / client n·∫∑ng =====
            elif code in network_or_severe_client_errors:
                logging.error(f"{log_prefix_hor} L·ªói k·∫øt n·ªëi/client khi x√°c minh: {server_message} (Code: {code})")
                self.cfg['activation_status'] = 'OFFLINE_CHECK_FAILED'
                try:
                    save_config(self.cfg)
                except Exception as e:
                    logging.warning(f"{log_prefix_hor} L·ªói l∆∞u config: {e}")

                final_status_bar_message = "‚õî L·ªói m·∫°ng/k·∫øt n·ªëi: Kh√¥ng th·ªÉ x√°c minh b·∫£n quy·ªÅn."
                try:
                    messagebox.showerror(
                        "L·ªói X√°c Minh B·∫£n Quy·ªÅn",
                        "Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server ho·∫∑c c√≥ l·ªói trong qu√° tr√¨nh x√°c minh.\n"
                        "Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng.\n\n"
                        f"Chi ti·∫øt: {server_message} (M√£ l·ªói: {code})",
                        parent=self
                    )
                except Exception:
                    pass

                # Gi·ªØ th·ªëng nh·∫•t: UI quy·∫øt ƒë·ªãnh theo _is_app_fully_activated()
                self.after(0, self._apply_activation_ui_state)

            # ===== 4) C√°c tr∆∞·ªùng h·ª£p logic server kh√°c =====
            else:
                logging.warning(f"{log_prefix_hor} X√°c minh th·∫•t b·∫°i (logic server). Server b√°o: '{code}' - Message: '{server_message}'")

                # N·∫øu kh√¥ng c√≥ license tr√™n server & kh√¥ng g·ª≠i key ban ƒë·∫ßu & ch∆∞a t·ª´ng c√≥ key n√†o ƒë∆∞·ª£c l∆∞u -> th·ª≠ start_trial
                if code in server_indicates_no_license_found and not original_key_sent and not self.cfg.get('license_key'):
                    # TH√äM ƒêI·ªÄU KI·ªÜN: and not self.cfg.get('license_key')
                    # ƒêi·ªÅu ki·ªán n√†y ƒë·∫£m b·∫£o ch·ªâ b·∫Øt ƒë·∫ßu trial khi app th·ª±c s·ª± "trong tr·∫Øng", ch∆∞a t·ª´ng c√≥ key.
                    logging.info(f"{log_prefix_hor} Server b√°o '{code}', kh√¥ng c√≥ key g·ª≠i ƒëi V√Ä kh√¥ng c√≥ key trong config. S·∫Ω th·ª≠ start_trial().")
                    attempt_new_trial = True
                else:
                    # C·∫≠p nh·∫≠t cfg theo ph·∫£n h·ªìi server ƒë·ªÉ UI bi·∫øt tr·∫°ng th√°i th·∫≠t
                    self.cfg['activation_status'] = code
                    self.cfg['license_key'] = ""  # Xo√° key kh√¥ng h·ª£p l·ªá
                    self.cfg['expiry_date'] = payload.get('expiry_date') or self.cfg.get('expiry_date', "")
                    try:
                        save_config(self.cfg)
                    except Exception as e:
                        logging.warning(f"{log_prefix_hor} L·ªói l∆∞u config: {e}")

                    final_status_bar_message = f"‚õî B·∫£n quy·ªÅn kh√¥ng h·ª£p l·ªá (Server: {code})."

                    # So·∫°n th√¥ng ƒëi·ªáp g·ª£i √Ω nh·∫≠p key
                    if code == "HWID_MISMATCH_ON_SERVER":
                        prompt_message_for_ui_dialog = f"License key '{original_key_sent}' ƒë√£ ƒë∆∞·ª£c d√πng tr√™n m√°y kh√°c.\nVui l√≤ng nh·∫≠p key m·ªõi cho m√°y n√†y."
                    elif code == "EXPIRED_ON_SERVER":
                        expiry_display = payload.get('expiry_date', 'kh√¥ng r√µ')
                        prompt_message_for_ui_dialog = f"B·∫£n d√πng th·ª≠ c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n v√†o ng√†y {expiry_display}.\nVui l√≤ng nh·∫≠p key b·∫£n quy·ªÅn ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng."
                    elif code == "KEY_NOT_FOUND":
                        prompt_message_for_ui_dialog = f"License key '{original_key_sent}' kh√¥ng t√¨m th·∫•y ho·∫∑c ƒë√£ b·ªã thu h·ªìi.\nVui l√≤ng nh·∫≠p key m·ªõi."
                    else:
                        prompt_message_for_ui_dialog = f"B·∫£n quy·ªÅn kh√¥ng h·ª£p l·ªá (Server: {code}).\n{server_message}\n\nVui l√≤ng nh·∫≠p key m·ªõi."
                    needs_prompt_for_new_key = True

                    # √Åp d·ª•ng UI theo ngu·ªìn s·ª± th·∫≠t (b·ªã unactivated n·∫øu h·∫øt h·∫°n/kh√¥ng h·ª£p l·ªá)
                    self.after(0, self._apply_activation_ui_state)

            # --- C·∫≠p nh·∫≠t timestamp revalidation n·∫øu c√≥ giao ti·∫øp ƒë∆∞·ª£c v·ªõi server ---
            communication_failure_codes = [
                "NETWORK_TIMEOUT", "NETWORK_ERROR",
                "INVALID_SERVER_JSON_RESPONSE", "INVALID_SERVER_RESPONSE_STRUCTURE",
                "UNEXPECTED_CLIENT_VERIFICATION_ERROR", "UNKNOWN_ERROR_CLIENT",
                "HWID_ERROR_CLIENT_THREAD", "OFFLINE_CHECK_FAILED"
            ]
            try:
                if code not in communication_failure_codes:
                    self.cfg['last_license_revalidation_timestamp'] = int(time.time())
                    logging.info(f"{log_prefix_hor} ƒê√£ c·∫≠p nh·∫≠t last_license_revalidation_timestamp (ServerStatusCode: {code}).")
                    # save_config kh√¥ng b·∫Øt bu·ªôc g·ªçi l·∫°i ngay t·∫°i ƒë√¢y
            except Exception as e_save_reval_ts:
                logging.error(f"{log_prefix_hor} L·ªói khi c·∫≠p nh·∫≠t last_license_revalidation_timestamp: {e_save_reval_ts}")

            if final_status_bar_message:
                try:
                    self.update_status(final_status_bar_message)
                except Exception:
                    pass

            # ƒêi·ªÅu h∆∞·ªõng sau c√πng
            if attempt_new_trial:
                logging.info(f"{log_prefix_hor} G·ªçi self.start_trial() cho HWID: {original_hwid_sent}")
                self.after(50, self.start_trial)  # start_trial s·∫Ω t·ª± _apply_activation_ui_state trong finally
                self.mark_startup_task_done('activation')
            elif needs_prompt_for_new_key:
                # Hi·ªÉn th·ªã prompt nh·∫≠p key
                self.after(100, self.prompt_and_activate, prompt_message_for_ui_dialog)
                self.mark_startup_task_done('activation')
            else:
                self.mark_startup_task_done('activation')

            logging.info(f"{log_prefix_hor} Ho√†n t·∫•t. AttemptTrial={attempt_new_trial}, NeedsPromptKey={needs_prompt_for_new_key}")

            if callback:
                try:
                    callback()
                except Exception:
                    pass

        except Exception as e:
            logging.error(f"{log_prefix_hor} L·ªói kh√¥ng mong mu·ªën trong _handle_online_verification_result: {e}", exc_info=True)
            # Fallback an to√†n
            try:
                self.after(0, self._apply_activation_ui_state)
            except Exception:
                pass
            try:
                self.mark_startup_task_done('activation')
            except Exception:
                pass
            if callback:
                try:
                    callback()
                except Exception:
                    pass


# H√†m ki·ªÉm tra k√≠ch ho·∫°t b·∫£n quy·ªÅn
    def check_activation_status(self, callback=None):
        """
        B·∫Øt ƒë·∫ßu qu√° tr√¨nh ki·ªÉm tra b·∫£n quy·ªÅn trong m·ªôt lu·ªìng n·ªÅn ƒë·ªÉ kh√¥ng l√†m treo UI.
        (ƒê√É S·ª¨A: S·∫Ω kh√¥ng g·ªçi tr·ª±c ti·∫øp handle_..._state n·ªØa).
        """
        logging.info("[MainThread] Y√™u c·∫ßu b·∫Øt ƒë·∫ßu ki·ªÉm tra b·∫£n quy·ªÅn trong lu·ªìng n·ªÅn...")
        # self.update_status("‚è≥ ƒêang ki·ªÉm tra b·∫£n quy·ªÅn...") # Kh√¥ng c·∫ßn update status ·ªü ƒë√¢y, splash screen ƒëang l√†m vi·ªác ƒë√≥

        # T·∫°o v√† b·∫Øt ƒë·∫ßu lu·ªìng m·ªõi
        activation_check_thread = threading.Thread(
            # S·ª≠a l·∫°i target th√†nh h√†m worker m·ªõi, truy·ªÅn callback v√†o ƒë√≥
            target=self._check_activation_status_thread,
            args=(callback,), # Truy·ªÅn callback v√†o lu·ªìng
            daemon=True,
            name="ActivationCheckWorkerThread_v2" # ƒê·ªïi t√™n ƒë·ªÉ d·ªÖ debug
        )
        activation_check_thread.start()


    # H√ÄM M·ªöI: Ch·ª©a to√†n b·ªô logic ki·ªÉm tra b·∫£n quy·ªÅn, s·∫Ω ch·∫°y trong lu·ªìng n·ªÅn
    def _check_activation_status_thread(self, callback=None):
        """
        H√†m worker ch·∫°y trong lu·ªìng n·ªÅn ƒë·ªÉ ki·ªÉm tra b·∫£n quy·ªÅn.
        (PHI√äN B·∫¢N 8.0 - C·∫¨P NH·∫¨T HO√ÄN CH·ªàNH)
        - S·∫Ω c·∫≠p nh·∫≠t self.final_activation_state thay v√¨ g·ªçi tr·ª±c ti·∫øp c√°c h√†m UI.
        - X·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p l·ªói m·ªôt c√°ch nh·∫•t qu√°n.
        """
        current_thread_name_cas = threading.current_thread().name
        log_prefix_cas = f"[{current_thread_name_cas}_CheckActivation_v8_Final]"
        logging.info(f"{log_prefix_cas} B·∫Øt ƒë·∫ßu ki·ªÉm tra tr·∫°ng th√°i k√≠ch ho·∫°t (∆∞u ti√™n offline)...")

        # --- Helper function ƒë·ªÉ g·ªçi c√°c h√†m GUI tr√™n lu·ªìng ch√≠nh ---
        def _call_on_main_thread(func, *args, **kwargs):
            if hasattr(self, 'after') and callable(self.after):
                self.after(0, lambda: func(*args, **kwargs))
            else:
                logging.error(f"{log_prefix_cas} KH√îNG TH·ªÇ G·ªåI TR√äN LU·ªíNG CH√çNH: 'self.after' kh√¥ng kh·∫£ d·ª•ng. H√†m: {func.__name__}")
        # --- K·∫øt th√∫c Helper ---

        # --- 1. L·∫•y th√¥ng tin ƒë√£ l∆∞u t·ª´ config v√† HWID hi·ªán t·∫°i ---
        stored_activation_status = self.cfg.get('activation_status')
        stored_expiry_date_str = self.cfg.get('expiry_date')
        stored_license_key = self.cfg.get('license_key', "")
        stored_hwid = self.cfg.get('hardware_id')

        current_hwid = self.get_hardware_id()
        if current_hwid == "UNKNOWN_HWID":
            logging.error(f"{log_prefix_cas} L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ l·∫•y HWID c·ªßa m√°y hi·ªán t·∫°i.")
            self.cfg['activation_status'] = 'HWID_ERROR_CLIENT'
            self.cfg['license_key'] = ""
            save_config(self.cfg)

            # <<< THAY ƒê·ªîI 1: C·∫≠p nh·∫≠t bi·∫øn tr·∫°ng th√°i v√† g·ªçi callback >>>
            self.final_activation_state = 'unactivated'
            _call_on_main_thread(self.mark_startup_task_done, 'activation')
            _call_on_main_thread(messagebox.showerror, "L·ªói ƒê·ªãnh danh M√°y",
                                 "Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ID c·ªßa m√°y t√≠nh n√†y.\n"
                                 "Kh√¥ng th·ªÉ x√°c minh b·∫£n quy·ªÅn. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c li√™n h·ªá h·ªó tr·ª£.",
                                 parent=self)
            if callback:
                _call_on_main_thread(callback)
            return

        logging.info(f"{log_prefix_cas} Th√¥ng tin ƒë√£ l∆∞u: Status='{stored_activation_status}', Key='{stored_license_key[:5]}...', Expiry='{stored_expiry_date_str}', StoredHWID='{stored_hwid}'")
        logging.info(f"{log_prefix_cas} HWID hi·ªán t·∫°i c·ªßa m√°y: '{current_hwid}'")

        # --- 2. Logic Ki·ªÉm tra Offline ---
        perform_online_check = False
        reason_for_online_check = ""

        if not stored_activation_status or stored_activation_status == 'INACTIVE':
            perform_online_check = True
            reason_for_online_check = "Tr·∫°ng th√°i ch∆∞a k√≠ch ho·∫°t ho·∫∑c kh√¥ng c√≥ tr·∫°ng th√°i trong config."
        elif stored_hwid != current_hwid:
            perform_online_check = True
            reason_for_online_check = f"HWID kh√¥ng kh·ªõp (ƒê√£ l∆∞u: {stored_hwid}, Hi·ªán t·∫°i: {current_hwid}). C·∫ßn x√°c minh l·∫°i key cho m√°y n√†y."
            self.cfg['activation_status'] = 'HWID_MISMATCH_CLIENT_NEEDS_REVALIDATION'
        else:
            valid_active_statuses = ['ACTIVE', 'LIFETIME', 'ACTIVE_TEST', 'MONTHLY', '3_MONTH']
            timed_statuses = ['TRIAL'] # T√°ch ri√™ng Trial n·∫øu b·∫°n mu·ªën c√≥ logic ƒë·∫∑c bi·ªát

            if stored_activation_status in valid_active_statuses:
                # Ki·ªÉm tra ng√†y h·∫øt h·∫°n cho c√°c license c√≥ th·ªùi h·∫°n
                if stored_activation_status in ['MONTHLY', '3_MONTH'] and stored_expiry_date_str:
                    try:
                        expiry_date_obj = datetime.strptime(stored_expiry_date_str, "%Y-%m-%d").date()
                        if expiry_date_obj < date.today():
                            perform_online_check = True
                            reason_for_online_check = f"License '{stored_activation_status}' ƒë√£ h·∫øt h·∫°n ({stored_expiry_date_str})."
                            self.cfg['activation_status'] = 'EXPIRED_CLIENT_NEEDS_REVALIDATION'
                    except ValueError:
                        perform_online_check = True
                        reason_for_online_check = f"L·ªói ƒë·ªãnh d·∫°ng ng√†y h·∫øt h·∫°n ({stored_expiry_date_str})."
                        self.cfg['activation_status'] = 'INVALID_EXPIRY_DATE_FORMAT'
                
                # N·∫øu kh√¥ng ph·∫£i license c√≥ th·ªùi h·∫°n ho·∫∑c c√≤n h·∫°n, th√¨ pass offline
                if not perform_online_check:
                    logging.info(f"{log_prefix_cas} Ki·ªÉm tra Offline: Th√†nh c√¥ng! (Status: '{stored_activation_status}')")
                    # <<< THAY ƒê·ªîI 2: C·∫≠p nh·∫≠t bi·∫øn tr·∫°ng th√°i >>>
                    self.final_activation_state = 'activated'
                    _call_on_main_thread(self.mark_startup_task_done, 'activation')
            
            elif stored_activation_status in timed_statuses:
                if stored_expiry_date_str:
                    try:
                        expiry_date_obj = datetime.strptime(stored_expiry_date_str, "%Y-%m-%d").date()
                        if expiry_date_obj >= date.today():
                            logging.info(f"{log_prefix_cas} Ki·ªÉm tra Offline: Th√†nh c√¥ng! (Trial c√≤n h·∫°n ƒë·∫øn {stored_expiry_date_str})")
                            # <<< THAY ƒê·ªîI 3: C·∫≠p nh·∫≠t bi·∫øn tr·∫°ng th√°i >>>
                            self.final_activation_state = 'activated'
                            _call_on_main_thread(self.mark_startup_task_done, 'activation')
                        else:
                            perform_online_check = True
                            reason_for_online_check = f"Trial ƒë√£ h·∫øt h·∫°n ({stored_expiry_date_str})."
                            self.cfg['activation_status'] = 'EXPIRED_CLIENT_NEEDS_REVALIDATION'
                    except ValueError:
                        perform_online_check = True
                        reason_for_online_check = f"L·ªói ƒë·ªãnh d·∫°ng ng√†y h·∫øt h·∫°n Trial ({stored_expiry_date_str})."
                        self.cfg['activation_status'] = 'INVALID_EXPIRY_DATE_FORMAT'
                else:
                    perform_online_check = True
                    reason_for_online_check = "Trial thi·∫øu ng√†y h·∫øt h·∫°n."
                    self.cfg['activation_status'] = 'MISSING_EXPIRY_DATE_FOR_TIMED_LICENSE'
            else:
                perform_online_check = True
                reason_for_online_check = f"Tr·∫°ng th√°i '{stored_activation_status}' y√™u c·∫ßu ki·ªÉm tra online."

        # --- 3. Th·ª±c hi·ªán Ki·ªÉm tra Online n·∫øu c·∫ßn ---
        if perform_online_check:
            logging.info(f"{log_prefix_cas} Y√™u c·∫ßu ki·ªÉm tra online. L√Ω do: {reason_for_online_check}")
            key_to_send_online = stored_license_key
            
            # H√†m n√†y s·∫Ω g·ªçi _handle_online_verification_result,
            # v√† h√†m ƒë√≥ c≈©ng ƒë√£ ƒë∆∞·ª£c s·ª≠a ƒë·ªÉ c·∫≠p nh·∫≠t self.final_activation_state.
            # N√≥ c≈©ng s·∫Ω t·ª± g·ªçi callback cu·ªëi c√πng.
            self._perform_online_license_verification(key_to_send_online, callback=callback)

        else: # Kh√¥ng c·∫ßn ki·ªÉm tra online
            logging.info(f"{log_prefix_cas} Kh√¥ng c·∫ßn ki·ªÉm tra online. G·ªçi callback (n·∫øu c√≥).")
            if callback:
                _call_on_main_thread(callback)



# H√†m ki·ªÉm tra b·∫£n quy·ªÅn ƒë·ªãnh k·ª≥
    def _maybe_trigger_periodic_license_revalidation(self):
        """
        Ki·ªÉm tra v√† c√≥ th·ªÉ k√≠ch ho·∫°t vi·ªác x√°c minh l·∫°i b·∫£n quy·ªÅn tr·ª±c tuy·∫øn ƒë·ªãnh k·ª≥.
        Ch·∫°y trong m·ªôt lu·ªìng n·ªÅn n·∫øu c·∫ßn x√°c minh.
        """
        current_thread_name_mtplr = threading.current_thread().name
        log_prefix_mtplr = f"[{current_thread_name_mtplr}_MaybePeriodicReval]"
        logging.info(f"{log_prefix_mtplr} B·∫Øt ƒë·∫ßu ki·ªÉm tra ƒëi·ªÅu ki·ªán x√°c minh l·∫°i b·∫£n quy·ªÅn ƒë·ªãnh k·ª≥.")

        try:
            # ƒêi·ªÅu ki·ªán 1: B·∫£n quy·ªÅn ph·∫£i ƒëang ƒë∆∞·ª£c coi l√† h·ª£p l·ªá offline
            stored_activation_status = self.cfg.get('activation_status')
            stored_hwid = self.cfg.get('hardware_id')
            current_hwid = self.get_hardware_id() # L·∫•y HWID hi·ªán t·∫°i

            is_currently_considered_active_offline = False
            valid_active_statuses_for_reval = ['ACTIVE', 'LIFETIME', 'ACTIVE_TEST']
            timed_statuses_for_reval = ['TRIAL', 'MONTHLY', '3_MONTH']

            if stored_hwid == current_hwid and stored_hwid != "UNKNOWN_HWID":
                if stored_activation_status in valid_active_statuses_for_reval:
                    is_currently_considered_active_offline = True
                elif stored_activation_status in timed_statuses_for_reval:
                    stored_expiry_date_str = self.cfg.get('expiry_date')
                    if stored_expiry_date_str:
                        try:
                            expiry_date_obj = datetime.strptime(stored_expiry_date_str, "%Y-%m-%d").date()
                            if expiry_date_obj >= date.today():
                                is_currently_considered_active_offline = True
                        except ValueError:
                            logging.warning(f"{log_prefix_mtplr} L·ªói ƒë·ªãnh d·∫°ng ng√†y h·∫øt h·∫°n ƒë√£ l∆∞u '{stored_expiry_date_str}' khi ki·ªÉm tra reval.")

            if not is_currently_considered_active_offline:
                logging.info(f"{log_prefix_mtplr} B·ªè qua ki·ªÉm tra ƒë·ªãnh k·ª≥: Tr·∫°ng th√°i offline kh√¥ng h·ª£p l·ªá ho·∫∑c HWID kh√¥ng kh·ªõp (Status: {stored_activation_status}, StoredHWID: {stored_hwid}, CurrentHWID: {current_hwid}).")
                return

            # ƒêi·ªÅu ki·ªán 2: ƒê√£ ƒë·∫øn l√∫c ki·ªÉm tra ƒë·ªãnh k·ª≥
            last_reval_timestamp = self.cfg.get('last_license_revalidation_timestamp', 0)
            current_timestamp = int(time.time())

            # LICENSE_REVALIDATION_INTERVAL_SECONDS ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü ƒë·∫ßu file
            should_revalidate_now = (current_timestamp - last_reval_timestamp >= LICENSE_REVALIDATION_INTERVAL_SECONDS) or \
                                    (last_reval_timestamp == 0) # Lu√¥n ki·ªÉm tra n·∫øu ch∆∞a t·ª´ng revalidate

            if should_revalidate_now:
                logging.info(f"{log_prefix_mtplr} ƒê√£ ƒë·∫øn l√∫c x√°c minh l·∫°i b·∫£n quy·ªÅn tr·ª±c tuy·∫øn ƒë·ªãnh k·ª≥ (L·∫ßn cu·ªëi reval: {datetime.fromtimestamp(last_reval_timestamp).strftime('%Y-%m-%d %H:%M:%S') if last_reval_timestamp > 0 else 'Ch∆∞a bao gi·ªù'}).")

                # L·∫•y license key hi·ªán t·∫°i t·ª´ config ƒë·ªÉ g·ª≠i l√™n server
                key_for_revalidation = self.cfg.get('license_key', "")

                # Ch·∫°y _perform_online_license_verification trong m·ªôt lu·ªìng m·ªõi
                # ƒë·ªÉ kh√¥ng ch·∫∑n giao di·ªán ng∆∞·ªùi d√πng.
                # HWID s·∫Ω ƒë∆∞·ª£c l·∫•y b√™n trong _perform_online_license_verification.
                revalidation_thread = threading.Thread(
                    target=self._perform_online_license_verification,
                    args=(key_for_revalidation,), 
                    daemon=True,
                    name="PeriodicLicenseRevalThread"
                )
                revalidation_thread.start()
                logging.info(f"{log_prefix_mtplr} ƒê√£ b·∫Øt ƒë·∫ßu lu·ªìng x√°c minh l·∫°i b·∫£n quy·ªÅn ƒë·ªãnh k·ª≥.")
                # Timestamp s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong _handle_online_verification_result
                # n·∫øu vi·ªác giao ti·∫øp v·ªõi server th√†nh c√¥ng.
            else:
                time_since_last_reval_hours = (current_timestamp - last_reval_timestamp) / 3600
                time_remaining_reval_hours = (LICENSE_REVALIDATION_INTERVAL_SECONDS - (current_timestamp - last_reval_timestamp)) / 3600
                logging.info(f"{log_prefix_mtplr} Ch∆∞a ƒë·∫øn l√∫c x√°c minh l·∫°i b·∫£n quy·ªÅn ƒë·ªãnh k·ª≥. "
                             f"L·∫ßn cu·ªëi c√°ch ƒë√¢y {time_since_last_reval_hours:.2f} gi·ªù. "
                             f"S·∫Ω ki·ªÉm tra l·∫°i sau kho·∫£ng {time_remaining_reval_hours:.2f} gi·ªù n·ªØa.")

        except Exception as e_outer_reval:
            logging.error(f"{log_prefix_mtplr} L·ªói kh√¥ng mong mu·ªën khi quy·∫øt ƒë·ªãnh c√≥ ch·∫°y ki·ªÉm tra ƒë·ªãnh k·ª≥ kh√¥ng: {e_outer_reval}", exc_info=True)



# H√†m Qu·∫£n L√Ω C√°c n√∫t h√†nh ƒë·ªông c·ªßa Tab Dubing
    def _set_dubbing_tab_ui_state(self):
        """
        ƒê·ªìng b·ªô UI tab Thuy·∫øt Minh theo tr·∫°ng th√°i k√≠ch ho·∫°t + c√°c t√°c v·ª• ƒëang ch·∫°y.
        Ch·ªâ d√πng _is_app_fully_activated() l√†m ngu·ªìn s·ª± th·∫≠t.
        """
        # --- Flags & helpers ---
        try:
            is_app_active = self._is_app_fully_activated()
        except Exception:
            is_app_active = False

        is_main_batch_processing = bool(getattr(self, 'dub_is_processing', False))
        is_batch = bool(getattr(self, 'dub_is_processing', False))
        is_gpt  = bool(getattr(self, 'is_gpt_processing_script', False))
        is_dalle = bool(getattr(self, 'is_dalle_processing', False))
        is_preview = bool(getattr(self, 'is_performing_single_task', False))
        is_any_task_running = is_batch or is_gpt or is_dalle or is_preview

        log_prefix = f"[UI_DubTab_SetState(Activated:{is_app_active}, BatchProcessing:{is_batch})]"
        logging.info(log_prefix)
        logging.debug(f"{log_prefix} Flags: GPT={is_gpt}, DALLE={is_dalle}, Preview={is_preview}")

        # States ti·ªán d√πng
        state_all = ctk.NORMAL if is_app_active else ctk.DISABLED
        state_main_idle = ctk.NORMAL if (is_app_active and not is_batch) else ctk.DISABLED
        state_when_not_busy = ctk.NORMAL if (is_app_active and not is_any_task_running) else ctk.DISABLED
        unactivated_text_short = "üîí K√≠ch ho·∫°t"
        unactivated_text_main = "üîí K√≠ch ho·∫°t (Dub)"

        def _cfg(widget, **kw):
            if widget and hasattr(widget, "configure") and widget.winfo_exists():
                try:
                    widget.configure(**kw)
                except Exception:
                    pass

        # --- H√ÄNH ƒê·ªòNG CH√çNH (panel tr√°i) ---
        btn_start = getattr(self, 'dub_start_batch_button', None)
        if is_batch:
            _cfg(btn_start, state=ctk.DISABLED, text="‚è≥ ƒêang x·ª≠ l√Ω...")
        elif not is_app_active:
            _cfg(btn_start, state=ctk.DISABLED, text=unactivated_text_main)
        else:
            # Khi ƒë√£ k√≠ch ho·∫°t & kh√¥ng batch: enable n·∫øu c√≥ queue
            if hasattr(self, '_update_dub_start_batch_button_state') and getattr(self, 'initial_ui_setup_complete', False):
                self.after(10, self._update_dub_start_batch_button_state)
            else:
                queue_has_items = bool(getattr(self, 'dub_processing_queue', []))
                _cfg(btn_start, state=(ctk.NORMAL if queue_has_items else ctk.DISABLED), text="üöÄ B·∫Øt ƒë·∫ßu Dubbing H√†ng lo·∫°t")

        btn_stop = getattr(self, 'dub_stop_button', None)
        _cfg(btn_stop, state=(ctk.NORMAL if is_batch else ctk.DISABLED))

        # Ch·ªçn Audio/Script
        for btn, label in {
            getattr(self, 'dub_load_audio_button', None): "üéµ Ch·ªçn Audio...",
            getattr(self, 'dub_load_script_button', None): "üìú Ch·ªçn Script...",
        }.items():
            _cfg(btn,
                 state=(ctk.DISABLED if is_batch else state_all),
                 text=(label if is_app_active else unactivated_text_short))

        # --- N√∫t "üé¨ Video/·∫¢nh..." ---
        vid_btn = getattr(self, 'dub_load_video_button', None)
        if vid_btn and vid_btn.winfo_exists():
            original_text_video = "üé¨ Video/·∫¢nh..."
            if not is_app_active:
                vid_btn.configure(state=ctk.DISABLED, text="üîí K√≠ch ho·∫°t")
            else:
                vid_btn.configure(
                    state=(ctk.DISABLED if is_main_batch_processing else ctk.NORMAL),
                    text=original_text_video
                )

        # Ch·ªçn th∆∞ m·ª•c output
        btn_output = getattr(self, 'dub_select_output_dir_button', None)
        _cfg(btn_output,
             state=(ctk.DISABLED if is_batch else state_all),
             text=("Ch·ªçn th∆∞ m·ª•c..." if is_app_active else unactivated_text_short))

        # Logo/Intro
        btn_branding = getattr(self, 'branding_settings_button_dub_tab', None)
        if not is_app_active:
            _cfg(btn_branding, state=ctk.DISABLED, text=unactivated_text_short)
        else:
            _cfg(btn_branding, state=(ctk.DISABLED if is_batch else ctk.NORMAL), text="üñº Logo/Intro")

        # C√°c control c·∫•u h√¨nh panel tr√°i
        for ctrl in [
            getattr(self, 'dub_chk_use_image_folder', None),
            getattr(self, 'dub_tts_engine_menu', None),
            getattr(self, 'dub_background_audio_menu', None),
            getattr(self, 'dub_slider_mix_level', None),
            getattr(self, 'dub_chk_use_custom_bg_music', None),
            getattr(self, 'dub_entry_custom_bg_music_volume', None),
            getattr(self, 'dub_btn_browse_bg_music', None),
            getattr(self, 'chk_optimize_dub_flow', None),
            getattr(self, 'dub_chk_show_advanced_audio_settings', None),
        ]:
            _cfg(ctrl, state=(ctk.DISABLED if is_batch else state_all))

        # N√∫t API Keys (cho ph√©p m·ªü khi ƒë√£ k√≠ch ho·∫°t)
        _cfg(getattr(self, 'api_settings_button_dub_tab', None),
             state=(ctk.NORMAL if is_app_active else ctk.DISABLED))

        # Chu·∫©n ho√° c·ªù "ƒëang b·∫≠n"
        is_batch        = bool(getattr(self, 'dub_is_processing', False))
        is_gpt_running  = bool(getattr(self, 'is_gpt_processing_script', False))
        is_dalle_running= bool(getattr(self, 'is_dalle_processing', False))
        is_preview_run  = bool(getattr(self, 'is_performing_single_task', False))
        is_any_task_running = is_batch or is_gpt_running or is_dalle_running or is_preview_run

        # L·∫•y key (an to√†n)
        openai_key = (self.openai_key_var.get().strip() if hasattr(self, 'openai_key_var') and self.openai_key_var else "")
        gemini_key = (self.gemini_key_var.get().strip() if hasattr(self, 'gemini_key_var') and self.gemini_key_var else "")
        google_json= (self.google_key_path_var.get().strip() if hasattr(self, 'google_key_path_var') and self.google_key_path_var else "")

        # --- HEADER PANEL PH·∫¢I ---

        # 1) ‚ú® Bi√™n t·∫≠p (AI)  -> b·∫≠t khi c√≥ OpenAI key HO·∫∂C Gemini key
        btn_ai = getattr(self, 'ai_edit_dub_script_button', None)
        if not is_app_active:
            _cfg(btn_ai, state=ctk.DISABLED, text=unactivated_text_short)
        elif is_any_task_running and not is_preview_run:
            _cfg(btn_ai, state=ctk.DISABLED, text="...")
        elif is_gpt_running:
            _cfg(btn_ai, state=ctk.DISABLED, text="AI ƒëang ch·∫°y...")
        else:
            can_use_ai = bool(openai_key) or bool(gemini_key)
            _cfg(btn_ai, state=(ctk.NORMAL if can_use_ai else ctk.DISABLED), text="‚ú® Bi√™n t·∫≠p (AI)")

        # 2) üé® T·∫°o ·∫¢nh AI (DALL¬∑E) -> b·∫≠t khi c√≥ OpenAI key
        btn_dalle = getattr(self, 'dalle_button_dub_tab', None)
        if not is_app_active:
            _cfg(btn_dalle, state=ctk.DISABLED, text=unactivated_text_short)
        elif is_any_task_running and not is_preview_run:
            _cfg(btn_dalle, state=ctk.DISABLED, text="...")
        elif is_dalle_running:
            _cfg(btn_dalle, state=ctk.DISABLED, text="üé® ƒêang v·∫Ω...")
        else:
            can_use_dalle = bool(openai_key)
            _cfg(btn_dalle, state=(ctk.NORMAL if can_use_dalle else ctk.DISABLED), text="üé® T·∫°o ·∫¢nh AI")

        # 3) üñº ·∫¢nh(Imagen) -> b·∫≠t khi c√≥ ƒë∆∞·ªùng d·∫´n JSON Google (kh√¥ng li√™n quan OpenAI/Gemini)
        btn_imagen = getattr(self, 'imagen_button_dub_tab', None)
        if not is_app_active:
            _cfg(btn_imagen, state=ctk.DISABLED, text=unactivated_text_short)
        elif is_any_task_running and not is_preview_run:
            _cfg(btn_imagen, state=ctk.DISABLED, text="...")
        elif bool(getattr(self, 'is_imagen_processing', False)):
            _cfg(btn_imagen, state=ctk.DISABLED, text="üñºÔ∏è ƒêang v·∫Ω...")
        else:
            can_use_imagen = bool(google_json)
            _cfg(btn_imagen, state=(ctk.NORMAL if can_use_imagen else ctk.DISABLED), text="üñº ·∫¢nh(Imagen)")

        # 4) Nghe th·ª≠ Script
        btn_preview = getattr(self, 'dub_preview_button', None)
        preview_text = "üîä Nghe th·ª≠ Script"
        if is_preview:
            _cfg(btn_preview, state=ctk.DISABLED, text="...")
        elif is_batch or not is_app_active:
            _cfg(btn_preview, state=ctk.DISABLED, text=(preview_text if is_app_active else unactivated_text_short))
        else:
            # ƒë·∫£m b·∫£o text v·ªÅ m·∫∑c ƒë·ªãnh khi ƒë∆∞·ª£c ph√©p d√πng
            if btn_preview and btn_preview.winfo_exists() and getattr(btn_preview, "cget", None):
                if btn_preview.cget("text") != preview_text:
                    _cfg(btn_preview, text=preview_text)

        # 5) N√∫t l∆∞u/ch·ªânh s·ª≠a script & audio
        for btn, label in {
            getattr(self, 'dub_btn_save_audio_from_text', None): "üíæ L∆∞u Audio",
            getattr(self, 'dub_btn_save_script', None): "üíæ L∆∞u Script",
            getattr(self, 'dub_btn_edit_script', None): "‚úç S·ª≠a Script",
        }.items():
            locked = (not is_app_active) or is_any_task_running
            _cfg(btn, state=(ctk.DISABLED if locked else ctk.NORMAL),
                 text=(label if is_app_active else unactivated_text_short))

        # 6) M·ªü th∆∞ m·ª•c Output
        _cfg(getattr(self, 'dub_btn_open_output_folder', None),
             state=(ctk.NORMAL if is_app_active else ctk.DISABLED))

        # --- Textbox k·ªãch b·∫£n ---
        tb = getattr(self, 'dub_script_textbox', None)
        if tb and hasattr(tb, "configure") and tb.winfo_exists():
            if (not is_app_active) or is_any_task_running:
                _cfg(tb, state=ctk.DISABLED)
                if not is_app_active:
                    # Ch√®n placeholder ‚Äúkho√°‚Äù n·∫øu c·∫ßn
                    try:
                        cur = tb.get("1.0", "end-1c")
                    except Exception:
                        cur = ""
                    placeholder = getattr(self, 'dub_script_textbox_placeholder', "")
                    if cur.strip() == placeholder.strip() or self._is_textbox_content_invalid_for_script(cur.strip()):
                        try:
                            tb.delete("1.0", "end")
                            tb.insert("1.0", "Vui l√≤ng k√≠ch ho·∫°t ƒë·ªÉ s·ª≠ d·ª•ng tr√¨nh so·∫°n th·∫£o k·ªãch b·∫£n.")
                        except Exception:
                            pass
            else:
                _cfg(tb, state=ctk.NORMAL)
                try:
                    cur = tb.get("1.0", "end-1c")
                except Exception:
                    cur = ""
                if "Vui l√≤ng k√≠ch ho·∫°t ƒë·ªÉ s·ª≠ d·ª•ng tr√¨nh so·∫°n th·∫£o k·ªãch b·∫£n." in cur:
                    try:
                        tb.delete("1.0", "end")
                        tb.insert("1.0", getattr(self, 'dub_script_textbox_placeholder', "[N·ªôi dung k·ªãch b·∫£n...·ªü ƒë√¢y]"))
                    except Exception:
                        pass

        # --- G·ªçi c√°c c·∫≠p nh·∫≠t ph·ª• thu·ªôc ---
        if hasattr(self, 'dub_update_image_folder_controls_visibility'):
            self.dub_update_image_folder_controls_visibility()

        if getattr(self, 'initial_ui_setup_complete', False):
            if hasattr(self, 'dub_on_tts_engine_selected'):
                try:
                    self.dub_on_tts_engine_selected(self.dub_selected_tts_engine_var.get(), _from_task_setup=True)
                except Exception:
                    pass
            if hasattr(self, 'dub_on_background_audio_option_changed'):
                try:
                    self.dub_on_background_audio_option_changed(self.dub_background_audio_option_var.get(), update_status=False)
                except Exception:
                    pass
            if hasattr(self, 'dub_update_custom_bg_music_controls_visibility'):
                self.dub_update_custom_bg_music_controls_visibility()
            if hasattr(self, '_toggle_dub_flow_options_visibility'):
                self._toggle_dub_flow_options_visibility()
            if hasattr(self, '_toggle_advanced_dub_audio_settings_visibility'):
                self._toggle_advanced_dub_audio_settings_visibility()
            if hasattr(self, '_update_dub_script_controls_state'):
                self.after(50, self._update_dub_script_controls_state)

        logging.info(f"{log_prefix} Ho√†n t·∫•t c·∫≠p nh·∫≠t UI tab Thuy·∫øt Minh.")



# H√†m ti·ªán √≠ch: L·∫•y Hardware ID (HWID) c·ªßa m√°y
    def get_hardware_id(self):
        """
        Tr·∫£ v·ªÅ Hardware ID ·ªïn ƒë·ªãnh, ƒëa n·ªÅn t·∫£ng theo th·ª© t·ª± ∆∞u ti√™n:
        1) MAC (ch·∫•p nh·∫≠n c·∫£ LAA, ch·ªâ lo·∫°i 0)
        2) Windows: MachineGuid -> SMBIOS UUID (CIM/WMIC)
           macOS:   IOPlatformUUID -> Hardware UUID (system_profiler)
           Linux:   /etc/machine-id -> DMI product_uuid
        Ghi v√†o self.cfg['hardware_id'] n·∫øu l·∫•y ƒë∆∞·ª£c.
        """
        import sys, os, re, uuid, logging, subprocess

        def _save_and_return(hwid: str):
            if hwid and hwid != "UNKNOWN_HWID":
                if getattr(self, "cfg", None) is not None:
                    try:
                        if self.cfg.get('hardware_id') != hwid:
                            self.cfg['hardware_id'] = hwid
                            logging.info(f"[HWID] ƒê√£ ch·ªçn HWID: {hwid}")
                    except Exception:
                        # N·∫øu self.cfg kh√¥ng ph·∫£i dict, b·ªè qua l∆∞u
                        pass
            return hwid


        # --- 1) MAC (∆∞u ti√™n ƒë·ªÉ t∆∞∆°ng th√≠ch c√°c license c≈©) ---
        try:
            mac_int = uuid.getnode()
            if mac_int not in (None, 0):
                mac_hex = f"{mac_int:012X}"
                if is_plausible_hwid(mac_hex):
                    return _save_and_return(f"MAC_{mac_hex}")
        except Exception as e:
            logging.warning(f"[HWID] L·ªói l·∫•y MAC: {e}")

        # --- 2) Theo h·ªá ƒëi·ªÅu h√†nh ---
        platform = sys.platform

        # Windows
        if platform.startswith("win"):
            # 2.1) MachineGuid
            try:
                import winreg
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Cryptography") as k:
                    mguid, _ = winreg.QueryValueEx(k, "MachineGuid")
                mg = normalize_hwid_string(str(mguid))
                if is_plausible_hwid(mg):
                    return _save_and_return(f"WINMG_{mg}")
            except Exception as e:
                logging.warning(f"[HWID] MachineGuid kh√¥ng d√πng ƒë∆∞·ª£c: {e}")

            # 2.2) SMBIOS UUID qua PowerShell CIM
            try:
                ps = ["powershell", "-NoProfile", "-Command",
                      "(Get-CimInstance -ClassName Win32_ComputerSystemProduct).UUID"]
                r = subprocess.run(ps, capture_output=True, text=True, timeout=6)
                u = normalize_hwid_string(r.stdout)
                if is_plausible_hwid(u):
                    return _save_and_return(f"WINUUID_{u}")
            except Exception as e:
                logging.warning(f"[HWID] CIM UUID kh√¥ng d√πng ƒë∆∞·ª£c: {e}")

            # 2.3) WMIC (backup cho m√°y c≈©)
            try:
                r = subprocess.run(["wmic", "csproduct", "get", "uuid"], capture_output=True, text=True, timeout=6)
                lines = [ln.strip() for ln in r.stdout.splitlines() if ln.strip() and "UUID" not in ln.upper()]
                if lines:
                    u = normalize_hwid_string(lines[0])
                    if is_plausible_hwid(u):
                        return _save_and_return(f"WINUUID_{u}")
            except Exception as e:
                logging.warning(f"[HWID] WMIC UUID kh√¥ng d√πng ƒë∆∞·ª£c: {e}")

        # macOS
        elif platform == "darwin":
            # 2.1) IOPlatformUUID
            try:
                r = subprocess.run(
                    ["ioreg", "-rd1", "-c", "IOPlatformExpertDevice"],
                    capture_output=True, text=True, timeout=6
                )
                m = re.search(r'IOPlatformUUID"\s*=\s*"([^"]+)"', r.stdout)
                if m:
                    u = normalize_hwid_string(m.group(1))
                    if is_plausible_hwid(u):
                        return _save_and_return(f"MACIOP_{u}")
            except Exception as e:
                logging.warning(f"[HWID] IOPlatformUUID kh√¥ng d√πng ƒë∆∞·ª£c: {e}")

            # 2.2) system_profiler
            try:
                r = subprocess.run(
                    ["system_profiler", "SPHardwareDataType"],
                    capture_output=True, text=True, timeout=10
                )
                m = re.search(r'Hardware UUID:\s*([A-Fa-f0-9-]+)', r.stdout)
                if m:
                    u = normalize_hwid_string(m.group(1))
                    if is_plausible_hwid(u):
                        return _save_and_return(f"MACSP_{u}")
            except Exception as e:
                logging.warning(f"[HWID] system_profiler kh√¥ng d√πng ƒë∆∞·ª£c: {e}")

        # Linux / Others
        else:
            # 2.1) /etc/machine-id ho·∫∑c /var/lib/dbus/machine-id
            try:
                for p in ("/etc/machine-id", "/var/lib/dbus/machine-id"):
                    if os.path.isfile(p):
                        with open(p, "r", encoding="utf-8", errors="ignore") as f:
                            mid = normalize_hwid_string(f.read())
                        if is_plausible_hwid(mid):
                            return _save_and_return(f"LINMID_{mid}")
            except Exception as e:
                logging.warning(f"[HWID] machine-id kh√¥ng d√πng ƒë∆∞·ª£c: {e}")

            # 2.2) DMI product_uuid
            try:
                p = "/sys/class/dmi/id/product_uuid"
                if os.path.isfile(p):
                    with open(p, "r", encoding="utf-8", errors="ignore") as f:
                        dmi = normalize_hwid_string(f.read())
                    if is_plausible_hwid(dmi):
                        return _save_and_return(f"LINDMI_{dmi}")
            except Exception as e:
                logging.warning(f"[HWID] DMI product_uuid kh√¥ng d√πng ƒë∆∞·ª£c: {e}")

        # 3) H·∫øt c√°ch
        logging.error("[HWID] Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c ƒë·ªãnh danh b·∫±ng m·ªçi ph∆∞∆°ng ph√°p.")
        return "UNKNOWN_HWID"


# H√†m h√†nh ƒë·ªông: Hi·ªÉn th·ªã dialog nh·∫≠p key v√† th·ª≠ k√≠ch ho·∫°t
    def prompt_and_activate(self, prompt_message="üîë Vui l√≤ng nh·∫≠p License Key c·ªßa b·∫°n:"):
        """ Hi·ªán dialog nh·∫≠p key v√† th·ª≠ k√≠ch ho·∫°t """
        logging.info(f"üîë Y√™u c·∫ßu nh·∫≠p license key: '{prompt_message}'")
        dialog = ctk.CTkInputDialog(text=prompt_message, title="K√≠ch ho·∫°t Piu")
        # C·ªë g·∫Øng cƒÉn gi·ªØa c∆° b·∫£n
        try:
            dialog.update_idletasks()
            dialog_w, dialog_h = dialog.winfo_reqwidth(), dialog.winfo_reqheight()
            main_w, main_h = self.winfo_width(), self.winfo_height()
            main_x, main_y = self.winfo_x(), self.winfo_y()
            pos_x = main_x + (main_w // 2) - (dialog_w // 2)
            pos_y = main_y + (main_h // 2) - (dialog_h // 2)
            dialog.geometry(f"+{pos_x}+{pos_y}")
        except Exception as e: logging.warning(f"Kh√¥ng th·ªÉ cƒÉn gi·ªØa dialog nh·∫≠p: {e}")

        entered_key = dialog.get_input()

        if entered_key is not None:
            entered_key = entered_key.strip()
            if entered_key:
                logging.info(f"Ng∆∞·ªùi d√πng ƒë√£ nh·∫≠p key: {entered_key}")
                # S·ª≠ d·ª•ng threading ƒë·ªÉ tr√°nh ch·∫∑n UI trong qu√° tr√¨nh y√™u c·∫ßu k√≠ch ho·∫°t
                thread = threading.Thread(target=self.activate_license, args=(entered_key,), daemon=True, name="ActivationThread")
                thread.start()
                return True # Cho bi·∫øt *n·ªó l·ª±c* k√≠ch ho·∫°t ƒë√£ b·∫Øt ƒë·∫ßu
            else:
                logging.warning("Ng∆∞·ªùi d√πng ƒë√£ g·ª≠i key r·ªóng.")
                messagebox.showwarning("Key kh√¥ng h·ª£p l·ªá", "üîë License Key kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")
                return False
        else:
            logging.info("Ng∆∞·ªùi d√πng ƒë√£ h·ªßy nh·∫≠p key.")
            return False # Ng∆∞·ªùi d√πng ƒë√£ h·ªßy


# H√†m logic (ch·∫°y trong lu·ªìng): G·ª≠i key v√† HWID ƒë·∫øn server ƒë·ªÉ k√≠ch ho·∫°t license
    def activate_license(self, license_key):
        """ G·ª≠i key v√† HWID ƒë·∫øn server k√≠ch ho·∫°t (thread-safe) """
        logging.info(f"üîë ƒêang th·ª≠ k√≠ch ho·∫°t license key: {license_key}")
        _update_status = lambda msg: self.after(0, self.update_status, msg)
        _show_info = lambda title, msg: self.after(0, messagebox.showinfo, title, msg)
        _show_error = lambda title, msg: self.after(0, messagebox.showerror, title, msg)

        _update_status(f"ƒêang k√≠ch ho·∫°t key: {license_key}...")
        current_hwid = self.get_hardware_id()
        if current_hwid == "UNKNOWN_HWID":
             _show_error("L·ªói ƒê·ªãnh danh", "Kh√¥ng th·ªÉ l·∫•y ƒë·ªãnh danh m√°y. K√≠ch ho·∫°t th·∫•t b·∫°i.")
             _update_status("‚õî L·ªói: Kh√¥ng th·ªÉ l·∫•y HWID")
             return # K√≠ch ho·∫°t th·∫•t b·∫°i trong thread

        logging.debug(f"ƒêang g·ª≠i y√™u c·∫ßu k√≠ch ho·∫°t qua LicensingService")

        try:
            result = licensing_activate(license_key, current_hwid)
            logging.info(f"Ph·∫£n h·ªìi server k√≠ch ho·∫°t: {result}")

            if result.get("status") == "success":
                retrieved_type = result.get("type", "ACTIVE")
                retrieved_expiry = result.get("expiry_date")
                # C·∫≠p nh·∫≠t config tr√™n lu·ªìng ch√≠nh
                def _update_cfg():
                    self.cfg['license_key'] = license_key
                    self.cfg['activation_status'] = retrieved_type # Server tr·∫£ v·ªÅ 'LIFETIME' cho retrieved_type (t·ª´ result.get("activation_status"))
                    self.cfg['expiry_date'] = retrieved_expiry
                    self.cfg['hardware_id'] = current_hwid
                    # D√íNG QUAN TR·ªåNG:
                    self.cfg['license_type'] = result.get('type', retrieved_type) 

                    save_config(self.cfg) # G·ªçi h√†m l∆∞u to√†n c·ª•c
                    self.handle_activated_state(show_detailed_status=True) # C·∫≠p nh·∫≠t UI v√† hi·ªÉn th·ªã chi ti·∫øt
                    self.mark_startup_task_done('activation')
                    # X·ª≠ l√Ω ng√†y h·∫øt h·∫°n
                    expiry_msg_display = retrieved_expiry if retrieved_expiry else "Kh√¥ng bao gi·ªù"

                    # L·∫•y th√¥ng b√°o g·ªëc t·ª´ server
                    server_message = result.get('message', 'K√≠ch ho·∫°t th√†nh c√¥ng!') # M·∫∑c ƒë·ªãnh l√† ti·∫øng Vi·ªát n·∫øu server kh√¥ng tr·∫£ message

                    # Vi·ªát h√≥a c√°c th√¥ng b√°o ti·∫øng Anh ph·ªï bi·∫øn t·ª´ server
                    display_message = server_message # M·∫∑c ƒë·ªãnh gi·ªØ nguy√™n th√¥ng b√°o t·ª´ server
                    if server_message == "License already activated on this machine.":
                        display_message = "License ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t tr√™n m√°y n√†y!"
                    elif server_message == "Activation successful!":
                         display_message = "K√≠ch ho·∫°t th√†nh c√¥ng!"
                    # Th√™m c√°c elif kh√°c ·ªü ƒë√¢y n·∫øu bi·∫øt server c√≥ th·ªÉ tr·∫£ v·ªÅ c√°c th√¥ng b√°o ti·∫øng Anh kh√°c
                    # elif server_message == "Another English message":
                    #     display_message = "B·∫£n d·ªãch ti·∫øng Vi·ªát t∆∞∆°ng ·ª©ng"

                    # C√°c nh√£n ti·∫øng Vi·ªát
                    type_label = "Lo·∫°i:"
                    expiry_label = "H·∫øt h·∫°n:"

                    # T·∫°o chu·ªói ho√†n ch·ªânh cho popup s·ª≠ d·ª•ng display_message ƒë√£ Vi·ªát h√≥a
                    success_msg = f"{display_message}\n\n{type_label} {retrieved_type}\n{expiry_label} {expiry_msg_display}"

                    # Hi·ªÉn th·ªã popup
                    _show_info("K√≠ch ho·∫°t Th√†nh c√¥ng", success_msg) # Ti√™u ƒë·ªÅ v·∫´n l√† ti·∫øng Vi·ªát

                self.after(0, _update_cfg)
            else: # K√≠ch ho·∫°t th·∫•t b·∫°i theo server
                error_message = result.get('message', 'L·ªói server kh√¥ng x√°c ƒë·ªãnh.')
                logging.error(f"K√≠ch ho·∫°t server th·∫•t b·∫°i: {error_message}")
                _show_error("K√≠ch ho·∫°t Th·∫•t b·∫°i", f"Kh√¥ng th·ªÉ k√≠ch ho·∫°t key:\n{error_message}")
                _update_status(f"‚õî L·ªói K√≠ch ho·∫°t: {error_message}")

        except requests.exceptions.Timeout:
            logging.error("Y√™u c·∫ßu k√≠ch ho·∫°t h·∫øt th·ªùi gian ch·ªù.")
            _show_error("L·ªói Timeout", "Server k√≠ch ho·∫°t kh√¥ng ph·∫£n h·ªìi k·ªãp th·ªùi. Ki·ªÉm tra m·∫°ng ho·∫∑c th·ª≠ l·∫°i sau.")
            _update_status("‚õî L·ªói: Timeout K√≠ch ho·∫°t")
        except requests.exceptions.RequestException as e:
            logging.error(f"L·ªói m·∫°ng/HTTP trong qu√° tr√¨nh k√≠ch ho·∫°t: {e}", exc_info=True)
            _show_error("L·ªói K·∫øt n·ªëi", f"Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server k√≠ch ho·∫°t.\nL·ªói: {e}")
            _update_status("‚õî L·ªói: M·∫°ng/HTTP")
        except json.JSONDecodeError:
            logging.error("Ph·∫£n h·ªìi JSON kh√¥ng h·ª£p l·ªá t·ª´ server k√≠ch ho·∫°t.")
            _show_error("L·ªói Ph·∫£n h·ªìi", "Server k√≠ch ho·∫°t tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.")
            _update_status("‚õî L·ªói: Ph·∫£n h·ªìi Server kh√¥ng h·ª£p l·ªá")
        except Exception as e:
            logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh trong qu√° tr√¨nh k√≠ch ho·∫°t: {e}", exc_info=True)
            _show_error("L·ªói Kh√¥ng x√°c ƒë·ªãnh", f"ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën trong qu√° tr√¨nh k√≠ch ho·∫°t:\n{e}")
            _update_status("‚õî L·ªói: L·ªói K√≠ch ho·∫°t Kh√¥ng x√°c ƒë·ªãnh")


# H√†m logic: Th·ª≠ b·∫Øt ƒë·∫ßu giai ƒëo·∫°n d√πng th·ª≠ (trial)
    def start_trial(self):
        """
        Th·ª≠ b·∫Øt ƒë·∫ßu giai ƒëo·∫°n d√πng th·ª≠ (trial) b·∫±ng c√°ch g·ªçi l√™n server Apps Script.
        (ƒê√É ƒê·ªíNG B·ªò v·ªõi _is_app_fully_activated + _apply_activation_ui_state)
        """
        import json, time
        import requests

        log_prefix = "[TRIAL_FINAL_FIX]"
        logging.info(f"{log_prefix} ƒêang th·ª≠ b·∫Øt ƒë·∫ßu giai ƒëo·∫°n d√πng th·ª≠ (G·ªçi Server)...")

        # C√°c helper hi·ªÉn th·ªã UI tr√™n main thread
        def _show_info_on_main_thread(title_si, msg_si):
            try:
                messagebox.showinfo(title_si, msg_si, parent=self)
            except Exception:
                pass

        def _show_error_on_main_thread(title_se, msg_se):
            try:
                messagebox.showerror(title_se, msg_se, parent=self)
            except Exception:
                pass

        _update_status = lambda msg: self.after(0, self.update_status, msg)

        try:
            # 1) L·∫•y HWID
            current_hwid = self.get_hardware_id()
            if current_hwid == "UNKNOWN_HWID" or not current_hwid:
                logging.error("Kh√¥ng th·ªÉ l·∫•y Hardware ID ƒë·ªÉ b·∫Øt ƒë·∫ßu d√πng th·ª≠.")
                self.after(0, lambda: _show_error_on_main_thread(
                    "L·ªói ƒê·ªãnh danh", "Kh√¥ng th·ªÉ l·∫•y ƒë·ªãnh danh m√°y. Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu d√πng th·ª≠."
                ))
                self.cfg['activation_status'] = 'HWID_ERROR_CLIENT'
                try:
                    save_config(self.cfg)
                except Exception:
                    pass
                # √Åp d·ª•ng UI theo ngu·ªìn s·ª± th·∫≠t & k·∫øt th√∫c
                self.after(0, self._apply_activation_ui_state)
                self.mark_startup_task_done('activation')
                return False

            # 2) G·ªçi server
            _update_status("ƒêang li√™n h·ªá server ƒë·ªÉ b·∫Øt ƒë·∫ßu d√πng th·ª≠...")
            logging.info(f"{log_prefix} G·ªçi LicensingService.start_trial")

            response_text_debug_trial = ""
            try:
                result = licensing_start_trial(current_hwid)
                response_text_debug_trial = result.get('raw', '')
                logging.info(f"Ph·∫£n h·ªìi server d√πng th·ª≠: {result}")

            except requests.exceptions.RequestException as e:
                logging.error(f"L·ªói m·∫°ng/HTTP trong qu√° tr√¨nh d√πng th·ª≠: {e}", exc_info=True)
                self.after(0, lambda err_msg=str(e): _show_error_on_main_thread(
                    "L·ªói K·∫øt n·ªëi", f"Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server.\nL·ªói: {err_msg}"
                ))
                _update_status("‚õî L·ªói: M·∫°ng/HTTP khi b·∫Øt ƒë·∫ßu d√πng th·ª≠")
                self.cfg['activation_status'] = 'TRIAL_NETWORK_ERROR'
                try:
                    save_config(self.cfg)
                except Exception:
                    pass
                # ƒê·ªìng b·ªô UI & k·∫øt th√∫c
                self.after(0, self._apply_activation_ui_state)
                self.mark_startup_task_done('activation')
                return False

            except Exception:
                logging.error(f"Ph·∫£n h·ªìi JSON kh√¥ng h·ª£p l·ªá t·ª´ server d√πng th·ª≠: {response_text_debug_trial[:200]}...", exc_info=True)
                self.after(0, lambda: _show_error_on_main_thread(
                    "L·ªói Ph·∫£n h·ªìi", "Server tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá."
                ))
                _update_status("‚õî L·ªói: Ph·∫£n h·ªìi Server kh√¥ng h·ª£p l·ªá")
                self.cfg['activation_status'] = 'TRIAL_INVALID_JSON'
                try:
                    save_config(self.cfg)
                except Exception:
                    pass
                # ƒê·ªìng b·ªô UI & k·∫øt th√∫c
                self.after(0, self._apply_activation_ui_state)
                self.mark_startup_task_done('activation')
                return False

            # 3) Ph√¢n t√≠ch k·∫øt qu·∫£
            status_field = (result.get("status") or "").strip().lower()   # "success"/"error"
            server_msg   = result.get("message", "")

            if status_field == "success":
                retrieved_type = (result.get("activation_status") or result.get("type") or "TRIAL")
                retrieved_type = retrieved_type.strip().upper()
                retrieved_expiry = (result.get("expiry_date") or "").strip()

                # C·∫≠p nh·∫≠t cfg theo server
                self.cfg['activation_status'] = retrieved_type
                self.cfg['expiry_date'] = retrieved_expiry
                self.cfg['hardware_id'] = current_hwid
                self.cfg['license_key'] = ""
                self.cfg['license_type'] = retrieved_type
                try:
                    self.cfg['last_license_revalidation_timestamp'] = int(time.time())
                except Exception:
                    pass

                try:
                    save_config(self.cfg)
                    logging.info("ƒê√£ l∆∞u c·∫•u h√¨nh tr·∫°ng th√°i D√πng th·ª≠ (theo server).")
                except Exception as e:
                    logging.warning(f"[TRIAL] Kh√¥ng l∆∞u ƒë∆∞·ª£c config: {e}")

                # Th√¥ng ƒëi·ªáp hi·ªÉn th·ªã
                display_message = server_msg
                if "Trial started successfully!" in (server_msg or ""):
                    display_message = f"‚úÖ B·∫°n ƒë√£ b·∫Øt ƒë·∫ßu d√πng th·ª≠.\nT√≠nh nƒÉng ƒë·∫ßy ƒë·ªß s·∫Ω ho·∫°t ƒë·ªông ƒë·∫øn h·∫øt ng√†y {retrieved_expiry or 'N/A'}."
                elif "existing license" in (server_msg or "") or "active trial" in (server_msg or ""):
                    display_message = f"‚úÖ M√°y n√†y ƒë√£ ƒëƒÉng k√Ω ho·∫∑c b·∫Øt ƒë·∫ßu d√πng th·ª≠ tr∆∞·ªõc ƒë√≥.\nH·∫°n d√πng ƒë·∫øn: {retrieved_expiry or 'N/A'}."

                self.after(0, lambda dm=display_message: _show_info_on_main_thread("Th√¥ng b√°o D√πng th·ª≠", dm))
                # √Åp d·ª•ng UI theo ngu·ªìn s·ª± th·∫≠t
                self.after(0, self._apply_activation_ui_state)
                self.mark_startup_task_done('activation')
                return True

            else:
                error_message = result.get('message', 'Server t·ª´ ch·ªëi b·∫Øt ƒë·∫ßu d√πng th·ª≠.')
                server_reported_status = (result.get('activation_status') or 'TRIAL_DENIED_BY_SERVER').strip().upper()

                logging.error(f"Server t·ª´ ch·ªëi d√πng th·ª≠: {error_message} (Server status: {server_reported_status})")
                self.after(0, lambda em=error_message: _show_error_on_main_thread(
                    "Kh√¥ng th·ªÉ B·∫Øt ƒë·∫ßu D√πng th·ª≠", f"Server b√°o l·ªói:\n{em}"
                ))

                self.cfg['activation_status'] = server_reported_status
                try:
                    self.cfg['last_license_revalidation_timestamp'] = int(time.time())
                except Exception:
                    pass
                try:
                    save_config(self.cfg)
                except Exception:
                    pass

                # √Åp d·ª•ng UI theo ngu·ªìn s·ª± th·∫≠t
                self.after(0, self._apply_activation_ui_state)
                self.mark_startup_task_done('activation')
                return False

        except Exception as e:
            logging.error(f"{log_prefix} L·ªói kh√¥ng mong mu·ªën khi b·∫Øt ƒë·∫ßu d√πng th·ª≠: {e}", exc_info=True)
            self.after(0, lambda err_msg=str(e): _show_error_on_main_thread(
                "L·ªói B·∫Øt ƒë·∫ßu D√πng th·ª≠", f"ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën:\n{err_msg}"
            ))
            self.cfg['activation_status'] = 'TRIAL_EXCEPTION'
            try:
                save_config(self.cfg)
            except Exception:
                pass
            # ƒê·ªìng b·ªô UI & k·∫øt th√∫c
            self.after(0, self._apply_activation_ui_state)
            self.mark_startup_task_done('activation')
            return False


# H√†m logic (ch·∫°y trong lu·ªìng): Ki·ªÉm tra phi√™n b·∫£n c·∫≠p nh·∫≠t m·ªõi c·ªßa ·ª©ng d·ª•ng
    def check_for_update(self, manual=False):
        """ Ki·ªÉm tra c·∫≠p nh·∫≠t ·ª©ng d·ª•ng. √çt th√¥ng b√°o h∆°n khi ch·∫°y t·ª± ƒë·ªông. """
        # Ch·ªâ hi·ªÉn th·ªã "ƒêang ki·ªÉm tra..." n·∫øu l√† ki·ªÉm tra th·ªß c√¥ng
        if manual:
            _update_status = lambda msg: self.after(0, self.update_status, msg)
            _update_status("üîé ƒêang ki·ªÉm tra c·∫≠p nh·∫≠t...")
        else:
            _update_status = lambda msg: None # H√†m r·ªóng, kh√¥ng l√†m g√¨ v·ªõi status bar khi t·ª± ƒë·ªông

        _show_info = lambda title, msg: self.after(0, lambda t=title, m=msg: messagebox.showinfo(t, m, parent=self))
        _show_error = lambda title, msg: self.after(0, lambda t=title, m=msg: messagebox.showerror(t, m, parent=self))

        update_url = "https://drive.google.com/uc?id=1bHCjOv06hEie--o7xOpLeweguJPWRFxF&export=download" # URL v√≠ d·ª•
        logging.info(f"ƒêang ki·ªÉm tra c·∫≠p nh·∫≠t (Manual={manual}) t·ª´: {update_url}")
        update_found = False
        error_occurred = False
        config_changed_by_update_check = False # C·ªù ƒë·ªÉ bi·∫øt c√≥ c·∫ßn l∆∞u config kh√¥ng

        try:
            from services.update_service import fetch_update_info
            svc_resp = fetch_update_info(update_url, timeout_seconds=15)
            if svc_resp.get('status') == 'network_error':
                raise requests.exceptions.RequestException(svc_resp.get('error', 'Network error'))
            if svc_resp.get('status') == 'invalid_json':
                raise json.JSONDecodeError("Invalid JSON", doc="", pos=0)
            if svc_resp.get('status') == 'invalid':
                raise ValueError(svc_resp.get('error', 'Invalid data'))
            data = svc_resp.get('data', {})

            latest_ver = data.get("version", "").strip()
            changelog = data.get("changelog", "N/A")
            dl_url = data.get("download_url", "")

            if not latest_ver or not dl_url:
                raise ValueError("Thi·∫øu 'version' ho·∫∑c 'download_url' trong th√¥ng tin c·∫≠p nh·∫≠t.")

            if is_newer_version(latest_ver, CURRENT_VERSION):
                skipped_ver_in_cfg = self.cfg.get("skipped_specific_version")

                # N·∫øu phi√™n b·∫£n m·ªõi n√†y kh√°c v√† th·ª±c s·ª± m·ªõi h∆°n m·ªôt phi√™n b·∫£n ƒë√£ t·ª´ng b·ªã b·ªè qua,
                # th√¨ c·ªù b·ªè qua c≈© kh√¥ng c√≤n √Ω nghƒ©a.
                if skipped_ver_in_cfg and \
                   latest_ver != skipped_ver_in_cfg and \
                   version.parse(latest_ver) > version.parse(skipped_ver_in_cfg):
                    logging.info(f"Phi√™n b·∫£n m·ªõi {latest_ver} kh√°c v√† m·ªõi h∆°n phi√™n b·∫£n ƒë√£ b·ªè qua ({skipped_ver_in_cfg}). X√≥a c·ªù b·ªè qua c≈©.")
                    if "skipped_specific_version" in self.cfg:
                        del self.cfg["skipped_specific_version"]
                        config_changed_by_update_check = True # ƒê√°nh d·∫•u config ƒë√£ thay ƒë·ªïi
                    skipped_ver_in_cfg = None # C·∫≠p nh·∫≠t bi·∫øn local ƒë·ªÉ logic d∆∞·ªõi ch·∫°y ƒë√∫ng cho l·∫ßn ki·ªÉm tra n√†y

                # Ki·ªÉm tra xem phi√™n b·∫£n hi·ªán t·∫°i c√≥ ph·∫£i l√† phi√™n b·∫£n ƒë√£ b·ªã b·ªè qua kh√¥ng (ch·ªâ √°p d·ª•ng cho ki·ªÉm tra t·ª± ƒë·ªông)
                # Bi·∫øn skipped_ver_in_cfg c√≥ th·ªÉ l√† None n·∫øu v·ª´a ƒë∆∞·ª£c x√≥a ·ªü tr√™n.
                if latest_ver == skipped_ver_in_cfg and not manual:
                    logging.info(f"C·∫≠p nh·∫≠t phi√™n b·∫£n {latest_ver} c√≥ s·∫µn nh∆∞ng ƒë√£ ƒë∆∞·ª£c ng∆∞·ªùi d√πng b·ªè qua (ki·ªÉm tra t·ª± ƒë·ªông).")
                    update_found = False # Kh√¥ng coi l√† "t√¨m th·∫•y" ƒë·ªÉ hi·ªÉn th·ªã popup
                else:
                    # Hi·ªÉn th·ªã popup n·∫øu:
                    # 1. ƒê√¢y l√† phi√™n b·∫£n m·ªõi v√† ch∆∞a t·ª´ng b·ªã b·ªè qua (ho·∫∑c c·ªù b·ªè qua c≈© v·ª´a ƒë∆∞·ª£c x√≥a).
                    # 2. ƒê√¢y l√† ki·ªÉm tra th·ªß c√¥ng (manual=True), ngay c·∫£ khi phi√™n b·∫£n n√†y ƒë√£ b·ªã b·ªè qua tr∆∞·ªõc ƒë√≥ cho ki·ªÉm tra t·ª± ƒë·ªông.
                    update_found = True
                    current_skip_status_for_log = "Kh√¥ng"
                    if latest_ver == skipped_ver_in_cfg: # skipped_ver_in_cfg ·ªü ƒë√¢y l√† gi√° tr·ªã sau khi c√≥ th·ªÉ ƒë√£ b·ªã clear
                        current_skip_status_for_log = skipped_ver_in_cfg if skipped_ver_in_cfg else "V·ª´a x√≥a c·ªù skip c≈©"
                    
                    logging.info(f"C√≥ phi√™n b·∫£n m·ªõi: {latest_ver} > {CURRENT_VERSION}. S·∫Ω hi·ªÉn th·ªã popup (manual={manual}, skipped_for_this_ver='{current_skip_status_for_log}').")
                    
                    # G·ªçi show_update_popup tr√™n lu·ªìng ch√≠nh
                    self.after(0, lambda lv=latest_ver, cl=changelog, du=dl_url: self.show_update_popup(lv, cl, du))
                    
                    if manual: # Ch·ªâ c·∫≠p nh·∫≠t status bar ngay n·∫øu l√† manual check v√† c√≥ update
                        _update_status(f"üîî C√≥ c·∫≠p nh·∫≠t m·ªõi: v{latest_ver}!")
            
            else: # version.parse(latest_ver) <= version.parse(CURRENT_VERSION)
                update_found = False # Kh√¥ng c√≥ phi√™n b·∫£n m·ªõi h∆°n
                logging.info("·ª®ng d·ª•ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t (phi√™n b·∫£n hi·ªán t·∫°i l√† m·ªõi nh·∫•t ho·∫∑c m·ªõi h∆°n server).")
                if manual:
                    _show_info("‚úÖ ƒê√£ c·∫≠p nh·∫≠t", "B·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t.")
                    # Kh√¥ng c·∫ßn thi·∫øt ph·∫£i update status bar ·ªü ƒë√¢y n·ªØa v√¨ ƒë√£ c√≥ popup info
                    # _update_status("‚úÖ ƒêang s·ª≠ d·ª•ng phi√™n b·∫£n m·ªõi nh·∫•t.")

            # N·∫øu config thay ƒë·ªïi (v√≠ d·ª• x√≥a c·ªù skip c≈©), l√™n l·ªãch l∆∞u l·∫°i
            if config_changed_by_update_check:
                self.after(10, self.save_current_config) # G·ªçi h√†m l∆∞u config c·ªßa app ch√≠nh

        except requests.exceptions.RequestException as e:
            error_occurred = True
            logging.error(f"L·ªói m·∫°ng khi ki·ªÉm tra c·∫≠p nh·∫≠t: {e}")
            msg = "‚ö†Ô∏è L·ªói m·∫°ng khi ki·ªÉm tra c·∫≠p nh·∫≠t."
            self.after(0, self.update_status, msg) # Lu√¥n b√°o l·ªói
            if manual: _show_error("L·ªói K·∫øt n·ªëi", f"Kh√¥ng th·ªÉ ki·ªÉm tra c·∫≠p nh·∫≠t:\n{e}")
        except json.JSONDecodeError:
            error_occurred = True
            logging.error("Ph·∫£n h·ªìi JSON kh√¥ng h·ª£p l·ªá t·ª´ server c·∫≠p nh·∫≠t.")
            msg = "‚ö†Ô∏è L·ªói ƒë·ªçc th√¥ng tin c·∫≠p nh·∫≠t."
            self.after(0, self.update_status, msg) # Lu√¥n b√°o l·ªói
            if manual: _show_error("L·ªói Ph·∫£n h·ªìi", "Kh√¥ng th·ªÉ ƒë·ªçc th√¥ng tin c·∫≠p nh·∫≠t t·ª´ server.")
        except ValueError as e: # B·∫Øt l·ªói t·ª´ "Thi·∫øu 'version' ho·∫∑c 'download_url'..."
            error_occurred = True
            logging.error(f"L·ªói d·ªØ li·ªáu trong th√¥ng tin c·∫≠p nh·∫≠t: {e}")
            msg = f"‚ö†Ô∏è L·ªói d·ªØ li·ªáu c·∫≠p nh·∫≠t."
            self.after(0, self.update_status, msg) # Lu√¥n b√°o l·ªói
            if manual: _show_error("L·ªói D·ªØ li·ªáu", f"Th√¥ng tin c·∫≠p nh·∫≠t kh√¥ng ƒë·∫ßy ƒë·ªß:\n{e}")
        except Exception as e:
            error_occurred = True
            logging.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra c·∫≠p nh·∫≠t: {e}", exc_info=True)
            msg = "‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra c·∫≠p nh·∫≠t."
            self.after(0, self.update_status, msg) # Lu√¥n b√°o l·ªói
            if manual: _show_error("L·ªói Kh√¥ng x√°c ƒë·ªãnh", f"ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën:\n{e}")
        finally:
             # G·ªçi h√†m ho√†n th√†nh, truy·ªÅn th√™m c√°c c·ªù tr·∫°ng th√°i
             self.after(50, self.on_update_check_complete, manual, error_occurred, update_found)


# H√†m UI: Hi·ªÉn th·ªã popup th√¥ng b√°o c√≥ c·∫≠p nh·∫≠t m·ªõi
    def show_update_popup(self, latest_ver, changelog, download_url):
        """ Hi·ªÉn th·ªã popup th√¥ng b√°o c·∫≠p nh·∫≠t, s·ª≠a l·ªói n√∫t v√† ƒë√≥ng popup khi t·∫£i. """
        # Tr√°nh m·ªü nhi·ªÅu popup
        if hasattr(self, 'update_popup') and self.update_popup and self.update_popup.winfo_exists():
            logging.warning("Popup c·∫≠p nh·∫≠t ƒë√£ hi·ªÉn th·ªã. ƒêang focus...")
            try:
                self.update_popup.focus()
                self.update_popup.lift()
                self.update_popup.attributes("-topmost", True)
            except Exception: pass
            return

        try:
            popup = ctk.CTkToplevel(self)
            self.update_popup = popup
            popup.title("üîî C√≥ C·∫≠p nh·∫≠t M·ªõi!")
            # C√≥ th·ªÉ tƒÉng chi·ªÅu cao m·ªôt ch√∫t n·∫øu c·∫ßn th√™m kh√¥ng gian cho n√∫t l·ªõn h∆°n
            popup.geometry("460x370")
            popup.resizable(False, False)
            popup.attributes("-topmost", True)
            popup.grab_set()

            # --- CƒÉn gi·ªØa popup ---
            try:
                self.update_idletasks(); popup.update_idletasks()
                main_x, main_y = self.winfo_x(), self.winfo_y()
                main_w, main_h = self.winfo_width(), self.winfo_height()
                popup_w, popup_h = 460, 370 # S·ª≠ d·ª•ng k√≠ch th∆∞·ªõc m·ªõi n·∫øu thay ƒë·ªïi geometry
                x = main_x + (main_w // 2) - (popup_w // 2); y = main_y + (main_h // 2) - (popup_h // 2)
                popup.geometry(f"{popup_w}x{popup_h}+{x}+{y}")
            except Exception as e: logging.warning(f"Kh√¥ng th·ªÉ cƒÉn gi·ªØa popup c·∫≠p nh·∫≠t: {e}")

            # --- B·ªë c·ª•c n·ªôi dung d√πng pack ---
            main_frame = ctk.CTkFrame(popup, fg_color="transparent")
            main_frame.pack(expand=True, fill="both", padx=15, pady=15)

            # 1. Ti√™u ƒë·ªÅ Phi√™n b·∫£n m·ªõi
            title_label = ctk.CTkLabel( main_frame, text=f"‚ú® Phi√™n b·∫£n m·ªõi: v{latest_ver}", font=ctk.CTkFont(size=16, weight="bold"), text_color="#00FFC8" )
            title_label.pack(pady=(0, 15))

            # 2. Nh√£n "Chi ti·∫øt thay ƒë·ªïi"
            changelog_title_label = ctk.CTkLabel( main_frame, text="üìã Chi ti·∫øt thay ƒë·ªïi:", font=ctk.CTkFont(size=12, weight="bold"), anchor="w" )
            changelog_title_label.pack(fill="x", pady=(0, 5))

            # 3. Textbox hi·ªÉn th·ªã changelog
            textbox_container = ctk.CTkFrame(main_frame, fg_color="#282828", corner_radius=5)
            textbox_container.pack(expand=True, fill="both", pady=(0, 15))

            changelog_textbox = ctk.CTkTextbox( textbox_container, wrap="word", font=ctk.CTkFont(family="Arial", size=11), fg_color="transparent", border_width=0, text_color="#E0E0E0" )
            changelog_textbox.pack(expand=True, fill="both", padx=8, pady=8)
            processed_changelog = changelog or "Kh√¥ng c√≥ chi ti·∫øt."; processed_changelog = processed_changelog.replace("‚úîÔ∏è", "- ").replace("‚ú®", "* ")
            changelog_textbox.insert("1.0", processed_changelog); changelog_textbox.configure(state="disabled")

            # 4. Frame ch·ª©a n√∫t b·∫•m ·ªü d∆∞·ªõi c√πng
            button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
            button_frame.pack(fill="x", side="bottom", pady=(5,0)) # ƒê·ªám tr√™n nh·ªè

            # --- N√∫t b·∫•m v·ªõi Icon, Font v√† Height r√µ r√†ng ---
            button_font = ctk.CTkFont(family="Arial", size=12) 
            button_height = 40 

            # H√†m ƒë√≥ng popup an to√†n
            def on_popup_close():
                try:
                    if popup and popup.winfo_exists():
                        if popup.grab_status() != "none": popup.grab_release()
                        popup.destroy()
                    # Quan tr·ªçng: ƒê·∫∑t l·∫°i bi·∫øn ƒë·ªÉ c√≥ th·ªÉ m·ªü popup l·∫ßn sau
                    if hasattr(self, 'update_popup'):
                         self.update_popup = None
                except Exception as close_err:
                    logging.error(f"L·ªói khi ƒë√≥ng popup c·∫≠p nh·∫≠t: {close_err}")

            # H√†m cho n√∫t T·∫£i Ngay: M·ªü link v√† ƒë√≥ng popup
            def download_and_close(url_to_open):
                try:
                    webbrowser.open(url_to_open) # M·ªü tr√¨nh duy·ªát
                except Exception as wb_err:
                    logging.error(f"L·ªói m·ªü tr√¨nh duy·ªát: {wb_err}")
                    # Hi·ªán l·ªói ngay tr√™n popup n·∫øu kh√¥ng m·ªü ƒë∆∞·ª£c link
                    messagebox.showerror("L·ªói M·ªü Link", f"Kh√¥ng th·ªÉ m·ªü link t·∫£i:\n{wb_err}", parent=popup)
                # Lu√¥n g·ªçi ƒë√≥ng popup sau khi th·ª≠ m·ªü link (d√π th√†nh c√¥ng hay l·ªói)
                on_popup_close()

            # === TH√äM H√ÄM X·ª¨ L√ù CHO N√öT "B·ªé QUA PHI√äN B·∫¢N N√ÄY" ===
            def skip_this_version_action(version_to_skip):
                logging.info(f"Ng∆∞·ªùi d√πng ch·ªçn b·ªè qua c·∫≠p nh·∫≠t phi√™n b·∫£n: {version_to_skip}")
                self.cfg["skipped_specific_version"] = version_to_skip # L∆∞u phi√™n b·∫£n b·ªã b·ªè qua
                self.save_current_config() # G·ªçi h√†m l∆∞u config c·ªßa app ch√≠nh
                on_popup_close() # ƒê√≥ng popup

            # N√∫t ƒê√≥ng (b√™n ph·∫£i c√πng)
            close_button = ctk.CTkButton(
                button_frame,
                text="‚úñ ƒê√≥ng",             
                command=on_popup_close,    
                width=70,
                height=button_height,   
                font=button_font
            )
            close_button.pack(side="right", padx=(10, 0), pady=(0,5)) 

            # N√∫t T·∫£i Ngay (b√™n tr√°i n√∫t ƒê√≥ng)
            download_button = ctk.CTkButton(
                button_frame,
                text="‚¨á T·∫£i Ngay",          
                command=lambda u=download_url: download_and_close(u), # << G·ªçi h√†m download_and_close
                width=110,                  
                height=button_height,     
                font=button_font,
                fg_color="#0078D4",
                hover_color="#005A9E"
            )
            download_button.pack(side="right", padx=(0, 0), pady=(0,5)) 

            # N√∫t ƒê·ªÉ sau (Close)
            close_button = ctk.CTkButton(
                button_frame,
                text="ƒê·ªÉ sau", # C√≥ th·ªÉ ƒë·ªïi th√†nh "Nh·∫Øc t√¥i sau" ho·∫∑c "ƒê√≥ng"
                command=on_popup_close,
                width=70,
                height=button_height,
                font=button_font
            )
            close_button.pack(side="right", padx=(10, 50), pady=(0,5)) # padx=(left, right)

            # === TH√äM N√öT "B·ªé QUA B·∫¢N N√ÄY" ===
            skip_button = ctk.CTkButton(
                button_frame,
                text="B·ªè qua Update",
                command=lambda v=latest_ver: skip_this_version_action(v),
                width=110, # ƒêi·ªÅu ch·ªânh chi·ªÅu r·ªông n·∫øu c·∫ßn
                height=button_height,
                font=button_font,
                fg_color="#FFA500" # M√†u cam ho·∫∑c m·ªôt m√†u kh√°c ƒë·ªÉ ph√¢n bi·ªát
            )
            skip_button.pack(side="right", padx=(10, 0), pady=(0,5)) # S·∫Ω n·∫±m b√™n tr√°i n√∫t "ƒê·ªÉ sau"

            # --- K·∫øt th√∫c N√∫t b·∫•m ---

            popup.protocol("WM_DELETE_WINDOW", on_popup_close) # N√∫t X c·ªßa c·ª≠a s·ªï c≈©ng g·ªçi h√†m ƒë√≥ng chu·∫©n

        except Exception as e:
            logging.error(f"L·ªói hi·ªÉn th·ªã popup c·∫≠p nh·∫≠t: {e}", exc_info=True)
            # ƒê·∫£m b·∫£o ƒë√≥ng popup n·∫øu c√≥ l·ªói khi ƒëang t·∫°o
            if 'popup' in locals() and popup and popup.winfo_exists():
                 try:
                     if popup.grab_status() != "none": popup.grab_release()
                     popup.destroy()
                     if hasattr(self, 'update_popup'): self.update_popup = None
                 except Exception: pass


# H√†m h√†nh ƒë·ªông: K√≠ch ho·∫°t ki·ªÉm tra c·∫≠p nh·∫≠t th·ªß c√¥ng t·ª´ ng∆∞·ªùi d√πng
    def manual_check_update(self):
        """ K√≠ch ho·∫°t ki·ªÉm tra c·∫≠p nh·∫≠t th·ªß c√¥ng """
        if self.is_manual_update_checking: # NgƒÉn ch·∫∑n nhi·ªÅu l·∫ßn ki·ªÉm tra th·ªß c√¥ng c√πng l√∫c
            logging.info("Ki·ªÉm tra c·∫≠p nh·∫≠t th·ªß c√¥ng ƒë√£ ƒëang ch·∫°y.")
            # C√≥ th·ªÉ th√¥ng b√°o cho ng∆∞·ªùi d√πng n·∫øu mu·ªën, v√≠ d·ª•:
            # messagebox.showinfo("Th√¥ng b√°o", "ƒêang ki·ªÉm tra c·∫≠p nh·∫≠t, vui l√≤ng ƒë·ª£i...", parent=self)
            return

        self.is_manual_update_checking = True # ƒê·∫∑t c·ªù b√°o ƒëang ki·ªÉm tra th·ªß c√¥ng
        self.update_status("üîé ƒêang ki·ªÉm tra c·∫≠p nh·∫≠t th·ªß c√¥ng...") # ƒê·ªïi icon v√† text
        thread = threading.Thread(target=self.check_for_update, args=(True,), daemon=True, name="ManualUpdateCheck")
        thread.start()


# H√†m callback: ƒê∆∞·ª£c g·ªçi khi qu√° tr√¨nh ki·ªÉm tra c·∫≠p nh·∫≠t ho√†n t·∫•t
    def on_update_check_complete(self, manual, error_occurred, update_found):
        """
        ƒê∆∞·ª£c g·ªçi khi qu√° tr√¨nh ki·ªÉm tra c·∫≠p nh·∫≠t ho√†n t·∫•t (c·∫£ t·ª± ƒë·ªông v√† th·ªß c√¥ng).
        C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i m·ªôt c√°ch ph√π h·ª£p, ƒë·∫∑c bi·ªát sau khi ki·ªÉm tra th·ªß c√¥ng.
        """
        logging.info(f"Ki·ªÉm tra c·∫≠p nh·∫≠t ho√†n t·∫•t. Manual={manual}, Error={error_occurred}, UpdateFound={update_found}.")

        if not error_occurred: # Ch·ªâ c·∫≠p nh·∫≠t timestamp n·∫øu kh√¥ng c√≥ l·ªói nghi√™m tr·ªçng
            try:
                self.cfg['last_update_check_timestamp'] = int(time.time())
                self.save_current_config()
                logging.info(f"ƒê√£ c·∫≠p nh·∫≠t last_update_check_timestamp v√†o config (Error khi ki·ªÉm tra: {error_occurred}).")
            except Exception as e_save_timestamp:
                logging.error(f"L·ªói khi l∆∞u last_update_check_timestamp: {e_save_timestamp}")

        self.mark_startup_task_done('update') # Vi·ªác n√†y s·∫Ω g·ªçi check_if_fully_ready

        if manual:
            self.is_manual_update_checking = False # Reset c·ªù ·ªü ƒë√¢y

            # X√°c ƒë·ªãnh c√°c t√°c v·ª• kh√°c c√≥ ƒëang ch·∫°y kh√¥ng
            is_busy_with_other_tasks = (
                self.is_subbing or 
                self.is_downloading or 
                self.is_loading_model_for_timer or 
                self.dub_is_processing or
                self.is_creating_slideshow or
                self.is_gpt_processing_script or
                self.is_dalle_processing
            )
            
            final_manual_check_status_message = "" # Th√¥ng b√°o cu·ªëi c√πng s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t ·ªü ƒë√¢y

            if error_occurred:
                # Thanh tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t b√™n trong check_for_update v·ªõi th√¥ng b√°o l·ªói
                # Kh√¥ng c·∫ßn ƒë·∫∑t l·∫°i ·ªü ƒë√¢y n·∫øu kh√¥ng mu·ªën ghi ƒë√® th√¥ng b√°o l·ªói ƒë√≥
                logging.debug("[OnUpdateComplete-Manual] L·ªói x·∫£y ra, gi·ªØ nguy√™n status l·ªói t·ª´ check_for_update.")
            elif update_found:
                # Thanh tr·∫°ng th√°i c≈©ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t b√™n trong check_for_update v·ªõi th√¥ng b√°o c√≥ c·∫≠p nh·∫≠t
                logging.debug("[OnUpdateComplete-Manual] T√¨m th·∫•y c·∫≠p nh·∫≠t, gi·ªØ nguy√™n status t·ª´ check_for_update.")
            else: # Kh√¥ng c√≥ l·ªói, kh√¥ng t√¨m th·∫•y c·∫≠p nh·∫≠t m·ªõi
                final_manual_check_status_message = "‚úÖ B·∫°n ƒëang d√πng b·∫£n m·ªõi nh·∫•t."
            
            # Ch·ªâ c·∫≠p nh·∫≠t status bar n·∫øu c√≥ th√¥ng b√°o cu·ªëi c√πng v√† kh√¥ng c√≥ t√°c v·ª• n√†o kh√°c ƒëang b·∫≠n
            if final_manual_check_status_message and not is_busy_with_other_tasks:
                self.after(100, lambda: self.update_status(final_manual_check_status_message))
            elif not is_busy_with_other_tasks: # N·∫øu kh√¥ng b·∫≠n, v√† c≈©ng kh√¥ng c√≥ th√¥ng b√°o c·ª• th·ªÉ n√†o kh√°c
                # L√∫c n√†y, check_if_fully_ready s·∫Ω ƒë·∫£m nh·∫≠n vi·ªác ƒë·∫∑t tr·∫°ng th√°i "S·∫µn s√†ng!"
                logging.debug("[OnUpdateComplete-Manual] Manual check xong, kh√¥ng b·∫≠n, kh√¥ng c√≥ th√¥ng b√°o c·ª• th·ªÉ. ƒê·ªÉ check_if_fully_ready x·ª≠ l√Ω.")
            else: # ƒêang b·∫≠n v·ªõi t√°c v·ª• kh√°c
                logging.debug(f"[OnUpdateComplete-Manual] Manual check xong, nh∆∞ng ƒëang b·∫≠n. Kh√¥ng ghi ƒë√® status hi·ªán t·∫°i.")


        logging.debug("[OnUpdateComplete] K·∫øt th√∫c x·ª≠ l√Ω on_update_check_complete.")


# --------------------
    # 4.10 Logic C·ªët l√µi - Qu·∫£n l√Ω Kh·ªüi ƒë·ªông & T·∫Øt
# --------------------

# H√†m g·ªçi ki·ªÉm tra c·∫≠p nh·∫≠t sau 24h
    def _maybe_trigger_auto_update_check(self):
        """
        Ki·ªÉm tra v√† c√≥ th·ªÉ k√≠ch ho·∫°t ki·ªÉm tra c·∫≠p nh·∫≠t t·ª± ƒë·ªông trong n·ªÅn.
        H√†m n√†y ƒë∆∞·ª£c g·ªçi sau khi ·ª©ng d·ª•ng ƒë√£ kh·ªüi ƒë·ªông xong.
        """
        # Ghi log ƒë·ªÉ bi·∫øt h√†m ƒë∆∞·ª£c g·ªçi
        logging.info("[AutoUpdateCheck] Ki·ªÉm tra ƒëi·ªÅu ki·ªán ƒë·ªÉ ch·∫°y ki·ªÉm tra c·∫≠p nh·∫≠t t·ª± ƒë·ªông...")

        try:
            # L·∫•y th·ªùi gian ki·ªÉm tra l·∫ßn cu·ªëi t·ª´ config
            last_check_timestamp = self.cfg.get('last_update_check_timestamp', 0)
            current_timestamp = int(time.time())

            # T√≠nh to√°n xem ƒë√£ ƒë·∫øn l√∫c c·∫ßn ki·ªÉm tra hay ch∆∞a
            should_check_now = (current_timestamp - last_check_timestamp >= UPDATE_CHECK_INTERVAL_SECONDS)

            if should_check_now:
                logging.info(f"[AutoUpdateCheck] ƒê√£ ƒë·∫øn l√∫c ki·ªÉm tra c·∫≠p nh·∫≠t (L·∫ßn cu·ªëi: {datetime.fromtimestamp(last_check_timestamp).strftime('%Y-%m-%d %H:%M:%S') if last_check_timestamp > 0 else 'Ch∆∞a bao gi·ªù'}).")
                
                # B·∫Øt ƒë·∫ßu lu·ªìng ki·ªÉm tra c·∫≠p nh·∫≠t.
                # args=(False,) nghƒ©a l√† ƒë√¢y l√† ki·ªÉm tra t·ª± ƒë·ªông, s·∫Ω kh√¥ng hi·ªán popup n·∫øu kh√¥ng c√≥ g√¨ m·ªõi.
                threading.Thread(target=self.check_for_update, args=(False,), daemon=True, name="AutoUpdateCheckThread").start()
            
            else:
                # Ghi log n·∫øu ch∆∞a ƒë·∫øn l√∫c, ƒë·ªÉ ti·ªán theo d√µi
                time_remaining_hours = (UPDATE_CHECK_INTERVAL_SECONDS - (current_timestamp - last_check_timestamp)) / 3600
                logging.info(f"[AutoUpdateCheck] Ch∆∞a ƒë·∫øn l√∫c ki·ªÉm tra c·∫≠p nh·∫≠t. S·∫Ω ki·ªÉm tra l·∫°i sau kho·∫£ng {time_remaining_hours:.2f} gi·ªù n·ªØa.")

        except Exception as e:
            # Ghi l·∫°i l·ªói n·∫øu c√≥ b·∫•t k·ª≥ v·∫•n ƒë·ªÅ n√†o x·∫£y ra trong qu√° tr√¨nh n√†y
            logging.error(f"L·ªói trong _maybe_trigger_auto_update_check: {e}", exc_info=True)


# H√†m qu·∫£n l√Ω kh·ªüi ƒë·ªông: ƒê√°nh d·∫•u m·ªôt t√°c v·ª• kh·ªüi ƒë·ªông ƒë√£ ho√†n th√†nh
    def mark_startup_task_done(self, task_name):
        """ƒê√°nh d·∫•u m·ªôt t√°c v·ª• kh·ªüi ƒë·ªông ƒë√£ ho√†n th√†nh."""
        if task_name in self.startup_tasks_status:
            self.startup_tasks_status[task_name] = True
            logging.info(f"T√°c v·ª• kh·ªüi ƒë·ªông '{task_name}' ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u ho√†n th√†nh.")


# H√†m qu·∫£n l√Ω kh·ªüi ƒë·ªông: Ki·ªÉm tra xem ·ª©ng d·ª•ng ƒë√£ ho√†n to√†n s·∫µn s√†ng ch∆∞a
    def check_if_fully_ready(self):
        """
        H√†m cu·ªëi c√πng, ch·ªãu tr√°ch nhi·ªám ƒë√≥ng m√†n h√¨nh ch·ªù, hi·ªÉn th·ªã ·ª©ng d·ª•ng,
        V√Ä √ÅP D·ª§NG TR·∫†NG TH√ÅI B·∫¢N QUY·ªÄN CU·ªêI C√ôNG L√äN GIAO DI·ªÜN.
        (ƒê√É CHU·∫®N HO√Å: ch·ªâ d√πng _apply_activation_ui_state)
        """
        # N·∫øu app ƒë√£ kh·ªüi t·∫°o xong r·ªìi th√¨ kh√¥ng c·∫ßn l√†m g√¨ n·ªØa
        if not self.is_app_initializing:
            return

        logging.info(">>> H√†m check_if_fully_ready ƒë∆∞·ª£c g·ªçi ƒë·ªÉ ho√†n t·∫•t kh·ªüi ƒë·ªông.")

        # --- B·∫ÆT ƒê·∫¶U C√ÅC B∆Ø·ªöC CU·ªêI C√ôNG ---
        # 1. ƒê√°nh d·∫•u qu√° tr√¨nh kh·ªüi t·∫°o logic ƒë√£ ho√†n t·∫•t
        self.is_app_initializing = False

        # 2. ƒê√≥ng m√†n h√¨nh ch·ªù
        if hasattr(self, 'splash') and self.splash and self.splash.winfo_exists():
            try:
                self.splash.close()
            except Exception:
                pass
            self.splash = None
            logging.info(">>> M√†n h√¨nh ch·ªù ƒë√£ ƒë√≥ng.")

        # 3. √ÅP D·ª§NG TR·∫†NG TH√ÅI GIAO DI·ªÜN theo NGU·ªíN S·ª∞ TH·∫¨T
        try:
            # N·∫øu h√†m n√†y ƒë√¥i khi ch·∫°y t·ª´ thread ph·ª• v√† Tkinter k√™u ca,
            # ƒë·ªïi sang: self.after(0, self._apply_activation_ui_state); return
            self._apply_activation_ui_state()
        except Exception as e:
            logging.error("L·ªói khi √°p d·ª•ng tr·∫°ng th√°i giao di·ªán, fallback unactivated.", exc_info=True)
            self.handle_unactivated_state()

        # 4. √Åp d·ª•ng giao di·ªán t·ªëi/s√°ng theo config
        try:
            self.change_appearance_mode_event(self.cfg.get("appearance_mode", "dark"))
        except Exception:
            pass

        # 5. Hi·ªÉn th·ªã c·ª≠a s·ªï ch√≠nh c·ªßa ·ª©ng d·ª•ng
        if not self.winfo_viewable():
            self.deiconify()
            self.lift()
            self.attributes("-topmost", True)
            self.after(200, lambda: self.attributes("-topmost", False))
            self.focus_force()

        # 6. C·∫£nh b√°o n·∫øu thi·∫øu ph·ª• thu·ªôc (sau khi ƒë√£ √°p d·ª•ng tr·∫°ng th√°i k√≠ch ho·∫°t)
        if getattr(self, 'missing_dependencies_list', None):
            warning_message = (
                "‚ö†Ô∏è C√°c th√†nh ph·∫ßn sau b·ªã thi·∫øu ho·∫∑c kh√¥ng t√¨m th·∫•y:\n\n- " +
                "\n- ".join(self.missing_dependencies_list) +
                "\n\nM·ªôt s·ªë ch·ª©c nƒÉng c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông. Vui l√≤ng sao ch√©p ƒë·ªß c√°c file ƒëi k√®m."
            )
            try:
                messagebox.showwarning("Thi·∫øu Ph·ª• Thu·ªôc", warning_message, parent=self)
            except Exception:
                pass

        # 7. ƒê√°nh d·∫•u giao di·ªán ƒë√£ ho√†n t·∫•t thi·∫øt l·∫≠p
        self.initial_ui_setup_complete = True
        logging.info(">>> ·ª®NG D·ª§NG ƒê√É KH·ªûI ƒê·ªòNG HO√ÄN T·∫§T <<<")

        self.after(1000, self._maybe_refresh_google_voices_cache) # T·∫£i gi·ªçng Google sau 1 gi√¢y
        # 8. B·∫Øt ƒë·∫ßu c√°c t√°c v·ª• ch·∫°y n·ªÅn ƒë·ªãnh k·ª≥ SAU KHI app ƒë√£ ch·∫°y ·ªïn ƒë·ªãnh
        self.after(10000, self._maybe_trigger_auto_update_check)
        self.after(20000, self._maybe_trigger_periodic_license_revalidation)


# H√†m m·ªõi: B·∫Øt ƒë·∫ßu t·∫£i danh s√°ch gi·ªçng Google sau khi UI ƒë√£ s·∫µn s√†ng
    def _start_initial_google_voice_fetch(self):
        """L·∫•y key path v√† b·∫Øt ƒë·∫ßu lu·ªìng t·∫£i danh s√°ch gi·ªçng Google trong n·ªÅn."""
        key_path_for_thread = self.google_key_path_var.get()
        if key_path_for_thread and os.path.exists(key_path_for_thread):
            logging.info("Ph√°t hi·ªán c√≥ file Google Key, b·∫Øt ƒë·∫ßu t·∫£i danh s√°ch gi·ªçng ƒë·ªçc Google TTS trong n·ªÅn (sau khi kh·ªüi ƒë·ªông)...")
            threading.Thread(
                target=self._fetch_google_tts_voices_thread,
                args=(self._handle_fetched_google_voices, key_path_for_thread),
                daemon=True,
                name="InitialGoogleVoiceFetch"
            ).start()
        else:
            logging.info("Kh√¥ng c√≥ file Google Key, b·ªè qua vi·ªác t·∫£i danh s√°ch gi·ªçng ƒë·ªçc t·ª± ƒë·ªông khi kh·ªüi ƒë·ªông.")

#------------------------------
# H√†m ki·ªÉm tra b·∫£n quy·ªÅn trung t√¢m, DUY NH·∫§T.
    def _is_app_fully_activated(self) -> bool:
        """
        H√†m ki·ªÉm tra b·∫£n quy·ªÅn TRUNG T√ÇM (duy nh·∫•t):
        - Ki·ªÉm tra HWID kh·ªõp (n·∫øu c√≥ l∆∞u)
        - Ki·ªÉm tra status h·ª£p l·ªá
        - V·ªõi status c√≥ th·ªùi h·∫°n, ki·ªÉm tra expiry >= h√¥m nay
        """
        from datetime import datetime, date

        # L·∫•y & chu·∫©n ho√° d·ªØ li·ªáu
        status = (self.cfg.get("activation_status") or "").strip().upper()
        expiry_str = (self.cfg.get("expiry_date") or "").strip()

        # H·ªó tr·ª£ nhi·ªÅu t√™n key HWID ƒë·ªÉ tr√°nh l·ªách config
        stored_hwid = (
            self.cfg.get("hardware_id")
            or self.cfg.get("stored_hwid")
            or self.cfg.get("StoredHWID")
            or ""
        )
        stored_hwid = stored_hwid.strip()

        # L·∫•y HWID hi·ªán t·∫°i
        try:
            current_hwid = (self.get_hardware_id() or "").strip()
        except Exception:
            current_hwid = ""

        # 1) HWID ph·∫£i kh·ªõp (n·∫øu ƒë√£ c√≥ v√† h·ª£p l·ªá)
        if stored_hwid and stored_hwid != "UNKNOWN_HWID" and current_hwid and (stored_hwid != current_hwid):
            logging.debug(f"[License] HWID mismatch: stored={stored_hwid}, current={current_hwid}")
            return False

        # 2) Nh√≥m status: lu√¥n active vs. c·∫ßn h·∫°n d√πng
        ALWAYS_ACTIVE = {"LIFETIME", "ACTIVE", "ACTIVE_TEST"}
        NEED_EXPIRY  = {"TRIAL", "MONTHLY", "3_MONTH"}

        # Lu√¥n active (kh√¥ng c·∫ßn ng√†y h·∫øt h·∫°n)
        if status in ALWAYS_ACTIVE:
            return True

        # C√°c status c·∫ßn ng√†y h·∫øt h·∫°n c√≤n h·ª£p l·ªá
        if status in NEED_EXPIRY:
            if not expiry_str:
                logging.debug("[License] Thi·∫øu expiry_date cho g√≥i c√≥ th·ªùi h·∫°n.")
                return False
            try:
                # ∆Øu ti√™n ƒë·ªãnh d·∫°ng ISO "YYYY-MM-DD"
                exp_date = datetime.strptime(expiry_str, "%Y-%m-%d").date()
            except Exception:
                # Th·ª≠ ISO linh ho·∫°t (n·∫øu c√≥ th·ªùi gian k√®m theo)
                try:
                    exp_date = date.fromisoformat(expiry_str)
                except Exception:
                    logging.debug(f"[License] ƒê·ªãnh d·∫°ng expiry_date kh√¥ng h·ª£p l·ªá: {expiry_str!r}")
                    return False
            return exp_date >= date.today()

        # 3) M·ªçi tr·∫°ng th√°i kh√°c (INACTIVE, NOT_FOUND, EXPIRED, r·ªóng, None, ...) = kh√¥ng k√≠ch ho·∫°t
        return False


    def _apply_activation_ui_state(self):
        """ƒê·ªìng b·ªô to√†n b·ªô UI theo tr·∫°ng th√°i k√≠ch ho·∫°t th·ª±c s·ª±."""
        try:
            is_active = self._is_app_fully_activated()
        except Exception:
            is_active = False

        self.final_activation_state = 'activated' if is_active else 'unactivated'

        if is_active:
            # Kh√¥ng c·∫ßn show popup/tr·∫°ng th√°i d√†i d√≤ng ·ªü ƒë√¢y
            return self.handle_activated_state(show_detailed_status=False)
        else:
            return self.handle_unactivated_state()


# H√†m ti·ªán √≠ch UI: C·∫≠p nh·∫≠t giao di·ªán cho tr·∫°ng th√°i ch∆∞a k√≠ch ho·∫°t/h·∫øt h·∫°n
    def handle_unactivated_state(self):
        """ C·∫≠p nh·∫≠t UI cho tr·∫°ng th√°i ch∆∞a k√≠ch ho·∫°t/h·∫øt h·∫°n """
        logging.warning("ƒêang x·ª≠ l√Ω UI cho tr·∫°ng th√°i ch∆∞a k√≠ch ho·∫°t.")
        unactivated_state = "disabled"
        unactivated_text_short = "üîí K√≠ch ho·∫°t"

        # --- Tab Ph·ª• ƒê·ªÅ & Thuy·∫øt Minh (Logic n√†y ƒë√£ ƒë√∫ng) ---
        if hasattr(self, '_set_subtitle_tab_ui_state'):
            self._set_subtitle_tab_ui_state(subbing_active=False)
        if hasattr(self, '_set_dubbing_tab_ui_state'):
            self._set_dubbing_tab_ui_state()
        
        if hasattr(self, 'download_view_frame') and self.download_view_frame:
            self.download_view_frame.set_download_ui_state(downloading=False)
        
        # Logic t∆∞·ªùng minh ƒë·ªÉ thay ƒë·ªïi text c·ªßa c√°c n√∫t ch√≠nh
        unactivated_text_main_download = "üîí K√≠ch ho·∫°t (T·∫£i)"
        unactivated_text_all_button = "üîí K√≠ch ho·∫°t (ALL)"
        unactivated_text_sheet_button = "üîí K√≠ch ho·∫°t (Sheet)"
        
        download_buttons_to_lock = {
            getattr(self, 'download_start_button', None): unactivated_text_main_download,
            getattr(self, 'all_button', None): unactivated_text_all_button,
            getattr(self, 'add_sheet_button', None): unactivated_text_sheet_button,
        }
        for btn, text in download_buttons_to_lock.items():
            if btn and hasattr(btn, 'configure') and btn.winfo_exists():
                btn.configure(state=unactivated_state, text=text)

        # Kh√≥a √¥ nh·∫≠p li·ªáu v√† ch√®n th√¥ng b√°o
        download_tab_textbox = getattr(self.download_view_frame, 'download_url_text', None)
        if download_tab_textbox and download_tab_textbox.winfo_exists():
            try:
                download_tab_textbox.configure(state="normal")
                download_tab_textbox.delete("1.0", "end")
                download_tab_textbox.insert("1.0", self.download_url_placeholder)
                download_tab_textbox.configure(state="disabled")
            except Exception: pass

        # --- Tab Upload YouTube ---
        if hasattr(self, '_update_youtube_ui_state'):
            self._update_youtube_ui_state(is_uploading=False)

        # --- Tab AI Bi√™n T·∫≠p (S·ª≠a l·∫°i ƒë·ªÉ thay ƒë·ªïi c·∫£ text) ---
        ai_editor_tab = getattr(self, 'ai_editor_view_frame', None)
        if ai_editor_tab and isinstance(ai_editor_tab, AIEditorTab):
            logging.info("Kh√≥a giao di·ªán cho Tab AI Bi√™n T·∫≠p...")
            
            # V√¥ hi·ªáu h√≥a v√† ƒë·ªïi text c√°c n√∫t ch√≠nh
            ai_editor_tab.start_button.configure(state=unactivated_state, text="üîí K√≠ch ho·∫°t (Bi√™n t·∫≠p)")
            ai_editor_tab.add_files_button.configure(state=unactivated_state, text="üîí K√≠ch ho·∫°t")
            ai_editor_tab.edit_prompt_button.configure(state=unactivated_state, text="üîí K√≠ch ho·∫°t")
            
            # Kh√≥a √¥ nh·∫≠p li·ªáu ch√≠nh v√† hi·ªÉn th·ªã th√¥ng b√°o
            ai_editor_tab.content_textbox.configure(state="normal")
            ai_editor_tab.content_textbox.delete("1.0", "end")
            ai_editor_tab.content_textbox.insert("1.0", "Vui l√≤ng k√≠ch ho·∫°t ƒë·ªÉ s·ª≠ d·ª•ng tr√¨nh bi√™n t·∫≠p AI.")
            ai_editor_tab.content_textbox.configure(state="disabled")
            
            # V√¥ hi·ªáu h√≥a c√°c t√πy ch·ªçn kh√°c
            ai_editor_tab.rename_checkbox.configure(state=unactivated_state)
            ai_editor_tab.auto_naming_checkbox.configure(state=unactivated_state)
            ai_editor_tab.chain_enabled_checkbox.configure(state=unactivated_state)
            ai_editor_tab._toggle_rename_entry()
            ai_editor_tab._toggle_naming_options()
            ai_editor_tab._toggle_production_chain_widgets()
            ai_editor_tab.status_label_aie.configure(text="‚õî AI Bi√™n T·∫≠p: Y√™u c·∫ßu k√≠ch ho·∫°t b·∫£n quy·ªÅn.")

        # --- C·∫≠p nh·∫≠t chung ---
        self.title(f"{APP_NAME} - (Ch∆∞a K√≠ch ho·∫°t)")
        self.update_status("‚õî Y√™u c·∫ßu K√≠ch ho·∫°t")
        

# H√†m ti·ªán √≠ch UI: C·∫≠p nh·∫≠t giao di·ªán cho tr·∫°ng th√°i ƒë√£ k√≠ch ho·∫°t
    def handle_activated_state(self, show_detailed_status=False):
        """ C·∫≠p nh·∫≠t UI cho tr·∫°ng th√°i ƒë√£ k√≠ch ho·∫°t """

        # Phanh an to√†n: ch·ªâ cho ph√©p khi TH·ª∞C S·ª∞ c√≤n h·∫°n
        if not self._is_app_fully_activated():
            logging.warning("handle_activated_state ƒë∆∞·ª£c g·ªçi khi license kh√¥ng h·ª£p l·ªá ‚Üí fallback unactivated.")
            return self.handle_unactivated_state()
        
        logging.info("ƒêang x·ª≠ l√Ω UI cho tr·∫°ng th√°i ƒë√£ k√≠ch ho·∫°t.")
        activated_state = "normal"

        # --- Tab Ph·ª• ƒê·ªÅ (Logic g·ªëc ƒë√£ ƒë√∫ng) ---
        if hasattr(self, '_set_subtitle_tab_ui_state'):
            self._set_subtitle_tab_ui_state(subbing_active=False)

        # --- Tab T·∫£i Xu·ªëng (S·ª≠a l·∫°i ƒë·ªÉ kh√¥i ph·ª•c text) ---
        if hasattr(self, 'download_view_frame') and self.download_view_frame:
            self.download_view_frame.set_download_ui_state(downloading=False)
        
        # Logic t∆∞·ªùng minh ƒë·ªÉ kh√¥i ph·ª•c text c·ªßa c√°c n√∫t ch√≠nh
        download_buttons_to_restore = {
            getattr(self, 'download_start_button', None): "‚úÖ B·∫Øt ƒë·∫ßu T·∫£i (Ch·ªâ T·∫£i)",
            getattr(self, 'all_button', None): "üöÄ ALL (D/S/D)",
            getattr(self, 'add_sheet_button', None): "üìë Th√™m t·ª´ Sheet"
        }
        for btn, text in download_buttons_to_restore.items():
            if btn and hasattr(btn, 'configure') and btn.winfo_exists():
                btn.configure(state=activated_state, text=text)

        # Kh√¥i ph·ª•c √¥ nh·∫≠p li·ªáu
        download_tab_textbox = getattr(self.download_view_frame, 'download_url_text', None)
        if download_tab_textbox and download_tab_textbox.winfo_exists():
            try:
                current_text = download_tab_textbox.get("1.0", "end-1c")
                # Ch·ªâ x√≥a n·∫øu n·ªôi dung l√† th√¥ng b√°o placeholder
                if self.download_url_placeholder in current_text:
                    download_tab_textbox.delete("1.0", "end")
            except Exception: pass

        # --- Tab Thuy·∫øt Minh (Logic g·ªëc ƒë√£ ƒë√∫ng) ---
        if hasattr(self, '_set_dubbing_tab_ui_state'):
            self._set_dubbing_tab_ui_state()            
        
        # --- Tab Upload YouTube (B·ªï sung) ---
        if hasattr(self, '_update_youtube_ui_state'):
            self._update_youtube_ui_state(is_uploading=False)
            logging.info("ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i UI cho tab Upload YT (activated).")

        # --- Tab AI Bi√™n T·∫≠p (B·ªï sung) ---
        ai_editor_tab = getattr(self, 'ai_editor_view_frame', None)
        if ai_editor_tab and isinstance(ai_editor_tab, AIEditorTab):
            logging.info("M·ªü kh√≥a giao di·ªán cho Tab AI Bi√™n T·∫≠p...")
            ai_editor_tab.start_button.configure(state=activated_state, text="üöÄ B·∫Øt ƒë·∫ßu Bi√™n t·∫≠p H√†ng lo·∫°t")
            ai_editor_tab.add_files_button.configure(state=activated_state, text="‚ûï Th√™m Files K·ªãch b·∫£n...")
            ai_editor_tab.edit_prompt_button.configure(state=activated_state, text="‚öôÔ∏è T√πy ch·ªânh Prompt AI...")
            
            ai_editor_tab.content_textbox.configure(state="normal")
            current_ai_text = ai_editor_tab.content_textbox.get("1.0", "end-1c")
            if "Vui l√≤ng k√≠ch ho·∫°t" in current_ai_text:
                ai_editor_tab.content_textbox.delete("1.0", "end")
                
            ai_editor_tab.rename_checkbox.configure(state=activated_state)
            ai_editor_tab.auto_naming_checkbox.configure(state=activated_state)
            ai_editor_tab.chain_enabled_checkbox.configure(state=activated_state)
            ai_editor_tab._toggle_rename_entry()
            ai_editor_tab._toggle_naming_options()
            ai_editor_tab._toggle_production_chain_widgets()
            ai_editor_tab.status_label_aie.configure(text="‚úÖ AI Bi√™n T·∫≠p: S·∫µn s√†ng bi√™n t·∫≠p K·ªãch B·∫£n.")

        # --- C·∫≠p nh·∫≠t Ti√™u ƒë·ªÅ v√† Status Bar (Logic g·ªëc ƒë√£ ƒë√∫ng) ---
        status = self.cfg.get('activation_status', 'N/A')
        expiry = self.cfg.get('expiry_date')
        license_type_display = self.cfg.get('license_type', status)

        title_suffix = f" - ({license_type_display})"
        expiry_text = "H·∫øt h·∫°n: N/A"

        if license_type_display == "TRIAL":
            try:
                if expiry:
                    expiry_date_obj = datetime.strptime(expiry, "%Y-%m-%d").date()
                    days_left = (expiry_date_obj - date.today()).days
                    if days_left >= 0: 
                        title_suffix = f" - D√πng th·ª≠ (c√≤n {days_left} ng√†y)"
                        expiry_text = f"D√πng th·ª≠ h·∫øt h·∫°n: {expiry}"
                    else: 
                        title_suffix = " - D√πng th·ª≠ (ƒê√£ h·∫øt h·∫°n)"
                        expiry_text = f"D√πng th·ª≠ ƒë√£ h·∫øt h·∫°n: {expiry}"
                        self.after(10, self.handle_unactivated_state)
                        return
                else: 
                    title_suffix = " - D√πng th·ª≠ (Kh√¥ng r√µ h·∫°n)"
                    expiry_text = "D√πng th·ª≠ h·∫øt h·∫°n: Kh√¥ng x√°c ƒë·ªãnh"
            except Exception: 
                title_suffix = " - D√πng th·ª≠ (L·ªói ng√†y)"
                expiry_text = "D√πng th·ª≠ h·∫øt h·∫°n: L·ªói ƒë·ªãnh d·∫°ng"
        elif license_type_display == "LIFETIME" or license_type_display == "ACTIVE_TEST":
            title_suffix = f" - B·∫£n quy·ªÅn ({license_type_display})"
            expiry_text = "H·∫øt h·∫°n: Kh√¥ng bao gi·ªù"
        elif expiry:
             try:
                expiry_date_obj = datetime.strptime(expiry, "%Y-%m-%d").date()
                if expiry_date_obj >= date.today(): 
                    title_suffix = f" - C√≥ b·∫£n quy·ªÅn (ƒë·∫øn {expiry})"
                    expiry_text = f"H·∫øt h·∫°n: {expiry}"
                else: 
                    title_suffix = f" - C√≥ b·∫£n quy·ªÅn (ƒê√£ h·∫øt h·∫°n {expiry})"
                    expiry_text = f"ƒê√£ h·∫øt h·∫°n: {expiry}"
                    self.after(10, self.handle_unactivated_state)
                    return
             except Exception: 
                title_suffix = f" - C√≥ b·∫£n quy·ªÅn ({license_type_display})"
                expiry_text = f"H·∫øt h·∫°n: L·ªói ƒë·ªãnh d·∫°ng ({expiry})"
        
        self.title(f"{APP_NAME}{title_suffix}")

        if show_detailed_status:
            # N·∫øu ƒë∆∞·ª£c y√™u c·∫ßu, hi·ªÉn th·ªã th√¥ng b√°o chi ti·∫øt
            self.update_status(f"‚úÖ ƒê√£ k√≠ch ho·∫°t ({license_type_display}) | {expiry_text}")
            # L√™n l·ªãch ƒë·ªÉ quay v·ªÅ tr·∫°ng th√°i "S·∫µn s√†ng" sau 5 gi√¢y (5000ms)
            self.after(5000, lambda: self.update_status("‚úÖ S·∫µn s√†ng s·ª≠ d·ª•ng!"))
        else:
            # N·∫øu kh√¥ng, ch·ªâ hi·ªÉn th·ªã th√¥ng b√°o "S·∫µn s√†ng" chung
            self.update_status("‚úÖ Piu ƒë√£ s·∫µn s√†ng s·ª≠ d·ª•ng!")


#-----------------------------------
# H√†m logic: Ki·ªÉm tra ho√†n th√†nh t√°c v·ª• v√† th·ª±c hi·ªán t·∫Øt m√°y n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
    def _check_completion_and_shutdown(self):
        """
        Ki·ªÉm tra xem t·∫•t c·∫£ t√°c v·ª• ƒë√£ ho√†n th√†nh ch∆∞a v√† th·ª±c hi·ªán t·∫Øt m√°y n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu.
        PHI√äN B·∫¢N N√ÇNG C·∫§P: T·ª± ƒë·ªông l∆∞u config v√† tho√°t ·ª©ng d·ª•ng tr∆∞·ªõc khi t·∫Øt m√°y,
        ƒë·ªìng th·ªùi gi·ªØ l·∫°i c√°c logic ki·ªÉm tra stop_event v√† th√¥ng b√°o ho√†n th√†nh.
        """

        # L√≠nh g√°c: N·∫øu c·ª≠a s·ªï ch√≠nh kh√¥ng c√≤n t·ªìn t·∫°i, kh√¥ng l√†m g√¨ c·∫£.
        if self._is_shutting_down or not self.winfo_exists():
            logging.info("[_check_completion_and_shutdown] B·ªè qua v√¨ c·ª≠a s·ªï ƒë√£ ƒë√≥ng ho·∫∑c ƒëang trong qu√° tr√¨nh t·∫Øt.")
            return
        
        current_thread_name_ccs = threading.current_thread().name
        logging.info(f"[{current_thread_name_ccs}] Ki·ªÉm tra ho√†n th√†nh v√† t·∫Øt m√°y. Tr·∫°ng th√°i: "
                     f"Y√™u c·∫ßu T·∫Øt m√°y={getattr(self, 'shutdown_requested_by_task', 'N/A')}, "
                     f"ƒêang T·∫£i={self.is_downloading}, ƒêang Sub={self.is_subbing}, "
                     f"ƒêang Dub={self.dub_is_processing}, ƒêang Load Model Timer={self.is_loading_model_for_timer}, "
                     f"ƒêang T·∫°o Slideshow={self.is_creating_slideshow}, ƒêang GPT Script={self.is_gpt_processing_script}, "
                     f"ƒêang DALL-E={self.is_dalle_processing}, StopEvent Set={self.stop_event.is_set()}")

        all_timer_tasks_are_truly_stopped = not (
            self.is_downloading or
            self.is_subbing or
            self.is_loading_model_for_timer or
            self.dub_is_processing or
            self.is_creating_slideshow or
            self.is_gpt_processing_script or
            self.is_dalle_processing or
            self.is_gemini_processing or
            self.is_imagen_processing or
            self.is_ai_batch_processing or
            self.is_uploading_youtube or
            self.is_chain_handoff
        )

        is_chain_still_active = hasattr(self, 'chain_download_sub_dub_active') and self.chain_download_sub_dub_active
        can_consider_shutdown = all_timer_tasks_are_truly_stopped and not is_chain_still_active

        if all_timer_tasks_are_truly_stopped:
            if self.start_time is not None:
                logging.info(f"[{current_thread_name_ccs}] T·∫•t c·∫£ t√°c v·ª• d√πng timer ƒë√£ d·ª´ng ho√†n to√†n. ƒê·∫∑t self.start_time = None.")
                self.start_time = None
            logging.info(f"[{current_thread_name_ccs}] T·∫•t c·∫£ t√°c v·ª• timer ƒë√£ d·ª´ng.")
        else:
            # Logic ghi log c√°c t√°c v·ª• c√≤n ƒëang ch·∫°y c·ªßa b·∫°n (gi·ªØ nguy√™n)
            active_flags_detail_ccs = [
                flag_name for flag_name, flag_val in [
                    ("is_downloading", self.is_downloading),
                    ("is_subbing", self.is_subbing),
                    ("is_loading_model_for_timer", self.is_loading_model_for_timer),
                    ("dub_is_processing", self.dub_is_processing),
                    ("is_creating_slideshow", self.is_creating_slideshow),
                    ("is_gpt_processing_script", self.is_gpt_processing_script),
                    ("is_dalle_processing", self.is_dalle_processing)
                ] if flag_val
            ]
            logging.debug(f"[{current_thread_name_ccs}] V·∫´n c√≤n t√°c v·ª• d√πng timer ƒëang ch·∫°y: {', '.join(active_flags_detail_ccs)}. self.start_time kh√¥ng ƒë∆∞·ª£c reset.")

        # --- B·∫ÆT ƒê·∫¶U KH·ªêI LOGIC CH√çNH ƒê√É C·∫¨P NH·∫¨T ---
        if hasattr(self, 'shutdown_requested_by_task') and self.shutdown_requested_by_task and can_consider_shutdown:
            
            # N·∫øu ng∆∞·ªùi d√πng ƒë√£ ch·ªß ƒë·ªông nh·∫•n D·ª´ng, kh√¥ng th·ª±c hi·ªán t·∫Øt m√°y
            if self.stop_event.is_set():
                logging.info(f"[{current_thread_name_ccs}] Y√™u c·∫ßu t·∫Øt m√°y b·ªã h·ªßy do ng∆∞·ªùi d√πng ƒë√£ ch·ªß ƒë·ªông d·ª´ng t√°c v·ª•.")
                self.shutdown_requested_by_task = False
            else:
                # B·∫Øt ƒë·∫ßu chu·ªói s·ª± ki·ªán t·∫Øt m√°y
                logging.info(f"[{current_thread_name_ccs}] ƒêi·ªÅu ki·ªán t·∫Øt m√°y ƒë√£ th·ªèa m√£n. B·∫Øt ƒë·∫ßu chu·ªói s·ª± ki·ªán t·∫Øt m√°y.")
                
                # >>> THAY ƒê·ªîI QUAN TR·ªåNG NH·∫§T N·∫∞M ·ªû ƒê√ÇY <<<
                # ƒê·∫∑t c·ªù n√†y NGAY L·∫¨P T·ª®C ƒë·ªÉ ngƒÉn c√°c l·ªánh g·ªçi sau n√†y v√†o h√†m n√†y.
                self._is_shutting_down = True
                
                # Reset c·ªù ƒë·ªÉ kh√¥ng b·ªã g·ªçi l·∫°i
                self.shutdown_requested_by_task = False
                self._is_automated_quit = True
                logging.info("ƒê·∫∑t c·ªù _is_automated_quit = True v√† _is_shutting_down = True.")
            
                # <<< THAY ƒê·ªîI 1: L√™n l·ªãch v√† L∆ØU L·∫†I ID c·ªßa c√°c l·ªánh `after` >>>
                self._after_id_save_config_on_shutdown = self.after(57000, self.save_current_config)
                
                # <<< THAY ƒê·ªîI 2: G·ªçi tr·ª±c ti·∫øp h√†m _perform_full_quit thay v√¨ quit_application >>>
                self._after_id_quit_on_shutdown = self.after(60000, self._perform_full_quit)
                
                logging.info(f"ƒê√£ l√™n l·ªãch L∆ØU config (ID: {self._after_id_save_config_on_shutdown}) v√† THO√ÅT app (ID: {self._after_id_quit_on_shutdown}).")

                # B·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c 2 ph√∫t c·ªßa H·ªÜ TH·ªêNG
                self.download_view_frame.log_download("   ‚è≥ ƒêang h·∫πn gi·ªù t·∫Øt m√°y (3 ph√∫t)... ·ª®ng d·ª•ng s·∫Ω t·ª± l∆∞u v√† tho√°t tr∆∞·ªõc ƒë√≥.")
                if shutdown_system(delay_minutes=2):
                    self.after(100, self.show_shutdown_cancel_popup)
                    self.shutdown_scheduled = True
                    self.update_status("‚è∞ ƒê√£ h·∫πn gi·ªù t·∫Øt m√°y sau 3 ph√∫t...")
                else:
                    self.download_view_frame.log_download("   ‚ùå Kh√¥ng th·ªÉ h·∫πn gi·ªù t·∫Øt m√°y.")
                    self.update_status("‚ùå L·ªói h·∫πn gi·ªù t·∫Øt m√°y.")
                    self.shutdown_scheduled = False
        
        # GI·ªÆ L·∫†I LOGIC C≈®: X·ª≠ l√Ω khi kh√¥ng c√≥ y√™u c·∫ßu t·∫Øt m√°y
        elif all_timer_tasks_are_truly_stopped: 
            logging.info(f"[{current_thread_name_ccs}] T·∫•t c·∫£ t√°c v·ª• ƒë√£ d·ª´ng, kh√¥ng c√≥ y√™u c·∫ßu t·∫Øt m√°y.")

            # G·ª≠i th√¥ng b√°o ho√†n th√†nh n·∫øu kh√¥ng ph·∫£i do ng∆∞·ªùi d√πng d·ª´ng (logic c≈© c·ªßa b·∫°n)
            if not self.stop_event.is_set(): 
                logging.info(f"[{current_thread_name_ccs}] T√°c v·ª• ƒë√£ ho√†n th√†nh t·ª± nhi√™n. K√≠ch ho·∫°t th√¥ng b√°o.")
                
                if PYSTRAY_AVAILABLE and self.tray_icon and self.tray_icon.visible and self.state() == 'withdrawn':
                    try:
                        self.tray_icon.notify('Piu - T√°c v·ª• ho√†n th√†nh!', 'T·∫•t c·∫£ c√°c t√°c v·ª• ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω xong.')
                        logging.info("ƒê√£ g·ª≠i th√¥ng b√°o ho√†n th√†nh qua khay h·ªá th·ªëng.")
                    except Exception as e_notify:
                        logging.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o qua khay h·ªá th·ªëng: {e_notify}")
                
                elif sys.platform == "win32" and PYWIN32_AVAILABLE and self.state() != 'withdrawn':
                    try:
                        hwnd = self.winfo_id()
                        win32gui.FlashWindowEx(hwnd, win32con.FLASHW_ALL | win32con.FLASHW_TIMERNOFG, 5, 200)
                    except Exception as e_flash:
                        logging.warning(f"Kh√¥ng th·ªÉ l√†m nh·∫•p nh√°y c·ª≠a s·ªï: {e_flash}")



# H√†m x·ª≠ l√Ω Ch·ªâ cho ch·∫°y 1 l·∫ßn App
    if PYWIN32_AVAILABLE and sys.platform == "win32":
        def _activate_existing_window(self):
            """
            C·ªë g·∫Øng t√¨m v√† k√≠ch ho·∫°t c·ª≠a s·ªï ch√≠nh c·ªßa instance ·ª©ng d·ª•ng ƒëang ch·∫°y.
            Lo·∫°i tr·ª´ PID c·ªßa process hi·ªán t·∫°i v√† s·ª≠ d·ª•ng chu·ªói k√≠ch ho·∫°t m·∫°nh m·∫Ω h∆°n.
            """
            # C√°c import c·∫ßn thi·∫øt cho h√†m n√†y
            import win32gui
            import win32con
            import win32process
            import os
            import time # Th√™m import time cho time.sleep

            target_window_title_keyword = APP_NAME # APP_NAME l√† h·∫±ng s·ªë to√†n c·ª•c
            found_hwnd = None
            current_pid = os.getpid() # L·∫•y PID c·ªßa instance hi·ªán t·∫°i (th·ª© hai)

            logging.debug(f"_activate_existing_window: B·∫Øt ƒë·∫ßu t√¨m c·ª≠a s·ªï v·ªõi t·ª´ kh√≥a ti√™u ƒë·ªÅ: '{target_window_title_keyword}', Current PID: {current_pid}")

            def enum_windows_callback(hwnd, lParam):
                nonlocal found_hwnd
                try:
                    # Kh√¥ng ki·ªÉm tra IsWindowVisible ·ªü ƒë√¢y ƒë·ªÉ t√¨m c·∫£ c·ª≠a s·ªï ƒë√£ withdraw
                    window_title = win32gui.GetWindowText(hwnd)
                    
                    # L·∫•y Process ID c·ªßa c·ª≠a s·ªï ƒëang duy·ªát
                    _, window_pid = win32process.GetWindowThreadProcessId(hwnd)

                    if target_window_title_keyword in window_title and window_pid != current_pid:
                        if win32gui.GetParent(hwnd) == 0: # ƒê·∫£m b·∫£o l√† c·ª≠a s·ªï top-level
                            className = win32gui.GetClassName(hwnd)
                            logging.debug(f"_activate_existing_window: T√¨m th·∫•y ·ª©ng vi√™n - HWND: {hwnd}, Ti√™u ƒë·ªÅ: '{window_title}', Class: '{className}', PID: {window_pid}")
                            
                            # ∆Øu ti√™n c·ª≠a s·ªï c√≥ class Tkinter n·∫øu c√≥ nhi·ªÅu c·ª≠a s·ªï tr√πng t√™n v√† PID
                            if "TkTopLevel" in className or "CTK" in className or "Tk" == className :
                                found_hwnd = hwnd
                                logging.info(f"_activate_existing_window: ƒê√£ ch·ªçn HWND (Tkinter/CTK class): {hwnd}")
                                return False # D·ª´ng EnumWindows, ƒë√£ t√¨m th·∫•y ·ª©ng vi√™n t·ªët nh·∫•t
                            elif not found_hwnd: # N·∫øu ch∆∞a t√¨m th·∫•y c·ª≠a s·ªï Tkinter n√†o, t·∫°m l·∫•y c·ª≠a s·ªï n√†y
                                found_hwnd = hwnd
                                logging.info(f"_activate_existing_window: T·∫°m ch·ªçn HWND (class kh√°c): {hwnd}. Ti·∫øp t·ª•c t√¨m ki·∫øm ·ª©ng vi√™n t·ªët h∆°n.")
                                # Kh√¥ng return False ·ªü ƒë√¢y, ti·∫øp t·ª•c t√¨m ki·∫øm n·∫øu c√≥ c·ª≠a s·ªï Tkinter/CTK ph√π h·ª£p h∆°n
                except Exception as e_enum_item:
                    logging.debug(f"_activate_existing_window: L·ªói khi x·ª≠ l√Ω m·ªôt c·ª≠a s·ªï (HWND {hwnd}) trong EnumWindows: {e_enum_item}")
                return True # Ti·∫øp t·ª•c EnumWindows

            try:
                win32gui.EnumWindows(enum_windows_callback, None)
            except Exception as e_enum_call:
                logging.error(f"L·ªói trong qu√° tr√¨nh g·ªçi EnumWindows: {e_enum_call}")
                return False

            if found_hwnd:
                try:
                    logging.info(f"_activate_existing_window: ƒê√£ t√¨m th·∫•y HWND m·ª•c ti√™u: {found_hwnd}. Th·ª±c hi·ªán c√°c b∆∞·ªõc k√≠ch ho·∫°t.")
                    
                    placement = win32gui.GetWindowPlacement(found_hwnd)
                    logging.debug(f"_activate_existing_window: Placement cho HWND {found_hwnd}: {placement}")

                    if placement[1] == win32con.SW_SHOWMINIMIZED:
                        logging.debug(f"_activate_existing_window: HWND {found_hwnd} ƒëang minimized, th·ª±c hi·ªán SW_RESTORE.")
                        win32gui.ShowWindow(found_hwnd, win32con.SW_RESTORE)
                    else:
                        logging.debug(f"_activate_existing_window: HWND {found_hwnd} kh√¥ng minimized (showCmd={placement[1]}), th·ª±c hi·ªán SW_SHOWNORMAL.")
                        win32gui.ShowWindow(found_hwnd, win32con.SW_SHOWNORMAL)
                    
                    time.sleep(0.1) 

                    logging.debug(f"_activate_existing_window: Th·ª±c hi·ªán SetForegroundWindow cho HWND {found_hwnd}.")
                    win32gui.SetForegroundWindow(found_hwnd)
                    time.sleep(0.05) 

                    win32gui.BringWindowToTop(found_hwnd)
                    logging.debug(f"_activate_existing_window: Th·ª±c hi·ªán BringWindowToTop cho HWND {found_hwnd}.")
                    
                    win32gui.FlashWindow(found_hwnd, True) 
                    
                    logging.info(f"ƒê√£ ho√†n t·∫•t c√°c l·ªánh k√≠ch ho·∫°t cho c·ª≠a s·ªï (HWND: {found_hwnd}).")
                    return True
                except Exception as e_activate:
                    logging.error(f"L·ªói khi c·ªë g·∫Øng k√≠ch ho·∫°t c·ª≠a s·ªï (HWND: {found_hwnd}): {e_activate}", exc_info=True)
                    return False
            else:
                logging.info(f"Kh√¥ng t√¨m th·∫•y c·ª≠a s·ªï c·ªßa instance {APP_NAME} (kh√°c PID hi·ªán t·∫°i) ƒëang ch·∫°y ƒë·ªÉ k√≠ch ho·∫°t.")
                return False
            return False


# H√†m s·ª± ki·ªán: X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n n√∫t X c·ªßa c·ª≠a s·ªï ho·∫∑c nh·∫≠n s·ª± ki·ªán QuitApp t·ª´ khay
    def on_close(self, from_event=False):
        """
        (PHI√äN B·∫¢N C·∫¨P NH·∫¨T 5 - GI·∫¢I PH√ÅP CU·ªêI C√ôNG)
        S·ª≠ d·ª•ng tkinter.Toplevel g·ªëc ƒë·ªÉ ƒë·∫£m b·∫£o icon hi·ªÉn th·ªã ·ªïn ƒë·ªãnh.
        """
        global PYSTRAY_AVAILABLE
        logging.info(f"Y√™u c·∫ßu ƒê√≥ng/·∫®n. C·ªù ƒêang Tho√°t: {self._is_quitting}, Pystray C√≥ s·∫µn: {PYSTRAY_AVAILABLE}, T·ª´ S·ª± ki·ªán: {from_event}")

        if self._is_quitting:
            self._perform_full_quit()
            return

        if not PYSTRAY_AVAILABLE:
            if messagebox.askyesno("X√°c nh·∫≠n tho√°t", "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën tho√°t ·ª©ng d·ª•ng Piu kh√¥ng?", parent=self):
                self._perform_full_quit()
            return

        # S·ª≠ d·ª•ng tkinter.Toplevel thay v√¨ ctk.CTkToplevel >>>
        import tkinter as tk # C·∫ßn import tkinter
        popup = tk.Toplevel(self)
        popup.configure(bg=self._apply_appearance_mode(ctk.ThemeManager.theme["CTkFrame"]["fg_color"])) # L·∫•y m√†u n·ªÅn c·ªßa theme

        popup.title("N√∫t X ƒë√£ ƒë∆∞·ª£c nh·∫•n...!")
        popup.iconbitmap(resource_path("logo_Piu.ico")) # Icon s·∫Ω ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh
        popup.transient(self)
        popup.grab_set()
        popup.resizable(False, False)

        try:
            self.update_idletasks()
            popup_width = 350
            popup_height = 145
            x = self.winfo_x() + (self.winfo_width() // 2) - (popup_width // 2)
            y = self.winfo_y() + (self.winfo_height() // 2) - (popup_height // 2)
            popup.geometry(f"{popup_width}x{popup_height}+{x}+{y}")
        except Exception as e:
            logging.warning(f"Kh√¥ng th·ªÉ cƒÉn gi·ªØa popup x√°c nh·∫≠n ƒë√≥ng: {e}")

        # --- N·ªôi dung c·ªßa popup (v·∫´n d√πng widget c·ªßa customtkinter) ---
        main_frame = ctk.CTkFrame(popup, fg_color="transparent")
        main_frame.pack(expand=True, fill="both", padx=20, pady=20)

        ctk.CTkLabel(main_frame, text="B·∫°n mu·ªën tho√°t ·ª©ng d·ª•ng! \nHay ch·ªâ ·∫©n v√†o khay h·ªá th·ªëng?",
                     wraplength=310, font=("Segoe UI", 13)).pack(pady=(0, 20))

        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(fill="x")
        button_frame.grid_columnconfigure((0, 1), weight=1)

        def action_exit():
            popup.destroy()
            self.quit_application()

        def action_hide():
            popup.destroy()
            self.withdraw()

        def action_cancel():
            popup.destroy()

        btn_exit = ctk.CTkButton(button_frame, text="Tho√°t ·ª©ng d·ª•ng",
                                  fg_color="#E53935", hover_color="#C62828",
                                  command=action_exit)
        btn_exit.grid(row=0, column=0, padx=(0, 5), sticky="ew")

        btn_hide = ctk.CTkButton(button_frame, text="·∫®n v√†o khay",
                                   command=action_hide)
        btn_hide.grid(row=0, column=1, padx=(5, 0), sticky="ew")
        
        popup.protocol("WM_DELETE_WINDOW", action_cancel)


# H√†m logic n·ªôi b·ªô: Th·ª±c hi·ªán tu·∫ßn t·ª± c√°c b∆∞·ªõc ƒë·ªÉ ƒë√≥ng ·ª©ng d·ª•ng ho√†n to√†n
    def _perform_full_quit(self):
        """ Th·ª±c hi·ªán tu·∫ßn t·ª± c√°c b∆∞·ªõc ƒë·ªÉ ƒë√≥ng ·ª©ng d·ª•ng ho√†n to√†n """
        
        self._is_shutting_down = True
        logging.info("B·∫Øt ƒë·∫ßu tr√¨nh t·ª± tho√°t ho√†n to√†n...")

        # 1. G·ª≠i t√≠n hi·ªáu d·ª´ng cho c√°c t√°c v·ª• n·ªÅn (n·∫øu ƒëang ch·∫°y)
        if self.is_subbing or self.is_downloading:
             self.stop_event.set()
             logging.info("ƒê√£ ƒë·∫∑t c·ªù d·ª´ng cho c√°c t√°c v·ª• n·ªÅn.")

        # 2. X·ª≠ l√Ω h·ªßy h·∫πn gi·ªù t·∫Øt m√°y (N·∫æU ƒê√É ƒê∆Ø·ª¢C H·∫∏N)
        try:
            if hasattr(self, 'shutdown_scheduled') and self.shutdown_scheduled and not self._is_automated_quit:
                 logging.info("ƒê√£ h·∫πn gi·ªù t·∫Øt m√°y tr∆∞·ªõc ƒë√≥, h·ªèi ng∆∞·ªùi d√πng h·ªßy...")
                 if messagebox.askyesno("H·ªßy t·∫Øt m√°y?",
                                        "H·ªá th·ªëng ƒë√£ ƒë∆∞·ª£c h·∫πn gi·ªù t·∫Øt m√°y.\nB·∫°n c√≥ mu·ªën h·ªßy l·ªánh n√†y tr∆∞·ªõc khi tho√°t?",
                                        icon='question', parent=self):
                     logging.info("Ng∆∞·ªùi d√πng ch·ªçn h·ªßy h·∫πn gi·ªù t·∫Øt m√°y khi ƒë√≥ng.")
                     if cancel_shutdown_system():
                         self.shutdown_scheduled = False
                         logging.info("ƒê√£ h·ªßy th√†nh c√¥ng h·∫πn gi·ªù t·∫Øt m√°y khi ƒë√≥ng.")
                     else:
                         messagebox.showwarning("L·ªói/Kh√¥ng c·∫ßn", "Kh√¥ng th·ªÉ h·ªßy l·ªánh t·∫Øt m√°y ho·∫∑c kh√¥ng c√≥ l·ªánh n√†o ƒëang ch·ªù.", parent=self)
                         logging.warning("L·ªói h·ªßy h·∫πn gi·ªù t·∫Øt m√°y khi ƒë√≥ng (ho·∫∑c kh√¥ng c√≥ l·ªánh n√†o).")
                 else:
                      logging.info("Ng∆∞·ªùi d√πng ch·ªçn KH√îNG h·ªßy h·∫πn gi·ªù t·∫Øt m√°y khi ƒë√≥ng.")
            else:
                 logging.info("Ch∆∞a h·∫πn gi·ªù t·∫Øt m√°y, kh√¥ng c·∫ßn h·ªèi h·ªßy khi ƒë√≥ng.")
        except Exception as e:
             logging.error(f"L·ªói trong qu√° tr√¨nh ki·ªÉm tra h·ªßy t·∫Øt m√°y khi ƒë√≥ng: {e}", exc_info=True)

        # 3. D·ª´ng icon tr√™n khay h·ªá th·ªëng (n·∫øu c√≥)
        if hasattr(self, 'tray_icon') and self.tray_icon and self.tray_icon.visible:
            try:
                logging.info("ƒêang d·ª´ng icon khay h·ªá th·ªëng...")
                self.tray_icon.stop()
            except Exception as e: logging.error(f"L·ªói d·ª´ng icon khay h·ªá th·ªëng: {e}")

        # === TH√äM LOGIC GI·∫¢I PH√ìNG MUTEX ·ªû ƒê√ÇY ===
        if sys.platform == "win32" and PYWIN32_AVAILABLE and hasattr(self, 'mutex') and self.mutex:
            try:
                logging.debug(f"Chu·∫©n b·ªã gi·∫£i ph√≥ng Mutex handle: {self.mutex} t·ª´ _perform_full_quit.")
                win32api.CloseHandle(self.mutex)
                self.mutex = None
                logging.info("ƒê√£ gi·∫£i ph√≥ng Mutex (Windows) th√†nh c√¥ng khi ƒë√≥ng ·ª©ng d·ª•ng.")
            except Exception as e_release_mutex_on_quit:
                logging.error(f"L·ªói khi gi·∫£i ph√≥ng Mutex (Windows) l√∫c tho√°t: {e_release_mutex_on_quit}")

        # 4. L∆∞u c·∫•u h√¨nh l·∫ßn cu·ªëi
        try:
            logging.info("ƒêang l∆∞u c·∫•u h√¨nh khi ƒë√≥ng...")
            self.save_current_config()
        except Exception as e: logging.error(f"L·ªói l∆∞u config khi ƒë√≥ng: {e}")

        # 5. D·ªçn d·∫πp th∆∞ m·ª•c t·∫°m
        try:
            if hasattr(self, '_temp_dir_context'):
                self._temp_dir_context.cleanup()
                logging.info("ƒê√£ d·ªçn d·∫πp th∆∞ m·ª•c t·∫°m.")
        except Exception as e: logging.error(f"L·ªói d·ªçn d·∫πp th∆∞ m·ª•c t·∫°m: {e}")

        # 6. ƒê√≥ng c·ª≠a s·ªï ch√≠nh (an to√†n qua self.after)
        logging.info("L√™n l·ªãch h·ªßy c·ª≠a s·ªï ƒë·ªÉ tho√°t ho√†n to√†n.")
        self.after(100, self.destroy) # Ch·ªù nh·∫π ƒë·ªÉ c√°c t√°c v·ª• kh√°c ho√†n t·∫•t

    # --------------------
    # 4.10.x K√≠ch ho·∫°t c·ª≠a s·ªï instance ƒëang ch·∫°y (Windows)
    # --------------------
    def _activate_existing_window(self) -> bool:
        """Th·ª≠ ƒë∆∞a c·ª≠a s·ªï instance ƒëang ch·∫°y l√™n tr∆∞·ªõc (Windows)."""
        if sys.platform != "win32":
            return False
        try:
            import win32gui
            import win32con
            import win32process
            import os
            import time

            target_window_title_keyword = APP_NAME
            found_hwnd = None
            current_pid = os.getpid()

            def enum_windows_callback(hwnd, lParam):
                nonlocal found_hwnd
                try:
                    window_title = win32gui.GetWindowText(hwnd)
                    _, window_pid = win32process.GetWindowThreadProcessId(hwnd)
                    if target_window_title_keyword in window_title and window_pid != current_pid:
                        if win32gui.GetParent(hwnd) == 0:
                            class_name = win32gui.GetClassName(hwnd)
                            if ("TkTopLevel" in class_name) or ("CTK" in class_name) or (class_name == "Tk"):
                                found_hwnd = hwnd
                                return False
                            elif not found_hwnd:
                                found_hwnd = hwnd
                except Exception:
                    pass
                return True

            try:
                win32gui.EnumWindows(enum_windows_callback, None)
            except Exception as e_enum_call:
                logging.error(f"L·ªói trong qu√° tr√¨nh g·ªçi EnumWindows: {e_enum_call}")
                return False

            if found_hwnd:
                try:
                    placement = win32gui.GetWindowPlacement(found_hwnd)
                    if placement[1] == win32con.SW_SHOWMINIMIZED:
                        win32gui.ShowWindow(found_hwnd, win32con.SW_RESTORE)
                    else:
                        win32gui.ShowWindow(found_hwnd, win32con.SW_SHOWNORMAL)

                    # Cho ph√©p foreground t·ª´ b·∫•t k·ª≥ ti·∫øn tr√¨nh n√†o (ASFW_ANY = -1)
                    try:
                        import ctypes
                        ctypes.windll.user32.AllowSetForegroundWindow(ctypes.c_int(-1))
                    except Exception:
                        pass

                    # G·∫Øn lu·ªìng ƒë·ªÉ n√¢ng quy·ªÅn focus
                    try:
                        current_thread_id = win32api.GetCurrentThreadId()
                        target_thread_id, _ = win32process.GetWindowThreadProcessId(found_hwnd)
                        win32process.AttachThreadInput(current_thread_id, target_thread_id, True)
                    except Exception:
                        current_thread_id = None
                        target_thread_id = None

                    # Toggle topmost ƒë·ªÉ v∆∞·ª£t h·∫°n ch·∫ø focus
                    SWP_FLAGS = win32con.SWP_NOMOVE | win32con.SWP_NOSIZE | win32con.SWP_SHOWWINDOW
                    try:
                        win32gui.SetWindowPos(found_hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0, SWP_FLAGS)
                        time.sleep(0.05)
                        win32gui.SetWindowPos(found_hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0, SWP_FLAGS)
                    except Exception:
                        pass

                    # Th·ª© t·ª± g·ªçi t·ªëi ∆∞u
                    try:
                        win32gui.BringWindowToTop(found_hwnd)
                    except Exception:
                        pass
                    try:
                        win32gui.SetForegroundWindow(found_hwnd)
                    except Exception:
                        pass
                    try:
                        win32gui.SetActiveWindow(found_hwnd)
                    except Exception:
                        pass

                    # Th√°o g·∫Øn lu·ªìng n·∫øu ƒë√£ g·∫Øn
                    try:
                        if current_thread_id and target_thread_id:
                            win32process.AttachThreadInput(current_thread_id, target_thread_id, False)
                    except Exception:
                        pass

                    # Nh√°y ƒë·ªÉ thu h√∫t ch√∫ √Ω n·∫øu v·∫´n ·ªü n·ªÅn
                    try:
                        win32gui.FlashWindow(found_hwnd, True)
                    except Exception:
                        pass

                    logging.info("ƒê√£ k√≠ch ho·∫°t c·ª≠a s·ªï instance ƒëang ch·∫°y (BringToFront).")
                    return True
                except Exception as e_activate:
                    logging.error(f"L·ªói khi c·ªë g·∫Øng k√≠ch ho·∫°t c·ª≠a s·ªï: {e_activate}", exc_info=True)
                    return False
            else:
                logging.info(f"Kh√¥ng t√¨m th·∫•y c·ª≠a s·ªï c·ªßa instance {APP_NAME} (kh√°c PID hi·ªán t·∫°i) ƒëang ch·∫°y ƒë·ªÉ k√≠ch ho·∫°t.")
                return False
        except Exception as e:
            logging.error(f"Kh√¥ng th·ªÉ k√≠ch ho·∫°t c·ª≠a s·ªï instance ƒëang ch·∫°y: {e}", exc_info=True)
            return False

    # --------------------
    # 4.11 Logic C·ªët l√µi - Qu·∫£n l√Ω Khay h·ªá th·ªëng
    # --------------------

    # H√†m ti·ªán √≠ch: Thi·∫øt l·∫≠p v√† ch·∫°y icon tr√™n khay h·ªá th·ªëng
    def setup_tray_icon(self):
        """ Thi·∫øt l·∫≠p v√† ch·∫°y icon khay h·ªá th·ªëng trong m·ªôt thread """
        global PYSTRAY_AVAILABLE
        if not PYSTRAY_AVAILABLE: return
        try:
            icon_path = resource_path("logo_Piu.ico")
            if not os.path.exists(icon_path): raise FileNotFoundError(f"Kh√¥ng t√¨m th·∫•y icon khay: {icon_path}")
            image = Image.open(icon_path)
            menu = pystray.Menu(
                pystray.MenuItem('Hi·ªán App', self.show_window, default=True),
                pystray.Menu.SEPARATOR,
                pystray.MenuItem('Tho√°t', self.quit_application)
            )
            self.tray_icon = pystray.Icon("Piu", image, "Piu", menu)
            self.tray_thread = threading.Thread(target=self.tray_icon.run, daemon=True, name="PystrayThread")
            self.tray_thread.start()
            logging.info("ƒê√£ b·∫Øt ƒë·∫ßu thread icon khay h·ªá th·ªëng.")
        except Exception as e:
            logging.error(f"L·ªói thi·∫øt l·∫≠p icon khay h·ªá th·ªëng: {e}", exc_info=True)
            self.tray_icon = None


    # H√†m h√†nh ƒë·ªông: Hi·ªÉn th·ªã l·∫°i c·ª≠a s·ªï ·ª©ng d·ª•ng t·ª´ khay h·ªá th·ªëng
    def show_window(self):
        """
        MODIFIED: Chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i hi·ªÉn th·ªã c·ªßa c·ª≠a s·ªï (toggle).
        - N·∫øu ƒëang ·∫©n -> Hi·ªán.
        - N·∫øu ƒëang hi·ªán -> ·∫®n.
        - N·∫øu splash screen ƒëang ch·∫°y -> Tho√°t.
        """
        # 1.∆Øu ti√™n tho√°t n·∫øu splash screen ƒëang hi·ªÉn th·ªã
        if hasattr(self, 'splash') and self.splash and self.splash.winfo_exists():
            logging.warning("Nh·∫•n v√†o tray icon khi splash screen ƒëang hi·ªÉn th·ªã. K√≠ch ho·∫°t tho√°t ·ª©ng d·ª•ng.")
            self.quit_application()
            return

        # 2. Ki·ªÉm tra tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa c·ª≠a s·ªï ch√≠nh
        if self.state() == 'normal':
            # N·∫øu c·ª≠a s·ªï ƒëang hi·ªÉn th·ªã (normal), th√¨ ·∫©n n√≥ ƒëi
            logging.info("C·ª≠a s·ªï ƒëang hi·ªÉn th·ªã, y√™u c·∫ßu ·∫©n v√†o khay h·ªá th·ªëng qua tray icon.")
            # G·ªçi h√†m on_close() v√¨ n√≥ ƒë√£ ch·ª©a logic self.withdraw()
            # Vi·ªác n√†y gi√∫p t√°i s·ª≠ d·ª•ng code v√† nh·∫•t qu√°n v·ªõi vi·ªác nh·∫•n n√∫t 'X'
            self.on_close() 
        else:
            # N·∫øu c·ª≠a s·ªï ƒëang ·∫©n ('withdrawn'), th√¨ hi·ªán n√≥ l√™n (logic c≈© c·ªßa b·∫°n)
            logging.info("C·ª≠a s·ªï ƒëang ·∫©n, kh√¥i ph·ª•c t·ª´ khay th√¥ng qua tray icon.")
            try:
                self.after(0, self.deiconify)
                self.after(100, self.lift)
                self.after(200, self.focus_force)
            except Exception as e:
                logging.error(f"L·ªói kh√¥i ph·ª•c c·ª≠a s·ªï: {e}")



    # H√†m h√†nh ƒë·ªông: X·ª≠ l√Ω y√™u c·∫ßu tho√°t ·ª©ng d·ª•ng t·ª´ menu c·ªßa icon khay
    def quit_application(self, icon=None):
        """ D·ª´ng icon khay v√† k√≠ch ho·∫°t s·ª± ki·ªán ƒë√≥ng ·ª©ng d·ª•ng """
        logging.info("Y√™u c·∫ßu tho√°t t·ª´ khay h·ªá th·ªëng.")
        self._is_quitting = True
        try:
            if icon: icon.stop()
            elif hasattr(self, 'tray_icon') and self.tray_icon: self.tray_icon.stop()
        except Exception as e: logging.error(f"L·ªói d·ª´ng icon khay: {e}")
        # K√≠ch ho·∫°t s·ª± ki·ªán ƒë√≥ng tr√™n lu·ªìng ch√≠nh
        try:
            logging.info("ƒêang t·∫°o s·ª± ki·ªán <<QuitApp>>...")
            self.event_generate("<<QuitApp>>")
        except TclError as e: logging.warning(f"L·ªói Tcl khi t·∫°o s·ª± ki·ªán QuitApp (ƒëang ƒë√≥ng?): {e}")
        except Exception as e: logging.error(f"L·ªói t·∫°o s·ª± ki·ªán QuitApp: {e}", exc_info=True)

# --------------------
# 4.12 H√†m H·ªó tr·ª£
# --------------------

# H√†m ƒë·∫∑t ƒë·ªô ∆∞u ti√™n CPU cho ti·∫øn tr√¨nh hi·ªán t·∫°i v√† c√°c ti·∫øn tr√¨nh con c·ªßa n√≥.
    def _set_cpu_priority(self, limit_cpu: bool):
        """
        ƒê·∫∑t ƒë·ªô ∆∞u ti√™n CPU cho ti·∫øn tr√¨nh hi·ªán t·∫°i v√† c√°c ti·∫øn tr√¨nh con c·ªßa n√≥.

        Args:
            limit_cpu (bool): True ƒë·ªÉ ƒë·∫∑t ƒë·ªô ∆∞u ti√™n th·∫•p, False ƒë·ªÉ ƒë·∫∑t v·ªÅ b√¨nh th∆∞·ªùng.
        """
        log_prefix = "[CPU_Priority]"
        try:
            # L·∫•y ƒë·ªëi t∆∞·ª£ng ti·∫øn tr√¨nh c·ªßa ·ª©ng d·ª•ng Piu hi·ªán t·∫°i
            parent_process = psutil.Process(os.getpid())
            
            # L·∫•y danh s√°ch t·∫•t c·∫£ c√°c ti·∫øn tr√¨nh con m·ªôt c√°ch ƒë·ªá quy
            child_processes = parent_process.children(recursive=True)
            
            # G·ªôp ti·∫øn tr√¨nh cha v√† t·∫•t c·∫£ ti·∫øn tr√¨nh con v√†o m·ªôt danh s√°ch
            all_processes = [parent_process] + child_processes

            if limit_cpu:
                # N·∫øu ng∆∞·ªùi d√πng ch·ªçn "Gi·∫£m ∆∞u ti√™n"
                priority_class = psutil.BELOW_NORMAL_PRIORITY_CLASS if sys.platform == "win32" else 10
                priority_name = "Below Normal"
            else:
                # N·∫øu ng∆∞·ªùi d√πng b·ªè ch·ªçn, tr·∫£ v·ªÅ ƒë·ªô ∆∞u ti√™n "B√¨nh th∆∞·ªùng"
                priority_class = psutil.NORMAL_PRIORITY_CLASS if sys.platform == "win32" else 0
                priority_name = "Normal"

            logging.info(f"{log_prefix} Y√™u c·∫ßu ƒë·∫∑t ƒë·ªô ∆∞u ti√™n CPU th√†nh: '{priority_name}' cho {len(all_processes)} ti·∫øn tr√¨nh.")

            for proc in all_processes:
                try:
                    # ƒê·∫∑t ƒë·ªô ∆∞u ti√™n cho t·ª´ng ti·∫øn tr√¨nh
                    proc.nice(priority_class)
                    logging.debug(f"{log_prefix} ƒê√£ ƒë·∫∑t ƒë·ªô ∆∞u ti√™n cho PID {proc.pid} ({proc.name()}) th√†nh c√¥ng.")
                except psutil.NoSuchProcess:
                    # B·ªè qua n·∫øu ti·∫øn tr√¨nh con ƒë√£ k·∫øt th√∫c trong l√∫c duy·ªát
                    logging.debug(f"{log_prefix} Ti·∫øn tr√¨nh PID {proc.pid} kh√¥ng c√≤n t·ªìn t·∫°i ƒë·ªÉ ƒë·∫∑t ƒë·ªô ∆∞u ti√™n.")
                    continue
                except psutil.AccessDenied:
                    logging.warning(f"{log_prefix} Kh√¥ng c√≥ quy·ªÅn thay ƒë·ªïi ƒë·ªô ∆∞u ti√™n cho PID {proc.pid} ({proc.name()}).")
                except Exception as e_set:
                    logging.error(f"{log_prefix} L·ªói khi ƒë·∫∑t ƒë·ªô ∆∞u ti√™n cho PID {proc.pid} ({proc.name()}): {e_set}")

            if self.initial_ui_setup_complete: # Ch·ªâ hi·ªán status sau khi app ƒë√£ kh·ªüi ƒë·ªông xong
                status_msg = f"‚ÑπÔ∏è ƒê√£ ƒë·∫∑t ∆∞u ti√™n CPU: {priority_name} (gi√∫p m√°y m∆∞·ª£t h∆°n khi ch·∫°y)" if limit_cpu else "‚úÖ ƒê√£ kh√¥i ph·ª•c ∆∞u ti√™n CPU v·ªÅ b√¨nh th∆∞·ªùng."
                self.update_status(status_msg)

        except Exception as e:
            logging.error(f"{log_prefix} L·ªói nghi√™m tr·ªçng trong h√†m _set_cpu_priority: {e}", exc_info=True)
            if self.initial_ui_setup_complete:
                self.update_status("‚ùå L·ªói: Kh√¥ng th·ªÉ thay ƒë·ªïi ∆∞u ti√™n CPU.")



# H√†m h√†nh ƒë·ªông: M·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t API Keys
    def open_api_settings_window(self):
        """ M·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t API Keys """
        # Ki·ªÉm tra xem c·ª≠a s·ªï ƒë√£ m·ªü ch∆∞a (ƒë·ªÉ tr√°nh m·ªü nhi·ªÅu l·∫ßn)
        if hasattr(self, '_api_settings_win') and self._api_settings_win and self._api_settings_win.winfo_exists():
            self._api_settings_win.focus()
            logging.warning("C·ª≠a s·ªï c√†i ƒë·∫∑t API ƒë√£ m·ªü.")
            return

        logging.info("M·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t API Keys...")
        # T·∫°o c·ª≠a s·ªï m·ªõi, truy·ªÅn v√†o c·ª≠a s·ªï ch√≠nh (self) v√† c√°c bi·∫øn StringVar c·∫ßn thi·∫øt
        self._api_settings_win = APISettingsWindow(self, self.openai_key_var, self.google_key_path_var, self.gemini_key_var)
        # (Kh√¥ng c·∫ßn g·ªçi mainloop ·ªü ƒë√¢y)


# H√†m ti·ªán √≠ch l·ªõp: L·∫•y b·∫£n sao c√°c c√†i ƒë·∫∑t hi·ªán t·∫°i cho m·ªôt t√°c v·ª•
    def _get_config_snapshot(self):
        # Kh·ªüi t·∫°o snapshot v·ªõi c√°c gi√° tr·ªã c·∫•u h√¨nh chung
        snapshot = {
            "output_path": self.output_path_var.get(),
            "model": self.model_var.get(),
            "format": self.format_var.get(),
            "split": self.enable_split_var.get(),
            "max_chars": safe_int(self.max_chars_var.get(), 90),
            "max_lines": safe_int(self.max_lines_var.get(), 1),
            "split_mode": self.split_mode_var.get(),
            "language": self.source_lang_var.get(),
            "merge_mode": self.merge_sub_var.get().lower(),
            "translation_engine": self.translation_engine_var.get(),
            "bilingual": self.bilingual_var.get(),
            "target_lang": self.target_lang_var.get(),
            "pause_for_edit": self.pause_for_edit_var.get(),
            "openai_style": self.openai_translation_style_var.get(),
            "optimize_whisper_tts_voice": self.optimize_whisper_tts_voice_var.get() if hasattr(self, 'optimize_whisper_tts_voice_var') else False,
            "branding_intro_enabled": self.cfg.get("branding_intro_enabled", False),
            "branding_intro_path": self.cfg.get("branding_intro_path", ""),
            "branding_outro_enabled": self.cfg.get("branding_outro_enabled", False),
            "branding_outro_path": self.cfg.get("branding_outro_path", ""),
            "branding_logo_enabled": self.cfg.get("branding_logo_enabled", False),
            "branding_logo_path": self.cfg.get("branding_logo_path", ""),
            "branding_logo_position": self.cfg.get("branding_logo_position", "bottom_right"),
            "branding_logo_opacity_percent": self.cfg.get("branding_logo_opacity_percent", 80),
            "branding_logo_size_percent": self.cfg.get("branding_logo_size_percent", 10),
            "branding_logo_margin_px": self.cfg.get("branding_logo_margin_px", 10),

            "ffmpeg_preset": self.cfg.get("ffmpeg_preset", "medium"),
            "ffmpeg_crf": self.cfg.get("ffmpeg_crf", 22),
        }

        # --- L·∫§Y C√ÄI ƒê·∫∂T STYLE PH·ª§ ƒê·ªÄ T·ª™ SELF.CFG ---
        logging.debug("[GetSnapshot] ƒêang l·∫•y c√†i ƒë·∫∑t style ph·ª• ƒë·ªÅ t·ª´ self.cfg cho snapshot.")

        snapshot["sub_style_font_name"] = self.cfg.get("sub_style_font_name", "Arial")
        snapshot["sub_style_font_size"] = self.cfg.get("sub_style_font_size", 60) 
        snapshot["sub_style_font_bold"] = self.cfg.get("sub_style_font_bold", True)

        snapshot["sub_style_text_color_rgb_str"] = self.cfg.get("sub_style_text_color_rgb_str", "255,255,255")
        snapshot["sub_style_text_opacity_percent"] = self.cfg.get("sub_style_text_opacity_percent", 100)

        snapshot["sub_style_background_mode"] = self.cfg.get("sub_style_background_mode", "ƒê·ªï B√≥ng")
        snapshot["sub_style_bg_color_rgb_str"] = self.cfg.get("sub_style_bg_color_rgb_str", "0,0,0") 
        snapshot["sub_style_bg_box_actual_opacity_percent"] = self.cfg.get("sub_style_bg_box_actual_opacity_percent", 75) 

        snapshot["sub_style_outline_enabled"] = self.cfg.get("sub_style_outline_enabled", False)
        snapshot["sub_style_outline_size"] = self.cfg.get("sub_style_outline_size", 2.0) 
        snapshot["sub_style_outline_color_rgb_str"] = self.cfg.get("sub_style_outline_color_rgb_str", "0,0,0")
        snapshot["sub_style_outline_opacity_percent"] = self.cfg.get("sub_style_outline_opacity_percent", 100)

        snapshot["margin_v"] = self.cfg.get("margin_v", 60)
        # --- K·∫øt th√∫c ph·∫ßn l·∫•y c√†i ƒë·∫∑t style ph·ª• ƒë·ªÅ t·ª´ self.cfg ---
        logging.debug(f"[GetSnapshot_v2] Snapshot ƒë∆∞·ª£c t·∫°o. Optimize TTS Voice: {snapshot.get('optimize_whisper_tts_voice')}") # Th√™m log ƒë·ªÉ ki·ªÉm tra
        logging.debug(f"[GetSnapshot] Snapshot ho√†n ch·ªânh: {json.dumps(snapshot, indent=2, ensure_ascii=False)}")
        return snapshot



# H√†m ti·ªán √≠ch UI Subtitle: Hi·ªÉn th·ªã n·ªôi dung ph·ª• ƒë·ªÅ l√™n √¥ Textbox
    def show_sub_in_textbox(self, content):
        """ C·∫≠p nh·∫≠t an to√†n n·ªôi dung textbox ph·ª• ƒë·ªÅ """
        subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
        if not subtitle_textbox or not subtitle_textbox.winfo_exists():
            logging.warning("Widget textbox ph·ª• ƒë·ªÅ kh√¥ng kh·∫£ d·ª•ng ƒë·ªÉ c·∫≠p nh·∫≠t.")
            return
        try:
            # B∆Ø·ªöC 1: Lu√¥n b·∫≠t state='normal' ƒë·ªÉ cho ph√©p x√≥a v√† ch√®n
            subtitle_textbox.configure(state="normal")
            # B∆Ø·ªöC 2: X√≥a n·ªôi dung c≈© v√† ch√®n n·ªôi dung m·ªõi
            subtitle_textbox.delete("0.0", "end")

            if content and content.strip(): # N·∫øu c√≥ n·ªôi dung th·ª±c s·ª±
                subtitle_textbox.insert("0.0", content)
            else: # N·∫øu n·ªôi dung r·ªóng ho·∫∑c ch·ªâ l√† kho·∫£ng tr·∫Øng
                placeholder = getattr(self, 'subtitle_textbox_placeholder', "[N·ªôi dung ph·ª• ƒë·ªÅ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...]")
                subtitle_textbox.insert("0.0", placeholder)

            # B∆Ø·ªöC 3: N·∫øu kh√¥ng cho ph√©p s·ª≠a, ƒë·∫∑t l·∫°i state='disabled'
            if not self.allow_edit_sub:
                if subtitle_textbox and subtitle_textbox.winfo_exists():
                    subtitle_textbox.configure(state="disabled")
            logging.debug("ƒê√£ c·∫≠p nh·∫≠t n·ªôi dung textbox ph·ª• ƒë·ªÅ.")
        except Exception as e:
             logging.error(f"L·ªói c·∫≠p nh·∫≠t textbox ph·ª• ƒë·ªÅ: {e}", exc_info=True)


# H√ÄM TI·ªÜN √çCH L∆ØU C·∫§U H√åNH HI·ªÜN T·∫†I C·ª¶A ·ª®NG D·ª§NG!!!=============================================================================================================================================================
    def save_current_config(self):
        """ Thu th·∫≠p t·∫•t c·∫£ gi√° tr·ªã c·∫•u h√¨nh hi·ªán t·∫°i v√† l∆∞u v√†o file """
        if hasattr(self, '_is_restoring_task_config') and self._is_restoring_task_config:
            logging.debug("[SaveConfig] B·ªè qua l∆∞u config v√¨ ƒëang trong qu√° tr√¨nh kh√¥i ph·ª•c c·∫•u h√¨nh t√°c v·ª• dubbing.")
            return         
        logging.debug("[SaveConfig] B·∫Øt ƒë·∫ßu thu th·∫≠p v√† l∆∞u c·∫•u h√¨nh...")

        # Thu th·∫≠p C·∫•u h√¨nh Subtitle
        self.cfg["language"] = self.source_lang_var.get()
        self.cfg["model"] = self.model_var.get()
        self.cfg["format"] = self.format_var.get()
        self.cfg["output_path"] = self.output_path_var.get()
        self.cfg["merge_mode"] = self.merge_sub_var.get()        
        self.cfg["bilingual"] = self.bilingual_var.get()
        self.cfg["target_lang"] = self.target_lang_var.get()
        self.cfg["split"] = self.enable_split_var.get()
        self.cfg["max_chars"] = safe_int(self.max_chars_var.get(), 90)
        self.cfg["max_lines"] = safe_int(self.max_lines_var.get(), 1)
        self.cfg["split_mode"] = self.split_mode_var.get()
        self.cfg["manual_merge_mode"] = self.manual_merge_mode_var.get()
        self.cfg["sub_cps_for_timing"] = safe_int(self.sub_cps_for_timing_var.get(), 17)

        # L∆∞u tr·∫°ng th√°i checkbox "L∆∞u v√†o th∆∞ m·ª•c media"
        if hasattr(self, 'save_in_media_folder_var'):
            self.cfg["save_in_media_folder"] = self.save_in_media_folder_var.get()

        # >>> T·ªêI ∆ØU WHISPER TTS <<<
        if hasattr(self, 'optimize_whisper_tts_voice_var'): # Ki·ªÉm tra an to√†n
            self.cfg["optimize_whisper_tts_voice"] = self.optimize_whisper_tts_voice_var.get()

        # >>> CHIA D√íNG TEXT CHO TAB SUB <<<
        if hasattr(self, 'auto_format_plain_text_to_srt_var'): # Ki·ªÉm tra thu·ªôc t√≠nh t·ªìn t·∫°i
            self.cfg["auto_format_plain_text_to_srt"] = self.auto_format_plain_text_to_srt_var.get()

        # L∆∞u l·ª±a ch·ªçn model GPT cho vi·ªác s·ª≠a k·ªãch b·∫£n
        if hasattr(self, 'gpt_model_for_script_editing_var'):
            self.cfg["gpt_model_for_script_editing"] = self.gpt_model_for_script_editing_var.get()

        # --- TH√äM V√ÄO ƒê√ÇY: L∆ØU C·∫§U H√åNH NH·ªäP ƒêI·ªÜU & T·ªêC ƒê·ªò ƒê·ªåC ---
        if hasattr(self, 'sub_pacing_pause_medium_ms_var'):
            self.cfg["sub_pacing_pause_medium_ms"] = safe_int(self.sub_pacing_pause_medium_ms_var.get(), 150)
        if hasattr(self, 'sub_pacing_pause_period_ms_var'):
            self.cfg["sub_pacing_pause_period_ms"] = safe_int(self.sub_pacing_pause_period_ms_var.get(), 300)
        if hasattr(self, 'sub_pacing_pause_question_ms_var'):
            self.cfg["sub_pacing_pause_question_ms"] = safe_int(self.sub_pacing_pause_question_ms_var.get(), 450)
        if hasattr(self, 'sub_pacing_long_sentence_threshold_var'):
            self.cfg["sub_pacing_long_sentence_threshold"] = safe_int(self.sub_pacing_long_sentence_threshold_var.get(), 55)
        if hasattr(self, 'sub_pacing_fast_cps_multiplier_var'):
            try:
                self.cfg["sub_pacing_fast_cps_multiplier"] = float(self.sub_pacing_fast_cps_multiplier_var.get())
            except (ValueError, TypeError):
                self.cfg["sub_pacing_fast_cps_multiplier"] = 1.1 # M·∫∑c ƒë·ªãnh n·∫øu l·ªói

        # Thu th·∫≠p C·∫•u h√¨nh Downloader
        self.cfg["download_playlist"] = self.download_playlist_var.get()
        self.cfg["download_path"] = self.download_path_var.get()
        self.cfg["download_mode"] = self.download_mode_var.get()
        self.cfg["download_video_quality"] = self.download_video_quality_var.get()
        self.cfg["download_audio_quality"] = self.download_audio_quality_var.get()
        self.cfg["download_sound_enabled"] = self.download_sound_var.get()
        self.cfg["download_sound_path"] = self.download_sound_path_var.get()
        self.cfg["download_shutdown_enabled"] = self.download_shutdown_var.get()
        self.cfg["download_rename_enabled"] = self.download_rename_var.get()
        self.cfg["download_rename_base_name"] = self.download_rename_box_var.get()
        self.cfg["download_stop_on_error"] = self.download_stop_on_error_var.get()
        self.cfg["sheet_id"] = self.sheet_id_var.get()
        self.cfg["sheet_range"] = self.sheet_range_var.get()
        self.cfg["disable_auto_sheet_check"] = self.disable_auto_sheet_check_var.get()
        self.cfg["google_service_account_path"] = self.google_key_path_var.get() 
        self.cfg["translation_engine"] = self.translation_engine_var.get()      
        self.cfg["openai_translation_style"] = self.openai_translation_style_var.get()
        self.cfg["pause_for_edit"] = self.pause_for_edit_var.get()
        self.cfg["download_auto_dub_after_sub"] = self.download_auto_dub_after_sub_var.get()
        self.cfg["auto_upload_after_download"] = self.auto_upload_after_download_var.get()
        self.cfg["download_use_cookies"] = self.download_use_cookies_var.get()
        self.cfg["download_cookies_path"] = self.download_cookies_path_var.get()        

        # L∆ØU C·∫§U H√åNH API KEY  
        self.cfg["openai_api_key"] = self.openai_key_var.get()
        self.cfg["gemini_api_key"] = self.gemini_key_var.get()       


        # --- TH√äM PH·∫¶N THU TH·∫¨P C·∫§U H√åNH THUY·∫æT MINH (DUBBING) V√ÄO ƒê√ÇY ---
        logging.debug("ƒêang thu th·∫≠p c·∫•u h√¨nh Thuy·∫øt Minh ƒë·ªÉ l∆∞u...")
        if hasattr(self, 'dub_selected_tts_engine_var'):
            self.cfg["dub_tts_engine"] = self.dub_selected_tts_engine_var.get()
        
        # --- L∆ØU ID GI·ªåNG ƒê·ªåC TH·ª∞C T·∫æ ---
        if hasattr(self, 'dub_selected_voice_id_var'): # Bi·∫øn n√†y l∆∞u ID th·ª±c t·∫ø
             self.cfg["dub_selected_voice_id"] = self.dub_selected_voice_id_var.get()
        
        if hasattr(self, 'dub_use_google_ssml_var'):
            self.cfg["dub_use_google_ssml"] = self.dub_use_google_ssml_var.get()        

        # === L∆ØU C√ÅC THAM S·ªê X·ª¨ L√ù AUDIO N√ÇNG CAO ===

        if hasattr(self, 'dub_sync_tolerance_ms_var'):
            self.cfg["dub_sync_tolerance_ms"] = safe_int(self.dub_sync_tolerance_ms_var.get(), 20)
        
        if hasattr(self, 'dub_sync_max_speed_up_var'):
            try: # Chuy·ªÉn sang float, n·∫øu l·ªói th√¨ d√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh
                self.cfg["dub_sync_max_speed_up"] = float(self.dub_sync_max_speed_up_var.get())
            except ValueError:
                self.cfg["dub_sync_max_speed_up"] = 1.50 
        
        if hasattr(self, 'dub_sync_min_speed_down_var'):
            try:
                # L∆∞u √Ω key config l√† "dub_sync_min_speed_down_val" nh∆∞ ƒë√£ ƒë·ªãnh nghƒ©a ·ªü __init__
                self.cfg["dub_sync_min_speed_down_val"] = self.dub_sync_min_speed_down_var.get() # L∆∞u d·∫°ng string
            except Exception as e: # B·∫Øt l·ªói t·ªïng qu√°t n·∫øu self.dub_sync_min_speed_down_var kh√¥ng t·ªìn t·∫°i
                logging.warning(f"L·ªói khi l∆∞u dub_sync_min_speed_down_val: {e}")
                self.cfg["dub_sync_min_speed_down_val"] = "1.0"

        if hasattr(self, 'dub_sync_force_cut_if_over_srt_duration_var'):
            self.cfg["dub_sync_force_cut_if_over_srt_duration"] = self.dub_sync_force_cut_if_over_srt_duration_var.get()
        
        if hasattr(self, 'dub_sync_min_srt_duration_for_adjust_ms_var'):
            self.cfg["dub_sync_min_srt_duration_for_adjust_ms"] = safe_int(self.dub_sync_min_srt_duration_for_adjust_ms_var.get(), 200)

        if hasattr(self, 'dub_sync_pad_short_tts_var'):
            self.cfg["dub_sync_pad_short_tts"] = self.dub_sync_pad_short_tts_var.get()
        
        if hasattr(self, 'dub_min_gap_between_segments_ms_var'):
            self.cfg["dub_min_gap_between_segments_ms"] = safe_int(self.dub_min_gap_between_segments_ms_var.get(), 0)

        if hasattr(self, 'dub_audio_fade_in_duration_s_var'):
            try:
                self.cfg["dub_audio_fade_in_duration_s"] = float(self.dub_audio_fade_in_duration_s_var.get())
            except ValueError:
                self.cfg["dub_audio_fade_in_duration_s"] = 0.05
        
        if hasattr(self, 'dub_audio_fade_out_duration_s_var'):
            try:
                self.cfg["dub_audio_fade_out_duration_s"] = float(self.dub_audio_fade_out_duration_s_var.get())
            except ValueError:
                self.cfg["dub_audio_fade_out_duration_s"] = 0.03
                
        # L∆∞u tr·∫°ng th√°i hi·ªÉn th·ªã c·ªßa checkbox t√πy ch·ªçn n√¢ng cao
        if hasattr(self, 'dub_show_advanced_audio_settings_var'):
            self.cfg["dub_show_advanced_audio_settings"] = self.dub_show_advanced_audio_settings_var.get()
        
        # T√πy ch·ªçn √¢m thanh n·ªÅn
        if hasattr(self, 'dub_background_audio_option_var'):
            self.cfg["dub_background_audio_option"] = self.dub_background_audio_option_var.get() 
        if hasattr(self, 'dub_background_mix_level_var'):
            self.cfg["dub_background_mix_level"] = self.dub_background_mix_level_var.get() 

        # Nh·∫°c n·ªÅn t√πy ch·ªânh
        if hasattr(self, 'dub_use_custom_bg_music_var'):
            self.cfg["dub_use_custom_bg_music"] = self.dub_use_custom_bg_music_var.get() 
        if hasattr(self, 'dub_custom_bg_music_path_var'):
            self.cfg["dub_custom_bg_music_path"] = self.dub_custom_bg_music_path_var.get() 
        self.cfg["dub_custom_bg_volume"] = self.get_validated_custom_bg_volume_float() 

        # --- TH√äM M·ªöI ƒê·ªÇ L∆ØU C·∫§U H√åNH TH∆Ø M·ª§C NH·∫†C N·ªÄN ---
        if hasattr(self, 'dub_custom_bg_music_folder_path_var'):
            self.cfg["dub_custom_bg_music_folder_path"] = self.dub_custom_bg_music_folder_path_var.get()
        if hasattr(self, 'dub_randomize_bg_music_var'):
            self.cfg["dub_randomize_bg_music"] = self.dub_randomize_bg_music_var.get()
        # --- K·∫æT TH√öC TH√äM M·ªöI ---
            
        # Th∆∞ m·ª•c output cho dubbing
        if hasattr(self, 'dub_output_path_var'):
            self.cfg["dub_output_path"] = self.dub_output_path_var.get()

        # --- K·∫æT TH√öC PH·∫¶N THU TH·∫¨P C·∫§U H√åNH THUY·∫æT MINH ---
        
        # Thu th·∫≠p C·∫•u h√¨nh License (ƒê·∫£m b·∫£o ƒë·ªçc ƒë√∫ng gi√° tr·ªã ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t)
        self.cfg['license_key'] = self.cfg.get('license_key', "")
        self.cfg['activation_status'] = self.cfg.get('activation_status', 'INACTIVE')
        self.cfg['expiry_date'] = self.cfg.get('expiry_date', None)
        self.cfg['hardware_id'] = self.cfg.get('hardware_id', None)
        self.cfg['license_type'] = self.cfg.get('license_type', self.cfg.get('activation_status', 'INACTIVE'))

        # Thu th·∫≠p C·∫•u h√¨nh Kh√°c
        self.cfg["dependency_checked_ok"] = self.cfg.get("dependency_checked_ok", False)

        # --- L∆ØU C·∫§U H√åNH CHO T√ôY CH·ªåN G·ªòP KH·ªêI PH·ª§ ƒê·ªÄ ---
        self.cfg["enable_block_merging"] = self.enable_block_merging_var.get()

        # S·ª≠ d·ª•ng safe_int ƒë·ªÉ ƒë·∫£m b·∫£o gi√° tr·ªã l√† s·ªë v√† c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu ng∆∞·ªùi d√πng nh·∫≠p linh tinh
        self.cfg["merge_max_time_gap_ms"] = safe_int(self.merge_max_time_gap_var.get(), 369)
        self.cfg["merge_curr_max_len_normal"] = safe_int(self.merge_curr_max_len_normal_var.get(), 36)
        self.cfg["auto_add_manual_sub_task"] = self.auto_add_manual_sub_task_var.get()
        
        # Th∆∞ m·ª•c ·∫£nh
        if hasattr(self, 'dub_use_image_folder_var'):
            self.cfg["dub_use_image_folder"] = self.dub_use_image_folder_var.get()
        if hasattr(self, 'dub_selected_image_folder_path_var'):
            self.cfg["dub_slideshow_image_folder"] = self.dub_selected_image_folder_path_var.get()

        # === TH√äM PH·∫¶N L∆ØU C·∫§U H√åNH T·ªêI ∆ØU LU·ªíNG ƒê·ªåC THUY·∫æT MINH ===
        if hasattr(self, 'optimize_dub_flow_var'):
            self.cfg["optimize_dub_flow_enabled"] = self.optimize_dub_flow_var.get()
            
        if hasattr(self, 'dub_force_recalculate_timing_var'):
            self.cfg["dub_force_recalculate_timing"] = self.dub_force_recalculate_timing_var.get()
            
        if hasattr(self, 'dub_split_enabled_for_flow_var'):
            self.cfg["dub_split_enabled_for_flow"] = self.dub_split_enabled_for_flow_var.get()
        if hasattr(self, 'dub_max_chars_for_flow_var'):
            self.cfg["dub_max_chars_for_flow"] = safe_int(self.dub_max_chars_for_flow_var.get(), 999)
        if hasattr(self, 'dub_max_lines_for_flow_var'):
            self.cfg["dub_max_lines_for_flow"] = safe_int(self.dub_max_lines_for_flow_var.get(), 1)
        if hasattr(self, 'dub_split_mode_for_flow_var'):
            self.cfg["dub_split_mode_for_flow"] = self.dub_split_mode_for_flow_var.get()

        if hasattr(self, 'dub_auto_optimize_on_paste_var'):
            self.cfg["dub_auto_optimize_on_paste"] = self.dub_auto_optimize_on_paste_var.get()

        if hasattr(self, 'dub_cps_for_timing_var'):
            try:
                self.cfg["dub_cps_for_timing"] = int(self.dub_cps_for_timing_var.get())
            except ValueError:
                self.cfg["dub_cps_for_timing"] = 15 # Gi√° tr·ªã m·∫∑c ƒë·ªãnh an to√†n n·∫øu ng∆∞·ªùi d√πng nh·∫≠p kh√¥ng ph·∫£i s·ªë

        # --- L∆ØU C·∫§U H√åNH BRANDING ---
        if hasattr(self, 'branding_intro_enabled_var'):
            self.cfg["branding_intro_enabled"] = self.branding_intro_enabled_var.get()
        if hasattr(self, 'branding_intro_path_var'):
            self.cfg["branding_intro_path"] = self.branding_intro_path_var.get()

        ### TH√äM M·ªöI: L∆ØU C·∫§U H√åNH INTRO T·ª™ ·∫¢NH ###
        if hasattr(self, 'branding_intro_from_image_enabled_var'):
            self.cfg["branding_intro_from_image_enabled"] = self.branding_intro_from_image_enabled_var.get()
        if hasattr(self, 'branding_intro_image_path_var'):
            self.cfg["branding_intro_image_path"] = self.branding_intro_image_path_var.get()
        if hasattr(self, 'branding_intro_image_duration_var'):
            try:
                self.cfg["branding_intro_image_duration_s"] = float(self.branding_intro_image_duration_var.get())
            except ValueError:
                self.cfg["branding_intro_image_duration_s"] = 5.0 # M·∫∑c ƒë·ªãnh n·∫øu l·ªói

        if hasattr(self, 'branding_outro_enabled_var'):
            self.cfg["branding_outro_enabled"] = self.branding_outro_enabled_var.get()
        if hasattr(self, 'branding_outro_path_var'):
            self.cfg["branding_outro_path"] = self.branding_outro_path_var.get()

        ### TH√äM M·ªöI: L∆ØU C·∫§U H√åNH OUTRO T·ª™ ·∫¢NH ###
        if hasattr(self, 'branding_outro_from_image_enabled_var'):
            self.cfg["branding_outro_from_image_enabled"] = self.branding_outro_from_image_enabled_var.get()
        if hasattr(self, 'branding_outro_image_path_var'):
            self.cfg["branding_outro_image_path"] = self.branding_outro_image_path_var.get()
        if hasattr(self, 'branding_outro_image_duration_var'):
            try:
                self.cfg["branding_outro_image_duration_s"] = float(self.branding_outro_image_duration_var.get())
            except ValueError:
                self.cfg["branding_outro_image_duration_s"] = 5.0 # M·∫∑c ƒë·ªãnh n·∫øu l·ªói

        if hasattr(self, 'branding_logo_enabled_var'):
            self.cfg["branding_logo_enabled"] = self.branding_logo_enabled_var.get()
        if hasattr(self, 'branding_logo_path_var'):
            self.cfg["branding_logo_path"] = self.branding_logo_path_var.get()
        
        if hasattr(self, 'branding_logo_position_var'):
            self.cfg["branding_logo_position"] = self.branding_logo_position_var.get()
        if hasattr(self, 'branding_logo_opacity_var'):
            self.cfg["branding_logo_opacity_percent"] = self.branding_logo_opacity_var.get() # L∆∞u d∆∞·ªõi d·∫°ng int
        if hasattr(self, 'branding_logo_size_percent_var'):
            self.cfg["branding_logo_size_percent"] = self.branding_logo_size_percent_var.get() # L∆∞u d∆∞·ªõi d·∫°ng int
        if hasattr(self, 'branding_logo_margin_px_var'):
            self.cfg["branding_logo_margin_px"] = self.branding_logo_margin_px_var.get() # L∆∞u d∆∞·ªõi d·∫°ng int
        # --- K·∫æT TH√öC L∆ØU C·∫§U H√åNH BRANDING ---

        # --- Thu th·∫≠p C·∫•u h√¨nh Style Ph·ª• ƒë·ªÅ ---
        if hasattr(self, 'sub_style_font_name_var'):
            self.cfg["sub_style_font_name"] = self.sub_style_font_name_var.get()
        if hasattr(self, 'sub_style_font_size_var'):
            self.cfg["sub_style_font_size"] = self.sub_style_font_size_var.get()
        if hasattr(self, 'sub_style_font_bold_var'):
            self.cfg["sub_style_font_bold"] = self.sub_style_font_bold_var.get()

        if hasattr(self, 'sub_style_text_color_rgb_str_var'):
            self.cfg["sub_style_text_color_rgb_str"] = self.sub_style_text_color_rgb_str_var.get()
        if hasattr(self, 'sub_style_text_opacity_percent_var'):
            self.cfg["sub_style_text_opacity_percent"] = self.sub_style_text_opacity_percent_var.get()

        if hasattr(self, 'sub_style_background_mode_var'):
            self.cfg["sub_style_background_mode"] = self.sub_style_background_mode_var.get()
        if hasattr(self, 'sub_style_bg_color_rgb_str_var'):
            self.cfg["sub_style_bg_color_rgb_str"] = self.sub_style_bg_color_rgb_str_var.get()
        if hasattr(self, 'sub_style_bg_box_actual_opacity_percent_var'):
            self.cfg["sub_style_bg_box_actual_opacity_percent"] = self.sub_style_bg_box_actual_opacity_percent_var.get()

        if hasattr(self, 'sub_style_outline_enabled_var'):
            self.cfg["sub_style_outline_enabled"] = self.sub_style_outline_enabled_var.get()
        if hasattr(self, 'sub_style_outline_size_var'):
            self.cfg["sub_style_outline_size"] = self.sub_style_outline_size_var.get()
        if hasattr(self, 'sub_style_outline_color_rgb_str_var'):
            self.cfg["sub_style_outline_color_rgb_str"] = self.sub_style_outline_color_rgb_str_var.get()
        if hasattr(self, 'sub_style_outline_opacity_percent_var'):
            self.cfg["sub_style_outline_opacity_percent"] = self.sub_style_outline_opacity_percent_var.get()

        if hasattr(self, 'sub_style_marginv_var'):
            self.cfg["margin_v"] = self.sub_style_marginv_var.get()

        if "ffmpeg_preset" not in self.cfg:
            self.cfg["ffmpeg_preset"] = "medium" # Gi√° tr·ªã m·∫∑c ƒë·ªãnh b·∫°n ƒëang d√πng
            logging.info("[SaveConfig] Kh·ªüi t·∫°o 'ffmpeg_preset' v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh 'medium' v√†o c·∫•u h√¨nh.")
        # N·∫øu key ƒë√£ t·ªìn t·∫°i trong self.cfg, n√≥ s·∫Ω kh√¥ng b·ªã ghi ƒë√® ·ªü ƒë√¢y, gi√° tr·ªã hi·ªán t·∫°i s·∫Ω ƒë∆∞·ª£c l∆∞u.

        if "ffmpeg_crf" not in self.cfg:
            self.cfg["ffmpeg_crf"] = 22 # Gi√° tr·ªã m·∫∑c ƒë·ªãnh b·∫°n ƒëang d√πng
            logging.info("[SaveConfig] Kh·ªüi t·∫°o 'ffmpeg_crf' v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh '22' v√†o c·∫•u h√¨nh.")

        # --- K·∫øt th√∫c Thu th·∫≠p C·∫•u h√¨nh Style Ph·ª• ƒë·ªÅ ---

        # === TH√äM KH·ªêI L∆ØU C·∫§U H√åNH UPLOAD YOUTUBE V√ÄO ƒê√ÇY ===
        logging.debug("[SaveConfig] Thu th·∫≠p v√† l∆∞u c·∫•u h√¨nh cho Upload YouTube...")
        if hasattr(self, 'youtube_privacy_status_var'):
            self.cfg["youtube_default_privacy"] = self.youtube_privacy_status_var.get()
        if hasattr(self, 'youtube_playlist_var'):
            self.cfg["youtube_playlist_name"] = self.youtube_playlist_var.get()            
        if hasattr(self, 'auto_upload_to_youtube_var'):
            self.cfg["auto_upload_to_youtube"] = self.auto_upload_to_youtube_var.get()
        if hasattr(self, 'youtube_upload_method_var'):
            self.cfg["youtube_upload_method"] = self.youtube_upload_method_var.get()
        if hasattr(self, 'chrome_portable_path_var'):
            self.cfg["chrome_portable_path"] = self.chrome_portable_path_var.get()
        if hasattr(self, 'chromedriver_path_var'):
            self.cfg["chromedriver_path"] = self.chromedriver_path_var.get()
        if hasattr(self, 'youtube_headless_var'):
            self.cfg["youtube_run_headless"] = self.youtube_headless_var.get()
        if hasattr(self, 'youtube_fetch_metadata_var'):
            self.cfg["youtube_fetch_metadata_enabled"] = self.youtube_fetch_metadata_var.get()

        # CODE L∆ØU TI√äU ƒê·ªÄ, M√î T·∫¢, TAGS
        if hasattr(self, 'youtube_title_var'):
            self.cfg["youtube_last_title"] = self.youtube_title_var.get()
        if hasattr(self, 'youtube_tags_var'):
            self.cfg["youtube_last_tags"] = self.youtube_tags_var.get()
        if hasattr(self, 'youtube_description_textbox') and self.youtube_description_textbox.winfo_exists():
            self.cfg["youtube_last_description"] = self.youtube_description_textbox.get("1.0", "end-1c")
        if hasattr(self, 'youtube_autofill_var'):
            self.cfg["youtube_autofill_enabled"] = self.youtube_autofill_var.get()
        if hasattr(self, 'youtube_category_id_var'):
            self.cfg["youtube_default_category_id"] = self.youtube_category_id_var.get()
        if hasattr(self, 'youtube_add_end_screen_var'):
            self.cfg["youtube_add_end_screen"] = self.youtube_add_end_screen_var.get()
        if hasattr(self, 'youtube_add_cards_var'):
            self.cfg["youtube_add_cards"] = self.youtube_add_cards_var.get()
        if hasattr(self, 'metadata_auto_increment_thumb_var'):
            self.cfg["metadata_auto_increment_thumb"] = self.metadata_auto_increment_thumb_var.get()            

        # --- KH·ªêI L∆ØU C·∫§U H√åNH BRANDING ---
        logging.debug("[SaveConfig] Thu th·∫≠p c·∫•u h√¨nh Branding...")
        if hasattr(self, 'branding_intro_enabled_var'):
            self.cfg["branding_intro_enabled"] = self.branding_intro_enabled_var.get()
        if hasattr(self, 'branding_intro_path_var'):
            self.cfg["branding_intro_path"] = self.branding_intro_path_var.get()

        if hasattr(self, 'branding_outro_enabled_var'):
            self.cfg["branding_outro_enabled"] = self.branding_outro_enabled_var.get()
        if hasattr(self, 'branding_outro_path_var'):
            self.cfg["branding_outro_path"] = self.branding_outro_path_var.get()

        if hasattr(self, 'branding_logo_enabled_var'):
            self.cfg["branding_logo_enabled"] = self.branding_logo_enabled_var.get()
        if hasattr(self, 'branding_logo_path_var'):
            self.cfg["branding_logo_path"] = self.branding_logo_path_var.get()
        
        if hasattr(self, 'branding_logo_position_var'):
            self.cfg["branding_logo_position"] = self.branding_logo_position_var.get()
        if hasattr(self, 'branding_logo_opacity_var'):
            self.cfg["branding_logo_opacity_percent"] = self.branding_logo_opacity_var.get()
        if hasattr(self, 'branding_logo_size_percent_var'):
            self.cfg["branding_logo_size_percent"] = self.branding_logo_size_percent_var.get()
        if hasattr(self, 'branding_logo_margin_px_var'):
            self.cfg["branding_logo_margin_px"] = self.branding_logo_margin_px_var.get()

        # L∆∞u c·∫•u h√¨nh CPU
        if hasattr(self, 'limit_cpu_var'): # Ki·ªÉm tra an to√†n
            self.cfg["limit_cpu_usage"] = self.limit_cpu_var.get()

        # L∆ØU C·∫§U H√åNH CHO CHU·ªñI S·∫¢N XU·∫§T T·ª™ AI EDITOR TAB >>>
        if hasattr(self, 'ai_editor_view_frame'): # ƒê·∫£m b·∫£o tab AI Editor ƒë√£ ƒë∆∞·ª£c t·∫°o
            self.cfg["ai_editor_output_folder"] = self.ai_editor_view_frame.output_folder_var.get()
            self.cfg["ai_editor_enable_chain"] = self.ai_editor_view_frame.enable_production_chain_var.get()
            self.cfg["ai_editor_chain_output_path"] = self.ai_editor_view_frame.production_chain_output_path_var.get()
            self.cfg["ai_editor_rename_enabled"] = self.ai_editor_view_frame.rename_var.get()
            self.cfg["ai_editor_auto_naming_enabled"] = self.ai_editor_view_frame.auto_naming_var.get()
            self.cfg["ai_editor_rename_base_name"] = self.ai_editor_view_frame.rename_base_name_var.get()
            self.cfg["ai_editor_series_name"] = self.ai_editor_view_frame.series_name_var.get()
            self.cfg["ai_editor_start_chapter"] = self.ai_editor_view_frame.start_chapter_var.get()
            self.cfg["ai_editor_en_tts_mode"] = self.ai_editor_view_frame.en_tts_mode_var.get()

        # L∆∞u c√†i ƒë·∫∑t Imagen Motion
        if hasattr(self, 'imagen_motion_effect_var'):
            self.cfg["imagen_motion_effect"] = self.imagen_motion_effect_var.get()
        if hasattr(self, 'imagen_motion_speed_var'):
            self.cfg["imagen_motion_speed"] = self.imagen_motion_speed_var.get()

        # L∆ØU C·∫§U H√åNH FFmpeg
        # L·∫•y gi√° tr·ªã encoder ch√≠nh t·ª´ chu·ªói, v√≠ d·ª• "h264_nvenc" t·ª´ "h264_nvenc (NVIDIA GPU)"
        encoder_full_string = self.ffmpeg_encoder_var.get()
        encoder_value_to_save = encoder_full_string.split(" ")[0]
        self.cfg["ffmpeg_encoder"] = encoder_value_to_save

        self.cfg["ffmpeg_preset"] = self.ffmpeg_preset_var.get()
        self.cfg["ffmpeg_crf"] = safe_int(self.ffmpeg_crf_var.get(), 23)

        # L∆∞u
        save_config(self.cfg) # S·ª≠ d·ª•ng h√†m save to√†n c·ª•c


# H·ªèi ng∆∞·ªùi d√πng x√°c nh·∫≠n v√† l∆∞u nhanh to√†n b·ªô c·∫•u h√¨nh hi·ªán t·∫°i v√†o config.json.
    def _quick_save_config(self):
        """
        H·ªèi ng∆∞·ªùi d√πng x√°c nh·∫≠n v√† l∆∞u nhanh to√†n b·ªô c·∫•u h√¨nh hi·ªán t·∫°i v√†o config.json.
        """
        logging.info("Ng∆∞·ªùi d√πng y√™u c·∫ßu L∆∞u nhanh c·∫•u h√¨nh.")
        
        # H·ªèi x√°c nh·∫≠n
        answer = messagebox.askyesno(
            "X√°c nh·∫≠n L∆∞u Nhanh",
            "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën l∆∞u t·∫•t c·∫£ c√°c c√†i ƒë·∫∑t hi·ªán t·∫°i v√†o file c·∫•u h√¨nh ch√≠nh (config.json) kh√¥ng?\n\n"
            "C√°c c√†i ƒë·∫∑t n√†y s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông t·∫£i l·∫°i v√†o l·∫ßn kh·ªüi ƒë·ªông sau.",
            icon='question',
            parent=self
        )

        if answer:
            try:
                self.save_current_config() # G·ªçi h√†m l∆∞u ch√≠nh c·ªßa b·∫°n
                logging.info("L∆∞u nhanh c·∫•u h√¨nh th√†nh c√¥ng.")
                self.update_status("‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh th√†nh c√¥ng!")
                
                # L√™n l·ªãch ƒë·ªÉ reset status v·ªÅ tr·∫°ng th√°i m·∫∑c ƒë·ªãnh sau 4 gi√¢y
                self.after(4000, self._reset_status_to_default)

            except Exception as e:
                logging.error(f"L·ªói khi th·ª±c hi·ªán L∆∞u nhanh: {e}", exc_info=True)
                messagebox.showerror("L·ªói L∆∞u Nhanh", f"Kh√¥ng th·ªÉ l∆∞u c·∫•u h√¨nh.\nL·ªói: {e}", parent=self)


#-------------------
# 2 H√†m Th·ªëng k√™ API
    def _track_api_call(self, service_name, units=1):
        """
        H√†m trung t√¢m ƒë·ªÉ ghi nh·∫≠n m·ªôt l·∫ßn g·ªçi API v√† c·∫≠p nh·∫≠t b·ªô ƒë·∫øm.
        """
        try:
            if self.stop_event.is_set():
                logging.debug(f"B·ªè qua theo d√µi API cho '{service_name}' v√¨ ·ª©ng d·ª•ng ƒëang ƒë√≥ng.")
                return

            current_month_key = datetime.now().strftime("%Y-%m")

            if "api_stats" not in self.cfg:
                self.cfg["api_stats"] = {}

            if current_month_key not in self.cfg["api_stats"]:
                logging.info(f"Ph√°t hi·ªán th√°ng m·ªõi ({current_month_key}). ƒêang reset b·ªô ƒë·∫øm API.")
                self.cfg["api_stats"] = {
                    current_month_key: {
                        "gemini_calls": 0,
                        "openai_calls": 0,
                        "openai_tts_chars": 0,
                        "dalle_images": 0,
                        "imagen_images": 0,
                        "google_tts_chars": 0,
                        "google_translate_chars": 0
                    }
                }

            current_count = self.cfg["api_stats"][current_month_key].get(service_name, 0)
            self.cfg["api_stats"][current_month_key][service_name] = current_count + units

            if not self.stop_event.is_set():
                self.after(0, self._update_api_stats_display)

        except Exception as e:
            logging.error(f"L·ªói khi theo d√µi API call cho '{service_name}': {e}", exc_info=True)


#  L·∫•y d·ªØ li·ªáu t·ª´ self.cfg v√† c·∫≠p nh·∫≠t nh√£n th·ªëng k√™ API.
    def _update_api_stats_display(self):
        """
        (ƒê√É N√ÇNG C·∫§P V·ªöI ∆Ø·ªöC T√çNH CHI PH√ç V√Ä TH·ªêNG K√ä K√ù T·ª∞)
        L·∫•y d·ªØ li·ªáu t·ª´ self.cfg, t√≠nh to√°n chi ph√≠ ∆∞·ªõc t√≠nh, v√† c·∫≠p nh·∫≠t nh√£n th·ªëng k√™ API.
        """
        if not hasattr(self, 'api_stats_var') or not self.api_stats_var:
            return

        current_month_key = datetime.now().strftime("%Y-%m")
        monthly_stats = self.cfg.get("api_stats", {}).get(current_month_key, {})
        
        total_cost_usd = 0.0

        # --- T√≠nh to√°n chi ph√≠ cho t·ª´ng d·ªãch v·ª• ---
        # Google
        google_tts_chars = monthly_stats.get("google_tts_chars", 0)
        google_translate_chars = monthly_stats.get("google_translate_chars", 0)
        google_total_chars = google_tts_chars + google_translate_chars
        
        google_tts_cost = (google_tts_chars / 1_000_000) * API_PRICING_USD["google_tts_chars_per_million"]
        google_translate_cost = (google_translate_chars / 1_000_000) * API_PRICING_USD["google_translate_chars_per_million"]
        imagen_cost = monthly_stats.get("imagen_images", 0) * API_PRICING_USD["imagen_images_per_image"]
        gemini_cost = monthly_stats.get("gemini_calls", 0) * API_PRICING_USD["gemini_calls_per_call_estimate"]
        total_cost_usd += google_tts_cost + google_translate_cost + imagen_cost + gemini_cost

        # OpenAI
        openai_tts_chars = monthly_stats.get("openai_tts_chars", 0)
        
        openai_tts_cost = (openai_tts_chars / 1_000_000) * API_PRICING_USD["openai_tts_chars_per_million"]
        dalle_cost = monthly_stats.get("dalle_images", 0) * API_PRICING_USD["dalle_images_per_image"]
        openai_calls_cost = monthly_stats.get("openai_calls", 0) * API_PRICING_USD["openai_calls_per_call_estimate"]
        total_cost_usd += openai_tts_cost + dalle_cost + openai_calls_cost

        # Chuy·ªÉn ƒë·ªïi sang VNƒê v√† ƒë·ªãnh d·∫°ng
        total_cost_vnd = total_cost_usd * API_PRICING_USD["USD_TO_VND_RATE"]
        cost_str_vnd = f"{total_cost_vnd:,.0f} VNƒê"

        # --- T·∫°o chu·ªói hi·ªÉn th·ªã ---
        gemini_calls = monthly_stats.get("gemini_calls", 0)
        openai_calls = monthly_stats.get("openai_calls", 0)
        imagen_images = monthly_stats.get("imagen_images", 0)
        
        # T·∫°o chu·ªói hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß h∆°n
        display_string = (
            f"üìä API T.{datetime.now().month}: "
            f"Gemini: {gemini_calls:,} | "
            #f"OpenAI: {openai_calls:,} | "
            f"Imagen: {imagen_images:,} ·∫£nh | "
            f"Google Chars: {google_total_chars:,} | "
            f"üí≤: {cost_str_vnd}"
        )
        
        self.api_stats_var.set(display_string)


#---------------------

# Nh√≥m h√†m cho ch·ª©c nƒÉng L∆∞u Preset
    def _save_project_preset(self):
        """
        M·ªü h·ªôp tho·∫°i ƒë·ªÉ ng∆∞·ªùi d√πng l∆∞u to√†n b·ªô c·∫•u h√¨nh hi·ªán t·∫°i v√†o m·ªôt file preset.
        """
        logging.info("Y√™u c·∫ßu l∆∞u Preset d·ª± √°n...")

        # 1) C·∫≠p nh·∫≠t self.cfg t·ª´ UI
        self.save_current_config()

        # 1.1) √âp ch·∫Øc 3 gi√° tr·ªã nh·∫°y c·∫£m v√†o self.cfg tr∆∞·ªõc khi dump
        try:
            if hasattr(self, 'openai_key_var'):
                self.cfg["openai_api_key"] = (self.openai_key_var.get() or "").strip()
            if hasattr(self, 'gemini_key_var'):
                self.cfg["gemini_api_key"] = (self.gemini_key_var.get() or "").strip()
            if hasattr(self, 'google_key_path_var'):
                self.cfg["google_service_account_path"] = (self.google_key_path_var.get() or "").strip()
        except Exception as e:
            logging.warning(f"[Preset] Kh√¥ng th·ªÉ ƒë·ªçc key/ƒë∆∞·ªùng d·∫´n t·ª´ UI: {e}")

        # 2) H·ªôp tho·∫°i "Save As"
        file_path = filedialog.asksaveasfilename(
            title="L∆∞u Preset C√†i ƒë·∫∑t D·ª± √°n",
            initialdir=self.output_path_var.get() or get_default_downloads_folder(),
            initialfile="Preset_DuAn_CuaToi.json",
            defaultextension=".json",
            filetypes=[("Piu Preset Files", "*.json"), ("All files", "*.*")],
            parent=self
        )

        if not file_path:
            logging.info("Ng∆∞·ªùi d√πng ƒë√£ h·ªßy l∆∞u Preset.")
            return

        # 3) Ghi d·ªØ li·ªáu t·ª´ self.cfg v√†o file ƒë√£ ch·ªçn
        try:
            # (tu·ª≥ ch·ªçn) log ki·ªÉm tra nhanh, kh√¥ng l·ªô key
            logging.debug("[Preset] L∆∞u preset v·ªõi: "
                          f"openai={'***' if self.cfg.get('openai_api_key') else '(empty)'}; "
                          f"gemini={'***' if self.cfg.get('gemini_api_key') else '(empty)'}; "
                          f"gjson={bool(self.cfg.get('google_service_account_path'))}")

            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(self.cfg, f, ensure_ascii=False, indent=2)

            messagebox.showinfo("L∆∞u th√†nh c√¥ng",
                                f"ƒê√£ l∆∞u th√†nh c√¥ng Preset v√†o:\n{os.path.basename(file_path)}",
                                parent=self)
            logging.info(f"ƒê√£ l∆∞u th√†nh c√¥ng Preset d·ª± √°n t·∫°i: {file_path}")
            self.update_status(f"‚úÖ ƒê√£ l∆∞u Preset: {os.path.basename(file_path)}")

        except Exception as e:
            logging.error(f"L·ªói khi l∆∞u file Preset '{file_path}': {e}", exc_info=True)
            messagebox.showerror("L·ªói L∆∞u Preset",
                                 f"Kh√¥ng th·ªÉ l∆∞u file Preset.\nL·ªói: {e}",
                                 parent=self)



# M·ªü h·ªôp tho·∫°i ƒë·ªÉ ng∆∞·ªùi d√πng ch·ªçn v√† t·∫£i m·ªôt file preset c√†i ƒë·∫∑t
    def _load_project_preset(self):
        """
        M·ªü h·ªôp tho·∫°i ƒë·ªÉ ng∆∞·ªùi d√πng ch·ªçn v√† t·∫£i m·ªôt file preset c√†i ƒë·∫∑t.
        (ƒê√É S·ª¨A L·ªñI: B·∫£o to√†n th·ªëng k√™ API v√† kh√¥ng l√†m m·∫•t API keys/Google JSON n·∫øu preset thi·∫øu.)
        >>> PHI√äN B·∫¢N HO√ÄN CH·ªàNH: T·ª± ƒë·ªông t·∫£i l·∫°i metadata v√† l√†m m·ªõi UI. <<<
        """
        logging.info("Y√™u c·∫ßu t·∫£i Preset d·ª± √°n...")
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn File Preset ƒë·ªÉ T·∫£i",
            filetypes=[("Piu Preset Files", "*.json"), ("All files", "*.*")],
            parent=self
        )

        if not file_path:
            logging.info("Ng∆∞·ªùi d√πng ƒë√£ h·ªßy t·∫£i Preset.")
            return

        try:
            # B∆∞·ªõc 1: Sao l∆∞u 'api_stats' v√† c√°c key quan tr·ªçng hi·ªán t·∫°i
            current_api_stats = self.cfg.get("api_stats", {})
            
            def _safe_get(var_name, cfg_key):
                try:
                    var = getattr(self, var_name, None)
                    if var is not None:
                        val = var.get()
                        return (val or "").strip()
                except Exception:
                    pass
                return (self.cfg.get(cfg_key) or "").strip()

            current_openai = _safe_get('openai_key_var', 'openai_api_key')
            current_gemini = _safe_get('gemini_key_var', 'gemini_api_key')
            current_google_json = _safe_get('google_key_path_var', 'google_service_account_path')

            with open(file_path, 'r', encoding='utf-8') as f:
                loaded_data = json.load(f)

            # B∆∞·ªõc 2: H·ª£p nh·∫•t d·ªØ li·ªáu
            merged = dict(self.cfg)
            merged.update(loaded_data)

            if not (loaded_data.get("openai_api_key") or "").strip():
                merged["openai_api_key"] = current_openai
            if not (loaded_data.get("gemini_api_key") or "").strip():
                merged["gemini_api_key"] = current_gemini
            if not (loaded_data.get("google_service_account_path") or "").strip():
                merged["google_service_account_path"] = current_google_json

            # B∆∞·ªõc 3: Ph·ª•c h·ªìi 'api_stats'
            if current_api_stats:
                merged["api_stats"] = current_api_stats

            # C·∫≠p nh·∫≠t c·∫•u h√¨nh & √°p d·ª•ng l√™n UI
            self.cfg = merged
            self._apply_config_to_ui(self.cfg)
            
            # 1. N·∫°p l·∫°i cache metadata trong n·ªÅn t·ª´ ƒë∆∞·ªùng d·∫´n m·ªõi
            self._load_master_metadata_cache()
            logging.info("ƒê√£ n·∫°p l·∫°i master_metadata_cache t·ª´ preset m·ªõi.")

            # 2. KI·ªÇM TRA V√Ä L√ÄM M·ªöI C·ª¨A S·ªî METADATA N·∫æU N√ì ƒêANG M·ªû
            if hasattr(self, '_metadata_manager_win') and self._metadata_manager_win and self._metadata_manager_win.winfo_exists():
                logging.info("Ph√°t hi·ªán c·ª≠a s·ªï Metadata ƒëang m·ªü. Y√™u c·∫ßu t·∫£i l·∫°i d·ªØ li·ªáu tr√™n giao di·ªán...")
                new_path = self.cfg.get('last_master_metadata_path')
                if new_path:
                    # G·ªçi h√†m c·ªßa c·ª≠a s·ªï Metadata ƒë·ªÉ n√≥ t·ª± v·∫Ω l·∫°i giao di·ªán
                    self._metadata_manager_win._load_and_populate_from_path(new_path)

            messagebox.showinfo("T·∫£i th√†nh c√¥ng",
                                f"ƒê√£ t·∫£i v√† √°p d·ª•ng th√†nh c√¥ng Preset t·ª´:\n{os.path.basename(file_path)}",
                                parent=self)
            logging.info(f"ƒê√£ √°p d·ª•ng th√†nh c√¥ng Preset t·ª´: {file_path}")
            self.update_status(f"‚úÖ ƒê√£ t·∫£i Preset: {os.path.basename(file_path)}")

        except json.JSONDecodeError as e:
            messagebox.showerror("L·ªói File JSON",
                                 f"File Preset kh√¥ng h·ª£p l·ªá ho·∫∑c b·ªã l·ªói.\nL·ªói: {e}",
                                 parent=self)
        except Exception as e:
            logging.error(f"L·ªói khi t·∫£i ho·∫∑c √°p d·ª•ng file Preset '{file_path}': {e}", exc_info=True)
            messagebox.showerror("L·ªói T·∫£i Preset",
                                 f"Kh√¥ng th·ªÉ √°p d·ª•ng file Preset.\nL·ªói: {e}",
                                 parent=self)


#  H√†m "nh·∫°c tr∆∞·ªüng": Nh·∫≠n m·ªôt dictionary config v√† √°p d·ª•ng c√°c gi√° tr·ªã c·ªßa n√≥
    def _apply_config_to_ui(self, new_cfg):
        """
        H√†m "nh·∫°c tr∆∞·ªüng": Nh·∫≠n m·ªôt dictionary config v√† √°p d·ª•ng c√°c gi√° tr·ªã c·ªßa n√≥
        l√™n t·∫•t c·∫£ c√°c bi·∫øn v√† widget t∆∞∆°ng ·ª©ng tr√™n giao di·ªán.
        (PHI√äN B·∫¢N HO√ÄN CH·ªàNH)
        """
        logging.info("B·∫Øt ƒë·∫ßu √°p d·ª•ng c·∫•u h√¨nh m·ªõi t·ª´ file preset v√†o giao di·ªán...")
        
        # ƒê·∫∑t m·ªôt c·ªù ƒë·ªÉ c√°c h√†m trace_add kh√¥ng l∆∞u l·∫°i config ngay l·∫≠p t·ª©c
        self._is_restoring_task_config = True

        try:
            # --- C√†i ƒë·∫∑t chung ---
            self.change_appearance_mode_event(new_cfg.get("appearance_mode", "dark"))
            if hasattr(self, 'limit_cpu_var'):
                self.limit_cpu_var.set(new_cfg.get("limit_cpu_usage", True))

            # --- C√†i ƒë·∫∑t API Keys ---
            # --- Ch·ªâ set n·∫øu preset c√≥ gi√° tr·ªã; n·∫øu preset thi·∫øu/r·ªóng th√¨ gi·ªØ nguy√™n UI ---
            def _set_var_if_nonempty(var, val):
                if val is not None and str(val).strip() != "":
                    var.set(val)

            if hasattr(self, 'openai_key_var'):
                _set_var_if_nonempty(self.openai_key_var, new_cfg.get("openai_api_key"))
            if hasattr(self, 'gemini_key_var'):
                _set_var_if_nonempty(self.gemini_key_var, new_cfg.get("gemini_api_key"))
            if hasattr(self, 'google_key_path_var'):
                _set_var_if_nonempty(self.google_key_path_var, new_cfg.get("google_service_account_path"))

            # --- Tab T·∫£i Xu·ªëng ---
            if hasattr(self, 'download_playlist_var'):
                self.download_playlist_var.set(new_cfg.get("download_playlist", False))
            if hasattr(self, 'download_path_var'):
                self.download_path_var.set(new_cfg.get("download_path", get_default_downloads_folder()))
            if hasattr(self, 'download_mode_var'):
                self.download_mode_var.set(new_cfg.get("download_mode", "video"))
            if hasattr(self, 'download_video_quality_var'):
                self.download_video_quality_var.set(new_cfg.get("download_video_quality", "1080p"))
            if hasattr(self, 'download_audio_quality_var'):
                self.download_audio_quality_var.set(new_cfg.get("download_audio_quality", "320k"))
            if hasattr(self, 'download_sound_var'):
                self.download_sound_var.set(new_cfg.get("download_sound_enabled", False))
            if hasattr(self, 'download_sound_path_var'):
                self.download_sound_path_var.set(new_cfg.get("download_sound_path", ""))
            if hasattr(self, 'download_shutdown_var'):
                self.download_shutdown_var.set(new_cfg.get("download_shutdown_enabled", False))
            if hasattr(self, 'download_rename_var'):
                self.download_rename_var.set(new_cfg.get("download_rename_enabled", False))
            if hasattr(self, 'download_rename_box_var'):
                self.download_rename_box_var.set(new_cfg.get("download_rename_base_name", ""))
            if hasattr(self, 'download_stop_on_error_var'):
                self.download_stop_on_error_var.set(new_cfg.get("download_stop_on_error", False))
            if hasattr(self, 'sheet_id_var'):
                self.sheet_id_var.set(new_cfg.get("sheet_id", ""))
            if hasattr(self, 'sheet_range_var'):
                self.sheet_range_var.set(new_cfg.get("sheet_range", "Sheet1!B2:B"))
            if hasattr(self, 'disable_auto_sheet_check_var'):
                self.disable_auto_sheet_check_var.set(new_cfg.get("disable_auto_sheet_check", False))
            if hasattr(self, 'download_auto_dub_after_sub_var'):
                self.download_auto_dub_after_sub_var.set(new_cfg.get("download_auto_dub_after_sub", False))
            if hasattr(self, 'download_use_cookies_var'):
                self.download_use_cookies_var.set(new_cfg.get("download_use_cookies", False))
            if hasattr(self, 'download_cookies_path_var'):
                self.download_cookies_path_var.set(new_cfg.get("download_cookies_path", ""))                

            # --- Tab Ph·ª• ƒê·ªÅ ---
            if hasattr(self, 'source_lang_var'):
                self.source_lang_var.set(new_cfg.get("language", "auto"))
            if hasattr(self, 'model_var'):
                self.model_var.set(new_cfg.get("model", "medium"))
            if hasattr(self, 'format_var'):
                self.format_var.set(new_cfg.get("format", "srt"))
            if hasattr(self, 'output_path_var'):
                self.output_path_var.set(new_cfg.get("output_path", get_default_downloads_folder()))
            if hasattr(self, 'merge_sub_var'):
                self.merge_sub_var.set(new_cfg.get("merge_mode", "Kh√¥ng g·ªôp"))
            if hasattr(self, 'bilingual_var'):
                self.bilingual_var.set(new_cfg.get("bilingual", False))
            if hasattr(self, 'target_lang_var'):
                self.target_lang_var.set(new_cfg.get("target_lang", "vi"))
            if hasattr(self, 'enable_split_var'):
                self.enable_split_var.set(new_cfg.get("split", False))
            if hasattr(self, 'max_chars_var'):
                self.max_chars_var.set(str(new_cfg.get("max_chars", 90)))
            if hasattr(self, 'max_lines_var'):
                self.max_lines_var.set(str(new_cfg.get("max_lines", 1)))
            if hasattr(self, 'split_mode_var'):
                self.split_mode_var.set(new_cfg.get("split_mode", "char"))
            if hasattr(self, 'manual_merge_mode_var'):
                self.manual_merge_mode_var.set(new_cfg.get("manual_merge_mode", False))
            if hasattr(self, 'sub_cps_for_timing_var'):
                self.sub_cps_for_timing_var.set(str(new_cfg.get("sub_cps_for_timing", 17)))
            if hasattr(self, 'save_in_media_folder_var'):
                self.save_in_media_folder_var.set(new_cfg.get("save_in_media_folder", False))
            if hasattr(self, 'optimize_whisper_tts_voice_var'):
                self.optimize_whisper_tts_voice_var.set(new_cfg.get("optimize_whisper_tts_voice", False))
            if hasattr(self, 'auto_format_plain_text_to_srt_var'):
                self.auto_format_plain_text_to_srt_var.set(new_cfg.get("auto_format_plain_text_to_srt", False))
            if hasattr(self, 'gpt_model_for_script_editing_var'):
                self.gpt_model_for_script_editing_var.set(new_cfg.get("gpt_model_for_script_editing", "gpt-3.5-turbo"))
            if hasattr(self, 'gemini_model_for_script_editing_var'):
                # L·∫•y model m·∫∑c ƒë·ªãnh t·ª´ danh s√°ch c√≥ s·∫µn ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n
                default_gemini_model = self.AVAILABLE_GEMINI_MODELS_FOR_SCRIPT_EDITING[0]
                self.gemini_model_for_script_editing_var.set(new_cfg.get("gemini_model_for_script_editing", default_gemini_model))                
            if hasattr(self, 'translation_engine_var'):
                self.translation_engine_var.set(new_cfg.get("translation_engine", "Kh√¥ng d·ªãch"))
            if hasattr(self, 'openai_translation_style_var'):
                self.openai_translation_style_var.set(new_cfg.get("openai_translation_style", "M·∫∑c ƒë·ªãnh (trung t√≠nh)"))
            if hasattr(self, 'pause_for_edit_var'):
                self.pause_for_edit_var.set(new_cfg.get("pause_for_edit", False))

            # --- C√†i ƒë·∫∑t Nh·ªãp ƒëi·ªáu & T·ªëc ƒë·ªô ƒê·ªçc (N√¢ng cao) ---
            if hasattr(self, 'sub_pacing_pause_medium_ms_var'):
                self.sub_pacing_pause_medium_ms_var.set(str(new_cfg.get("sub_pacing_pause_medium_ms", 150)))
            if hasattr(self, 'sub_pacing_pause_period_ms_var'):
                self.sub_pacing_pause_period_ms_var.set(str(new_cfg.get("sub_pacing_pause_period_ms", 300)))
            if hasattr(self, 'sub_pacing_pause_question_ms_var'):
                self.sub_pacing_pause_question_ms_var.set(str(new_cfg.get("sub_pacing_pause_question_ms", 450)))
            if hasattr(self, 'sub_pacing_long_sentence_threshold_var'):
                self.sub_pacing_long_sentence_threshold_var.set(str(new_cfg.get("sub_pacing_long_sentence_threshold", 55)))
            if hasattr(self, 'sub_pacing_fast_cps_multiplier_var'):
                self.sub_pacing_fast_cps_multiplier_var.set(str(new_cfg.get("sub_pacing_fast_cps_multiplier", 1.1)))
                
            # --- Tab Thuy·∫øt Minh ---
            if hasattr(self, 'dub_output_path_var'):
                self.dub_output_path_var.set(new_cfg.get("dub_output_path", get_default_downloads_folder()))
            
            if hasattr(self, 'dub_selected_tts_engine_var'):
                # 1. ƒê·∫∑t bi·∫øn engine
                selected_engine = new_cfg.get("dub_tts_engine", "Google Translate (gTTS)")
                self.dub_selected_tts_engine_var.set(selected_engine)

                # 2. B·∫Øt bu·ªôc c·∫≠p nh·∫≠t danh s√°ch gi·ªçng ƒë·ªçc cho engine ƒë√£ ch·ªçn
                if hasattr(self, 'dub_on_tts_engine_selected'):
                    self.dub_on_tts_engine_selected(selected_engine, _from_task_setup=True)
            
            # 3. ƒê·∫∑t ID c·ªßa gi·ªçng ƒë·ªçc ƒë√£ l∆∞u
            if hasattr(self, 'dub_selected_voice_id_var'):
                selected_voice_id = new_cfg.get("dub_selected_voice_id", "")
                self.dub_selected_voice_id_var.set(selected_voice_id)

            # 4. T√¨m t√™n hi·ªÉn th·ªã t∆∞∆°ng ·ª©ng v·ªõi ID v√† ƒë·∫∑t n√≥ cho menu (D√πng self.after ƒë·ªÉ ƒë·∫£m b·∫£o menu ƒë√£ c·∫≠p nh·∫≠t)
            def _set_display_name_from_preset():
                final_display_name = ""
                loaded_voice_id = self.dub_selected_voice_id_var.get()
                
                # T√¨m t√™n hi·ªÉn th·ªã t∆∞∆°ng ·ª©ng v·ªõi ID gi·ªçng ƒë·ªçc ƒë√£ l∆∞u
                if hasattr(self, 'dub_current_engine_voice_display_to_id_map') and loaded_voice_id:
                    for name, v_id in self.dub_current_engine_voice_display_to_id_map.items():
                        if v_id == loaded_voice_id:
                            final_display_name = name
                            break
                
                # ƒê·∫∑t t√™n hi·ªÉn th·ªã cho menu
                if final_display_name:
                    self.dub_selected_voice_display_name_var.set(final_display_name)
                else:
                    first_choice = None
                    try:
                        if hasattr(self, 'dub_voice_option_menu'):
                            if hasattr(self.dub_voice_option_menu, 'filtered_list') and self.dub_voice_option_menu.filtered_list:
                                candidates = [n for n in self.dub_voice_option_menu.filtered_list if not n.startswith('---')]
                                if candidates:
                                    first_choice = candidates[0]
                            elif hasattr(self.dub_voice_option_menu, 'values_dict') and self.dub_voice_option_menu.values_dict:
                                candidates = [n for n in self.dub_voice_option_menu.values_dict.keys() if not n.startswith('---')]
                                if candidates:
                                    first_choice = candidates[0]
                    except Exception:
                        pass
                    if first_choice:
                        self.dub_selected_voice_display_name_var.set(first_choice)
                    else:
                        self.dub_selected_voice_display_name_var.set("N/A")
                

                # --- B·∫ÆT ƒê·∫¶U KH·ªêI LOGIC S·ª¨A L·ªñI SSML ---
                ssml_checkbox = getattr(self, 'dub_chk_use_google_ssml', None)
                if ssml_checkbox and ssml_checkbox.winfo_exists():
                    is_chirp_voice = "chirp" in self.dub_selected_voice_id_var.get().lower()
                    
                    if is_chirp_voice:
                        # N·∫øu l√† gi·ªçng Chirp, B·∫ÆT BU·ªòC t·∫Øt v√† v√¥ hi·ªáu h√≥a SSML
                        ssml_checkbox.configure(state="disabled", text="SSML kh√¥ng h·ªó tr·ª£ cho gi·ªçng Chirp")
                        self.dub_use_google_ssml_var.set(False)
                    else:
                        # N·∫øu KH√îNG ph·∫£i Chirp, b·∫≠t l·∫°i v√† √°p d·ª•ng gi√° tr·ªã t·ª´ preset
                        ssml_checkbox.configure(state="normal", text="T·∫°o SSML c∆° b·∫£n (Google TTS)")
                        # L·∫•y gi√° tr·ªã SSML ƒë√£ l∆∞u trong file preset (new_cfg)
                        ssml_enabled_in_preset = new_cfg.get("dub_use_google_ssml", False)
                        self.dub_use_google_ssml_var.set(ssml_enabled_in_preset)
                # --- K·∫æT TH√öC KH·ªêI LOGIC S·ª¨A L·ªñI SSML ---
                
                logging.info(f"Preset Load: ƒê√£ ƒë·∫∑t gi·ªçng ƒë·ªçc hi·ªÉn th·ªã th√†nh '{self.dub_selected_voice_display_name_var.get()}' (t·ª´ ID: '{loaded_voice_id}')")

            self.after(50, _set_display_name_from_preset)

            if hasattr(self, 'dub_use_google_ssml_var'):
                self.dub_use_google_ssml_var.set(new_cfg.get("dub_use_google_ssml", False))
            if hasattr(self, 'dub_sync_tolerance_ms_var'):
                self.dub_sync_tolerance_ms_var.set(str(new_cfg.get("dub_sync_tolerance_ms", 20)))
            if hasattr(self, 'dub_sync_max_speed_up_var'):
                self.dub_sync_max_speed_up_var.set(str(new_cfg.get("dub_sync_max_speed_up", 1.50)))
            if hasattr(self, 'dub_sync_min_speed_down_var'):
                self.dub_sync_min_speed_down_var.set(str(new_cfg.get("dub_sync_min_speed_down_val", "1.0")))
            if hasattr(self, 'dub_sync_force_cut_if_over_srt_duration_var'):
                self.dub_sync_force_cut_if_over_srt_duration_var.set(new_cfg.get("dub_sync_force_cut_if_over_srt_duration", True))
            if hasattr(self, 'dub_sync_min_srt_duration_for_adjust_ms_var'):
                self.dub_sync_min_srt_duration_for_adjust_ms_var.set(str(new_cfg.get("dub_sync_min_srt_duration_for_adjust_ms", 200)))
            if hasattr(self, 'dub_sync_pad_short_tts_var'):
                self.dub_sync_pad_short_tts_var.set(new_cfg.get("dub_sync_pad_short_tts", True))
            if hasattr(self, 'dub_min_gap_between_segments_ms_var'):
                self.dub_min_gap_between_segments_ms_var.set(str(new_cfg.get("dub_min_gap_between_segments_ms", 0)))
            if hasattr(self, 'dub_audio_fade_in_duration_s_var'):
                self.dub_audio_fade_in_duration_s_var.set(str(new_cfg.get("dub_audio_fade_in_duration_s", 0.05)))
            if hasattr(self, 'dub_audio_fade_out_duration_s_var'):
                self.dub_audio_fade_out_duration_s_var.set(str(new_cfg.get("dub_audio_fade_out_duration_s", 0.03)))
            if hasattr(self, 'dub_show_advanced_audio_settings_var'):
                self.dub_show_advanced_audio_settings_var.set(new_cfg.get("dub_show_advanced_audio_settings", False))
            if hasattr(self, 'dub_background_audio_option_var'):
                self.dub_background_audio_option_var.set(new_cfg.get("dub_background_audio_option", "Tr·ªôn v·ªõi √¢m thanh g·ªëc (m·ª©c nh·ªè)"))
            if hasattr(self, 'dub_background_mix_level_var'):
                self.dub_background_mix_level_var.set(new_cfg.get("dub_background_mix_level", 0.30))
            if hasattr(self, 'dub_use_custom_bg_music_var'):
                self.dub_use_custom_bg_music_var.set(new_cfg.get("dub_use_custom_bg_music", False))
            if hasattr(self, 'dub_custom_bg_music_path_var'):
                self.dub_custom_bg_music_path_var.set(new_cfg.get("dub_custom_bg_music_path", ""))
            if hasattr(self, 'dub_custom_bg_music_volume_percent_str_var'):
                self.dub_custom_bg_music_volume_percent_str_var.set(str(int(new_cfg.get("dub_custom_bg_volume", 0.25) * 100)))
            if hasattr(self, 'dub_custom_bg_music_folder_path_var'):
                self.dub_custom_bg_music_folder_path_var.set(new_cfg.get("dub_custom_bg_music_folder_path", ""))
            if hasattr(self, 'dub_randomize_bg_music_var'):
                self.dub_randomize_bg_music_var.set(new_cfg.get("dub_randomize_bg_music", False))
            if hasattr(self, 'dub_use_image_folder_var'):
                self.dub_use_image_folder_var.set(new_cfg.get("dub_use_image_folder", False))
            if hasattr(self, 'dub_selected_image_folder_path_var'):
                self.dub_selected_image_folder_path_var.set(new_cfg.get("dub_slideshow_image_folder", ""))
            if hasattr(self, 'optimize_dub_flow_var'):
                self.optimize_dub_flow_var.set(new_cfg.get("optimize_dub_flow_enabled", False))
            if hasattr(self, 'dub_force_recalculate_timing_var'):
                self.dub_force_recalculate_timing_var.set(new_cfg.get("dub_force_recalculate_timing", False))
            if hasattr(self, 'dub_split_enabled_for_flow_var'):
                self.dub_split_enabled_for_flow_var.set(new_cfg.get("dub_split_enabled_for_flow", True))
            if hasattr(self, 'dub_max_chars_for_flow_var'):
                self.dub_max_chars_for_flow_var.set(str(new_cfg.get("dub_max_chars_for_flow", 999)))
            if hasattr(self, 'dub_max_lines_for_flow_var'):
                self.dub_max_lines_for_flow_var.set(str(new_cfg.get("dub_max_lines_for_flow", 1)))
            if hasattr(self, 'dub_split_mode_for_flow_var'):
                self.dub_split_mode_for_flow_var.set(new_cfg.get("dub_split_mode_for_flow", "underthesea (Ti·∫øng Vi·ªát)"))
            if hasattr(self, 'dub_auto_optimize_on_paste_var'):
                self.dub_auto_optimize_on_paste_var.set(new_cfg.get("dub_auto_optimize_on_paste", False))
            if hasattr(self, 'dub_cps_for_timing_var'):
                self.dub_cps_for_timing_var.set(str(new_cfg.get("dub_cps_for_timing", 17)))
            self.after(100, self._update_ssml_checkbox_state)                

            # --- Style Ph·ª• ƒë·ªÅ ---
            if hasattr(self, 'sub_style_font_name_var'):
                self.sub_style_font_name_var.set(new_cfg.get("sub_style_font_name", "Arial"))
            if hasattr(self, 'sub_style_font_size_var'):
                self.sub_style_font_size_var.set(new_cfg.get("sub_style_font_size", 60))
            if hasattr(self, 'sub_style_font_bold_var'):
                self.sub_style_font_bold_var.set(new_cfg.get("sub_style_font_bold", True))
            if hasattr(self, 'sub_style_text_color_rgb_str_var'):
                self.sub_style_text_color_rgb_str_var.set(new_cfg.get("sub_style_text_color_rgb_str", "255,255,255"))
            if hasattr(self, 'sub_style_text_opacity_percent_var'):
                self.sub_style_text_opacity_percent_var.set(new_cfg.get("sub_style_text_opacity_percent", 100))
            if hasattr(self, 'sub_style_background_mode_var'):
                self.sub_style_background_mode_var.set(new_cfg.get("sub_style_background_mode", "ƒê·ªï B√≥ng"))
            if hasattr(self, 'sub_style_bg_color_rgb_str_var'):
                self.sub_style_bg_color_rgb_str_var.set(new_cfg.get("sub_style_bg_color_rgb_str", "0,0,0"))
            if hasattr(self, 'sub_style_bg_box_actual_opacity_percent_var'):
                self.sub_style_bg_box_actual_opacity_percent_var.set(new_cfg.get("sub_style_bg_box_actual_opacity_percent", 75))
            if hasattr(self, 'sub_style_outline_enabled_var'):
                self.sub_style_outline_enabled_var.set(new_cfg.get("sub_style_outline_enabled", False))
            if hasattr(self, 'sub_style_outline_size_var'):
                self.sub_style_outline_size_var.set(new_cfg.get("sub_style_outline_size", 2.0))
            if hasattr(self, 'sub_style_outline_color_rgb_str_var'):
                self.sub_style_outline_color_rgb_str_var.set(new_cfg.get("sub_style_outline_color_rgb_str", "0,0,0"))
            if hasattr(self, 'sub_style_outline_opacity_percent_var'):
                self.sub_style_outline_opacity_percent_var.set(new_cfg.get("sub_style_outline_opacity_percent", 100))
            if hasattr(self, 'sub_style_marginv_var'):
                self.sub_style_marginv_var.set(new_cfg.get("margin_v", 60))

            # --- Branding ---
            if hasattr(self, 'branding_intro_enabled_var'):
                self.branding_intro_enabled_var.set(new_cfg.get("branding_intro_enabled", False))
            if hasattr(self, 'branding_intro_path_var'):
                self.branding_intro_path_var.set(new_cfg.get("branding_intro_path", ""))
            if hasattr(self, 'branding_outro_enabled_var'):
                self.branding_outro_enabled_var.set(new_cfg.get("branding_outro_enabled", False))
            if hasattr(self, 'branding_outro_path_var'):
                self.branding_outro_path_var.set(new_cfg.get("branding_outro_path", ""))
            if hasattr(self, 'branding_logo_enabled_var'):
                self.branding_logo_enabled_var.set(new_cfg.get("branding_logo_enabled", False))
            if hasattr(self, 'branding_logo_path_var'):
                self.branding_logo_path_var.set(new_cfg.get("branding_logo_path", ""))
            if hasattr(self, 'branding_logo_position_var'):
                self.branding_logo_position_var.set(new_cfg.get("branding_logo_position", "bottom_right"))
            if hasattr(self, 'branding_logo_opacity_var'):
                self.branding_logo_opacity_var.set(new_cfg.get("branding_logo_opacity_percent", 80))
            if hasattr(self, 'branding_logo_size_percent_var'):
                self.branding_logo_size_percent_var.set(new_cfg.get("branding_logo_size_percent", 10))
            if hasattr(self, 'branding_logo_margin_px_var'):
                self.branding_logo_margin_px_var.set(new_cfg.get("branding_logo_margin_px", 10))
            # T·∫£i c·∫•u h√¨nh Intro t·ª´ ·∫£nh
            if hasattr(self, 'branding_intro_from_image_enabled_var'):
                self.branding_intro_from_image_enabled_var.set(new_cfg.get("branding_intro_from_image_enabled", False))
            if hasattr(self, 'branding_intro_image_path_var'):
                self.branding_intro_image_path_var.set(new_cfg.get("branding_intro_image_path", ""))
            if hasattr(self, 'branding_intro_image_duration_var'):
                self.branding_intro_image_duration_var.set(str(new_cfg.get("branding_intro_image_duration_s", "5.0")))
            # T·∫£i c·∫•u h√¨nh Outro t·ª´ ·∫£nh
            if hasattr(self, 'branding_outro_from_image_enabled_var'):
                self.branding_outro_from_image_enabled_var.set(new_cfg.get("branding_outro_from_image_enabled", False))
            if hasattr(self, 'branding_outro_image_path_var'):
                self.branding_outro_image_path_var.set(new_cfg.get("branding_outro_image_path", ""))
            if hasattr(self, 'branding_outro_image_duration_var'):
                self.branding_outro_image_duration_var.set(str(new_cfg.get("branding_outro_image_duration_s", "5.0")))

            # --- Upload YouTube ---
            if hasattr(self, 'youtube_privacy_status_var'):
                self.youtube_privacy_status_var.set(new_cfg.get("youtube_default_privacy", "private"))
            if hasattr(self, 'youtube_playlist_var'):
                self.youtube_playlist_var.set(new_cfg.get("youtube_playlist_name", ""))
            if hasattr(self, 'auto_upload_to_youtube_var'):
                self.auto_upload_to_youtube_var.set(new_cfg.get("auto_upload_to_youtube", False))
            if hasattr(self, 'youtube_upload_method_var'):
                self.youtube_upload_method_var.set(new_cfg.get("youtube_upload_method", "api"))
            if hasattr(self, 'chrome_portable_path_var'):
                self.chrome_portable_path_var.set(new_cfg.get("chrome_portable_path", ""))
            if hasattr(self, 'chromedriver_path_var'):
                self.chromedriver_path_var.set(new_cfg.get("chromedriver_path", ""))
            if hasattr(self, 'youtube_headless_var'):
                self.youtube_headless_var.set(new_cfg.get("youtube_run_headless", True))
            if hasattr(self, 'youtube_title_var'):
                self.youtube_title_var.set(new_cfg.get("youtube_last_title", ""))
            if hasattr(self, 'youtube_tags_var'):
                self.youtube_tags_var.set(new_cfg.get("youtube_last_tags", ""))
            if hasattr(self, 'youtube_description_textbox'):
                self.youtube_description_textbox.delete("1.0", "end")
                self.youtube_description_textbox.insert("1.0", new_cfg.get("youtube_last_description", ""))
            if hasattr(self, 'youtube_autofill_var'):
                self.youtube_autofill_var.set(new_cfg.get("youtube_autofill_enabled", False))
            if hasattr(self, 'youtube_fetch_metadata_var'):
                self.youtube_fetch_metadata_var.set(new_cfg.get("youtube_fetch_metadata_enabled", False))
            if hasattr(self, 'youtube_add_end_screen_var'):
                self.youtube_add_end_screen_var.set(new_cfg.get("youtube_add_end_screen", False))
            if hasattr(self, 'youtube_add_cards_var'):
                self.youtube_add_cards_var.set(new_cfg.get("youtube_add_cards", False))
            if hasattr(self, 'metadata_auto_increment_thumb_var'):
                self.metadata_auto_increment_thumb_var.set(new_cfg.get("metadata_auto_increment_thumb", True))
                
            if hasattr(self, 'youtube_category_id_var') and hasattr(self, 'youtube_category_display_var'):
                
                # L·∫•y category ID t·ª´ preset ƒë√£ t·∫£i
                loaded_category_id = new_cfg.get("youtube_default_category_id", '24') # M·∫∑c ƒë·ªãnh l√† '24' (Gi·∫£i tr√≠)

                # 1. C·∫≠p nh·∫≠t bi·∫øn l∆∞u ID (quan tr·ªçng cho logic n·ªÅn)
                self.youtube_category_id_var.set(loaded_category_id)

                # 2. T√åM V√Ä C·∫¨P NH·∫¨T BI·∫æN HI·ªÇN TH·ªä TR√äN GIAO DI·ªÜN
                # L·∫•y t√™n hi·ªÉn th·ªã t·ª´ ID b·∫±ng c√°ch tra c·ª©u trong t·ª´ ƒëi·ªÉn YOUTUBE_CATEGORIES
                display_name = YOUTUBE_CATEGORIES.get(loaded_category_id, "Gi·∫£i tr√≠") # Fallback v·ªÅ 'Gi·∫£i tr√≠'

                # C·∫≠p nh·∫≠t bi·∫øn m√† OptionMenu ƒëang theo d√µi
                self.youtube_category_display_var.set(display_name)

            # T·∫£i c·∫•u h√¨nh Imagen
            if hasattr(self, 'imagen_min_scene_duration_var'):
                self.imagen_min_scene_duration_var.set(new_cfg.get("imagen_min_scene_duration", "Kh√¥ng gi·ªõi h·∫°n"))
            # Load Preset cho Imagen Motion
            if hasattr(self, 'imagen_motion_effect_var'):
                self.imagen_motion_effect_var.set(new_cfg.get("imagen_motion_effect", "Kh√¥ng c√≥"))
            if hasattr(self, 'imagen_motion_speed_var'):
                self.imagen_motion_speed_var.set(new_cfg.get("imagen_motion_speed", "V·ª´a"))

            # T·∫¢I C·∫§U H√åNH CHO TAB AI BI√äN T·∫¨P >>>
            if hasattr(self, 'ai_editor_view_frame'):
                aie = self.ai_editor_view_frame

                # 1) Load c√°c bi·∫øn UI theo preset (gi·ªØ nguy√™n logic c≈©)
                aie.output_folder_var.set(new_cfg.get("ai_editor_output_folder", get_default_downloads_folder()))
                aie.enable_production_chain_var.set(new_cfg.get("ai_editor_enable_chain", False))
                aie.production_chain_output_path_var.set(new_cfg.get("ai_editor_chain_output_path", ""))

                # --- T·∫¢I C√ÄI ƒê·∫∂T PRESET ---
                aie.rename_var.set(new_cfg.get("ai_editor_rename_enabled", False))
                aie.auto_naming_var.set(new_cfg.get("ai_editor_auto_naming_enabled", True))
                aie.rename_base_name_var.set(new_cfg.get("ai_editor_rename_base_name", ""))
                aie.series_name_var.set(new_cfg.get("ai_editor_series_name", "ƒê·∫•u Ph√° Th∆∞∆°ng Khung"))
                aie.start_chapter_var.set(new_cfg.get("ai_editor_start_chapter", "1"))
                aie.en_tts_mode_var.set(new_cfg.get("ai_editor_en_tts_mode", False))

                # 2) ƒê·ªìng b·ªô ENGINE + MODEL + PROMPT v√†o STATE (ƒë·ªÉ √°p d·ª•ng ngay, kh√¥ng c·∫ßn m·ªü popup)
                # Engine ƒëang d√πng
                engine_from_preset = new_cfg.get("last_used_ai_engine_aie", getattr(aie, "current_engine", "üíé Gemini"))
                aie.current_engine = engine_from_preset

                # (N·∫øu UI c√≥ combobox/var ch·ªçn engine th√¨ set cho kh·ªõp hi·ªÉn th·ªã)
                if hasattr(aie, "ai_engine_var"):
                    try:
                        aie.ai_engine_var.set(engine_from_preset)
                    except Exception:
                        pass

                # Model theo preset (n·∫øu c√≥ c√°c bi·∫øn model cho t·ª´ng engine)
                if hasattr(aie, 'gpt_model_var'):
                    aie.gpt_model_var.set(
                        new_cfg.get("gpt_model_for_aie", AIEditorTab.AVAILABLE_GPT_MODELS_FOR_SCRIPT_EDITING[0])
                    )
                if hasattr(aie, 'gemini_model_var'):
                    aie.gemini_model_var.set(
                        new_cfg.get("gemini_model_for_aie", AIEditorTab.AVAILABLE_GEMINI_MODELS_FOR_SCRIPT_EDITING[0])
                    )

                # Ch·ªçn key prompt theo engine
                # - N·∫øu t√™n engine ch·ª©a "Gemini" => d√πng key gemini
                # - N·∫øu ch·ª©a "GPT"/"OpenAI" => d√πng key gpt
                # - fallback: n·∫øu b·∫°n c√≥ engine kh√°c th√¨ d√πng key tu·ª≥ ch·ªânh
                if "Gemini" in engine_from_preset:
                    prompt_key = "last_used_gemini_prompt_ai_batch_editor"
                elif ("GPT" in engine_from_preset) or ("OpenAI" in engine_from_preset):
                    prompt_key = "last_used_gpt_prompt_ai_batch_editor"
                else:
                    prompt_key = "ai_editor_custom_prompt"

                preset_prompt = new_cfg.get(prompt_key, "")
                aie.current_prompt = preset_prompt  # <‚Äî quan tr·ªçng: state ch·∫°y th·ª±c t·∫ø

                # (N·∫øu UI c√≥ √¥ hi·ªÉn th·ªã prompt th√¨ set cho kh·ªõp hi·ªÉn th·ªã)
                # Th·ª≠ theo m·ªôt v√†i t√™n bi·∫øn hay d√πng; c√≥ c√°i n√†o th√¨ set c√°i ƒë√≥.
                for attr in ("prompt_text_var", "prompt_var", "aie_prompt_text_var"):
                    if hasattr(aie, attr):
                        try:
                            getattr(aie, attr).set(preset_prompt)
                            break
                        except Exception:
                            pass

                # 3) Xo√° cache prompt (n·∫øu c√≥) ƒë·ªÉ ƒë·∫£m b·∫£o l·∫ßn ch·∫°y sau build l·∫°i theo preset m·ªõi
                for cache_attr in ("base_prompt_cache", "compiled_prompt_cache"):
                    if hasattr(aie, cache_attr):
                        setattr(aie, cache_attr, None)                
                
            #------------------------
            # G·ªåI C√ÅC H√ÄM C·∫¨P NH·∫¨T GIAO DI·ªÜN (PHI√äN B·∫¢N HO√ÄN CH·ªàNH)

            logging.info("ƒê√£ c·∫≠p nh·∫≠t c√°c bi·∫øn, ƒëang l√™n l·ªãch l√†m m·ªõi to√†n b·ªô giao di·ªán...")

            # C·∫≠p nh·∫≠t cho Tab Download
            self.after(50, lambda: self.download_view_frame.set_download_ui_state(downloading=False))

            # C·∫≠p nh·∫≠t cho Tab Subtitle (h√†m n√†y s·∫Ω t·ª± g·ªçi c√°c h√†m con c·ªßa n√≥)
            self.after(100, lambda: self._set_subtitle_tab_ui_state(subbing_active=False))

            # C·∫≠p nh·∫≠t cho Tab Dubbing (h√†m n√†y c≈©ng l√† "nh·∫°c tr∆∞·ªüng" cho tab c·ªßa n√≥)
            self.after(150, self._set_dubbing_tab_ui_state) # Kh√¥ng c·∫ßn tham s·ªë

            # C·∫≠p nh·∫≠t cho Tab Upload
            self.after(200, lambda: self._update_youtube_ui_state(is_uploading=False))
            self.after(210, lambda: self._on_upload_method_changed(self.youtube_upload_method_var.get()))
            
            # C·∫≠p nh·∫≠t cho Tab AI Editor
            if hasattr(self, 'ai_editor_view_frame'):
                self.after(250, self.ai_editor_view_frame._toggle_rename_entry)
                self.after(260, self.ai_editor_view_frame._toggle_naming_options)
                self.after(270, self.ai_editor_view_frame._toggle_production_chain_widgets)

            # LOGIC T·∫¢I C√ÄI ƒê·∫∂T FFmpeg
            if hasattr(self, 'ffmpeg_preset_var'):
                self.ffmpeg_preset_var.set(new_cfg.get("ffmpeg_preset", "veryfast"))
            if hasattr(self, 'ffmpeg_crf_var'):
                self.ffmpeg_crf_var.set(str(new_cfg.get("ffmpeg_crf", "23")))

            # X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho encoder ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng tr√™n UI
            if hasattr(self, 'ffmpeg_encoder_var'):
                saved_encoder_short = new_cfg.get("ffmpeg_encoder", "libx264")

                # L∆Ø·ªöI AN TO√ÄN: Ki·ªÉm tra n·∫øu preset y√™u c·∫ßu GPU nh∆∞ng m√°y kh√¥ng c√≥
                if saved_encoder_short == "h264_nvenc" and self.cuda_status != 'AVAILABLE':
                    logging.warning(f"Preset y√™u c·∫ßu encoder NVENC nh∆∞ng kh√¥ng ph√°t hi·ªán GPU. T·ª± ƒë·ªông fallback v·ªÅ libx264 (CPU).")
                    # Ghi ƒë√® gi√° tr·ªã ƒë√£ t·∫£i t·ª´ preset v·ªÅ CPU
                    saved_encoder_short = "libx264"
                    # (T√πy ch·ªçn) Th√¥ng b√°o cho ng∆∞·ªùi d√πng
                    messagebox.showinfo("Fallback Encoder", 
                                        "Preset b·∫°n v·ª´a t·∫£i y√™u c·∫ßu encoder GPU (NVIDIA), nh∆∞ng kh√¥ng ph√°t hi·ªán card ƒë·ªì h·ªça t∆∞∆°ng th√≠ch tr√™n m√°y n√†y.\n\n"
                                        "·ª®ng d·ª•ng ƒë√£ t·ª± ƒë·ªông chuy·ªÉn v·ªÅ encoder CPU (libx264).",
                                        parent=self)

                # D·ª±ng l·∫°i chu·ªói hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß t·ª´ gi√° tr·ªã ƒë√£ l∆∞u (ho·∫∑c ƒë√£ fallback)
                if saved_encoder_short == "h264_nvenc":
                    self.ffmpeg_encoder_var.set("h264_nvenc (NVIDIA GPU)")
                else: # M·∫∑c ƒë·ªãnh l√† libx264
                    self.ffmpeg_encoder_var.set("libx264 (CPU, M·∫∑c ƒë·ªãnh)")

        finally:
            # Lu√¥n t·∫Øt c·ªù ·ªü cu·ªëi c√πng, sau khi t·∫•t c·∫£ c√°c l·ªánh `after` ƒë√£ ƒë∆∞·ª£c l√™n l·ªãch
            self.after(300, lambda: setattr(self, '_is_restoring_task_config', False))


#==================================================================================================================================================================================================================

# --- C√°c h√†m Placeholder Download ---    
    # H√†m h√†nh ƒë·ªông: B·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫£i xu·ªëng (ch·ªâ t·∫£i)
    def start_download(self):
        """
        L·∫•y th√¥ng tin t·ª´ UI (∆∞u ti√™n self.download_urls_list, sau ƒë√≥ ƒë·∫øn textbox),
        ki·ªÉm tra, reset retry counts, v√† b·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫£i xu·ªëng trong m·ªôt thread m·ªõi.
        Ch·ªâ th·ª±c hi·ªán t·∫£i, kh√¥ng t·ª± ƒë·ªông sub.
        """
        logging.info("--- Nh·∫•n n√∫t B·∫Øt ƒë·∫ßu T·∫£i (Ch·ªâ T·∫£i) ---")

        # --- B∆∞·ªõc 1: Reset b·ªô ƒë·∫øm l·ªói v√† x√°c ƒë·ªãnh danh s√°ch URL c·∫ßn x·ª≠ l√Ω ---
        self.download_retry_counts.clear() 
        logging.info("ƒê√£ x√≥a self.download_retry_counts cho l∆∞·ª£t t·∫£i m·ªõi.")
        # self.globally_completed_urls KH√îNG ƒë∆∞·ª£c clear ·ªü ƒë√¢y ƒë·ªÉ nh·ªõ c√°c link ƒë√£ ho√†n th√†nh trong c·∫£ session.

        urls_to_process_initial = [] # Danh s√°ch URL ban ƒë·∫ßu ƒë·ªÉ truy·ªÅn cho config (ch·ªß y·∫øu ƒë·ªÉ log)
        source_of_urls = ""

        if hasattr(self, 'download_urls_list') and self.download_urls_list:
            source_of_urls = "h√†ng ch·ªù hi·ªán t·∫°i (self.download_urls_list)"
            logging.info(f"S·∫Ω s·ª≠ d·ª•ng {len(self.download_urls_list)} link t·ª´ {source_of_urls}.")
            # urls_to_process_initial s·∫Ω ƒë∆∞·ª£c l·∫•y t·ª´ self.download_urls_list ·ªü d∆∞·ªõi n·∫øu c·∫ßn
        elif hasattr(self, 'download_view_frame') and hasattr(self.download_view_frame, 'download_url_text') and self.download_view_frame.download_url_text:
            # ∆Øu ti√™n 2: N·∫øu self.download_urls_list r·ªóng, ƒë·ªçc t·ª´ textbox
            urls_text_from_box = self.download_view_frame.download_url_text.get("1.0", "end-1c").strip()
            if urls_text_from_box:
                source_of_urls = "√¥ nh·∫≠p li·ªáu textbox"
                logging.info(f"H√†ng ch·ªù (self.download_urls_list) r·ªóng. ƒê·ªçc link t·ª´ {source_of_urls}.")
                
                temp_urls_from_box = []
                seen_urls_in_box = set()
                for line in urls_text_from_box.splitlines():
                    stripped_url = line.strip()
                    if stripped_url and stripped_url.startswith(('http://', 'https://')):
                        if stripped_url not in seen_urls_in_box:
                            temp_urls_from_box.append(stripped_url)
                            seen_urls_in_box.add(stripped_url)
                    elif stripped_url:
                         logging.warning(f"B·ªè qua URL kh√¥ng h·ª£p l·ªá t·ª´ textbox: {stripped_url}")
                
                if temp_urls_from_box:
                    # C·∫≠p nh·∫≠t self.download_urls_list b·∫±ng danh s√°ch m·ªõi t·ª´ textbox
                    self.download_urls_list = list(temp_urls_from_box) 
                    logging.info(f"ƒê√£ c·∫≠p nh·∫≠t self.download_urls_list v·ªõi {len(self.download_urls_list)} link t·ª´ {source_of_urls}.")
                else:
                    messagebox.showwarning("Link kh√¥ng h·ª£p l·ªá", f"Kh√¥ng t√¨m th·∫•y link h·ª£p l·ªá n√†o trong {source_of_urls}.", parent=self)
                    return
            else: # C·∫£ self.download_urls_list v√† textbox ƒë·ªÅu r·ªóng
                messagebox.showwarning("Thi·∫øu link", "Vui l√≤ng nh·∫≠p link v√†o √¥ ho·∫∑c th√™m t·ª´ Google Sheet.\nH√†ng ch·ªù hi·ªán t·∫°i c≈©ng ƒëang tr·ªëng.", parent=self)
                return
        else: # L·ªói c·∫•u tr√∫c app
            messagebox.showerror("L·ªói Giao Di·ªán", "Kh√¥ng t√¨m th·∫•y ngu·ªìn nh·∫≠p link (textbox ho·∫∑c h√†ng ch·ªù).", parent=self)
            return

        # Sau khi x√°c ƒë·ªãnh ngu·ªìn, urls_to_process_initial l√† b·∫£n sao c·ªßa self.download_urls_list hi·ªán t·∫°i
        if not self.download_urls_list: 
            messagebox.showwarning("H√†ng ch·ªù tr·ªëng", f"Kh√¥ng c√≥ link n√†o ƒë·ªÉ x·ª≠ l√Ω t·ª´ {source_of_urls}.", parent=self)
            return
        urls_to_process_initial = list(self.download_urls_list) # ƒê·ªÉ log s·ªë l∆∞·ª£ng ban ƒë·∫ßu

        # --- B∆∞·ªõc 2: Ki·ªÉm tra c√°c t√πy ch·ªçn kh√°c ---
        download_path = self.download_path_var.get()
        if not download_path:
             messagebox.showerror("L·ªói ƒê∆∞·ªùng D·∫´n", "Vui l√≤ng ch·ªçn th∆∞ m·ª•c l∆∞u t·∫£i v·ªÅ h·ª£p l·ªá.", parent=self)
             return
        if self.download_rename_var.get() and not self.download_rename_box_var.get().strip():
             messagebox.showwarning("Thi·∫øu t√™n file", "Vui l√≤ng nh·∫≠p t√™n chung khi ch·ªçn ƒë·ªïi t√™n h√†ng lo·∫°t!", parent=self)
             return
        sound_file_path = self.download_sound_path_var.get()
        if self.download_sound_var.get() and (not sound_file_path or not os.path.isfile(sound_file_path)):
            messagebox.showwarning("Thi·∫øu file √¢m thanh", "Vui l√≤ng ch·ªçn file √¢m thanh h·ª£p l·ªá ho·∫∑c b·ªè check 'Ph√°t nh·∫°c'.", parent=self)
            return

        # --- B∆∞·ªõc 3: Chu·∫©n b·ªã config cho thread ---
        config = {
            # "urls": urls_to_process_initial, # Kh√¥ng c·∫ßn truy·ªÅn list URL v√†o config n·ªØa
            "mode": self.download_mode_var.get(),
            "folder": download_path,
            "v_quality": self.download_video_quality_var.get().replace("p", ""),
            "a_quality": self.download_audio_quality_var.get().replace("k", ""),
            "rename_all": self.download_rename_var.get(),
            "base_name": self.download_rename_box_var.get().strip(),
            "do_sound": self.download_sound_var.get(),
            "sound_file": sound_file_path,
            "do_shutdown": self.download_shutdown_var.get(),
            "stop_on_error": self.download_stop_on_error_var.get(),
            "download_playlist": self.download_playlist_var.get(),
            "auto_sub_after_download": False, # ho·∫∑c True
            "use_cookies": self.download_use_cookies_var.get(),
            "cookies_file": self.download_cookies_path_var.get()
        }
        logging.info(f"Config t·∫£i (CH·ªà T·∫¢I) ƒë√£ chu·∫©n b·ªã. S·ªë link ban ƒë·∫ßu trong h√†ng ch·ªù: {len(urls_to_process_initial)} t·ª´ {source_of_urls}.")
        
        # --- B∆∞·ªõc 4: Chu·∫©n b·ªã giao di·ªán v√† tr·∫°ng th√°i ---
        self.current_download_url = None 
        self.update_download_queue_display() 

        # X√≥a log download s·ª≠ d·ª•ng method c·ªßa DownloadTab
        if hasattr(self, 'download_view_frame') and hasattr(self.download_view_frame, 'clear_download_log'):
            try:
                self.download_view_frame.clear_download_log()
            except Exception as e:
                logging.error(f"L·ªói khi x√≥a log download: {e}")

        self.stop_event.clear()
        self.download_view_frame.set_download_ui_state(downloading=True)
        self.download_view_frame.update_download_progress(0)

        self.download_view_frame.log_download(f"üöÄ B·∫Øt ƒë·∫ßu qu√° tr√¨nh CH·ªà T·∫¢I (Ngu·ªìn: {source_of_urls})...")
        self.download_view_frame.log_download(f"   - S·ªë link hi·ªán c√≥ trong h√†ng ch·ªù: {len(self.download_urls_list)}")
        self.download_view_frame.log_download(f"   - Ch·∫ø ƒë·ªô: {config['mode']}")
        self.download_view_frame.log_download(f"   - L∆∞u t·∫°i: {config['folder']}")

        # --- B∆∞·ªõc 5: L∆∞u c√†i ƒë·∫∑t hi·ªán t·∫°i v√† ghi nh·∫≠n y√™u c·∫ßu t·∫Øt m√°y ---
        self.save_current_config() 
        self.shutdown_requested_by_task = self.download_shutdown_var.get()
        logging.info(f"C·∫•u h√¨nh UI ƒë√£ l∆∞u. Y√™u c·∫ßu t·∫Øt m√°y b·ªüi t√°c v·ª•: {self.shutdown_requested_by_task}")

        self.start_time = time.time() 
        self.update_time_realtime() 

        # --- B∆∞·ªõc 6: Start download thread ---
        try:
            if self.download_thread and self.download_thread.is_alive():
                 logging.warning("Thread t·∫£i ƒëang ch·∫°y!")
                 messagebox.showwarning("ƒêang x·ª≠ l√Ω", "Qu√° tr√¨nh t·∫£i kh√°c ƒëang ch·∫°y, vui l√≤ng ƒë·ª£i.", parent=self)
                 self.download_view_frame.set_download_ui_state(downloading=True) 
                 return

            logging.info(f"CHU·∫®N B·ªä T·∫†O THREAD (start_download): self.download_urls_list l√∫c n√†y = {self.download_urls_list}")
            # Truy·ªÅn config v√†o run_download
            self.download_thread = threading.Thread(target=self.run_download, args=(config,), daemon=True, name="DownloadWorker")
            self.download_thread.start()
            logging.info("ƒê√£ b·∫Øt ƒë·∫ßu thread t·∫£i.")
        except Exception as e:
            logging.error(f"L·ªói b·∫Øt ƒë·∫ßu thread t·∫£i: {e}", exc_info=True)
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫£i:\n{e}", parent=self)
            self.download_view_frame.set_download_ui_state(downloading=False)



# H√†m h√†nh ƒë·ªông: D·ª´ng qu√° tr√¨nh t·∫£i xu·ªëng hi·ªán t·∫°i
    def stop_download(self):
        """ G·ª≠i t√≠n hi·ªáu d·ª´ng ƒë·∫øn thread t·∫£i v√† c·ªë g·∫Øng d·ª´ng ti·∫øn tr√¨nh con.
            MODIFIED: S·∫Ω KH√îNG x√≥a URL ƒëang t·∫£i b·ªã d·ª´ng kh·ªèi self.download_urls_list.
        """
        logging.warning(">>> Y√™u c·∫ßu D·ª´ng T·∫£i t·ª´ N√∫t c·ªßa Ng∆∞·ªùi d√πng <<<")

        is_running = self.download_thread and self.download_thread.is_alive()

        if is_running:
            self.download_view_frame.log_download("\nüõë ƒêang y√™u c·∫ßu d·ª´ng qu√° tr√¨nh t·∫£i...")
            self.stop_event.set()

            url_that_was_being_processed = self.current_download_url 

            self.is_downloading = False
            logging.info(f"[StopDownload] ƒê√£ ƒë·∫∑t self.is_downloading = False.")

            if self.shutdown_requested_by_task: # T·ª´ l·∫ßn s·ª≠a l·ªói tr∆∞·ªõc
                logging.info(f"[StopDownload] Ng∆∞·ªùi d√πng d·ª´ng t·∫£i, h·ªßy y√™u c·∫ßu t·∫Øt m√°y cho t√°c v·ª• n√†y.")
                self.shutdown_requested_by_task = False

            # --- THAY ƒê·ªîI ·ªû ƒê√ÇY: KH√îNG X√ìA URL KH·ªéI H√ÄNG CH·ªú ---
            if url_that_was_being_processed:
                logging.info(f"[StopDownload] URL ƒëang x·ª≠ l√Ω ('{url_that_was_being_processed[:60] if url_that_was_being_processed else 'None'}') s·∫Ω ƒë∆∞·ª£c gi·ªØ l·∫°i trong h√†ng ch·ªù theo y√™u c·∫ßu.")
            # C√°c d√≤ng code x√≥a "url_that_was_being_processed" kh·ªèi "self.download_urls_list"
            # v√† "self.download_retry_counts" ƒë√£ ƒë∆∞·ª£c B·ªé ƒêI ho·∫∑c COMMENT L·∫†I.
            # V√≠ d·ª•, c√°c d√≤ng sau s·∫Ω kh√¥ng c√≤n n·ªØa:
            # # self.download_urls_list.remove(url_that_was_being_processed)
            # # if url_that_was_being_processed in self.download_retry_counts:
            # #     del self.download_retry_counts[url_that_was_being_processed]
            # --- K·∫æT TH√öC THAY ƒê·ªîI ---

            self.current_download_url = None # V·∫´n quan tr·ªçng ƒë·ªÉ reset UI slot "ƒêANG T·∫¢I"

            proc = self.current_process
            if proc and proc.poll() is None:
                self.download_view_frame.log_download("   -> ƒêang c·ªë g·∫Øng d·ª´ng ti·∫øn tr√¨nh con (yt-dlp/ffmpeg)...")
                try:
                    proc.terminate()
                    proc.wait(timeout=1.5)
                    self.download_view_frame.log_download("   -> Ti·∫øn tr√¨nh con ƒë√£ d·ª´ng (terminate/wait).")
                except subprocess.TimeoutExpired:
                    self.download_view_frame.log_download("   -> Ti·∫øn tr√¨nh con kh√¥ng ph·∫£n h·ªìi, bu·ªôc d·ª´ng (kill)...")
                    try:
                        proc.kill()
                        self.download_view_frame.log_download("   -> ƒê√£ bu·ªôc d·ª´ng (kill) ti·∫øn tr√¨nh con.")
                    except Exception as kill_err:
                        self.download_view_frame.log_download(f"   -> L·ªói khi bu·ªôc d·ª´ng (kill): {kill_err}")
                except Exception as e:
                    self.download_view_frame.log_download(f"   -> L·ªói khi d·ª´ng ti·∫øn tr√¨nh con: {e}")
                    if proc.poll() is None:
                        try:
                            proc.kill()
                            self.download_view_frame.log_download("   -> ƒê√£ bu·ªôc d·ª´ng (kill) sau l·ªói.")
                        except Exception as kill_err_B:
                            self.download_view_frame.log_download(f"   -> L·ªói khi bu·ªôc d·ª´ng (kill) l·∫ßn 2: {kill_err_B}")
            else:
                self.download_view_frame.log_download("   -> Kh√¥ng t√¨m th·∫•y ti·∫øn tr√¨nh con ƒëang ch·∫°y ƒë·ªÉ d·ª´ng tr·ª±c ti·∫øp.")
            self.current_process = None

            self.after(0, lambda: self.download_view_frame.set_download_ui_state(downloading=False))
            self.after(10, self.update_download_queue_display) 
            self.after(20, lambda: self.download_view_frame.update_download_progress(0))
        else:
            self.download_view_frame.log_download("\n‚ÑπÔ∏è Kh√¥ng c√≥ ti·∫øn tr√¨nh t·∫£i n√†o ƒëang ch·∫°y ƒë·ªÉ d·ª´ng.")
            self.download_view_frame.set_download_ui_state(downloading=False)
            self.update_download_queue_display()


# H√†m ti·ªán √≠ch UI Download: B·∫≠t/t·∫Øt n√∫t ch·ªçn file √¢m thanh d·ª±a v√†o checkbox

# H√†m ti·ªán √≠ch UI Download: Hi·ªán/·∫®n √¥ nh·∫≠p t√™n file khi ch·ªçn ƒë·ªïi t√™n h√†ng lo·∫°t

    # H√ÄM M·ªöI: C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa n√∫t ch·ªçn file cookies
    def _toggle_cookies_button_state(self):
        """B·∫≠t/t·∫Øt n√∫t ch·ªçn file cookies (ƒê√É REFACTOR)"""
        if hasattr(self, 'download_view_frame'):
            btn = getattr(self.download_view_frame, 'download_cookies_button', None)
            if btn and btn.winfo_exists():
                new_state = "normal" if self.download_use_cookies_var.get() else "disabled"
                btn.configure(state=new_state)
            # G·ªçi h√†m update label t·ª´ DownloadTab
            self.download_view_frame._update_cookies_label()


#-------------------
# === H√ÄM _execute_ytdlp PHI√äN B·∫¢N HO√ÄN CH·ªàNH  ===
    # H√†m chi ti·∫øt: Th·ª±c thi l·ªánh yt-dlp ƒë·ªÉ t·∫£i file
    def _execute_ytdlp(self, url, config, is_video, index, task_object_ref=None):
        """ Th·ª±c thi yt-dlp, x·ª≠ l√Ω output, progress v√† t√πy ch·ªçn --ppa. """
        thread_name = threading.current_thread().name # L·∫•y t√™n lu·ªìng ƒë·ªÉ log
        logging.info(f"[{thread_name}] B·∫Øt ƒë·∫ßu t·∫£i: {'Video' if is_video else 'MP3'} - {url[:70]}...")

        # Ki·ªÉm tra c·ªù d·ª´ng s·ªõm
        if self.stop_event.is_set():
            logging.warning(f"[{thread_name}] T√°c v·ª• b·ªã d·ª´ng tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu yt-dlp.")
            return (False, None)

        # Kh·ªüi t·∫°o bi·∫øn k·∫øt qu·∫£ v√† tr·∫°ng th√°i
        process_result = False
        output_filepath = None
        output_lines = [] # L∆∞u c√°c d√≤ng output t·ª´ yt-dlp ƒë·ªÉ debug l·ªói
        base_folder = Path(".") # Kh·ªüi t·∫°o ƒë∆∞·ªùng d·∫´n g·ªëc
        proc = None # Kh·ªüi t·∫°o bi·∫øn ti·∫øn tr√¨nh l√† None

        try:
            # --- 1. Chu·∫©n b·ªã Th∆∞ m·ª•c Output ---
            base_folder_str = config.get("folder", ".") # L·∫•y ƒë∆∞·ªùng d·∫´n t·ª´ config
            if not base_folder_str: # X·ª≠ l√Ω n·∫øu ƒë∆∞·ªùng d·∫´n tr·ªëng
                 logging.error(f"[{thread_name}] ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c t·∫£i v·ªÅ b·ªã tr·ªëng!")
                 self.after(0, lambda: self.download_view_frame.log_download(f"   ‚ùå L·ªói: ƒê∆∞·ªùng d·∫´n l∆∞u tr·ªëng!"))
                 return (False, None)
            base_folder = Path(base_folder_str)
            try:
                base_folder.mkdir(parents=True, exist_ok=True) # T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a c√≥
                logging.debug(f"[{thread_name}] ƒê√£ ƒë·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i: {base_folder}")
            except OSError as e:
                logging.error(f"[{thread_name}] Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c '{base_folder}': {e}")
                self.after(0, lambda err=e, p=str(base_folder): self.download_view_frame.log_download(f"   ‚ùå L·ªói t·∫°o th∆∞ m·ª•c '{p}': {err}"))
                return (False, None) # Kh√¥ng th·ªÉ ti·∫øp t·ª•c n·∫øu kh√¥ng c√≥ th∆∞ m·ª•c

            # --- 2. X√¢y d·ª±ng L·ªánh cmd cho yt-dlp ---
            cmd = [YTDLP_PATH] # B·∫Øt ƒë·∫ßu v·ªõi ƒë∆∞·ªùng d·∫´n c·ªßa yt-dlp

            # T√πy ch·ªçn Playlist
            if not config.get("download_playlist", False):
                cmd.append("--no-playlist")

            # T√¨m v√† th√™m ƒë∆∞·ªùng d·∫´n ffmpeg
            ffmpeg_location = find_ffmpeg()
            if not ffmpeg_location:
                logging.error(f"[{thread_name}] Kh√¥ng t√¨m th·∫•y ffmpeg.")
                self.after(0, lambda: self.download_view_frame.log_download(f"   ‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y ffmpeg!"))
                self.after(0, lambda: self.update_status(f"‚ùå L·ªói t·∫£i: Thi·∫øu ffmpeg."))
                return (False, None)

            # Th√™m c√°c t√πy ch·ªçn yt-dlp chung
            common_options = [
                "--ffmpeg-location", ffmpeg_location,
                "--no-warnings",                  # ·∫®n c√°c c·∫£nh b√°o th√¥ng th∆∞·ªùng
                "--restrict-filenames",           # ƒê·∫£m b·∫£o t√™n file an to√†n cho HƒêH
                "--progress-template",            # ƒê·ªãnh d·∫°ng d√≤ng progress (c√≥ th·ªÉ t√πy ch·ªânh)
                    "download-title:%(info.title)s-ETA:%(progress.eta)s",
                "--socket-timeout", "30",         # Timeout cho k·∫øt n·ªëi m·∫°ng (gi√¢y)
                "--force-overwrite",              # Ghi ƒë√® n·∫øu file ƒë√£ t·ªìn t·∫°i
                # C√≥ th·ªÉ th√™m c√°c t√πy ch·ªçn kh√°c n·∫øu mu·ªën:
                #"--geo-bypass",                 # Th·ª≠ v∆∞·ª£t qua gi·ªõi h·∫°n ƒë·ªãa l√Ω
                #"--write-thumbnail",            # T·∫£i c·∫£ ·∫£nh thumbnail
                #"--limit-rate", "5M",          # Gi·ªõi h·∫°n t·ªëc ƒë·ªô t·∫£i (v√≠ d·ª• 5MB/s)
            ]
            cmd.extend(common_options)

            # Th√™m --verbose n·∫øu mu·ªën debug (m·∫∑c ƒë·ªãnh comment l·∫°i)
            cmd.append("--verbose")

            # --- Chu·∫©n b·ªã m·∫´u t√™n file output (-o) ---
            desired_ext = "mp4" if is_video else "mp3"
            output_tmpl_pattern = ""
            download_playlist = config.get("download_playlist", False)

            if config.get("rename_all", False) and config.get('base_name'):
                # ‚úÖ NH√ÅNH ƒê·ªîI T√äN H√ÄNG LO·∫†T (S·ª¨A L·ªñI GHI ƒê√à)
                safe_base_name = create_safe_filename(config['base_name'], remove_accents=False)
                if download_playlist:
                    # Playlist -> ƒë·ªÉ yt-dlp t·ª± tƒÉng index cho M·ªñI M·ª§C
                    index_token = "%(playlist_index)03d"
                else:
                    # Kh√¥ng ph·∫£i playlist -> d√πng index c·ªßa b·∫°n (ho·∫∑c %(autonumber)03d n·∫øu 1 l·ªánh c√≥ nhi·ªÅu URL)
                    # index ·ªü ƒë√¢y l√† tham s·ªë truy·ªÅn v√†o h√†m
                    index_token = f"{index:03d}"  # ho·∫∑c: "%(autonumber)03d"

                audio_suffix = "_audio" if not is_video else ""
                # Gi·ªØ ph·∫ßn m·ªü r·ªông c·ªë ƒë·ªãnh v√¨ b·∫°n ƒë√£ √©p mp3/mp4 b·∫±ng tham s·ªë
                output_tmpl_pattern = f"{safe_base_name} - {index_token}{audio_suffix}.{desired_ext}"
                logging.debug(f"[{thread_name}] Template rename_all: {output_tmpl_pattern}")

            else:
                # ‚úÖ NH√ÅNH M·∫∂C ƒê·ªäNH (ƒë√£ ƒë√∫ng, gi·ªØ nguy√™n tinh th·∫ßn c≈©)
                index_part = "%(playlist_index)03d - " if download_playlist else ""
                title_part = "%(title).15s"
                audio_suffix = "_audio" if not is_video else ""
                output_tmpl_pattern = f"{index_part}{title_part} - %(id)s{audio_suffix}.{desired_ext}"
                output_tmpl_pattern = re.sub(r'\s*-\s*-\s*', ' - ', output_tmpl_pattern).strip(' -')
                output_tmpl_pattern = re.sub(r'_-_', '_', output_tmpl_pattern)
                logging.debug(f"[{thread_name}] Template m·∫∑c ƒë·ªãnh: {output_tmpl_pattern}")

            # D·ªçn chu·ªói v√† fallback an to√†n
            output_tmpl_pattern = output_tmpl_pattern.replace("--.", ".").replace("__", "_").strip(" _-.")
            if not output_tmpl_pattern or not output_tmpl_pattern.endswith(f".{desired_ext}"):
                output_tmpl_pattern = f"downloaded_file_{index}.{desired_ext}"

            output_tmpl = str(base_folder / output_tmpl_pattern)
            cmd.extend(["-o", output_tmpl])

            # D·ªçn d·∫πp v√† ki·ªÉm tra fallback
            output_tmpl_pattern = output_tmpl_pattern.replace("--.", ".").replace("__", "_").strip(" _-.")
            if not output_tmpl_pattern or not output_tmpl_pattern.endswith(f".{desired_ext}"):
                 output_tmpl_pattern = f"downloaded_file_{index}.{desired_ext}" # T√™n d·ª± ph√≤ng an to√†n
            output_tmpl = str(base_folder / output_tmpl_pattern)

            # <<< TH√äM M·ªöI: X·ª≠ l√Ω Cookies >>>
            if config.get("use_cookies") and config.get("cookies_file"):
                cookies_path = config["cookies_file"]
                if os.path.exists(cookies_path):
                    logging.info(f"[{thread_name}] S·ª≠ d·ª•ng file cookies: {cookies_path}")
                    cmd.extend(["--cookies", cookies_path])
                else:
                    logging.warning(f"[{thread_name}] ƒê√£ b·∫≠t d√πng cookies nh∆∞ng file kh√¥ng t·ªìn t·∫°i: {cookies_path}")
            # <<< K·∫æT TH√öC TH√äM M·ªöI >>>

            cmd.extend(["-o", output_tmpl]) # Th√™m t√πy ch·ªçn ƒë∆∞·ªùng d·∫´n output

            # --- Th√™m t√πy ch·ªçn ƒë·ªãnh d·∫°ng v√† --ppa (N·∫æU L√Ä VIDEO v√† ƒê∆Ø·ª¢C CH·ªåN) ---
            if is_video:
                quality = config.get('v_quality', '1080') # L·∫•y ch·∫•t l∆∞·ª£ng video t·ª´ config
                # Format selection (∆∞u ti√™n mp4/m4a n·∫øu c√≥ th·ªÉ)
                format_select = "bv*[height<=%s][ext=mp4]+ba[ext=m4a]/bv*[height<=%s]+ba/b[height<=%s]/b" % (quality, quality, quality)
                if quality == 'best':
                     format_select = "bv*+ba/b" # L·∫•y video + audio t·ªët nh·∫•t
                cmd.extend(["-f", format_select, "--merge-output-format", "mp4"])

                # Ki·ªÉm tra checkbox "T·ªëi ∆∞u Mobile"
                optimize_mobile = False
                if hasattr(self, 'optimize_for_mobile_var'):
                    try: optimize_mobile = self.optimize_for_mobile_var.get()
                    except Exception as e_get: logging.error(f"L·ªói khi l·∫•y optimize_for_mobile_var: {e_get}")

                if optimize_mobile:
                    # Th√™m t√πy ch·ªçn PPA ƒë·ªÉ √©p ffmpeg re-encode t∆∞∆°ng th√≠ch iPhone
                    logging.info(f"[{thread_name}] ƒê√£ ch·ªçn T·ªëi ∆∞u Mobile, th√™m PPA cho ffmpeg...")
                    #ppa_string = "ffmpeg:-c:v libx264 -preset medium -crf 23 -profile:v baseline -level 3.0 -pix_fmt yuv420p -c:a aac -b:a 128k"
                    # C√¢n nh·∫Øc d√πng profile 'main' n·∫øu c·∫ßn ch·∫•t l∆∞·ª£ng cao h∆°n v√† ch·∫•p nh·∫≠n r·ªßi ro t∆∞∆°ng th√≠ch th·∫•p h∆°n baseline m·ªôt ch√∫t:
                    ppa_string = "ffmpeg:-c:v libx264 -preset medium -crf 22 -profile:v main -pix_fmt yuv420p -c:a aac -b:a 192k"
                    cmd.append("--ppa")
                    cmd.append(ppa_string)
                else:
                    # Kh√¥ng t·ªëi ∆∞u, ch·ªâ merge (yt-dlp t·ª± x·ª≠ l√Ω, th∆∞·ªùng l√† copy stream)
                    logging.info(f"[{thread_name}] Kh√¥ng ch·ªçn T·ªëi ∆∞u Mobile, gi·ªØ ch·∫•t l∆∞·ª£ng g·ªëc (ch·ªâ merge).")
                    # Kh√¥ng c·∫ßn th√™m c·ªù g√¨ c·∫£ ·ªü ƒë√¢y

            else: # N·∫øu l√† t·∫£i Audio
                quality = config.get('a_quality', 'best') # L·∫•y ch·∫•t l∆∞·ª£ng audio
                audio_q_ffmpeg = f"{quality}k" if quality != 'best' and quality.isdigit() else "0" # 0 l√† t·ªët nh·∫•t cho ffmpeg
                cmd.extend([
                    "-f", "ba/b",  # Ch·ªçn lu·ªìng audio t·ªët nh·∫•t
                    "-x",          # Tr√≠ch xu·∫•t audio
                    "--audio-format", "mp3", # ƒê·ªãnh d·∫°ng output l√† mp3
                    "--audio-quality", audio_q_ffmpeg # Ch·∫•t l∆∞·ª£ng audio (0=best)
                ])

            # Th√™m URL v√†o cu·ªëi c√πng
            cmd.append(url)
            logging.debug(f"[{thread_name}] L·ªánh yt-dlp ho√†n ch·ªânh s·∫Ω ch·∫°y: {' '.join(cmd)}")

            # Reset progress bar tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu
            self.after(0, lambda: self.download_view_frame.update_download_progress(0))

            # --- 3. Th·ª±c thi ti·∫øn tr√¨nh yt-dlp (streaming output) ---
            proc = None
            def _set_proc(p):
                nonlocal proc
                proc = p
                try:
                    setattr(self, 'current_process', p)
                except Exception:
                    pass

            def _clear_proc():
                nonlocal proc
                proc = None
                try:
                    setattr(self, 'current_process', None)
                except Exception:
                    pass

            # --- 4. V√≤ng l·∫∑p ƒë·ªçc Output t·ª´ yt-dlp ---
            progress_regex = re.compile(r"\[download\]\s+(\d{1,3}(?:[.,]\d+)?)%")
            destination_regex = re.compile( r"\[(?:download|Merger|ExtractAudio|ffmpeg)\]\s+(?:Destination:|Merging formats into|Extracting audio to|Deleting original file|Converting video to)\s*(.*)" )
            last_percent = -1.0; is_processing_step = False; potential_output_path = None

            # ƒê·ªçc t·ª´ng d√≤ng output cho ƒë·∫øn khi ti·∫øn tr√¨nh k·∫øt th√∫c
            for line in ytdlp_stream_output(
                cmd,
                process_name=f"{thread_name}_yt-dlp",
                hide_console_window=True,
                set_current_process=_set_proc,
                clear_current_process=_clear_proc,
            ):
                 if self.stop_event.is_set(): # X·ª≠ l√Ω d·ª´ng b·ªüi ng∆∞·ªùi d√πng
                      logging.warning(f"[{thread_name}] C·ªù d·ª´ng ƒë∆∞·ª£c k√≠ch ho·∫°t.")
                      try:
                          if proc and proc.poll() is None: proc.terminate(); logging.info(f"[{thread_name}] ƒê√£ g·ª≠i terminate.")
                      except Exception as term_err: logging.warning(f"L·ªói terminate: {term_err}")
                      break # Tho√°t v√≤ng l·∫∑p ƒë·ªçc

                 clean_line = line.strip()
                 if not clean_line: continue # B·ªè qua d√≤ng tr·ªëng
                 output_lines.append(clean_line) # L∆∞u l·∫°i d√≤ng log ƒë·ªÉ debug n·∫øu c·∫ßn
                 # G·ª≠i l√™n UI Log (c√≥ th·ªÉ l√†m ch·∫≠m n·∫øu qu√° nhi·ªÅu log verbose)
                 self.after(0, lambda line=clean_line: self.download_view_frame.log_download(f"      {line}"))

                 # Ph√¢n t√≠ch d√≤ng log ƒë·ªÉ t√¨m ƒë∆∞·ªùng d·∫´n file cu·ªëi ho·∫∑c tr·∫°ng th√°i
                 dest_match = destination_regex.search(clean_line)
                 if dest_match:
                    found_path_raw = dest_match.group(1).strip().strip('"')
                    # Ki·ªÉm tra n·∫øu l√† ƒë∆∞·ªùng d·∫´n file h·ª£p l·ªá v√† kh√¥ng ph·∫£i file t·∫°m
                    if not any(found_path_raw.endswith(ext) for ext in [".part", ".ytdl", ".temp"]) and os.path.splitext(found_path_raw)[1]:
                         potential_output_path = found_path_raw
                         logging.debug(f"C·∫≠p nh·∫≠t path cu·ªëi ti·ªÅm nƒÉng: {potential_output_path}")
                    elif not potential_output_path and any(found_path_raw.endswith(ext) for ext in [".part", ".ytdl", ".temp"]):
                         logging.debug(f"T√¨m th·∫•y path t·∫°m: {found_path_raw}")

                 # Ph√°t hi·ªán giai ƒëo·∫°n x·ª≠ l√Ω sau t·∫£i (ffmpeg, merge,...)
                 if not is_processing_step and any(tag in clean_line for tag in ["[ExtractAudio]", "[Merger]", "[ffmpeg]"]):
                      is_processing_step = True
                      self.after(0, lambda: self.download_view_frame.update_download_progress(100)) # Xem nh∆∞ download 100%
                      self.after(0, lambda: self.update_status("‚è≥ ƒêang x·ª≠ l√Ω (gh√©p/chuy·ªÉn ƒë·ªïi)..."))
                      logging.debug(f"[{thread_name}] B·∫Øt ƒë·∫ßu giai ƒëo·∫°n x·ª≠ l√Ω sau t·∫£i...")
                      continue # Kh√¥ng c·∫ßn parse % n·ªØa

                 # C·∫≠p nh·∫≠t thanh progress bar n·∫øu ƒëang trong giai ƒëo·∫°n download
                 if not is_processing_step:
                     match = progress_regex.search(clean_line)
                     if match:
                         percent_str = match.group(1).replace(',', '.')
                         try: # Kh·ªëi try/except ƒë·ªãnh d·∫°ng ƒë√∫ng
                             percent = float(percent_str)
                             if abs(percent - last_percent) >= 0.5 or percent >= 99.9:
                                 last_percent = percent
                                 self.after(0, lambda p=percent: self.download_view_frame.update_download_progress(p))
                         except ValueError:
                             pass # B·ªè qua n·∫øu l·ªói parse s·ªë

            # --- K·∫øt th√∫c v√≤ng l·∫∑p ƒë·ªçc Output ---
            logging.info(f"[{thread_name}] Ho√†n t·∫•t ƒë·ªçc stdout. Ch·ªù ti·∫øn tr√¨nh yt-dlp tho√°t...")

            # --- 5. L·∫•y m√£ tr·∫£ v·ªÅ ---
            return_code = -97 if proc is None else (proc.returncode if proc.poll() is not None else proc.wait(timeout=1))

            self.current_process = None # X√≥a tham chi·∫øu sau khi x·ª≠ l√Ω xong

            # --- 6. X·ª≠ l√Ω k·∫øt qu·∫£ cu·ªëi c√πng (PHI√äN B·∫¢N HO√ÄN CH·ªàNH) ---
            if self.stop_event.is_set() or return_code == -100:
                self.after(0, lambda: self.download_view_frame.log_download(f"   ‚ö†Ô∏è B·ªã d·ª´ng."))
                process_result = False
            
            # ∆Øu ti√™n ki·ªÉm tra s·ª± t·ªìn t·∫°i c·ªßa file output l√†m ƒëi·ªÅu ki·ªán th√†nh c√¥ng ch√≠nh
            
            final_output_path_check = None
            # C·ªë g·∫Øng x√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n file cu·ªëi c√πng b·∫•t k·ªÉ return_code l√† g√¨
            if potential_output_path and os.path.exists(potential_output_path) and os.path.getsize(potential_output_path) > 1024:
                final_output_path_check = potential_output_path
            elif os.path.exists(output_tmpl) and os.path.getsize(output_tmpl) > 1024:
                final_output_path_check = output_tmpl
            
            # N·∫øu t√¨m th·∫•y file output h·ª£p l·ªá
            if final_output_path_check:
                if return_code == 0:
                    logging.info(f"[{thread_name}] TH√ÄNH C√îNG: yt-dlp tho√°t v·ªõi m√£ 0 v√† file output h·ª£p l·ªá: {final_output_path_check}")
                    self.after(0, lambda: self.download_view_frame.log_download(f"   ‚úîÔ∏è Ho√†n th√†nh (M√£ 0)."))
                else:
                    logging.warning(f"[{thread_name}] TH√ÄNH C√îNG (FALLBACK): yt-dlp tho√°t v·ªõi m√£ l·ªói {return_code} nh∆∞ng ƒë√£ t·∫°o file th√†nh c√¥ng: {final_output_path_check}")
                    self.after(0, lambda: self.download_view_frame.log_download(f"   ‚úîÔ∏è Ho√†n th√†nh (v·ªõi fallback c·ªßa yt-dlp)."))
                
                self.after(10, lambda: self.download_view_frame.update_download_progress(100))
                process_result = True
                output_filepath = final_output_path_check
            
            # N·∫øu KH√îNG t√¨m th·∫•y file output n√†o h·ª£p l·ªá
            else:
                process_result = False
                full_output_log = "\n".join(output_lines)
                logging.error(f"[{thread_name}] TH·∫§T B·∫†I: Kh√¥ng t√¨m th·∫•y file output h·ª£p l·ªá. M√£ l·ªói yt-dlp: {return_code}. URL: {url}. Log:\n{full_output_log[-2000:]}") # Log 2000 d√≤ng cu·ªëi

                # Ph√¢n t√≠ch l·ªói c·ª• th·ªÉ ƒë·ªÉ th√¥ng b√°o cho ng∆∞·ªùi d√πng
                specific_error_msg = None
                full_output_lower = full_output_log.lower()
                if "login required" in full_output_lower or "private video" in full_output_lower or "cookies" in full_output_lower: specific_error_msg = "Y√™u c·∫ßu ƒëƒÉng nh·∫≠p ho·∫∑c video ri√™ng t∆∞."
                elif "video unavailable" in full_output_lower: specific_error_msg = "Video kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a."
                elif "copyright" in full_output_lower: specific_error_msg = "Video b·ªã ch·∫∑n do v·∫•n ƒë·ªÅ b·∫£n quy·ªÅn."
                elif "geo-restricted" in full_output_lower or "geo restricted" in full_output_lower: specific_error_msg = "Video b·ªã gi·ªõi h·∫°n ƒë·ªãa l√Ω."
                elif "unsupported url" in full_output_lower: specific_error_msg = "URL kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£."
                elif "fragment" in full_output_lower and "ffmpeg" in full_output_lower: specific_error_msg = "L·ªói gh√©p file (c√≥ th·ªÉ thi·∫øu ffmpeg?)."
                
                # T·∫°o th√¥ng b√°o l·ªói cho UI
                error_log_msg_ui = f"   ‚ùå L·ªói t·∫£i {'Video' if is_video else 'MP3'} (m√£ {return_code})"
                if specific_error_msg:
                    error_log_msg_ui += f": {specific_error_msg}"
                self.after(0, lambda msg=error_log_msg_ui: self.download_view_frame.log_download(msg))

        except FileNotFoundError:
             logging.error(f"L·ªói FileNotFoundError: Kh√¥ng t√¨m th·∫•y file th·ª±c thi '{YTDLP_PATH}'.")
             self.after(0, lambda: self.download_view_frame.log_download(f"   ‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y '{YTDLP_PATH}'.")); process_result = False
             self.after(0, lambda: self.update_status(f"‚ùå L·ªói t·∫£i: Kh√¥ng t√¨m th·∫•y '{YTDLP_PATH}'."))
        except Exception as e:
             import traceback; error_details = traceback.format_exc()
             logging.error(f"[{thread_name}] L·ªói kh√¥ng mong ƒë·ª£i trong _execute_ytdlp: {e}\n{error_details}")
             self.after(0, lambda err=e: self.download_view_frame.log_download(f"   ‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh: {err}")); process_result = False
        finally:
            # --- Kh·ªëi Finally (ƒê·∫£m b·∫£o d·ªçn d·∫πp v√† k·∫øt th√∫c) ---
            # D·ªçn d·∫πp file t·∫°m n·∫øu t·∫£i th·∫•t b·∫°i v√† kh√¥ng ph·∫£i do ng∆∞·ªùi d√πng d·ª´ng
            if not process_result and not self.stop_event.is_set():
                logging.info(f"[{thread_name}] T·∫£i th·∫•t b·∫°i. ƒêang th·ª≠ d·ªçn d·∫πp file t·∫°m...")
                try:
                    if base_folder.is_dir():
                        for item in base_folder.iterdir():
                            if item.is_file() and (item.suffix.lower() in ['.part', '.ytdl'] or item.name.endswith('.temp')):
                                logging.info(f"ƒêang x√≥a file t·∫°m: {item.name}")
                                try: item.unlink()
                                except OSError as del_err: logging.warning(f"Kh√¥ng th·ªÉ x√≥a {item.name}: {del_err}")
                except Exception as cleanup_err: logging.error(f"L·ªói d·ªçn d·∫πp file t·∫°m: {cleanup_err}")

            # ƒê·∫£m b·∫£o ti·∫øn tr√¨nh con ƒë√£ th·ª±c s·ª± k·∫øt th√∫c
            if proc and proc.poll() is None: # Ki·ªÉm tra l·∫°i l·∫ßn n·ªØa tr∆∞·ªõc khi kill
                logging.warning(f"[{thread_name}] Ti·∫øn tr√¨nh yt-dlp v·∫´n ch·∫°y trong finally? ƒêang kill.")
                try:
                    proc.kill(); proc.wait(timeout=2) # Kill v√† ch·ªù ch√∫t
                    logging.info(f"[{thread_name}] ƒê√£ kill ti·∫øn tr√¨nh trong finally.")
                except Exception as final_kill_err: logging.error(f"L·ªói khi kill ti·∫øn tr√¨nh trong finally: {final_kill_err}")

            # N·∫øu t·∫£i th√†nh c√¥ng, c·∫≠p nh·∫≠t ƒë·ªëi t∆∞·ª£ng t√°c v·ª•
            if process_result and task_object_ref is not None:
                if is_video:
                    task_object_ref['downloaded_video_path'] = output_filepath
                    logging.info(f"ƒê√£ c·∫≠p nh·∫≠t 'downloaded_video_path' trong Task Object: {os.path.basename(output_filepath if output_filepath else 'None')}")
                else: # is_audio
                    task_object_ref['downloaded_audio_path'] = output_filepath
                    logging.info(f"ƒê√£ c·∫≠p nh·∫≠t 'downloaded_audio_path' trong Task Object: {os.path.basename(output_filepath if output_filepath else 'None')}")

            logging.info(f"[{thread_name}] Ho√†n t·∫•t _execute_ytdlp. Th√†nh c√¥ng: {process_result}, ƒê∆∞·ªùng d·∫´n: {output_filepath}")
            # Tr·∫£ v·ªÅ k·∫øt qu·∫£ (True/False, ƒë∆∞·ªùng d·∫´n file ho·∫∑c None)
            return (process_result, output_filepath)


# H√†m logic ch√≠nh: Th·ª±c hi·ªán t·∫£i xu·ªëng c√°c URL trong m·ªôt lu·ªìng ri√™ng
    def run_download(self, config_from_start):
        """
        Th·ª±c hi·ªán qu√° tr√¨nh t·∫£i xu·ªëng c√°c URL.
        Lu√¥n l·∫•y URL ti·∫øp theo t·ª´ ƒë·∫ßu self.download_urls_list.
        X·ª≠ l√Ω th·ª≠ l·∫°i link l·ªói v√† ki·ªÉm tra Sheet t·ª± ƒë·ªông khi h√†ng ch·ªù tr·ªëng.
        S·ª≠ d·ª•ng self.globally_completed_urls ƒë·ªÉ kh√¥ng t·∫£i l·∫°i link ƒë√£ th√†nh c√¥ng.
        """

        with keep_awake("Download media"):

            thread_name = threading.current_thread().name
            logging.info(f"[{thread_name}] RUN_DOWNLOAD: B·∫Øt ƒë·∫ßu (phi√™n b·∫£n ƒë·ªông, retry, sheet, global_completed).")

            # C√°c bi·∫øn theo d√µi cho l∆∞·ª£t ch·∫°y n√†y c·ªßa run_download
            successfully_downloaded_video_files_this_run = []
            error_links_encountered_this_run = [] 
            success_count_this_run = 0
            processed_count_this_run = 0
            successfully_created_task_objects_this_run = []
            
            # C√†i ƒë·∫∑t cho vi·ªác ki·ªÉm tra Sheet t·ª± ƒë·ªông
            last_sheet_check_time = 0 
            sheet_check_interval = config_from_start.get("sheet_check_interval_seconds", 60) # L·∫•y t·ª´ config ho·∫∑c m·∫∑c ƒë·ªãnh 60s

            MAX_RETRIES_PER_LINK = config_from_start.get("max_retries_per_link", 2) # L·∫•y t·ª´ config ho·∫∑c m·∫∑c ƒë·ªãnh 2

            attempted_final_sheet_check = False # Gi·ªØ nguy√™n c·ªù n√†y

            while not self.stop_event.is_set():
                current_url_to_process = None

                # --- A. X·ª¨ L√ù KHI H√ÄNG CH·ªú TR·ªêNG HO·∫∂C CH·ªà C√ì LINK ƒê√É MAX_RETRIES (BAO G·ªíM KI·ªÇM TRA SHEET) ---
                # Ki·ªÉm tra xem c√≥ c·∫ßn fetch sheet kh√¥ng
                should_fetch_sheet = False
                if not self.download_urls_list: # H√†ng ch·ªù tr·ªëng ho√†n to√†n
                    should_fetch_sheet = True
                    logging.info(f"[{thread_name}] RUN_DOWNLOAD: H√†ng ch·ªù tr·ªëng, s·∫Ω xem x√©t ki·ªÉm tra Sheet.")
                else: # H√†ng ch·ªù kh√¥ng tr·ªëng, ki·ªÉm tra xem t·∫•t c·∫£ c√≥ ph·∫£i ƒë√£ max_retry kh√¥ng
                    all_remaining_are_max_retries = True
                    for url_in_q_check in self.download_urls_list:
                        if self.download_retry_counts.get(url_in_q_check, 0) < MAX_RETRIES_PER_LINK:
                            all_remaining_are_max_retries = False
                            break
                    if all_remaining_are_max_retries:
                        should_fetch_sheet = True
                        logging.info(f"[{thread_name}] RUN_DOWNLOAD: H√†ng ch·ªù ch·ªâ c√≤n c√°c link ƒë√£ max_retry, s·∫Ω xem x√©t ki·ªÉm tra Sheet.")
                
                if should_fetch_sheet:
                    if self.disable_auto_sheet_check_var.get():
                        if not self.download_urls_list: # Ch·ªâ tho√°t n·∫øu h√†ng ch·ªù th·ª±c s·ª± r·ªóng v√† kh√¥ng ƒë∆∞·ª£c ki·ªÉm tra sheet
                            logging.info(f"[{thread_name}] RUN_DOWNLOAD: H√†ng ch·ªù tr·ªëng (ho·∫∑c ch·ªâ c√≤n link max_retry) v√† ng∆∞·ªùi d√πng ƒë√£ t·∫Øt ki·ªÉm tra Sheet. K·∫øt th√∫c t·∫£i.")
                            break 
                    else: 
                        current_time = time.time()
                        if (current_time - last_sheet_check_time > sheet_check_interval) or not attempted_final_sheet_check:
                            if not attempted_final_sheet_check:
                                logging.info(f"[{thread_name}] RUN_DOWNLOAD: H√†ng ch·ªù tr·ªëng/ch·ªâ c√≤n link max_retry, th·ª±c hi·ªán ki·ªÉm tra Sheet l·∫ßn cu·ªëi/ƒë·∫ßu khi r·ªóng h·ª£p l·ªá.")
                            else:
                                logging.info(f"[{thread_name}] RUN_DOWNLOAD: H√†ng ch·ªù tr·ªëng/ch·ªâ c√≤n link max_retry, ƒë·∫øn gi·ªù ki·ªÉm tra Google Sheet ƒë·ªãnh k·ª≥...")
                            
                            attempted_final_sheet_check = True 

                            sheet_fetch_done_event = threading.Event()
                            local_links_from_sheet = None
                            local_fetch_success = False
                            local_error_msg = None

                            def after_sheet_fetch_callback(success, links_returned, error_msg):
                                nonlocal local_links_from_sheet, local_fetch_success, local_error_msg
                                local_fetch_success = success
                                if success and links_returned: local_links_from_sheet = links_returned
                                elif not success and error_msg: local_error_msg = error_msg
                                sheet_fetch_done_event.set()
                            
                            self.fetch_links_from_sheet(callback=after_sheet_fetch_callback, auto_triggered=True)
                            
                            logging.debug(f"[{thread_name}] RUN_DOWNLOAD: ƒêang ch·ªù k·∫øt qu·∫£ t·ª´ Google Sheet (timeout 30s)...")
                            sheet_fetch_done_event.wait(timeout=30)
                            last_sheet_check_time = time.time() 

                            if not sheet_fetch_done_event.is_set():
                                logging.warning(f"[{thread_name}] RUN_DOWNLOAD: Qu√° th·ªùi gian ch·ªù l·∫•y link t·ª´ Sheet ho·∫∑c callback c√≥ v·∫•n ƒë·ªÅ.")
                            elif local_fetch_success and local_links_from_sheet is not None:
                                newly_added_to_main_list_count = 0
                                for link_fs in local_links_from_sheet:
                                    if link_fs not in self.download_urls_list and \
                                       link_fs not in self.globally_completed_urls: 
                                        self.download_urls_list.append(link_fs)
                                        self.download_retry_counts.pop(link_fs, None) 
                                        newly_added_to_main_list_count +=1
                                    elif link_fs in self.globally_completed_urls:
                                         logging.debug(f"[{thread_name}] RUN_DOWNLOAD: B·ªè qua link t·ª´ Sheet (ƒë√£ ho√†n th√†nh tr∆∞·ªõc ƒë√≥): {link_fs[:60]}...")
                                    elif link_fs in self.download_urls_list:
                                         logging.debug(f"[{thread_name}] RUN_DOWNLOAD: B·ªè qua link t·ª´ Sheet (ƒë√£ c√≥ trong h√†ng ch·ªù): {link_fs[:60]}...")
                                if newly_added_to_main_list_count > 0:
                                    logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ th√™m {newly_added_to_main_list_count} link M·ªöI t·ª´ Sheet.")
                                    self.after(0, self.update_download_queue_display)
                                    attempted_final_sheet_check = False
                                else:
                                    logging.info(f"[{thread_name}] RUN_DOWNLOAD: Sheet ƒë∆∞·ª£c ki·ªÉm tra, kh√¥ng c√≥ link th·ª±c s·ª± m·ªõi.")
                            elif not local_fetch_success:
                                 logging.error(f"[{thread_name}] RUN_DOWNLOAD: L·ªói khi t·ª± ƒë·ªông l·∫•y link t·ª´ Sheet: {local_error_msg}")
                            else: 
                                 logging.info(f"[{thread_name}] RUN_DOWNLOAD: Kh√¥ng c√≥ link n√†o ƒë∆∞·ª£c tr·∫£ v·ªÅ t·ª´ Sheet.")

                        else: 
                            if not self.download_urls_list:
                                logging.debug(f"[{thread_name}] RUN_DOWNLOAD: H√†ng ch·ªù r·ªóng ho√†n to√†n, ch∆∞a ƒë·∫øn gi·ªù ki·ªÉm tra Sheet ƒë·ªãnh k·ª≥, t·∫°m d·ª´ng 5s.")
                                time.sleep(5) 
                                continue 
                
                # ƒêi·ªÅu ki·ªán tho√°t n·∫øu self.download_urls_list r·ªóng ho√†n to√†n sau m·ªçi n·ªó l·ª±c
                if not self.download_urls_list: 
                     logging.info(f"[{thread_name}] RUN_DOWNLOAD: H√†ng ch·ªù r·ªóng ho√†n to√†n. K·∫øt th√∫c t·∫£i.")
                     break

                # --- B. CH·ªåN URL TI·∫æP THEO T·ª™ self.download_urls_list ƒê·ªÇ X·ª¨ L√ù (∆ØU TI√äN LINK M·ªöI) ---
                current_url_to_process = None
                url_chosen_for_processing_index = -1

                # ∆Øu ti√™n 1: T√¨m link m·ªõi ho√†n to√†n (retry_count == 0 ho·∫∑c ch∆∞a c√≥ trong retry_counts)
                for i, url_in_q in enumerate(self.download_urls_list):
                    if self.download_retry_counts.get(url_in_q, 0) == 0: # ∆Øu ti√™n link ch∆∞a th·ª≠ ho·∫∑c retry count l√† 0
                        url_chosen_for_processing_index = i
                        logging.info(f"[{thread_name}] RUN_DOWNLOAD: ∆Øu ti√™n link m·ªõi/ch∆∞a th·ª≠: '{url_in_q[:50]}...' ·ªü v·ªã tr√≠ {i}.")
                        break 
                
                # ∆Øu ti√™n 2: N·∫øu kh√¥ng c√≥ link m·ªõi, t√¨m link ƒë√£ th·ª≠ nh∆∞ng ch∆∞a max retries
                if url_chosen_for_processing_index == -1: # Kh√¥ng t√¨m th·∫•y link m·ªõi ho√†n to√†n
                    for i, url_in_q in enumerate(self.download_urls_list):
                        if self.download_retry_counts.get(url_in_q, 0) < MAX_RETRIES_PER_LINK:
                            url_chosen_for_processing_index = i
                            logging.info(f"[{thread_name}] RUN_DOWNLOAD: Ch·ªçn link ƒë√£ th·ª≠ nh∆∞ng ch∆∞a max retries: '{url_in_q[:50]}...' ·ªü v·ªã tr√≠ {i}.")
                            break
                
                if url_chosen_for_processing_index != -1:
                    if url_chosen_for_processing_index > 0:
                        current_url_to_process = self.download_urls_list.pop(url_chosen_for_processing_index)
                        self.download_urls_list.insert(0, current_url_to_process)
                        logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ di chuy·ªÉn link '{current_url_to_process[:50]}...' l√™n ƒë·∫ßu h√†ng ch·ªù.")
                    else: # url_chosen_for_processing_index == 0 (link h·ª£p l·ªá ƒë√£ ·ªü ƒë·∫ßu)
                        current_url_to_process = self.download_urls_list[0]
                else:

                    logging.info(f"[{thread_name}] RUN_DOWNLOAD: Kh√¥ng c√≤n link h·ª£p l·ªá ƒë·ªÉ th·ª≠ (t·∫•t c·∫£ ƒë√£ l·ªói qu√° {MAX_RETRIES_PER_LINK} l·∫ßn ho·∫∑c h√†ng ch·ªù tr·ªëng sau khi l·ªçc). K·∫øt th√∫c t·∫£i.")
                    break 

                if not current_url_to_process:
                     logging.error(f"[{thread_name}] RUN_DOWNLOAD: L·ªói logic - Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c current_url_to_process d√π ƒë√£ ch·ªçn index. Tho√°t.")
                     break

                # T·∫†O ƒê·ªêI T∆Ø·ª¢NG T√ÅC V·ª§ CHO URL HI·ªÜN T·∫†I
                task_object = {
                    'source': current_url_to_process,
                    'identifier': get_identifier_from_source(current_url_to_process),
                    'downloaded_video_path': None,  # S·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau khi t·∫£i video
                    'downloaded_audio_path': None,  # S·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau khi t·∫£i audio
                }
                logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ t·∫°o Task Object v·ªõi Identifier: '{task_object['identifier']}'")
                
                # --- C. X·ª¨ L√ù URL ƒê√É CH·ªåN ---
                self.current_download_url = current_url_to_process
                processed_count_this_run += 1
                current_retry_for_url = self.download_retry_counts.get(current_url_to_process, 0)

                self.after(0, self.update_download_queue_display) # C·∫≠p nh·∫≠t UI ngay khi ch·ªçn link
                self.after(0, lambda url=current_url_to_process, p=processed_count_this_run, retries=current_retry_for_url, total_q=len(self.download_urls_list): \
                    self.update_status(f"‚è≥ ƒêang t·∫£i link {p} (Th·ª≠ {retries+1}, c√≤n {total_q-1} ch·ªù): {url[:45]}..."))
                self.after(0, lambda: self.download_view_frame.update_download_progress(0))
                self.after(0, lambda url_log=current_url_to_process, retries=current_retry_for_url: \
                    self.download_view_frame.log_download(f"\nüîó--- ƒêang x·ª≠ l√Ω link (Th·ª≠ l·∫ßn {retries+1}): {url_log} ---"))

                loop_start_time = time.time()
                link_overall_success = True
                video_filepath_result = None
                at_least_one_download_attempted = False

                # --- C.1. T·∫£i Video ---
                if config_from_start.get("mode", "video") in ["video", "both"]:
                    at_least_one_download_attempted = True
                    if self.stop_event.is_set(): link_overall_success = False
                    else:
                        self.after(0, lambda: self.download_view_frame.log_download("   üé¨ ƒêang t·∫£i Video..."))
                        video_success, video_filepath_returned = self._execute_ytdlp(current_url_to_process, config_from_start, is_video=True, index=processed_count_this_run, task_object_ref=task_object)
                        if not video_success: link_overall_success = False
                        elif video_filepath_returned: video_filepath_result = video_filepath_returned
                
                # --- C.2. T·∫£i MP3 ---
                should_download_mp3 = (config_from_start.get("mode", "video") in ["mp3", "both"])
                if should_download_mp3 and not self.stop_event.is_set() and \
                   (config_from_start.get("mode", "video") == "mp3" or link_overall_success): # Ch·ªâ t·∫£i MP3 n·∫øu mode l√† mp3 ho·∫∑c video (n·∫øu c√≥) ƒë√£ th√†nh c√¥ng
                    at_least_one_download_attempted = True
                    if config_from_start.get("mode", "video") == "both": self.after(0, lambda: self.download_view_frame.update_download_progress(0))
                    self.after(0, lambda: self.download_view_frame.log_download("   üéµ ƒêang t·∫£i MP3..."))
                    mp3_success, _ = self._execute_ytdlp(current_url_to_process, config_from_start, is_video=False, index=processed_count_this_run, task_object_ref=task_object)
                    if not mp3_success: link_overall_success = False
                elif should_download_mp3 and not link_overall_success and config_from_start.get("mode", "video") == "both":
                     logging.info(f"[{thread_name}] RUN_DOWNLOAD: Ch·∫ø ƒë·ªô 'both', video l·ªói n√™n b·ªè qua t·∫£i MP3 cho: {current_url_to_process}")
                     self.after(0, lambda url_log=current_url_to_process: self.download_view_frame.log_download(f"   ‚ö†Ô∏è Video l·ªói, b·ªè qua MP3 cho: {url_log[:80]}..."))

                if not at_least_one_download_attempted and not self.stop_event.is_set():
                    link_overall_success = False # Coi nh∆∞ l·ªói n·∫øu kh√¥ng c√≥ g√¨ ƒë∆∞·ª£c th·ª≠ t·∫£i
                    logging.warning(f"[{thread_name}] RUN_DOWNLOAD: Kh√¥ng c√≥ t√°c v·ª• t·∫£i n√†o cho URL: {current_url_to_process} v·ªõi ch·∫ø ƒë·ªô {config_from_start.get('mode', 'video')}")
                    self.after(0, lambda url_log=current_url_to_process: self.download_view_frame.log_download(f"   ‚ö†Ô∏è Kh√¥ng t·∫£i g√¨ cho: {url_log[:80]}... (Ch·∫ø ƒë·ªô: {config_from_start.get('mode', 'video')})"))
                    if current_url_to_process not in error_links_encountered_this_run: 
                        error_links_encountered_this_run.append(current_url_to_process)

                # --- C.3. X·ª≠ l√Ω k·∫øt qu·∫£ c·ªßa link n√†y ---
                if not self.stop_event.is_set(): 
                    loop_end_time = time.time()
                    duration = loop_end_time - loop_start_time
                    
                    if link_overall_success:
                        success_count_this_run += 1
                        self.after(0, lambda url_log=current_url_to_process, t=duration: self.download_view_frame.log_download(f"   ‚úÖ Ho√†n th√†nh Link: {url_log[:80]}... (Th·ªùi gian: {t:.2f}s)"))
                        if video_filepath_result and os.path.exists(video_filepath_result):
                            if video_filepath_result not in successfully_downloaded_video_files_this_run:
                                successfully_downloaded_video_files_this_run.append(video_filepath_result)

                        successfully_created_task_objects_this_run.append(task_object)
                        self.globally_completed_urls.add(current_url_to_process) # ƒê√°nh d·∫•u ƒë√£ ho√†n th√†nh to√†n c·ª•c
                        logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ th√™m '{current_url_to_process[:50]}...' v√†o globally_completed_urls.")
                        
                        try: # X√≥a kh·ªèi h√†ng ch·ªù v√† retry_counts
                            if self.download_urls_list and self.download_urls_list[0] == current_url_to_process:
                                self.download_urls_list.pop(0)
                                self.download_retry_counts.pop(current_url_to_process, None)
                                logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ x√≥a URL th√†nh c√¥ng '{current_url_to_process[:50]}...' v√† reset retry.")
                            elif current_url_to_process in self.download_urls_list: 
                                self.download_urls_list.remove(current_url_to_process)
                                self.download_retry_counts.pop(current_url_to_process, None)
                                logging.warning(f"[{thread_name}] RUN_DOWNLOAD: URL th√†nh c√¥ng '{current_url_to_process[:50]}...' ƒë∆∞·ª£c x√≥a (v√† reset retry) nh∆∞ng kh√¥ng t·ª´ v·ªã tr√≠ ƒë·∫ßu.")
                            else: 
                                logging.warning(f"[{thread_name}] RUN_DOWNLOAD: URL th√†nh c√¥ng '{current_url_to_process[:50]}...' kh√¥ng t√¨m th·∫•y ƒë·ªÉ x√≥a/reset retry.")
                        except Exception as e_remove:
                            logging.error(f"[{thread_name}] RUN_DOWNLOAD: L·ªói khi x√≥a URL th√†nh c√¥ng '{current_url_to_process[:50]}...': {e_remove}")
                    
                    else: # link_overall_success is False (v√† kh√¥ng ph·∫£i do stop_event)
                        self.after(0, lambda url_log=current_url_to_process, t=duration: self.download_view_frame.log_download(f"   ‚ö†Ô∏è Ho√†n th√†nh Link v·ªõi l·ªói: {url_log[:80]}... (Th·ªùi gian: {t:.2f}s)"))
                        if current_url_to_process not in error_links_encountered_this_run: 
                             error_links_encountered_this_run.append(current_url_to_process)

                        current_retry_for_url_after_attempt = self.download_retry_counts.get(current_url_to_process, 0) + 1
                        self.download_retry_counts[current_url_to_process] = current_retry_for_url_after_attempt
                        logging.info(f"[{thread_name}] RUN_DOWNLOAD: URL '{current_url_to_process[:50]}...' l·ªói l·∫ßn {current_retry_for_url_after_attempt}.")

                        if current_retry_for_url_after_attempt >= MAX_RETRIES_PER_LINK:
                            logging.warning(f"[{thread_name}] RUN_DOWNLOAD: URL '{current_url_to_process[:50]}...' ƒë√£ l·ªói {current_retry_for_url_after_attempt} l·∫ßn. S·∫Ω kh√¥ng th·ª≠ l·∫°i v√† gi·ªØ nguy√™n v·ªã tr√≠ (s·∫Ω b·ªã b·ªè qua ·ªü v√≤ng l·∫∑p sau).")
                            self.after(0, lambda url_log=current_url_to_process: self.download_view_frame.log_download(f"   üö´ Link {url_log[:50]}... ƒë√£ l·ªói qu√° nhi·ªÅu l·∫ßn, s·∫Ω kh√¥ng th·ª≠ l·∫°i."))

                        else:
                            if self.download_urls_list and self.download_urls_list[0] == current_url_to_process:
                                if len(self.download_urls_list) > 1: 
                                    try:
                                        failed_url = self.download_urls_list.pop(0)
                                        self.download_urls_list.append(failed_url)
                                        logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ chuy·ªÉn URL l·ªói (th·ª≠ l·∫ßn {current_retry_for_url_after_attempt}) '{failed_url[:50]}...' xu·ªëng cu·ªëi.")
                                    except Exception as e_move_failed:
                                        logging.error(f"[{thread_name}] RUN_DOWNLOAD: L·ªói khi chuy·ªÉn URL l·ªói '{current_url_to_process[:50]}...': {e_move_failed}")
                                else: 
                                    logging.warning(f"[{thread_name}] RUN_DOWNLOAD: URL l·ªói '{current_url_to_process[:50]}...' l√† m·ª•c duy nh·∫•t (th·ª≠ {current_retry_for_url_after_attempt}), kh√¥ng di chuy·ªÉn.")
                        
                        if config_from_start.get("stop_on_error", False):
                            self.after(0, lambda: self.download_view_frame.log_download("\n‚úã ƒê√£ b·∫≠t 'D·ª´ng khi l·ªói'. D·ª´ng x·ª≠ l√Ω!"))
                            self.stop_event.set() 
                
                if self.stop_event.is_set():
                    logging.info(f"[{thread_name}] RUN_DOWNLOAD: Ph√°t hi·ªán c·ªù d·ª´ng sau khi x·ª≠ l√Ω m·ªôt link, tho√°t v√≤ng l·∫∑p t·∫£i.")
                    break 
            
            # ===== K·∫æT TH√öC V√íNG L·∫∂P while not self.stop_event.is_set() =====
            logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ tho√°t v√≤ng l·∫∑p t·∫£i ch√≠nh.")

            # --- Kh·ªëi finally: D·ªçn d·∫πp v√† Ho√†n t·∫•t ---
            try:
                logging.info(f"[{thread_name}] RUN_DOWNLOAD: V√†o kh·ªëi finally.")
                self.current_download_url = None
                self.is_downloading = False 
                logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ ƒë·∫∑t self.is_downloading = False")
                self.after(10, self.update_download_queue_display)

                final_message = ""
                should_auto_sub = False
                files_for_sub = [] 

                current_remaining_links_in_master_queue = getattr(self, 'download_urls_list', [])
                
                unique_links_attempted_count = success_count_this_run + len(set(error_links_encountered_this_run))

                if self.stop_event.is_set():
                    final_message = "\nüõë Qu√° tr√¨nh t·∫£i ƒë√£ b·ªã d·ª´ng (b·ªüi ng∆∞·ªùi d√πng ho·∫∑c l·ªói)."
                    if current_remaining_links_in_master_queue : 
                         final_message += f"\n   (C√≤n {len(current_remaining_links_in_master_queue)} link trong h√†ng ch·ªù ch∆∞a x·ª≠ l√Ω ho√†n to√†n.)"
                    should_auto_sub = False
                else: 
                    final_message = f"\nüèÅ === T·ªîNG K·∫æT T·∫¢I ===\n"

                    # --- TH√äM TH√îNG B√ÅO V·ªÄ KI·ªÇM TRA SHEET ---
                    if self.disable_auto_sheet_check_var.get():
                        final_message += "   (T·ª± ƒë·ªông ki·ªÉm tra Google Sheet: ƒê√£ t·∫Øt b·ªüi ng∆∞·ªùi d√πng)\n"
                    else:
                        # C√≥ th·ªÉ th√™m th√¥ng tin v·ªÅ l·∫ßn ki·ªÉm tra sheet cu·ªëi c√πng n·∫øu mu·ªën, v√≠ d·ª•:
                        # if last_sheet_check_time > 0: # Bi·∫øn last_sheet_check_time c·∫ßn ƒë∆∞·ª£c gi·ªØ l·∫°i sau v√≤ng l·∫∑p
                        #    final_message += f"   (T·ª± ƒë·ªông ki·ªÉm tra Google Sheet: ƒê√£ b·∫≠t, l·∫ßn cu·ªëi l√∫c {datetime.fromtimestamp(last_sheet_check_time).strftime('%H:%M:%S')})\n"
                        # else:
                        final_message += "   (T·ª± ƒë·ªông ki·ªÉm tra Google Sheet: ƒê√£ b·∫≠t)\n"
                    # -----------------------------------------

                    final_message += f"   - T·ªïng s·ªë l∆∞·ª£t x·ª≠ l√Ω link trong l∆∞·ª£t n√†y: {processed_count_this_run}\n"

                    final_message += f"   - S·ªë link t·∫£i th√†nh c√¥ng trong l∆∞·ª£t n√†y: {success_count_this_run}\n"
                    
                    # Th√¥ng tin v·ªÅ c√°c link l·ªói G·∫∂P PH·∫¢I trong l∆∞·ª£t n√†y
                    if error_links_encountered_this_run:
                        final_message += f"   - S·ªë link g·∫∑p l·ªói trong l∆∞·ª£t n√†y: {len(error_links_encountered_this_run)}\n"
                        for err_link in error_links_encountered_this_run[:3]: # Hi·ªÉn th·ªã t·ªëi ƒëa 3 link l·ªói c·ª• th·ªÉ
                             retry_c_err = self.download_retry_counts.get(err_link, 0)
                             final_message += f"      - {err_link[:80]}... (ƒê√£ th·ª≠ {retry_c_err} l·∫ßn, t·ªëi ƒëa {MAX_RETRIES_PER_LINK})\n"
                        if len(error_links_encountered_this_run) > 3:
                            final_message += f"      ... v√† {len(error_links_encountered_this_run) - 3} link l·ªói kh√°c.\n"

                    # Th√¥ng tin v·ªÅ c√°c link C√íN L·∫†I trong h√†ng ch·ªù (c√≥ th·ªÉ l√† link l·ªói ƒë√£ max_retry, ho·∫∑c link ch∆∞a ƒë·∫øn l∆∞·ª£t n·∫øu b·ªã d·ª´ng)
                    if current_remaining_links_in_master_queue:
                        final_message += f"   - Link c√≤n l·∫°i trong h√†ng ch·ªù cu·ªëi c√πng: {len(current_remaining_links_in_master_queue)}\n"
                        for rem_link in current_remaining_links_in_master_queue[:3]: 
                            retry_c_rem = self.download_retry_counts.get(rem_link, 0)
                            status_rem = f"(ƒê√£ th·ª≠ {retry_c_rem} l·∫ßn)" if retry_c_rem > 0 else "(Ch∆∞a th·ª≠/ƒê√£ reset)"
                            if retry_c_rem >= MAX_RETRIES_PER_LINK:
                                status_rem = f"(ƒê√£ th·ª≠ {retry_c_rem} l·∫ßn - T·ªëi ƒëa)"
                            final_message += f"      - {rem_link[:80]}... {status_rem}\n"
                        if len(current_remaining_links_in_master_queue) > 3:
                            final_message += f"      ... v√† {len(current_remaining_links_in_master_queue) - 3} link kh√°c.\n"
                    elif not error_links_encountered_this_run and success_count_this_run == processed_count_this_run and processed_count_this_run > 0 : 
                         final_message += f"   üéâ T·∫•t c·∫£ {success_count_this_run} link y√™u c·∫ßu ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω th√†nh c√¥ng!\n"
                    elif processed_count_this_run == 0:
                         final_message += f"   ‚ÑπÔ∏è Kh√¥ng c√≥ link n√†o ƒë∆∞·ª£c x·ª≠ l√Ω trong l∆∞·ª£t n√†y (h√†ng ch·ªù c√≥ th·ªÉ ƒë√£ tr·ªëng t·ª´ ƒë·∫ßu).\n"


                    is_auto_sub_request = config_from_start.get("auto_sub_after_download", False)
                    if is_auto_sub_request:

                        verified_video_files = [f for f in successfully_downloaded_video_files_this_run if os.path.exists(f)] #S·ª≠a th√†nh _this_run
                        if verified_video_files:
                            should_auto_sub = True
                            files_for_sub = verified_video_files 
                            final_message += f"\nüîÑ ƒê√£ t·∫£i xong {len(files_for_sub)} file video. Chu·∫©n b·ªã t·ª± ƒë·ªông t·∫°o ph·ª• ƒë·ªÅ...\n"
                        else:
                            final_message += "\n‚ö†Ô∏è Y√™u c·∫ßu t·ª± ƒë·ªông sub, nh∆∞ng kh√¥ng c√≥ file video h·ª£p l·ªá n√†o ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng ƒë·ªÉ x·ª≠ l√Ω.\n"
                    else:
                         final_message += "\n(Kh√¥ng y√™u c·∫ßu t·ª± ƒë·ªông sub).\n"

                    if config_from_start.get("do_sound", False) and config_from_start.get("sound_file") and PLAYSOUND_AVAILABLE:
                       self.after(100, lambda: self.download_view_frame.log_download(" üîä ƒêang ph√°t √¢m thanh ho√†n t·∫•t t·∫£i..."))
                       play_sound_async(config_from_start["sound_file"]) # ƒê√£ s·ª≠a ·ªü b∆∞·ªõc tr∆∞·ªõc

                self.after(150, lambda msg=final_message: self.download_view_frame.log_download(msg))

                final_status_text = "‚úÖ T·∫£i ho√†n t·∫•t!" 
                if self.stop_event.is_set(): 
                    final_status_text = "üõë ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng/l·ªói."
                elif current_remaining_links_in_master_queue: 
                    final_status_text = f"‚ö†Ô∏è Ho√†n t·∫•t v·ªõi {len(current_remaining_links_in_master_queue)} link c√≤n l·∫°i/l·ªói."
                elif should_auto_sub: 
                    final_status_text = f"‚úÖ T·∫£i xong {len(files_for_sub)} video! ƒêang chuy·ªÉn sang Sub..."
                
                self.after(200, lambda text=final_status_text: self.update_status(text))

                if not should_auto_sub: 
                    self.after(250, lambda: self.download_view_frame.set_download_ui_state(downloading=False))

                if not self.stop_event.is_set() and not should_auto_sub:
                     self.after(250, lambda: self.download_view_frame.update_download_progress(0))

                # L·∫•y tr·∫°ng th√°i c·ªßa checkbox T·ª± ƒë·ªông Upload
                is_auto_upload_request = self.auto_upload_after_download_var.get()

                if should_auto_sub:
                    # ∆Øu ti√™n chu·ªói Sub -> Dub/Upload tr∆∞·ªõc (logic n√†y ƒë√£ x·ª≠ l√Ω vi·ªác upload sau sub)
                    self.after(500, self._trigger_auto_sub, successfully_created_task_objects_this_run, config_from_start.get("and_then_dub", False))
                    logging.info(f"[{thread_name}] RUN_DOWNLOAD: G·ªçi _trigger_auto_sub v·ªõi {len(successfully_created_task_objects_this_run)} task objects...")
                
                # <<< B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI CH√çNH ·ªû ƒê√ÇY >>>
                elif is_auto_upload_request and successfully_created_task_objects_this_run:
                    # N·∫øu ch·ªâ b·∫≠t Auto Upload (kh√¥ng b·∫≠t Auto Sub)
                    logging.info(f"[{thread_name}] RUN_DOWNLOAD: Chu·∫©n b·ªã th√™m {len(successfully_created_task_objects_this_run)} video ƒë√£ t·∫£i v√†o h√†ng ch·ªù Upload.")
                    self.after(0, lambda: self.update_status(f"‚úÖ T·∫£i xong! ƒêang th√™m v√†o h√†ng ch·ªù Upload..."))

                    # L·∫∑p qua c√°c task object ƒë√£ t·∫°o v√† th√™m v√†o h√†ng ch·ªù upload
                    for task_obj in successfully_created_task_objects_this_run:
                        # Vi·ªác g·ªçi self.after ·ªü ƒë√¢y s·∫Ω ƒë·∫£m b·∫£o c√°c t√°c v·ª• th√™m v√†o h√†ng ch·ªù ƒë∆∞·ª£c th·ª±c hi·ªán tu·∫ßn t·ª± tr√™n lu·ªìng ch√≠nh
                        self.after(10, self._add_completed_video_to_upload_queue, task_obj)
                    
                    # SAU KHI ƒê√É L√äN L·ªäCH TH√äM V√ÄO H√ÄNG CH·ªú, B√ÇY GI·ªú CH√öNG TA S·∫º K√çCH HO·∫†T QU√Å TR√åNH UPLOAD
                    def start_upload_chain():
                        logging.info(f"[{thread_name}] RUN_DOWNLOAD: K√≠ch ho·∫°t _start_youtube_batch_upload sau khi ƒë√£ th√™m file t·ª´ Download.")
                        # Chuy·ªÉn sang tab Upload cho ng∆∞·ªùi d√πng th·∫•y
                        try:
                            upload_tab_value = "üì§ Upload YT" 
                            if hasattr(self, 'view_switcher') and self.view_switcher.get() != upload_tab_value:
                                self.view_switcher.set(upload_tab_value)
                                self.switch_view(upload_tab_value)
                        except Exception as e_switch:
                            logging.error(f"[{thread_name}] L·ªói khi t·ª± ƒë·ªông chuy·ªÉn sang tab Upload: {e_switch}")

                        self._start_youtube_batch_upload()

                    # L√™n l·ªãch ƒë·ªÉ b·∫Øt ƒë·∫ßu chu·ªói upload sau m·ªôt kho·∫£ng tr·ªÖ nh·ªè (v√≠ d·ª• 500ms)
                    # ƒë·ªÉ ƒë·∫£m b·∫£o c√°c t√°c v·ª• "th√™m v√†o h√†ng ch·ªù" ƒë√£ ƒë∆∞·ª£c th·ª±c hi·ªán xong.
                    self.after(500, start_upload_chain)

                else:
                    # Tr∆∞·ªùng h·ª£p kh√¥ng c√≥ chu·ªói t·ª± ƒë·ªông n√†o, ch·ªâ d·ªçn d·∫πp v√† k·∫øt th√∫c
                    self.after(250, lambda: self.download_view_frame.set_download_ui_state(downloading=False))
                    self.after(600, self._check_completion_and_shutdown) 

                self.download_thread = None 
                logging.info(f"[{thread_name}] RUN_DOWNLOAD: ƒê√£ ho√†n t·∫•t kh·ªëi finally v√† k·∫øt th√∫c.")

            except Exception as e_final_outer: 
                logging.critical(f"[{thread_name}] RUN_DOWNLOAD: L·ªñI NGHI√äM TR·ªåNG kh√¥ng x·ª≠ l√Ω ƒë∆∞·ª£c: {e_final_outer}", exc_info=True)
                self.after(0, lambda: self.download_view_frame.set_download_ui_state(downloading=False)) 
                self.after(0, lambda: self.update_status(f"‚ùå L·ªói nghi√™m tr·ªçng khi t·∫£i!"))
                self.is_downloading = False 
                self.current_download_url = None
                self.download_thread = None


# H√†m logic: K√≠ch ho·∫°t qu√° tr√¨nh t·ª± ƒë·ªông t·∫°o ph·ª• ƒë·ªÅ sau khi t·∫£i xong
    def _trigger_auto_sub(self, list_of_task_objects, trigger_dubbing_afterwards=False): # S·ª≠a t√™n tham s·ªë
        """
        B·∫Øt ƒë·∫ßu qu√° tr√¨nh sub tr√™n lu·ªìng ch√≠nh sau khi t·∫£i xong.
        NH·∫¨N V√ÄO m·ªôt danh s√°ch c√°c task object.
        """
        logging.info(f"K√≠ch ho·∫°t t·ª± ƒë·ªông sub cho {len(list_of_task_objects)} task ƒë√£ t·∫£i.")

        self.pending_auto_dub_after_current_sub_batch = trigger_dubbing_afterwards
        if self.pending_auto_dub_after_current_sub_batch:
            self.files_for_chained_dubbing = []
            logging.info("   >>> Chu·∫©n b·ªã thu th·∫≠p k·∫øt qu·∫£ sub ƒë·ªÉ t·ª± ƒë·ªông thuy·∫øt minh.")

        if not list_of_task_objects:
            logging.warning("K√≠ch ho·∫°t t·ª± ƒë·ªông sub nh∆∞ng kh√¥ng nh·∫≠n ƒë∆∞·ª£c task object n√†o.")
            self.download_view_frame.set_download_ui_state(downloading=False)
            self.update_status("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file video ƒë·ªÉ t·ª± ƒë·ªông sub.")
            self._check_completion_and_shutdown()
            return

        # --- THAY ƒê·ªîI L·ªöN ·ªû ƒê√ÇY ---
        added_count = 0
        for task_obj in list_of_task_objects:
            # L·∫•y ƒë∆∞·ªùng d·∫´n video t·ª´ task object
            file_path = task_obj.get('downloaded_video_path')
            if file_path and os.path.exists(file_path):
                # Th√™m TO√ÄN B·ªò task object v√†o h√†ng ch·ªù, kh√¥ng ch·ªâ ƒë∆∞·ªùng d·∫´n
                if task_obj not in self.file_queue:
                    self.file_queue.append(task_obj)
                    added_count += 1
                    logging.info(f"ƒê√£ th√™m task object (ID: {task_obj.get('identifier')}) v√†o h√†ng ch·ªù sub.")
                else:
                    logging.warning(f"Task object (ID: {task_obj.get('identifier')}) ƒë√£ c√≥ trong h√†ng ch·ªù sub.")
            else:
                logging.warning(f"ƒê∆∞·ªùng d·∫´n file trong task object kh√¥ng h·ª£p l·ªá: {file_path}")

        if added_count == 0:
             logging.error("Kh√¥ng th·ªÉ th√™m file video ƒë√£ t·∫£i h·ª£p l·ªá n√†o v√†o h√†ng ch·ªù sub.")
             self.download_view_frame.set_download_ui_state(downloading=False) # ƒê·∫£m b·∫£o UI Download reset
             self.update_status("‚ùå L·ªói: Kh√¥ng th·ªÉ th√™m file video ƒë√£ t·∫£i v√†o h√†ng ch·ªù sub.")
             self._check_completion_and_shutdown()
             return

        # 2. C·∫≠p nh·∫≠t hi·ªÉn th·ªã h√†ng ch·ªù sub
        self.update_queue_display()
        logging.info(f"ƒê√£ th√™m {added_count} file v√†o h√†ng ch·ªù sub.")

        # 3. Chuy·ªÉn sang Tab Subtitle (n·∫øu ch∆∞a ·ªü ƒë√≥)
        try:
            subtitle_tab_value = "‚â° T·∫°o Ph·ª• ƒê·ªÅ" # Gi√° tr·ªã c·ªßa tab t·∫°o ph·ª• ƒë·ªÅ
            if hasattr(self, 'view_switcher') and self.view_switcher and self.view_switcher.winfo_exists():
                if self.view_switcher.get() != subtitle_tab_value:
                    self.view_switcher.set(subtitle_tab_value)
                    self.switch_view(subtitle_tab_value) # G·ªçi h√†m chuy·ªÉn tab c·ªßa b·∫°n
                    logging.info(f"ƒê√£ chuy·ªÉn view sang '{subtitle_tab_value}' ƒë·ªÉ t·ª± ƒë·ªông sub.")
            else:
                logging.warning("Kh√¥ng th·ªÉ t·ª± ƒë·ªông chuy·ªÉn view: kh√¥ng t√¨m th·∫•y view_switcher.")
        except Exception as switch_e:
             logging.error(f"L·ªói chuy·ªÉn view ƒë·ªÉ t·ª± ƒë·ªông sub: {switch_e}")


        # 4. G·ªçi h√†m b·∫Øt ƒë·∫ßu sub (auto_sub_all)
        # C√°c ki·ªÉm tra ƒëi·ªÅu ki·ªán (is_subbing, model loaded,...) gi·ªØ nguy√™n
        if self.is_subbing:
             messagebox.showwarning("ƒêang x·ª≠ l√Ω", "ƒêang x·ª≠ l√Ω t√°c v·ª• sub kh√°c. Vui l√≤ng ƒë·ª£i.", parent=self)
             self.download_view_frame.set_download_ui_state(downloading=False) # Reset UI Download
             self._check_completion_and_shutdown()
             return

        if self.whisper_model is None and not self.is_loading_model:
             messagebox.showwarning("Model ch∆∞a s·∫µn s√†ng", "Whisper model ch∆∞a s·∫µn s√†ng ƒë·ªÉ t·ª± ƒë·ªông sub. Vui l√≤ng ƒë·ª£i model t·∫£i xong ho·∫∑c ch·ªçn l·∫°i model v√† b·∫Øt ƒë·∫ßu sub th·ªß c√¥ng trong tab 'T·∫°o Ph·ª• ƒê·ªÅ'.", parent=self)
             self.download_view_frame.set_download_ui_state(downloading=False) # Reset UI Download
             return
        if self.is_loading_model:
             messagebox.showwarning("Model ƒëang t·∫£i", "Whisper model ƒëang ƒë∆∞·ª£c t·∫£i. Qu√° tr√¨nh sub s·∫Ω c·∫ßn ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu th·ªß c√¥ng sau khi model t·∫£i xong.", parent=self)
             self.download_view_frame.set_download_ui_state(downloading=False) # Reset UI Download
             return

        logging.info("G·ªçi auto_sub_all() ƒë·ªÉ b·∫Øt ƒë·∫ßu x·ª≠ l√Ω h√†ng ch·ªù sub.")
        self.auto_sub_all()

        self.after(100, lambda: self.download_view_frame.set_download_ui_state(downloading=False))
        logging.info("ƒê√£ l√™n l·ªãch reset UI c·ªßa tab Download sau khi k√≠ch ho·∫°t auto_sub_all.")






# H√†m h·ªó tr·ª£ UI Download: C·∫≠p nh·∫≠t hi·ªÉn th·ªã h√†ng ch·ªù t·∫£i xu·ªëng
    def update_download_queue_display(self):
        """ C·∫≠p nh·∫≠t n·ªôi dung hi·ªÉn th·ªã trong CTkScrollableFrame c·ªßa h√†ng ch·ªù download (Th√™m n√∫t L√™n/Xu·ªëng/X√≥a). """
        queue_widget = getattr(self.download_view_frame, 'download_queue_section', None) if hasattr(self, 'download_view_frame') else None
        if not queue_widget or not hasattr(queue_widget, 'winfo_exists') or not queue_widget.winfo_exists():
            return

        for widget in queue_widget.winfo_children():
            widget.destroy()

        current_url = getattr(self, 'current_download_url', None)
        all_urls_in_list = getattr(self, 'download_urls_list', [])
        
        waiting_urls_only = []
        if all_urls_in_list:
            if current_url:
                temp_waiting_list = []
                found_current_in_list = False
                for u_in_all in all_urls_in_list:
                    if u_in_all == current_url and not found_current_in_list:
                        found_current_in_list = True 
                        continue 
                    temp_waiting_list.append(u_in_all)
                
                if not found_current_in_list and current_url is not None:
                     waiting_urls_only = list(all_urls_in_list)
                else:
                     waiting_urls_only = temp_waiting_list
            else: 
                waiting_urls_only = list(all_urls_in_list)
        
        queue_len_display = len(waiting_urls_only)

        if current_url:
            frame = ctk.CTkFrame(queue_widget, fg_color="#007bff", corner_radius=5)
            frame.pack(fill="x", pady=(2, 3), padx=2)
            display_url_current = current_url if len(current_url) < 80 else current_url[:77] + "..."
            label_text = f"‚ñ∂Ô∏è ƒêANG T·∫¢I:\n   {display_url_current}"
            ctk.CTkLabel(frame, text=label_text, font=("Segoe UI", 10, "bold"), justify="left", anchor='w', text_color="white").pack(side="left", padx=5, pady=3)

        if not waiting_urls_only and not current_url:
            ctk.CTkLabel(queue_widget, text="[H√†ng ch·ªù download tr·ªëng]", font=("Segoe UI", 11), text_color="gray").pack(anchor="center", pady=20)
        elif not waiting_urls_only and current_url:
            ctk.CTkLabel(queue_widget, text="[ƒêang x·ª≠ l√Ω link cu·ªëi c√πng...]", font=("Segoe UI", 10, "italic"), text_color="gray").pack(anchor="center", pady=5)
        elif waiting_urls_only:
            for i, url_in_waiting_list in enumerate(waiting_urls_only):
                item_frame = ctk.CTkFrame(queue_widget, fg_color="transparent")
                item_frame.pack(fill="x", padx=2, pady=(1,2))

                display_url_waiting = url_in_waiting_list
                retry_count_for_this_url = self.download_retry_counts.get(url_in_waiting_list, 0)
                status_suffix = f" (L·ªói - th·ª≠ {retry_count_for_this_url} l·∫ßn)" if retry_count_for_this_url > 0 else ""

                ctk.CTkLabel(item_frame, text=f"{i+1}. {display_url_waiting}{status_suffix}", anchor="w", font=("Segoe UI", 10)).pack(side="left", padx=(5, 0), expand=True, fill="x")

                # --- KHUNG CH·ª®A C√ÅC N√öT ƒêI·ªÄU KHI·ªÇN ---
                controls_button_frame = ctk.CTkFrame(item_frame, fg_color="transparent")
                controls_button_frame.pack(side="right", padx=(0,5))

                # N√∫t L√™n
                # S·ª¨A STATE: Ch·ªâ NORMAL n·∫øu kh√¥ng ƒëang t·∫£i V√Ä kh√¥ng ph·∫£i m·ª•c ƒë·∫ßu ti√™n
                up_button_state_dl = ctk.NORMAL if not self.is_downloading and i > 0 else ctk.DISABLED
                up_button_dl = ctk.CTkButton(controls_button_frame, text="‚Üë",
                                          width=26, height=26,
                                          font=("Segoe UI", 14, "bold"),
                                          command=lambda idx_disp=i: self.move_item_in_download_queue(idx_disp, "up"), # S·ª¨A H√ÄM G·ªåI
                                          state=up_button_state_dl) # S·ª¨A STATE
                up_button_dl.pack(side="left", padx=(0, 2))

                # N√∫t Xu·ªëng
                # S·ª¨A STATE: Ch·ªâ NORMAL n·∫øu kh√¥ng ƒëang t·∫£i V√Ä kh√¥ng ph·∫£i m·ª•c cu·ªëi c√πng
                down_button_state_dl = ctk.NORMAL if not self.is_downloading and i < queue_len_display - 1 else ctk.DISABLED
                down_button_dl = ctk.CTkButton(controls_button_frame, text="‚Üì",
                                            width=26, height=26,
                                            font=("Segoe UI", 14, "bold"),
                                            command=lambda idx_disp=i: self.move_item_in_download_queue(idx_disp, "down"), # S·ª¨A H√ÄM G·ªåI
                                            state=down_button_state_dl) # S·ª¨A STATE
                down_button_dl.pack(side="left", padx=2)

                # N√∫t X√≥a
                # S·ª¨A STATE: Ch·ªâ NORMAL n·∫øu kh√¥ng ƒëang t·∫£i
                del_button_state_dl = ctk.NORMAL if not self.is_downloading else ctk.DISABLED
                del_button_dl = ctk.CTkButton(controls_button_frame, text="‚úï",
                                          width=26, height=26,
                                          font=("Segoe UI", 12, "bold"),
                                          command=lambda idx_disp=i: self.remove_item_from_download_queue(idx_disp), # S·ª¨A H√ÄM G·ªåI
                                          fg_color="#E74C3C", hover_color="#C0392B",
                                          text_color="white", state=del_button_state_dl) # S·ª¨A STATE
                del_button_dl.pack(side="left", padx=(2,0))


# H√†m logic (ch·∫°y trong lu·ªìng): Ki·ªÉm tra tr·∫°ng th√°i CUDA v√† VRAM GPU
    def check_cuda_status_thread(self, callback=None): 
        """Ch·∫°y ki·ªÉm tra CUDA v√† l·∫•y VRAM trong thread."""
        logging.info("B·∫Øt ƒë·∫ßu ki·ªÉm tra tr·∫°ng th√°i CUDA v√† VRAM (c√≥ callback)...")
        # G·ªçi h√†m is_cuda_available() ƒë√£ s·ª≠a ·ªü B∆∞·ªõc 1, nh·∫≠n v·ªÅ tuple
        status, vram_mb = is_cuda_available()
        # L√™n l·ªãch ch·∫°y h√†m _update_cuda_status_ui tr√™n lu·ªìng ch√≠nh v·ªõi c·∫£ status, vram_mb, v√† callback
        self.after(0, self._update_cuda_status_ui, status, vram_mb, callback) 



# H√†m callback UI: C·∫≠p nh·∫≠t hi·ªÉn th·ªã tr·∫°ng th√°i CUDA v√† VRAM tr√™n giao di·ªán - PHI√äN B·∫¢N S·ª¨A L·ªñI M√ÄU
    def _update_cuda_status_ui(self, status, vram_mb, callback=None):    
        """
        Callback ƒë·ªÉ c·∫≠p nh·∫≠t UI tr·∫°ng th√°i CUDA v√† VRAM (ch·∫°y tr√™n lu·ªìng ch√≠nh).
        S·ª≠ d·ª•ng tuple m√†u ƒë·ªÉ t∆∞∆°ng th√≠ch Light/Dark mode.
        """
        self.cuda_status = status
        self.gpu_vram_mb = vram_mb
        logging.info(f"Tr·∫°ng th√°i CUDA: {status}, T·ªïng VRAM: {vram_mb} MiB. Chu·∫©n b·ªã c·∫≠p nh·∫≠t UI.")

        status_message_to_display = "CUDA: ?"
        # ƒê·ªãnh nghƒ©a m√†u s·∫Øc cho c·∫£ 2 ch·∫ø ƒë·ªô S√°ng v√† T·ªëi
        status_color = ("gray10", "gray90") # M√†u m·∫∑c ƒë·ªãnh/l·ªói

        if status == 'AVAILABLE':
            vram_gb_str = f" ({(vram_mb / 1024):.1f} GB)" if vram_mb > 0 else ""
            status_message_to_display = f"CUDA: ‚úÖ S·∫µn s√†ng{vram_gb_str}"
            status_color = ("#008000", "#90EE90")  # (Dark Green cho Light Mode, Light Green cho Dark Mode)
        elif status == 'NO_DEVICE':
            status_message_to_display = "CUDA: ‚ö†Ô∏è Kh√¥ng c√≥ GPU"
            status_color = ("#E65100", "#FFB74D")  # (Dark Orange cho Light, Light Orange cho Dark)
        elif status == 'COMMAND_NOT_FOUND':
            status_message_to_display = "CUDA: ‚ùî (thi·∫øu nvidia-smi)"
            status_color = ("#E65100", "#FFB74D")
        else: # ERROR ho·∫∑c UNKNOWN
            status_message_to_display = "CUDA: ‚ùå L·ªói ki·ªÉm tra"
            status_color = ("#B71C1C", "#E57373")  # (Dark Red cho Light, Light Red cho Dark)
        
        # C·∫≠p nh·∫≠t label chuy√™n d·ª•ng trong tab Whisper
        if hasattr(self, 'cuda_status_label') and self.cuda_status_label and self.cuda_status_label.winfo_exists():
            self.cuda_status_label.configure(text=status_message_to_display, text_color=status_color)
        
        # C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i ch√≠nh ·ªü d∆∞·ªõi c√πng, n·∫øu kh√¥ng c√≥ t√°c v·ª• n√†o kh√°c ƒëang ch·∫°y
        # (ƒê·ªÉ tr√°nh ghi ƒë√® th√¥ng b√°o "ƒêang Sub...")
        if not (self.is_subbing or self.is_downloading or self.is_loading_model):
            self.update_status(status_message_to_display)
        
        #self.after(50, self._update_translation_engine_status)

        self.mark_startup_task_done('cuda_check')
        if callback:
            callback()


    # H√†m ti·ªán √≠ch UI: Kh√¥i ph·ª•c tr·∫°ng th√°i giao di·ªán sau khi t·∫£i model xong (ho·∫∑c l·ªói)
    def _reset_model_loading_ui(self):
        """Kh√¥i ph·ª•c tr·∫°ng th√°i UI sau khi t·∫£i model xong (ho·∫∑c l·ªói)."""
        logging.debug("ƒêang kh√¥i ph·ª•c UI sau khi t·∫£i model...")

        # T·∫ÆT C·ªú CHO ƒê·ªíNG H·ªí
        was_loading_model_for_timer = self.is_loading_model_for_timer # L∆∞u tr·∫°ng th√°i c≈©
        self.is_loading_model_for_timer = False
        logging.debug("ƒê√£ ƒë·∫∑t self.is_loading_model_for_timer = False")

        # K√≠ch ho·∫°t l·∫°i n√∫t Sub
        is_app_active = self._is_app_fully_activated()

        sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
        if sub_button and sub_button.winfo_exists():
             try:
                 # Ch·ªâ b·∫≠t l·∫°i n√∫t Sub n·∫øu kh√¥ng c√≥ t√°c v·ª• subbing n√†o kh√°c ƒëang ch·∫°y
                 if not self.is_subbing: # <<< TH√äM KI·ªÇM TRA N√ÄY >>>
                     current_state_sub_btn = "normal" if is_app_active else "disabled"
                     button_text_sub_btn = "‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu SUB" if is_app_active else "üîí K√≠ch ho·∫°t (Sub)"
                     # Ki·ªÉm tra xem c√≥ ·ªü manual mode kh√¥ng
                     if self.manual_merge_mode_var.get():
                         button_text_sub_btn = "üî® B·∫Øt ƒë·∫ßu Gh√©p Th·ªß C√¥ng"
                         current_state_sub_btn = "normal" # ·ªû manual mode, n√∫t n√†y n√™n b·∫≠t n·∫øu kh√¥ng subbing

                     sub_button.configure(state=current_state_sub_btn, text=button_text_sub_btn)
                     logging.debug(f"ƒê√£ kh√¥i ph·ª•c n√∫t Sub v·ªÅ tr·∫°ng th√°i: {current_state_sub_btn}")
                 else:
                     logging.debug("N√∫t Sub kh√¥ng ƒë∆∞·ª£c b·∫≠t l·∫°i v√¨ is_subbing v·∫´n True (c√≥ th·ªÉ t√°c v·ª• sub kh√°c ƒëang ch·ªù).")
             except Exception as e:
                 logging.warning(f"Kh√¥ng th·ªÉ kh√¥i ph·ª•c n√∫t Sub: {e}")

        # (M·ªöI) Ki·ªÉm tra v√† reset start_time n·∫øu kh√¥ng c√≤n t√°c v·ª• n√†o kh√°c d√πng timer
        if was_loading_model_for_timer: # Ch·ªâ ki·ªÉm tra n·∫øu n√≥ v·ª´a m·ªõi ƒë∆∞·ª£c t·∫Øt
            all_other_timer_tasks_stopped_after_model = not (
                self.is_downloading or
                self.is_subbing or
                # self.is_loading_model_for_timer is now False
                self.dub_is_processing or
                self.is_creating_slideshow or
                self.is_gpt_processing_script or
                self.is_dalle_processing
            )
            if all_other_timer_tasks_stopped_after_model:
                if self.start_time is not None:
                    self.start_time = None
                    logging.info("T·∫£i model ho√†n t·∫•t/l·ªói. Kh√¥ng c√≤n t√°c v·ª• n√†o kh√°c d√πng timer, ƒë√£ reset self.start_time.")
                    # C·∫≠p nh·∫≠t status n·∫øu kh√¥ng c√≥ g√¨ kh√°c ƒëang ch·∫°y
                    # H√†m check_if_fully_ready c≈©ng c√≥ th·ªÉ x·ª≠ l√Ω vi·ªác n√†y
                    if not (self.is_subbing or self.is_downloading or self.dub_is_processing): # Ki·ªÉm tra l·∫°i
                        self.after(100, lambda: self.update_status("‚úÖ Piu ƒë√£ x·ª≠ l√Ω xong. ·ª®ng d·ª•ng ƒë√£ s·∫µn s√†ng!"))
            else:
                logging.info("T·∫£i model ho√†n t·∫•t/l·ªói. V·∫´n c√≤n t√°c v·ª• kh√°c d√πng timer, self.start_time KH√îNG ƒë∆∞·ª£c reset b·ªüi _reset_model_loading_ui.")



# C√°c h√†m x·ª≠ l√Ω Google Sheet---------------------------------------------------------------------------------------------------------------------------
    # H√†m h√†nh ƒë·ªông: B·∫Øt ƒë·∫ßu qu√° tr√¨nh l·∫•y link t·ª´ Google Sheet
    def fetch_links_from_sheet(self, callback=None, auto_triggered=False):
        """
        X·ª≠ l√Ω vi·ªác l·∫•y Sheet ID v√† Range t·ª´ ng∆∞·ªùi d√πng (n·∫øu c·∫ßn khi kh√¥ng ph·∫£i auto_triggered)
        v√† kh·ªüi ch·∫°y lu·ªìng _fetch_sheet_data_thread ƒë·ªÉ l·∫•y link.

        Args:
            callback (function, optional): H√†m ƒë∆∞·ª£c g·ªçi sau khi lu·ªìng l·∫•y d·ªØ li·ªáu Sheet ho√†n t·∫•t.
                                           Signature: callback(success: bool, links: list|None, error_message: str|None)
            auto_triggered (bool, optional): True n·∫øu ƒë∆∞·ª£c g·ªçi t·ª± ƒë·ªông t·ª´ run_download.
                                             S·∫Ω kh√¥ng hi·ªÉn th·ªã dialog h·ªèi ID/Range ho·∫∑c c√°c messagebox th√¥ng th∆∞·ªùng.
        """
        current_thread_name = threading.current_thread().name
        logging.info(f"[{current_thread_name}] B·∫Øt ƒë·∫ßu fetch_links_from_sheet. Auto: {auto_triggered}, C√≥ callback: {callable(callback)}")

        sheet_id = self.sheet_id_var.get().strip()
        sheet_range = self.sheet_range_var.get().strip()

        # --- X·ª≠ l√Ω l·∫•y Sheet ID v√† Range t·ª´ ng∆∞·ªùi d√πng n·∫øu kh√¥ng ph·∫£i auto_triggered ---
        if not auto_triggered:
            if not sheet_id:
                dialog_id = ctk.CTkInputDialog(text="Vui l√≤ng nh·∫≠p Google Sheet ID:", title="Nh·∫≠p Sheet ID")
                try:
                    self.update_idletasks()
                    dialog_id.update_idletasks()
                    x = self.winfo_x() + (self.winfo_width() // 2) - (dialog_id.winfo_reqwidth() // 2)
                    y = self.winfo_y() + (self.winfo_height() // 2) - (dialog_id.winfo_reqheight() // 2)
                    dialog_id.geometry(f"+{x}+{y}")
                except Exception as e_center: logging.warning(f"L·ªói cƒÉn gi·ªØa dialog ID: {e_center}")
                
                entered_id = dialog_id.get_input()
                if entered_id is not None and entered_id.strip():
                    sheet_id = entered_id.strip()
                    self.sheet_id_var.set(sheet_id)
                    self.cfg['sheet_id'] = sheet_id # C·∫≠p nh·∫≠t config tr·ª±c ti·∫øp
                else:
                    logging.info(f"[{current_thread_name}] Ng∆∞·ªùi d√πng h·ªßy nh·∫≠p Sheet ID.")
                    if callback: self.after(0, lambda: callback(False, None, "Ng∆∞·ªùi d√πng h·ªßy nh·∫≠p Sheet ID.")) # G·ªçi callback tr√™n lu·ªìng ch√≠nh
                    else: messagebox.showwarning("Thi·∫øu th√¥ng tin", "B·∫°n c·∫ßn nh·∫≠p Google Sheet ID ƒë·ªÉ ti·∫øp t·ª•c.", parent=self)
                    if hasattr(self, 'download_view_frame'): self.download_view_frame._reenable_fetch_button() # B·∫≠t l·∫°i n√∫t n·∫øu n√≥ b·ªã disable
                    return
            
            default_range_example = "Sheet1!B2:B" # ƒê∆∞a ra ngo√†i ƒë·ªÉ d√πng chung
            if not sheet_range:
                dialog_range = ctk.CTkInputDialog(text=f"Vui l√≤ng nh·∫≠p Ph·∫°m vi c·∫ßn ƒë·ªçc:\n(V√≠ d·ª•: {default_range_example})", title="Nh·∫≠p Ph·∫°m vi Sheet")
                try:
                    self.update_idletasks()
                    dialog_range.update_idletasks()
                    x = self.winfo_x() + (self.winfo_width() // 2) - (dialog_range.winfo_reqwidth() // 2)
                    y = self.winfo_y() + (self.winfo_height() // 2) - (dialog_range.winfo_reqheight() // 2)
                    dialog_range.geometry(f"+{x}+{y}")
                except Exception as e_center: logging.warning(f"L·ªói cƒÉn gi·ªØa dialog Range: {e_center}")

                entered_range = dialog_range.get_input()
                if entered_range is not None and entered_range.strip():
                    if '!' not in entered_range or not entered_range.split('!')[1]: # Ki·ªÉm tra ƒë·ªãnh d·∫°ng c∆° b·∫£n
                        logging.warning(f"[{current_thread_name}] ƒê·ªãnh d·∫°ng Ph·∫°m vi Sheet kh√¥ng h·ª£p l·ªá: {entered_range}")
                        if callback: self.after(0, lambda: callback(False, None, f"ƒê·ªãnh d·∫°ng Ph·∫°m vi Sheet kh√¥ng h·ª£p l·ªá: {entered_range}"))
                        else: messagebox.showerror("Sai ƒë·ªãnh d·∫°ng", f"Ph·∫°m vi '{entered_range}' kh√¥ng h·ª£p l·ªá.\nV√≠ d·ª• ƒë√∫ng: {default_range_example}", parent=self)
                        if hasattr(self, 'download_view_frame'): self.download_view_frame._reenable_fetch_button()
                        return
                    else:
                        sheet_range = entered_range.strip()
                        self.sheet_range_var.set(sheet_range)
                        self.cfg['sheet_range'] = sheet_range # C·∫≠p nh·∫≠t config tr·ª±c ti·∫øp
                else:
                    logging.info(f"[{current_thread_name}] Ng∆∞·ªùi d√πng h·ªßy nh·∫≠p Ph·∫°m vi Sheet.")
                    if callback: self.after(0, lambda: callback(False, None, "Ng∆∞·ªùi d√πng h·ªßy nh·∫≠p Ph·∫°m vi Sheet."))
                    else: messagebox.showwarning("Thi·∫øu th√¥ng tin", f"B·∫°n c·∫ßn nh·∫≠p Ph·∫°m vi Sheet (v√≠ d·ª•: {default_range_example}) ƒë·ªÉ ti·∫øp t·ª•c.", parent=self)
                    if hasattr(self, 'download_view_frame'): self.download_view_frame._reenable_fetch_button()
                    return
        
        # --- Ki·ªÉm tra l·∫°i ID v√† Range tr∆∞·ªõc khi ch·∫°y thread (quan tr·ªçng cho c·∫£ auto v√† manual) ---
        if not sheet_id or not sheet_range:
            log_msg = f"[{current_thread_name}] Thi·∫øu Sheet ID ('{sheet_id}') ho·∫∑c Range ('{sheet_range}') ƒë·ªÉ l·∫•y link."
            logging.error(log_msg)
            if callback: self.after(0, lambda: callback(False, None, "Thi·∫øu Sheet ID ho·∫∑c Range trong c·∫•u h√¨nh."))
            if not auto_triggered: # Ch·ªâ hi·ªán l·ªói cho ng∆∞·ªùi d√πng n·∫øu h·ªç nh·∫•n n√∫t
                messagebox.showerror("Thi·∫øu Th√¥ng Tin", "Sheet ID ho·∫∑c Ph·∫°m vi kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng trong c·∫•u h√¨nh ho·∫∑c √¥ nh·∫≠p.", parent=self)
                if hasattr(self, 'download_view_frame'): self.download_view_frame._reenable_fetch_button()
            return

        # L∆∞u c·∫•u h√¨nh n·∫øu ng∆∞·ªùi d√πng ƒë√£ nh·∫≠p (kh√¥ng ph·∫£i auto) v√† c√≥ thay ƒë·ªïi
        if not auto_triggered: 
            self.save_current_config() # save_current_config s·∫Ω l·∫•y gi√° tr·ªã t·ª´ c√°c StringVar
            logging.info(f"[{current_thread_name}] ƒê√£ l∆∞u config (n·∫øu c√≥ thay ƒë·ªïi t·ª´ dialog) tr∆∞·ªõc khi l·∫•y link Sheet.")

        # --- V√¥ hi·ªáu h√≥a n√∫t v√† c·∫≠p nh·∫≠t status (CH·ªà KHI KH√îNG PH·∫¢I AUTO_TRIGGERED) ---
        if not auto_triggered:
            self.update_status("üîÑ ƒêang l·∫•y link t·ª´ Google Sheet...")
            if hasattr(self, 'add_sheet_button') and self.add_sheet_button and self.add_sheet_button.winfo_exists():
                try: self.add_sheet_button.configure(state="disabled", text="ƒêang l·∫•y...")
                except Exception: pass # B·ªè qua n·∫øu n√∫t kh√¥ng t·ªìn t·∫°i/l·ªói
        
        # --- Kh·ªüi ch·∫°y lu·ªìng l·∫•y d·ªØ li·ªáu ---
        logging.info(f"[{current_thread_name}] Chu·∫©n b·ªã ch·∫°y _fetch_sheet_data_thread. SheetID: {sheet_id}, Range: {sheet_range}, Auto: {auto_triggered}, Callback: {callable(callback)}")
        thread = threading.Thread(
            target=self._fetch_sheet_data_thread, 
            args=(sheet_id, sheet_range, callback, auto_triggered), # Truy·ªÅn callback v√† auto_triggered
            daemon=True, 
            name="SheetReaderThread"
        )
        thread.start()


# H√†m logic (ch·∫°y trong lu·ªìng): L·∫•y d·ªØ li·ªáu t·ª´ Google Sheet
    def _fetch_sheet_data_thread(self, sheet_id, sheet_range, callback=None, auto_triggered=False):
        """
        Lu·ªìng th·ª±c hi·ªán l·∫•y d·ªØ li·ªáu t·ª´ Google Sheet b·∫±ng API ch√≠nh th·ª©c.
        G·ªçi callback khi ho√†n th√†nh v·ªõi k·∫øt qu·∫£.
        """
        thread_name = threading.current_thread().name
        logging.info(f"[{thread_name}] B·∫Øt ƒë·∫ßu _fetch_sheet_data_thread. SheetID: {sheet_id}, Range: {sheet_range}, Auto: {auto_triggered}")

        service = None
        fetched_links_list = None 
        was_successful = False
        error_msg_for_callback = None

        try:
            logging.debug(f"[{thread_name}] ƒêang th·ª≠ l·∫•y service Google Sheets...")
            service = get_google_api_service(api_name='sheets', api_version='v4') # G·ªçi ƒë√∫ng t√™n v√† truy·ªÅn tham s·ªë Sheets API

            if service is None:
                # L·ªói x·∫£y ra trong get_sheets_service() ho·∫∑c ng∆∞·ªùi d√πng h·ªßy x√°c th·ª±c
                error_msg_for_callback = "L·ªói x√°c th·ª±c ho·∫∑c ng∆∞·ªùi d√πng h·ªßy k·∫øt n·ªëi Google Sheets."
                logging.error(f"[{thread_name}] {error_msg_for_callback}")
                
                if auto_triggered and not self.cfg.get("google_auth_declined_in_current_session", False):
                    def _handle_auto_auth_fail_for_sheet_thread():
                        self.disable_auto_sheet_check_var.set(True) 
                        self.cfg["disable_auto_sheet_check"] = True 
                        self.cfg["google_auth_declined_in_current_session"] = True 
                        save_config(self.cfg) # L∆∞u l·∫°i config
                        logging.warning(f"[{thread_name}] L·ªói x√°c th·ª±c Google (t·ª± ƒë·ªông), ƒë√£ t·ª± ƒë·ªông t·∫Øt ki·ªÉm tra Sheet cho session n√†y v√† l∆∞u config.")
                    self.after(0, _handle_auto_auth_fail_for_sheet_thread)
            else:
                # X√°c th·ª±c th√†nh c√¥ng, x√≥a c·ªù l·ªói session (n·∫øu c√≥) ƒë·ªÉ l·∫ßn sau n·∫øu c√≥ l·ªói v·∫´n hi·ªán UI x√°c th·ª±c
                if "google_auth_declined_in_current_session" in self.cfg:
                    logging.info(f"[{thread_name}] X√°c th·ª±c Google th√†nh c√¥ng, x√≥a c·ªù 'google_auth_declined_in_current_session'.")
                    self.cfg.pop("google_auth_declined_in_current_session")
                    save_config(self.cfg) # L∆∞u l·∫°i config
                
                logging.info(f"[{thread_name}] L·∫•y service Google Sheets th√†nh c√¥ng. ƒêang g·ªçi API...")
                sheet_api_service = service.spreadsheets() # ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n v·ªõi module
                result = sheet_api_service.values().get(spreadsheetId=sheet_id, range=sheet_range).execute()
                values = result.get('values', [])
                logging.info(f"[{thread_name}] Ph·∫£n h·ªìi t·ª´ Google Sheets API: {len(values)} h√†ng d·ªØ li·ªáu.")

                if not values:
                    logging.info(f"[{thread_name}] Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu (h√†ng r·ªóng) trong ph·∫°m vi Sheet ch·ªâ ƒë·ªãnh: {sheet_range}")
                    was_successful = True 
                    fetched_links_list = [] # Tr·∫£ v·ªÅ list r·ªóng n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
                    error_msg_for_callback = "Kh√¥ng c√≥ d·ªØ li·ªáu trong ph·∫°m vi Sheet ƒë√£ ch·ªçn." 
                else:
                    temp_links = []
                    for row_idx, row_data in enumerate(values):
                        if row_data and len(row_data) > 0: # Ki·ªÉm tra h√†ng v√† c·ªôt c√≥ t·ªìn t·∫°i
                             link_value = str(row_data[0]).strip() # Gi·∫£ s·ª≠ link ·ªü c·ªôt ƒë·∫ßu ti√™n (index 0)
                             if link_value.startswith(('http://', 'https://')):
                                  temp_links.append(link_value)
                             elif link_value: # N·∫øu c√≥ gi√° tr·ªã nh∆∞ng kh√¥ng ph·∫£i link
                                  logging.warning(f"[{thread_name}] B·ªè qua gi√° tr·ªã kh√¥ng ph·∫£i URL t·ª´ h√†ng {row_idx+1}, c·ªôt 1: '{link_value[:60]}...'")
                        else:
                             logging.debug(f"[{thread_name}] B·ªè qua h√†ng r·ªóng ho·∫∑c kh√¥ng c√≥ c·ªôt ƒë·∫ßu ti√™n ·ªü h√†ng {row_idx+1} t·ª´ sheet.")
                    
                    fetched_links_list = temp_links
                    was_successful = True # API g·ªçi th√†nh c√¥ng, d√π c√≥ th·ªÉ kh√¥ng c√≥ link n√†o h·ª£p l·ªá
                    logging.info(f"[{thread_name}] Tr√≠ch xu·∫•t ƒë∆∞·ª£c {len(fetched_links_list)} link h·ª£p l·ªá t·ª´ Sheet.")
        
        except HttpError as err:
            was_successful = False # ƒê√°nh d·∫•u l√† kh√¥ng th√†nh c√¥ng
            error_content_decoded = getattr(err, 'content', b'').decode('utf-8', 'replace')
            error_msg_for_callback = f"L·ªói Google API (Sheet): M√£ {err.resp.status}. "
            logging.error(f"[{thread_name}] {error_msg_for_callback} N·ªôi dung: {error_content_decoded}", exc_info=False)
            try: # C·ªë g·∫Øng parse l·ªói chi ti·∫øt t·ª´ JSON
                 error_json = json.loads(error_content_decoded)
                 error_detail_msg = error_json.get('error', {}).get('message', 'Kh√¥ng c√≥ chi ti·∫øt l·ªói c·ª• th·ªÉ t·ª´ JSON.')
                 error_msg_for_callback += error_detail_msg
                 # Th√™m g·ª£i √Ω d·ª±a tr√™n n·ªôi dung l·ªói
                 if "PERMISSION_DENIED" in error_content_decoded.upper(): # upper() ƒë·ªÉ b·∫Øt c·∫£ ch·ªØ th∆∞·ªùng
                     error_msg_for_callback += "\nG·ª£i √Ω: Sheet c√≥ th·ªÉ ch∆∞a ƒë∆∞·ª£c chia s·∫ª quy·ªÅn xem cho t√†i kho·∫£n Google ƒë√£ x√°c th·ª±c, ho·∫∑c Sheet ID/Ph·∫°m vi kh√¥ng ƒë√∫ng."
                 elif "REQUESTED_ENTITY_WAS_NOT_FOUND" in error_content_decoded.upper():
                      error_msg_for_callback += f"\nG·ª£i √Ω: Sheet ID '{sheet_id}' c√≥ th·ªÉ kh√¥ng t·ªìn t·∫°i ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p."
                 elif "UNABLE_TO_PARSE_RANGE" in error_content_decoded.upper():
                       error_msg_for_callback += f"\nG·ª£i √Ω: Ph·∫°m vi '{sheet_range}' kh√¥ng h·ª£p l·ªá."
            except json.JSONDecodeError:
                 error_msg_for_callback += f"Kh√¥ng th·ªÉ ph√¢n t√≠ch ph·∫£n h·ªìi l·ªói JSON. Ph·∫£n h·ªìi th√¥: {error_content_decoded[:250]}..."
            # Kh√¥ng return s·ªõm, ƒë·ªÉ kh·ªëi finally g·ªçi callback

        except Exception as e: # B·∫Øt c√°c l·ªói kh√¥ng mong mu·ªën kh√°c
            was_successful = False
            error_msg_for_callback = f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi l·∫•y link t·ª´ Sheet: {str(e)}"
            logging.error(f"[{thread_name}] {error_msg_for_callback}", exc_info=True)
            # Kh√¥ng return s·ªõm
        
        finally:
            log_final_status = f"Ho√†n t·∫•t _fetch_sheet_data_thread. Th√†nh c√¥ng k·ªπ thu·∫≠t (API call): {was_successful}, S·ªë link tr√≠ch xu·∫•t: {len(fetched_links_list) if fetched_links_list is not None else 'N/A'}"
            logging.info(f"[{thread_name}] {log_final_status}")
            
            if callback:
                try:
                    # G·ªçi callback tr√™n lu·ªìng ch√≠nh
                    self.after(0, lambda cb=callback, s=was_successful, l=fetched_links_list, err=error_msg_for_callback: cb(s, l, err))
                    logging.debug(f"[{thread_name}] ƒê√£ l√™n l·ªãch g·ªçi callback v·ªõi success={was_successful}.")
                except Exception as e_cb:
                    logging.error(f"[{thread_name}] L·ªói khi l√™n l·ªãch g·ªçi callback sau khi l·∫•y link t·ª´ Sheet: {e_cb}", exc_info=True)
            
            # Ch·ªâ x·ª≠ l√Ω UI (n√∫t, status) n·∫øu KH√îNG ph·∫£i auto_triggered V√Ä KH√îNG c√≥ callback
            # (V√¨ n·∫øu c√≥ callback, callback s·∫Ω ch·ªãu tr√°ch nhi·ªám x·ª≠ l√Ω UI ti·∫øp theo)
            if not auto_triggered and not callback:
                if was_successful:
                    if fetched_links_list: # C√≥ link
                        self.after(0, self._process_sheet_links, fetched_links_list) 
                        self.after(0, self.update_status, f"‚úÖ ƒê√£ l·∫•y {len(fetched_links_list)} link t·ª´ Google Sheet.")
                    else: # Kh√¥ng c√≥ link (list r·ªóng)
                         self.after(0, self.update_status, f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y link n√†o trong ph·∫°m vi Sheet ƒë√£ ch·ªçn.")
                         self.after(0, lambda msg="Kh√¥ng t√¨m th·∫•y link n√†o trong ph·∫°m vi Sheet ƒë∆∞·ª£c ch·ªçn.": messagebox.showinfo("Kh√¥ng c√≥ link", msg, parent=self))
                else: # Kh√¥ng th√†nh c√¥ng (c√≥ error_msg_for_callback)
                    self.after(0, self.update_status, f"‚ùå L·ªói l·∫•y link Sheet: {error_msg_for_callback[:100]}...") # Gi·ªõi h·∫°n ƒë·ªô d√†i msg
                    self.after(0, lambda msg=error_msg_for_callback: messagebox.showerror("L·ªói l·∫•y link t·ª´ Sheet", msg, parent=self))
                
                if hasattr(self, 'download_view_frame'): self.after(10, self.download_view_frame._reenable_fetch_button) # B·∫≠t l·∫°i n√∫t "Th√™m t·ª´ Sheet"



# H√†m h·ªó tr·ª£ UI: X·ª≠ l√Ω c√°c link l·∫•y ƒë∆∞·ª£c t·ª´ Sheet (th√™m v√†o Textbox)
    def _process_sheet_links(self, links):
        """ C·∫≠p nh·∫≠t √¥ Textbox v·ªõi c√°c link l·∫•y ƒë∆∞·ª£c t·ª´ Sheet (ch·∫°y tr√™n lu·ªìng ch√≠nh) """
        download_textbox = getattr(self.download_view_frame, 'download_url_text', None) if hasattr(self, 'download_view_frame') else None
        if not download_textbox or not download_textbox.winfo_exists():
            logging.error("Textbox download_url_text kh√¥ng t·ªìn t·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t link t·ª´ Sheet.")
            return

        if not isinstance(links, list):
             logging.error(f"D·ªØ li·ªáu links nh·∫≠n ƒë∆∞·ª£c kh√¥ng ph·∫£i l√† list: {type(links)}")
             messagebox.showerror("L·ªói d·ªØ li·ªáu", "D·ªØ li·ªáu link nh·∫≠n ƒë∆∞·ª£c t·ª´ Google Sheet kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng.", parent=self)
             return

        if not links:
            logging.info("Kh√¥ng c√≥ link h·ª£p l·ªá n√†o ƒë∆∞·ª£c tr·∫£ v·ªÅ t·ª´ Sheet.")
            messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng t√¨m th·∫•y link n√†o trong ph·∫°m vi ƒë√£ ch·ªçn tr√™n Google Sheet ho·∫∑c Sheet tr·ªëng.", parent=self)
            return

        try:
            current_content = download_textbox.get("1.0", "end-1c")
            current_links = set(line.strip() for line in current_content.splitlines() if line.strip())

            added_links = []
            for link in links:
                if link not in current_links:
                    added_links.append(link)
                    current_links.add(link)

            if not added_links:
                 logging.info("Kh√¥ng c√≥ link m·ªõi n√†o t·ª´ Sheet ƒë·ªÉ th√™m v√†o Textbox.")
                 messagebox.showinfo("Th√¥ng b√°o", "C√°c link tr√™n Sheet ƒë√£ c√≥ trong danh s√°ch t·∫£i.", parent=self)
                 return

            new_links_str = "\n".join(added_links)
            final_text = current_content
            if current_content and new_links_str:
                final_text += "\n"
            final_text += new_links_str

            download_textbox.delete("1.0", "end")
            download_textbox.insert("1.0", final_text)
            download_textbox.see("end")

            logging.info(f"ƒê√£ th√™m {len(added_links)} link m·ªõi t·ª´ Sheet v√†o Textbox.")
            messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ th√™m th√†nh c√¥ng {len(added_links)} link m·ªõi t·ª´ Google Sheet.", parent=self)

        except Exception as e:
            logging.error(f"L·ªói khi c·∫≠p nh·∫≠t Textbox v·ªõi link t·ª´ Sheet: {e}", exc_info=True)
            messagebox.showerror("L·ªói c·∫≠p nh·∫≠t", "Kh√¥ng th·ªÉ hi·ªÉn th·ªã link l·∫•y ƒë∆∞·ª£c t·ª´ Google Sheet.", parent=self)


# H√†m ƒë·ªìng b·ªô (√≠t d√πng): L·∫•y link t·ª´ Sheet (kh√¥ng ch·∫°y lu·ªìng)
    def _fetch_links_from_sheet_sync(self, service, sheet_id, sheet_range):
        """
        G·ªçi API Google Sheets ƒë·ªìng b·ªô ƒë·ªÉ l·∫•y danh s√°ch link.
        Tr·∫£ v·ªÅ list c√°c link ho·∫∑c None n·∫øu c√≥ l·ªói.
        """
        thread_name = threading.current_thread().name
        logging.info(f"[{thread_name}] SYNC Fetch: ƒêang g·ªçi Sheets API. ID: {sheet_id}, Ph·∫°m vi: {sheet_range}")

        if not service:
            logging.error(f"[{thread_name}] SYNC Fetch: Thi·∫øu ƒë·ªëi t∆∞·ª£ng service Google Sheets.")
            return None

        try:
            sheet = service.spreadsheets()
            result = sheet.values().get(spreadsheetId=sheet_id, range=sheet_range).execute()
            values = result.get('values', [])
            logging.info(f"[{thread_name}] SYNC Fetch: API tr·∫£ v·ªÅ {len(values)} h√†ng.")

            if not values:
                return []

            links = []
            for row in values:
                if row:
                     link_value = str(row[0]).strip()
                     if link_value.startswith(('http://', 'https://')):
                          links.append(link_value)
            logging.info(f"[{thread_name}] SYNC Fetch: Tr√≠ch xu·∫•t {len(links)} link h·ª£p l·ªá.")
            return links

        except HttpError as err:
            error_content = getattr(err, 'content', b'').decode('utf-8')
            logging.error(f"[{thread_name}] SYNC Fetch: L·ªói HTTP Google API: {err.resp.status} - {error_content}", exc_info=False)
            return None
        except Exception as e:
            logging.error(f"[{thread_name}] SYNC Fetch: L·ªói kh√¥ng mong ƒë·ª£i: {e}", exc_info=True)
            return None



# H√†m s·ª± ki·ªán: X·ª≠ l√Ω khi ng∆∞·ªùi d√πng thay ƒë·ªïi l·ª±a ch·ªçn engine d·ªãch
    def on_engine_change(self, selected_engine, update_status_bar=True): # Th√™m tham s·ªë update_status_bar
        """
        X·ª≠ l√Ω khi ng∆∞·ªùi d√πng ch·ªçn engine d·ªãch kh√°c.
        B·∫≠t/t·∫Øt c√°c control ph·ª• thu·ªôc (ng√¥n ng·ªØ ƒë√≠ch, song ng·ªØ).
        ·∫®n/hi·ªán frame ch·ªçn phong c√°ch GPT b·∫±ng pack/pack_forget.
        """
        logging.info(f"Engine d·ªãch ƒë∆∞·ª£c ch·ªçn: {selected_engine}")

        # === B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI: Th√™m ki·ªÉm tra b·∫£n quy·ªÅn ·ªü ƒë√¢y ===
        is_app_active = self._is_app_fully_activated()

        is_translation_enabled = selected_engine != "Kh√¥ng d·ªãch"
        new_state_general = ctk.NORMAL if is_translation_enabled else ctk.DISABLED

        # --- B·∫≠t/t·∫Øt c√°c control chung ---
        try:
            if hasattr(self, 'target_lang_menu') and self.target_lang_menu:
                self.target_lang_menu.configure(state=new_state_general)
            if hasattr(self, 'bilingual_checkbox') and self.bilingual_checkbox:
                self.bilingual_checkbox.configure(state=new_state_general)
                if not is_translation_enabled:
                    self.bilingual_var.set(False)
            
            # === THAY ƒê·ªîI ·ªû ƒê√ÇY: Logic cho n√∫t API Keys ===
            if hasattr(self, 'api_settings_button_translate_tab') and self.api_settings_button_translate_tab:
                 final_api_button_state = ctk.NORMAL if is_app_active else ctk.DISABLED
                 self.api_settings_button_translate_tab.configure(state=final_api_button_state)
            # === K·∫æT TH√öC THAY ƒê·ªîI ===

        except Exception as e:
            logging.warning(f"L·ªói khi c·∫•u h√¨nh control chung/n√∫t API: {e}")

        # --- LOGIC ·∫®N/HI·ªÜN FRAME CH·ªåN PHONG C√ÅCH OPENAI ---
        try:
            if hasattr(self, 'openai_style_frame') and self.openai_style_frame:
                if "ChatGPT API" in selected_engine:
                    if not self.openai_style_frame.winfo_ismapped():
                        self.openai_style_frame.pack(fill='x', padx=10, pady=(0, 5), after=self.target_lang_frame)
                else:
                    if self.openai_style_frame.winfo_ismapped():
                        self.openai_style_frame.pack_forget()
            elif "ChatGPT API" in selected_engine:
                 logging.warning("ƒê√£ ch·ªçn engine OpenAI nh∆∞ng openai_style_frame ch∆∞a ƒë∆∞·ª£c t·∫°o.")
        except Exception as e:
            logging.error(f"L·ªói khi ·∫©n/hi·ªán frame l·ª±a ch·ªçn phong c√°ch OpenAI: {e}", exc_info=True)

        # Ch·ªâ c·∫≠p nh·∫≠t thanh tr·∫°ng th√°i n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
        if hasattr(self, 'initial_ui_setup_complete') and self.initial_ui_setup_complete and update_status_bar:
            self._update_translation_engine_status()


# H√†m ti·ªán √≠ch UI: C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i v·ªõi th√¥ng tin v·ªÅ engine d·ªãch hi·ªán t·∫°i
    def _update_translation_engine_status(self):
        """
        Ki·ªÉm tra v√† C√ì TH·ªÇ c·∫≠p nh·∫≠t thanh tr·∫°ng th√°i d·ª±a tr√™n engine d·ªãch hi·ªán t·∫°i.
        S·∫Ω KH√îNG c·∫≠p nh·∫≠t n·∫øu c√≥ t√°c v·ª• quan tr·ªçng ƒëang ch·∫°y ho·∫∑c ƒëang trong qu√° tr√¨nh d·ª´ng.
        ƒê√É S·ª¨A L·∫¶N 2: Th√™m ƒëi·ªÅu ki·ªán ki·ªÉm tra c√°c tr·∫°ng th√°i t·ªïng k·∫øt ƒë·ªÉ kh√¥ng ghi ƒë√®.
        """
        # --- C·ªîNG B·∫¢O V·ªÜ (GUARD CLAUSE) ƒê√É N√ÇNG C·∫§P ---
        # 1. N·∫øu app ƒëang b·∫≠n, kh√¥ng l√†m g√¨ c·∫£
        is_busy = (self.is_subbing or self.is_downloading or self.is_loading_model or
                   self.dub_is_processing or self.is_creating_slideshow or
                   self.is_gpt_processing_script or self.is_dalle_processing or
                   self.is_gemini_processing or self.is_imagen_processing or
                   (hasattr(self, 'dub_stop_event') and self.dub_stop_event.is_set()) or
                   (hasattr(self, 'stop_event') and self.stop_event.is_set()))
        if is_busy:
            logging.debug("_update_translation_engine_status: B·ªè qua do app ƒëang b·∫≠n ho·∫∑c ƒëang d·ª´ng.")
            return

        # 2. KI·ªÇM TRA M·ªöI: N·∫øu app kh√¥ng b·∫≠n v√† status ƒëang l√† m·ªôt th√¥ng b√°o t·ªïng k·∫øt, th√¨ kh√¥ng ghi ƒë√®
        if hasattr(self, 'status_label') and self.status_label.winfo_exists():
            current_status = self.status_label.cget("text")
            current_status_lower = current_status.lower()
            
            # Danh s√°ch c√°c t·ª´ kh√≥a trong c√°c th√¥ng b√°o t·ªïng k·∫øt m√† ta kh√¥ng mu·ªën ghi ƒë√®
            summary_keywords = ["s·∫µn s√†ng", "ƒë√£ k√≠ch ho·∫°t", "y√™u c·∫ßu k√≠ch ho·∫°t", "ho√†n t·∫•t", "ƒë√£ d·ª´ng", "ƒë√£ l∆∞u"]
            
            # Ki·ªÉm tra xem status hi·ªán t·∫°i c√≥ ph·∫£i l√† m·ªôt trong c√°c th√¥ng b√°o t·ªïng k·∫øt kh√¥ng
            is_current_status_a_summary = any(keyword in current_status_lower for keyword in summary_keywords)

            if is_current_status_a_summary:
                logging.debug(f"_update_translation_engine_status: B·ªè qua v√¨ status hi·ªán t·∫°i l√† m·ªôt tr·∫°ng th√°i t√≥m t·∫Øt: '{current_status}'")
                return
        # --- K·∫æT TH√öC C·ªîNG B·∫¢O V·ªÜ ---

        # Ph·∫ßn code c√≤n l·∫°i c·ªßa h√†m gi·ªØ nguy√™n
        selected_engine = self.translation_engine_var.get()
        potential_status_message = f"‚ÑπÔ∏è Engine d·ªãch: {selected_engine}"
        warning_message = ""

        if "Google Cloud API" in selected_engine:
            key_path = self.google_key_path_var.get()
            if not HAS_GOOGLE_CLOUD_TRANSLATE:
                warning_message = " (Th∆∞ vi·ªán Google Cloud ch∆∞a c√†i!)"
            elif not key_path or not os.path.exists(key_path):
                warning_message = " (Ch∆∞a c·∫•u h√¨nh Google Key!)"
        elif "ChatGPT API" in selected_engine:
            api_key = self.openai_key_var.get()
            if not HAS_OPENAI:
                warning_message = " (Th∆∞ vi·ªán OpenAI ch∆∞a c√†i!)"
            elif not api_key:
                warning_message = " (Ch∆∞a c·∫•u h√¨nh OpenAI Key!)"
        
        if warning_message:
            potential_status_message += f" - ‚ö†Ô∏è{warning_message}"
        
        if hasattr(self, 'status_label') and self.status_label.winfo_exists():
            current_base_status_text = self.status_label.cget("text").split(" | ‚è± ")[0]
            if current_base_status_text != potential_status_message:
                 self.update_status(potential_status_message)
                 


# H√†m ti·ªán √≠ch UI: C·∫≠p nh·∫≠t giao di·ªán khi t√°c v·ª• Sub t·∫°m d·ª´ng ch·ªù ch·ªânh s·ª≠a
    def set_ui_for_paused_state(self, paused_file_path_default_for_display):
        current_thread_name_paused_ui = threading.current_thread().name
        log_prefix_paused_ui = f"[{current_thread_name_paused_ui}_SetPausedUI_v3_Updated]" # TƒÉng version log
        
        logging.info(f"{log_prefix_paused_ui} File SRT (display) ƒë∆∞·ª£c t·∫°m d·ª´ng ƒë·ªÉ ch·ªânh s·ª≠a: {paused_file_path_default_for_display}")
        self.update_status(f"‚è∏Ô∏è ƒê√£ t·∫°o/d·ªãch: {os.path.basename(paused_file_path_default_for_display)}. S·ª≠a ho·∫∑c ch·ªçn media r·ªìi nh·∫•n Ti·∫øp t·ª•c/Gh√©p.")

        # --- QUAN TR·ªåNG: C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI UI CHUNG TR∆Ø·ªöC ---
        if hasattr(self, '_set_subtitle_tab_ui_state'):
            self._set_subtitle_tab_ui_state(subbing_active=True) 
            logging.info(f"{log_prefix_paused_ui} ƒê√£ g·ªçi _set_subtitle_tab_ui_state(True) ƒë·ªÉ v√¥ hi·ªáu h√≥a c√°c control kh√¥ng c·∫ßn thi·∫øt.")
        
        if hasattr(self, 'stop_button') and self.stop_button.winfo_exists():
            self.stop_button.configure(state=ctk.NORMAL)
        
        # N√∫t "D·ª´ng Sub" v·∫´n n√™n ho·∫°t ƒë·ªông ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ h·ªßy ho√†n to√†n
        if hasattr(self, 'stop_button') and self.stop_button.winfo_exists():
            self.stop_button.configure(state=ctk.NORMAL) # ƒê·∫£m b·∫£o n√∫t D·ª´ng v·∫´n ho·∫°t ƒë·ªông

        # --- M·∫∑c ƒë·ªãnh load file "Display SRT" v√†o textbox ---
        loaded_content_successfully = False
        if paused_file_path_default_for_display and os.path.exists(paused_file_path_default_for_display):
            try:
                with open(paused_file_path_default_for_display, "r", encoding="utf-8-sig") as f:
                    content = f.read()
                self.current_srt_path = paused_file_path_default_for_display 
                self.show_sub_in_textbox(content)
                self.enable_sub_editing() 
                loaded_content_successfully = True
                logging.info(f"{log_prefix_paused_ui} ƒê√£ t·∫£i m·∫∑c ƒë·ªãnh file Display SRT '{os.path.basename(paused_file_path_default_for_display)}' v√†o textbox.")
            except Exception as e_load_paused:
                logging.error(f"{log_prefix_paused_ui} L·ªói khi t·∫£i file Display SRT m·∫∑c ƒë·ªãnh '{paused_file_path_default_for_display}': {e_load_paused}")
                self.show_sub_in_textbox(f"[L·ªñI T·∫¢I FILE DISPLAY SRT: {os.path.basename(paused_file_path_default_for_display)}]")
        else:
            logging.warning(f"{log_prefix_paused_ui} File Display SRT m·∫∑c ƒë·ªãnh kh√¥ng h·ª£p l·ªá: {paused_file_path_default_for_display}. Textbox c√≥ th·ªÉ tr·ªëng ho·∫∑c gi·ªØ n·ªôi dung c≈©.")
            self.show_sub_in_textbox("") 

        # --- K√çCH HO·∫†T C√ÅC N√öT CH·ªàNH S·ª¨A C·∫¶N THI·∫æT TR√äN HEADER C·ª¶A TEXTBOX (GHI ƒê√à _set_subtitle_tab_ui_state) ---
        try:
            is_app_active_paused = self._is_app_fully_activated()
        except Exception:
            is_app_active_paused = False
        
        # N√∫t "üìÇ M·ªü Sub..."
        open_sub_btn = getattr(self, 'open_sub_button_ref', None)
        if open_sub_btn and open_sub_btn.winfo_exists():
            open_sub_btn.configure(state=ctk.NORMAL if is_app_active_paused else ctk.DISABLED) # Ch·ªâ b·∫≠t n·∫øu app active
            logging.info(f"{log_prefix_paused_ui} N√∫t 'M·ªü Sub...' ƒë∆∞·ª£c ƒë·∫∑t state: {open_sub_btn.cget('state')}.")

        # N√∫t "üìù S·ª≠a Sub"
        edit_sub_btn = getattr(self, 'edit_sub_button_ref', None)
        if edit_sub_btn and edit_sub_btn.winfo_exists():
            edit_sub_btn.configure(state=ctk.NORMAL if is_app_active_paused else ctk.DISABLED) # Ch·ªâ b·∫≠t n·∫øu app active
            logging.info(f"{log_prefix_paused_ui} N√∫t 'S·ª≠a Sub' ƒë∆∞·ª£c ƒë·∫∑t state: {edit_sub_btn.cget('state')}.")
        
        # N√∫t "üíæ L∆∞u Sub"
        save_sub_btn = getattr(self, 'save_sub_button_ref', None)
        if save_sub_btn and save_sub_btn.winfo_exists():
            save_sub_btn.configure(state=ctk.NORMAL if is_app_active_paused and loaded_content_successfully else ctk.DISABLED)

        # N√∫t GPT v√† DALL-E
        can_use_openai_features_paused = is_app_active_paused and HAS_OPENAI and bool(self.openai_key_var.get())
        gpt_edit_btn_sub_paused = getattr(self, 'gpt_edit_script_button_main_tab', None)
        if gpt_edit_btn_sub_paused and gpt_edit_btn_sub_paused.winfo_exists():
            gpt_edit_btn_sub_paused.configure(state=ctk.NORMAL if can_use_openai_features_paused and loaded_content_successfully else ctk.DISABLED)
        
        dalle_button_sub_tab_paused = getattr(self, 'dalle_button_sub_tab', None)
        if dalle_button_sub_tab_paused and dalle_button_sub_tab_paused.winfo_exists():
             dalle_button_sub_tab_paused.configure(state=ctk.NORMAL if can_use_openai_features_paused and loaded_content_successfully else ctk.DISABLED)
        # -------------------------------------------------------------------------------------

        # --- Hi·ªÉn th·ªã Popup Th√¥ng b√°o ---
        is_optimize_tts_enabled_here = self.optimize_whisper_tts_voice_var.get() #
        display_srt_path_info = getattr(self, 'current_paused_display_srt_path', None)
        tts_srt_path_info = getattr(self, 'current_paused_tts_srt_path', None)

        popup_message_parts = [
            "·ª®ng d·ª•ng ƒë√£ t·∫°m d·ª´ng!",
            "B·∫°n c√≥ th·ªÉ:",
            "- Thay th·∫ø video/·∫£nh ƒëang d√πng b·∫±ng n√∫t 'üé¨ Ch·ªçn Video/·∫¢nh M·ªõi...'", #
            "- T·∫°o video t·ª´ nhi·ªÅu ·∫£nh b·∫±ng n√∫t 'üñºÔ∏è T·∫°o Slideshow t·ª´ Th∆∞ m·ª•c ·∫¢nh...'", #
            "- Ch·ªânh s·ª≠a n·ªôi dung ph·ª• ƒë·ªÅ trong √¥ b√™n ph·∫£i (n·∫øu c·∫ßn, nh·∫•n 'üìù S·ª≠a Sub' ƒë·ªÉ b·∫≠t ch·∫ø ƒë·ªô s·ª≠a).", #
            "- S·ª≠ d·ª•ng 'ü§ñ GPT Bi√™n T·∫≠p' ho·∫∑c 'üé® T·∫°o ·∫¢nh AI' (n·∫øu c√≥ API Key OpenAI)." #
        ]
        if is_optimize_tts_enabled_here and display_srt_path_info and tts_srt_path_info and os.path.exists(tts_srt_path_info) and os.path.exists(display_srt_path_info): # Th√™m ki·ªÉm tra file t·ªìn t·∫°i
            popup_message_parts.append(
                f"- D√πng n√∫t 'üìÇ M·ªü Sub...' ƒë·ªÉ ch·ªçn v√† s·ª≠a file ph·ª• ƒë·ªÅ cho Hi·ªÉn th·ªã ({os.path.basename(display_srt_path_info)}) ho·∫∑c file G·ªëc cho Thuy·∫øt Minh ({os.path.basename(tts_srt_path_info)})." #
            )
            popup_message_parts.append(f"  (M·∫∑c ƒë·ªãnh, ph·ª• ƒë·ªÅ cho Thuy·∫øt Minh s·∫Ω d√πng file: '{os.path.basename(tts_srt_path_info)}')") #
        elif is_optimize_tts_enabled_here: 
            popup_message_parts.append(
                "- T√πy ch·ªçn 'T·ªëi ∆∞u gi·ªçng ƒë·ªçc' ƒëang B·∫¨T, nh∆∞ng c√≥ th·ªÉ file SRT g·ªëc cho TTS ch∆∞a ƒë∆∞·ª£c t·∫°o/l·ªói. "
                "B·∫°n v·∫´n c√≥ th·ªÉ d√πng 'üìÇ M·ªü Sub...' ƒë·ªÉ t·∫£i file SRT hi·ªÉn th·ªã."
            )
        else: 
            popup_message_parts.append(
                "- D√πng n√∫t 'üìÇ M·ªü Sub...' ƒë·ªÉ t·∫£i l·∫°i file SRT kh√°c n·∫øu mu·ªën."
            )
        
        popup_message_parts.append("\nSau khi ho√†n t·∫•t ch·ªânh s·ª≠a, nh·∫•n '‚ñ∂Ô∏è Ti·∫øp t·ª•c G·ªôp Sub'.")
        final_popup_message = "\n".join(popup_message_parts)
        
        messagebox.showinfo("T·∫°m d·ª´ng ƒë·ªÉ ch·ªânh s·ª≠a", final_popup_message, parent=self)
        
        # --- K√≠ch ho·∫°t n√∫t "Ti·∫øp t·ª•c G·ªôp" ---
        if hasattr(self, 'continue_merge_button') and self.continue_merge_button.winfo_exists():
            if not self.continue_merge_button.winfo_ismapped():
                 widget_to_pack_continue_after = getattr(self, 'pause_edit_checkbox', None)
                 media_options_frame = getattr(self, 'sub_pause_media_options_frame', None)
                 if media_options_frame and media_options_frame.winfo_ismapped():
                     widget_to_pack_continue_after = media_options_frame
                 
                 parent_for_continue = getattr(self, 'merge_and_pause_frame_ref', self) 
                 if not (parent_for_continue and parent_for_continue.winfo_exists()): parent_for_continue = self

                 if widget_to_pack_continue_after and widget_to_pack_continue_after.winfo_exists() and widget_to_pack_continue_after.master == parent_for_continue:
                     self.continue_merge_button.pack(in_=parent_for_continue, fill="x", padx=10, pady=(5, 10), after=widget_to_pack_continue_after)
                 else:
                     self.continue_merge_button.pack(in_=parent_for_continue, fill="x", padx=10, pady=(5,10))
            self.continue_merge_button.configure(state=ctk.NORMAL)
            logging.info(f"{log_prefix_paused_ui} ƒê√£ k√≠ch ho·∫°t n√∫t 'Ti·∫øp t·ª•c G·ªôp Sub'.")

        logging.info(f"{log_prefix_paused_ui} Ho√†n t·∫•t set_ui_for_paused_state (v·ªõi popup ƒë∆°n gi·∫£n h√≥a v√† k√≠ch ho·∫°t n√∫t M·ªü Sub).")      
        

# H√†m ti·ªán √≠ch UI: Kh√¥i ph·ª•c tr·∫°ng th√°i giao di·ªán sau khi t·∫°m d·ª´ng ho·∫∑c d·ª´ng h·∫≥n t√°c v·ª• Sub
    def reset_ui_after_pause_or_stop(self):
        logging.info("[ResetUI] Kh√¥i ph·ª•c tr·∫°ng th√°i UI sau khi t·∫°m d·ª´ng/d·ª´ng h·∫≥n.")
        self.is_actively_paused_for_edit = False

        # T·∫Øt ch·∫ø ƒë·ªô s·ª≠a Textbox
        self.allow_edit_sub = False 
        subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
        if subtitle_textbox and subtitle_textbox.winfo_exists():
            subtitle_textbox.configure(state=ctk.DISABLED) 

        # Reset ƒë∆∞·ªùng d·∫´n media ƒë√£ ch·ªçn
        self.sub_pause_selected_media_path = None
        if hasattr(self, 'sub_pause_selected_media_info_label') and self.sub_pause_selected_media_info_label.winfo_exists():
            self.sub_pause_selected_media_info_label.configure(text="")

        # G·ªçi h√†m c·∫≠p nh·∫≠t UI t·ªïng th·ªÉ
        self._update_manual_mode_ui_elements() # H√†m n√†y s·∫Ω ·∫©n/hi·ªán c√°c n√∫t ƒë√∫ng c√°ch

        # C·∫≠p nh·∫≠t l·∫°i text n√∫t Sub ch√≠nh v√† c√°c n√∫t kh√°c c·ªßa tab
        self._set_subtitle_tab_ui_state(False) # False v√¨ kh√¥ng c√≤n subbing

        is_app_active = self._is_app_fully_activated()
        
        if not self.is_subbing and not self.is_downloading:
             is_app_active = self._is_app_fully_activated() # <<< TH√äM D√íNG N√ÄY
             self.update_status("‚úÖ S·∫µn s√†ng!" if is_app_active else "‚õî Y√™u c·∫ßu K√≠ch ho·∫°t") # <<< S·ª¨A is_active TH√ÄNH is_app_active
             

# H√†m h√†nh ƒë·ªông: Ti·∫øp t·ª•c t√°c v·ª• t·∫°o ph·ª• ƒë·ªÅ ƒëang b·ªã t·∫°m d·ª´ng
    def resume_paused_task(self):
        """G·ª≠i t√≠n hi·ªáu ƒë·ªÉ lu·ªìng ƒëang t·∫°m d·ª´ng ti·∫øp t·ª•c b∆∞·ªõc g·ªôp sub."""
        logging.info("Ng∆∞·ªùi d√πng nh·∫•n 'Ti·∫øp t·ª•c G·ªôp Sub'. G·ª≠i t√≠n hi·ªáu v√† c·∫≠p nh·∫≠t UI...")

        # --- C·∫≠p nh·∫≠t giao di·ªán NGAY L·∫¨P T·ª®C ---
        # Cho ng∆∞·ªùi d√πng bi·∫øt l·ªánh ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n
        self.update_status("‚ñ∂Ô∏è Chu·∫©n b·ªã ti·∫øp t·ª•c g·ªôp sub...")

        # V√¥ hi·ªáu h√≥a ngay n√∫t "Ti·∫øp t·ª•c G·ªôp" v√¨ ƒë√£ nh·∫•n
        if hasattr(self, 'continue_merge_button') and self.continue_merge_button.winfo_exists():
            self.continue_merge_button.configure(state=ctk.DISABLED)

        # ƒê·∫£m b·∫£o n√∫t "D·ª´ng Sub" v·∫´n c√≥ th·ªÉ nh·∫•n ƒë∆∞·ª£c (v√¨ t√°c v·ª• s·∫Øp ch·∫°y l·∫°i b∆∞·ªõc g·ªôp)
        if hasattr(self, 'stop_button') and self.stop_button.winfo_exists():
             # Ch·ªâ b·∫≠t n√∫t D·ª´ng n·∫øu is_subbing v·∫´n l√† True (logic an to√†n)
             if self.is_subbing:
                 self.stop_button.configure(state=ctk.NORMAL)

        # --- G·ª≠i t√≠n hi·ªáu cho lu·ªìng ƒëang ch·ªù ---
        # Ki·ªÉm tra xem threading.Event c√≥ t·ªìn t·∫°i kh√¥ng
        if hasattr(self, 'continue_merge_event') and self.continue_merge_event:
            # G·ªçi .set() ƒë·ªÉ ƒë√°nh th·ª©c lu·ªìng ƒëang g·ªçi .wait()
            self.continue_merge_event.set()
            logging.info("ƒê√£ g·ª≠i t√≠n hi·ªáu continue_merge_event.set()")
        else:
            # Tr∆∞·ªùng h·ª£p l·ªói kh√¥ng mong mu·ªën
            logging.error("Kh√¥ng t√¨m th·∫•y thu·ªôc t√≠nh 'continue_merge_event'. Kh√¥ng th·ªÉ g·ª≠i t√≠n hi·ªáu ti·∫øp t·ª•c.")
            messagebox.showerror("L·ªói Logic", "Kh√¥ng th·ªÉ t√¨m th·∫•y c∆° ch·∫ø ƒë·ªÉ ti·∫øp t·ª•c t√°c v·ª• ƒëang t·∫°m d·ª´ng.", parent=self)
            # C√≥ th·ªÉ g·ªçi h√†m reset UI ·ªü ƒë√¢y n·∫øu l·ªói
            self.reset_ui_after_pause_or_stop()


# 2 H√†m cho t√≠nh nƒÉng gh√©p tr√™n 25 ·∫£nh
    def _ffmpeg_concatenate_videos_from_list(self, concat_list_file, final_output_path):
        """S·ª≠ d·ª•ng FFmpeg concat demuxer ƒë·ªÉ gh√©p c√°c video t·ª´ m·ªôt file list."""
        worker_log_prefix = f"[{threading.current_thread().name}_FFmpegConcatVideos]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu gh√©p c√°c video clip t·ª´: {concat_list_file}")

        cmd_params = [
            "-y",
            "-f", "concat",
            "-safe", "0",
            "-i", os.path.abspath(concat_list_file),
            "-c", "copy",
            os.path.abspath(final_output_path)
        ]
        try:
            ffmpeg_run_command(
                cmd_params,
                process_name=f"{worker_log_prefix}_ConcatVideos",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=1800,
            )
            return True
        except Exception as e:
            logging.error(f"{worker_log_prefix} L·ªói gh√©p video: {e}", exc_info=True)
            return False

# H√†m t·∫°o slidle show cho gh√©p th·ªß c√¥ng
    def _create_video_from_images_thread_for_sub_pause(self, image_paths, current_srt_path_for_timing, temp_srt_path_to_delete=None):
        """
        (PHI√äN B·∫¢N N√ÇNG C·∫§P V5.1 - S·ª¨A L·ªñI T√äN BI·∫æN)
        T·∫°o slideshow t·ª´ ·∫£nh, ƒë·ªçc c√†i ƒë·∫∑t hi·ªáu ·ª©ng t·ª´ self.imagen_motion_effect_var
        ƒë·ªÉ quy·∫øt ƒë·ªãnh t·∫°o slideshow tƒ©nh hay slideshow chuy·ªÉn ƒë·ªông.
        """
        thread_name_wrapper = threading.current_thread().name
        is_manual_mode_when_thread_starts = self.manual_merge_mode_var.get()
        
        log_prefix_wrapper = f"[{thread_name_wrapper}_SubPauseSlideshow_v5.1_MotionFix(Manual:{is_manual_mode_when_thread_starts})]"
        logging.info(f"{log_prefix_wrapper} B·∫Øt ƒë·∫ßu t·∫°o slideshow t·ª´ {len(image_paths)} ·∫£nh, timing t·ª´ SRT: {os.path.basename(current_srt_path_for_timing)}.")

        self.is_creating_slideshow = True
        self.start_time = time.time()
        status_prefix_init = "Gh√©p Th·ªß C√¥ng" if is_manual_mode_when_thread_starts else "T·∫°m d·ª´ng Sub"
        initial_status_text = f"{status_prefix_init} - ƒêang chu·∫©n b·ªã t·∫°o video t·ª´ ·∫£nh..."
        self._last_status_text = initial_status_text
        self.after(0, lambda: self.update_status(initial_status_text))
        self.after(1000, self.update_time_realtime)
        
        def _disable_buttons_on_start():
            if hasattr(self, 'sub_pause_select_media_button') and self.sub_pause_select_media_button.winfo_exists():
                self.sub_pause_select_media_button.configure(state="disabled")
            if hasattr(self, 'sub_pause_select_folder_button') and self.sub_pause_select_folder_button.winfo_exists():
                self.sub_pause_select_folder_button.configure(state="disabled")
            if is_manual_mode_when_thread_starts:
                if hasattr(self, 'sub_button') and self.sub_button.winfo_exists():
                    self.sub_button.configure(state="disabled")
            else:
                if hasattr(self, 'continue_merge_button') and self.continue_merge_button.winfo_exists():
                    self.continue_merge_button.configure(state="disabled")
        self.after(0, _disable_buttons_on_start)

        slideshow_creation_successful_flag = False
        final_output_video_path_for_slideshow = None
        
        temp_files_created_in_thread = []

        try:
            parsed_srt_data_for_slideshow_timing = parse_srt_for_slideshow_timing(current_srt_path_for_timing)
            if not parsed_srt_data_for_slideshow_timing:
                raise ValueError(f"L·ªói parse SRT cho timing: {os.path.basename(current_srt_path_for_timing)}")

            padding_duration_ms = 3000
            last_event = parsed_srt_data_for_slideshow_timing[-1]
            last_end_ms = last_event.get('end_ms', 0)
            new_silent_event = {
                'original_index': last_event.get('original_index', len(parsed_srt_data_for_slideshow_timing)) + 1,
                'start_ms': last_end_ms, 'end_ms': last_end_ms + padding_duration_ms,
                'duration_ms': padding_duration_ms, 'text': ' '
            }
            parsed_srt_data_for_slideshow_timing.append(new_silent_event)
            total_slideshow_duration_s_from_srt = new_silent_event['end_ms'] / 1000.0
            logging.info(f"{log_prefix_wrapper} ƒê√£ th√™m {padding_duration_ms}ms padding. T·ªïng th·ªùi l∆∞·ª£ng m·ªõi: {total_slideshow_duration_s_from_srt:.3f}s.")
            
            num_images_original = len(image_paths)
            if not (num_images_original > 0 and total_slideshow_duration_s_from_srt > 0):
                raise ValueError("Kh√¥ng th·ªÉ t√≠nh th·ªùi l∆∞·ª£ng ·∫£nh (s·ªë ·∫£nh ho·∫∑c duration SRT kh√¥ng h·ª£p l·ªá).")

            crossfade_duration = 1.0
            master_image_durations_list = []
            if num_images_original > 1:
                total_lost_duration_due_to_fade = (num_images_original - 1) * crossfade_duration
                adjusted_total_duration = total_slideshow_duration_s_from_srt + total_lost_duration_due_to_fade
                duration_per_image_adjusted = adjusted_total_duration / num_images_original
                master_image_durations_list = [duration_per_image_adjusted] * num_images_original
            elif num_images_original == 1:
                master_image_durations_list = [total_slideshow_duration_s_from_srt]            

            # ƒê·ªçc l·ª±a ch·ªçn hi·ªáu ·ª©ng t·ª´ bi·∫øn c·ªßa app ch√≠nh (ƒë√£ s·ª≠a ƒë√∫ng t√™n bi·∫øn)
            motion_effect_choice = self.imagen_motion_effect_var.get() # <<< ### S·ª¨A L·ªñI ·ªû ƒê√ÇY ###
            logging.info(f"{log_prefix_wrapper} L·ª±a ch·ªçn hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông t·ª´ c√†i ƒë·∫∑t: '{motion_effect_choice}'")

            if motion_effect_choice == "Kh√¥ng c√≥":
                logging.info(f"{log_prefix_wrapper} G·ªçi h√†m slideshow Tƒ®NH (_ffmpeg_create_slideshow) v·ªõi chunking.")
                
                CHUNK_SIZE = 25
                image_chunks = [image_paths[i:i + CHUNK_SIZE] for i in range(0, len(image_paths), CHUNK_SIZE)]
                duration_chunks = [master_image_durations_list[i:i + CHUNK_SIZE] for i in range(0, len(master_image_durations_list), CHUNK_SIZE)]
                intermediate_video_clips = []
                
                for i, (image_chunk, duration_chunk) in enumerate(zip(image_chunks, duration_chunks)):
                    if self.dub_stop_event.is_set(): raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
                    self.after(0, lambda i=i, total=len(image_chunks): self.update_status(f"üéû T·∫°o slideshow Tƒ®NH: L√¥ ·∫£nh {i+1}/{total}..."))
                    
                    image_paths_for_ffmpeg = list(image_chunk)
                    durations_for_ffmpeg = list(duration_chunk)
                    num_images_in_chunk = len(image_chunk)
                    if num_images_in_chunk == 1:
                        DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_SUB = 0.7
                        chunk_duration = duration_chunk[0]
                        if chunk_duration > (DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_SUB + 0.1):
                            original_img_path = image_chunk[0]
                            base, ext = os.path.splitext(os.path.basename(original_img_path))
                            duplicated_image_path_temp_sub = os.path.join(self.temp_folder, f"sub_pause_dup_{base}_{i}.{ext}")
                            temp_files_created_in_thread.append(duplicated_image_path_temp_sub)
                            shutil.copy2(original_img_path, duplicated_image_path_temp_sub)
                            image_paths_for_ffmpeg.append(duplicated_image_path_temp_sub)
                            durations_for_ffmpeg = [chunk_duration - DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_SUB, DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S_SUB]

                    temp_clip_path = os.path.join(self.temp_folder, f"temp_clip_{i}.mp4")
                    temp_files_created_in_thread.append(temp_clip_path)
                    clip_success = self._ffmpeg_create_slideshow(
                        image_paths=image_paths_for_ffmpeg, output_video_path=temp_clip_path,
                        resolution=self.cfg.get("slideshow_resolution", "1920x1080"),
                        fps=self.cfg.get("slideshow_fps", 25), image_durations_list_seconds=durations_for_ffmpeg
                    )
                    if not clip_success: raise RuntimeError(f"L·ªói t·∫°o clip Tƒ®NH trung gian cho l√¥ ·∫£nh {i+1}.")
                    intermediate_video_clips.append(temp_clip_path)

                if not intermediate_video_clips: raise ValueError("Kh√¥ng t·∫°o ƒë∆∞·ª£c clip Tƒ®NH trung gian n√†o.")
                
                if len(intermediate_video_clips) == 1:
                    final_output_video_path_for_slideshow = os.path.join(self.temp_folder, f"sub_pause_slideshow_{int(time.time())}.mp4")
                    shutil.move(intermediate_video_clips[0], final_output_video_path_for_slideshow)
                    if intermediate_video_clips[0] in temp_files_created_in_thread:
                        temp_files_created_in_thread.remove(intermediate_video_clips[0])
                else:
                    self.after(0, lambda: self.update_status("üéû T·∫°o slideshow Tƒ®NH: ƒêang gh√©p c√°c clip..."))
                    temp_concat_list_path = os.path.join(self.temp_folder, "concat_list.txt")
                    temp_files_created_in_thread.append(temp_concat_list_path)
                    if not create_ffmpeg_concat_file_list(intermediate_video_clips, temp_concat_list_path):
                        raise RuntimeError("L·ªói t·∫°o file danh s√°ch ƒë·ªÉ gh√©p video Tƒ®NH.")
                    final_output_video_path_for_slideshow = os.path.join(self.temp_folder, f"sub_pause_slideshow_{int(time.time())}.mp4")
                    if not self._ffmpeg_concatenate_videos_from_list(temp_concat_list_path, final_output_video_path_for_slideshow):
                        raise RuntimeError("L·ªói gh√©p c√°c video clip Tƒ®NH trung gian.")
                
                slideshow_creation_successful_flag = True

            else: # Nh√°nh t·∫°o slideshow CHUY·ªÇN ƒê·ªòNG
                logging.info(f"{log_prefix_wrapper} G·ªçi h√†m slideshow CHUY·ªÇN ƒê·ªòNG (_ffmpeg_create_slideshow_with_motion).")
                
                CHUNK_SIZE = 25
                if len(image_paths) <= CHUNK_SIZE:
                    logging.info(f"{log_prefix_wrapper} S·ªë l∆∞·ª£ng ·∫£nh ({len(image_paths)}) nh·ªè, g·ªçi _ffmpeg_create_slideshow_with_motion tr·ª±c ti·∫øp.")
                    final_output_video_path_for_slideshow = os.path.join(self.temp_folder, f"sub_pause_slideshow_{int(time.time())}.mp4")
                    slideshow_creation_successful_flag = self._ffmpeg_create_slideshow_with_motion(
                        image_paths=image_paths, output_video_path=final_output_video_path_for_slideshow,
                        resolution=self.cfg.get("slideshow_resolution", "1920x1080"),
                        fps=self.cfg.get("slideshow_fps", 25),
                        image_durations_list_seconds=master_image_durations_list,
                        motion_effect=motion_effect_choice
                    )
                else:
                    logging.info(f"{log_prefix_wrapper} S·ªë l∆∞·ª£ng ·∫£nh ({len(image_paths)}) l·ªõn, b·∫Øt ƒë·∫ßu quy tr√¨nh chia nh√≥m cho slideshow chuy·ªÉn ƒë·ªông.")
                    image_chunks = [image_paths[i:i + CHUNK_SIZE] for i in range(0, len(image_paths), CHUNK_SIZE)]
                    duration_chunks = [master_image_durations_list[i:i + CHUNK_SIZE] for i in range(0, len(master_image_durations_list), CHUNK_SIZE)]
                    intermediate_motion_clips = []
                    
                    for i, (image_chunk, duration_chunk) in enumerate(zip(image_chunks, duration_chunks)):
                        if self.dub_stop_event.is_set(): raise InterruptedError("D·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
                        self.after(0, lambda i=i, total=len(image_chunks): self.update_status(f"üéû Motion: T·∫°o clip trung gian {i+1}/{total}..."))
                        temp_clip_path = os.path.join(self.temp_folder, f"temp_motion_clip_{i}_{uuid.uuid4().hex[:6]}.mp4")
                        temp_files_created_in_thread.append(temp_clip_path)
                        clip_success = self._ffmpeg_create_slideshow_with_motion(
                            image_paths=image_chunk, output_video_path=temp_clip_path,
                            resolution=self.cfg.get("slideshow_resolution", "1920x1080"),
                            fps=self.cfg.get("slideshow_fps", 25),
                            image_durations_list_seconds=duration_chunk,
                            motion_effect=motion_effect_choice
                        )
                        if not clip_success: raise RuntimeError(f"L·ªói t·∫°o clip chuy·ªÉn ƒë·ªông trung gian cho l√¥ {i+1}.")
                        intermediate_motion_clips.append(temp_clip_path)

                    self.after(0, lambda: self.update_status("üéû Motion: ƒêang gh√©p n·ªëi c√°c clip..."))
                    temp_concat_list_path = os.path.join(self.temp_folder, "concat_list_motion.txt")
                    temp_files_created_in_thread.append(temp_concat_list_path)
                    if not create_ffmpeg_concat_file_list(intermediate_motion_clips, temp_concat_list_path):
                        raise RuntimeError("L·ªói t·∫°o file danh s√°ch ƒë·ªÉ gh√©p video CHUY·ªÇN ƒê·ªòNG.")
                    final_output_video_path_for_slideshow = os.path.join(self.temp_folder, f"sub_pause_slideshow_{int(time.time())}.mp4")
                    if not self._ffmpeg_concatenate_videos_from_list(temp_concat_list_path, final_output_video_path_for_slideshow):
                        raise RuntimeError("L·ªói gh√©p c√°c video clip CHUY·ªÇN ƒê·ªòNG trung gian.")
                    
                    slideshow_creation_successful_flag = True            

        except Exception as e:
            final_message_for_status_bar = f"L·ªói t·∫°o slideshow: {e}"
            logging.error(f"{log_prefix_wrapper} {final_message_for_status_bar}", exc_info=True)
            self.after(0, lambda msg=final_message_for_status_bar: messagebox.showerror("L·ªói T·∫°o Slideshow", msg, parent=self))
        
        finally:
            self.is_creating_slideshow = False
            if not (self.is_subbing or self.is_downloading): self.start_time = None
            
            if temp_srt_path_to_delete and os.path.exists(temp_srt_path_to_delete):
                try: os.remove(temp_srt_path_to_delete)
                except: pass
                
            for temp_file in temp_files_created_in_thread:
                if os.path.exists(temp_file):
                    try: os.remove(temp_file)
                    except Exception as e_del: logging.warning(f"L·ªói khi x√≥a file t·∫°m '{temp_file}': {e_del}")

            if slideshow_creation_successful_flag:
                self.sub_pause_selected_media_path = final_output_video_path_for_slideshow
                success_msg = f"ƒê√£ t·∫°o video t·ª´ ·∫£nh: {os.path.basename(final_output_video_path_for_slideshow)}"
                self.after(0, lambda: self.sub_pause_selected_media_info_label.configure(text=success_msg))
                self.after(0, lambda: self.update_status(f"‚úÖ ƒê√£ t·∫°o video t·ª´ ·∫£nh th√†nh c√¥ng!"))
                if self.auto_add_manual_sub_task_var.get():
                    self.after(10, self._add_manual_sub_task_to_queue)
                else:
                    self.after(10, lambda: messagebox.showinfo(
                        "T·∫°o Slideshow Th√†nh c√¥ng",
                        "Video slideshow ƒë√£ ƒë∆∞·ª£c t·∫°o v√† t·ª± ƒë·ªông ch·ªçn l√†m media.\n\nH√£y nh·∫•n '‚ûï Th√™m v√†o H√†ng ch·ªù' ho·∫∑c '‚ñ∂ Ti·∫øp t·ª•c'.",
                        parent=self
                    ))
            else:
                self.sub_pause_selected_media_path = None
                self.after(0, lambda: self.sub_pause_selected_media_info_label.configure(text="L·ªói t·∫°o video t·ª´ ·∫£nh."))

            def _reenable_buttons_on_finish_local():
                if hasattr(self, 'sub_pause_select_media_button'): self.sub_pause_select_media_button.configure(state="normal")
                if hasattr(self, 'sub_pause_select_folder_button'): self.sub_pause_select_folder_button.configure(state="normal")
                if is_manual_mode_when_thread_starts:
                    sub_button = getattr(self.subtitle_view_frame, 'sub_button', None) if hasattr(self, 'subtitle_view_frame') else None
                    if sub_button and sub_button.winfo_exists():
                        sub_button.configure(state="normal")
                else:
                    is_still_in_auto_pause_ui_state = (self.is_subbing and self.pause_for_edit_var.get() and not self.continue_merge_event.is_set())
                    if hasattr(self, 'continue_merge_button'):
                        if is_still_in_auto_pause_ui_state: self.continue_merge_button.configure(state="normal")
                        else: self.continue_merge_button.configure(state="disabled")
            self.after(100, _reenable_buttons_on_finish_local)

            log_msg_final_slideshow = f"{log_prefix_wrapper} Ho√†n t·∫•t thread t·∫°o slideshow."
            if slideshow_creation_successful_flag and final_output_video_path_for_slideshow:
                log_msg_final_slideshow += f" K·∫øt qu·∫£: {final_output_video_path_for_slideshow}"
            else:
                log_msg_final_slideshow += " Kh√¥ng slideshow ƒë∆∞·ª£c t·∫°o ho·∫∑c l·ªói."
            logging.info(log_msg_final_slideshow)


# ======================================================================================================================================================
# SECTION: C√ÅC H√ÄM H·ªñ TR·ª¢ CHO TAB THUY·∫æT MINH (DUBBING)
# ======================================================================================================================================================

# --- H√ÄM M·ªöI X·ª¨ L√ù S·ª∞ KI·ªÜN D√ÅN CHO TEXTBOX THUY·∫æT MINH ---
    def _dub_handle_paste_and_optimize_text(self, event=None):
        """
        X·ª≠ l√Ω s·ª± ki·ªán d√°n v√†o dub_script_textbox.
        G·ªçi h√†m chuy·ªÉn ƒë·ªïi sang SRT/timed segments sau m·ªôt kho·∫£ng tr·ªÖ nh·ªè.
        """
        # Ch·ªâ th·ª±c hi·ªán n·∫øu c√°c checkbox li√™n quan ƒë∆∞·ª£c b·∫≠t
        if hasattr(self, 'dub_auto_optimize_on_paste_var') and \
           self.dub_auto_optimize_on_paste_var.get() and \
           hasattr(self, 'optimize_dub_flow_var') and \
           self.optimize_dub_flow_var.get(): # Ch·ªâ t·ªëi ∆∞u khi "T·ªëi ∆∞u lu·ªìng ƒë·ªçc" ch√≠nh c≈©ng b·∫≠t
            
            # G·ªçi h√†m t·ªëi ∆∞u sau 50ms ƒë·ªÉ ƒë·∫£m b·∫£o text ƒë√£ ƒë∆∞·ª£c d√°n v√†o textbox
            self.after(50, self._dub_convert_textbox_to_timed_segments_if_needed)
        # N·∫øu kh√¥ng, s·ª± ki·ªán d√°n m·∫∑c ƒë·ªãnh c·ªßa Tkinter s·∫Ω di·ªÖn ra b√¨nh th∆∞·ªùng.

    # --- H√ÄM M·ªöI TH·ª∞C HI·ªÜN LOGIC T·ªêI ∆ØU V√Ä C·∫¨P NH·∫¨T TEXTBOX ---
    def _dub_convert_textbox_to_timed_segments_if_needed(self):
        """
        Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán v√† chuy·ªÉn ƒë·ªïi n·ªôi dung plain text trong 
        dub_script_textbox th√†nh d·∫°ng SRT v·ªõi timing ∆∞·ªõc t√≠nh, n·∫øu c·∫ßn.
        """
        # Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán m·ªôt l·∫ßn n·ªØa (an to√†n)
        if not (hasattr(self, 'dub_auto_optimize_on_paste_var') and \
                self.dub_auto_optimize_on_paste_var.get() and \
                hasattr(self, 'optimize_dub_flow_var') and \
                self.optimize_dub_flow_var.get() and \
                hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists()):
            return

        plain_text_content = self.dub_script_textbox.get("1.0", "end-1c").strip()

        if not plain_text_content:
            logging.debug("[DubAutoOptimize] Textbox dub r·ªóng, kh√¥ng chuy·ªÉn ƒë·ªïi.")
            return

        # Ki·ªÉm tra nhanh xem n·ªôi dung c√≥ v·∫ª ƒë√£ l√† SRT ch∆∞a
        srt_quick_check_pattern = r"^\d+\s*[\r\n]+\d{2}:\d{2}:\d{2}[,.]\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}[,.]\d{3}"
        if re.match(srt_quick_check_pattern, plain_text_content, re.MULTILINE):
            logging.info("[DubAutoOptimize] N·ªôi dung textbox dub c√≥ v·∫ª ƒë√£ l√† SRT. B·ªè qua t·ª± ƒë·ªông t·ªëi ∆∞u khi d√°n.")
            # N·∫øu ƒë√£ l√† SRT, c√≥ th·ªÉ b·∫°n mu·ªën parse n√≥ v√† c·∫≠p nh·∫≠t self.dub_temp_srt_data_for_queue
            parsed_existing_srt = self._parse_plain_text_to_srt_data(plain_text_content, force_plain_text_processing=False)
            if parsed_existing_srt:
                self.dub_temp_srt_data_for_queue = parsed_existing_srt
                self.dub_current_script_path_for_queue_temp = "text_input_srt_like"
                self._update_dub_script_controls_state() # C·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c n√∫t
            return

        logging.info("[DubAutoOptimize] B·∫Øt ƒë·∫ßu t·ª± ƒë·ªông t·ªëi ∆∞u v√† t·∫°o timing cho text trong dub_script_textbox...")
        self.update_status("‚è≥ ƒêang t·ªëi ∆∞u v√† t·∫°o timing cho k·ªãch b·∫£n thuy·∫øt minh...")

        # Thu th·∫≠p c·∫•u h√¨nh chia d√≤ng v√† timing t·ª´ UI c·ªßa tab Thuy·∫øt Minh
        dub_flow_config = {
            "split_enabled": self.dub_split_enabled_for_flow_var.get(),
            "mode": self.dub_split_mode_for_flow_var.get(),
            "max_chars": safe_int(self.dub_max_chars_for_flow_var.get(), 999),
            "max_lines": safe_int(self.dub_max_lines_for_flow_var.get(), 1),
            "DEFAULT_CPS_FOR_TIMING": safe_int(self.dub_cps_for_timing_var.get(), 17),
            # C√°c gi√° tr·ªã m·∫∑c ƒë·ªãnh n√†y c√≥ th·ªÉ c·∫ßn ƒë∆∞·ª£c l·∫•y t·ª´ self.cfg ho·∫∑c h·∫±ng s·ªë
            "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": getattr(self, 'app_pause_ms_for_plain_text_estimate', 1), 
            "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
        }
        logging.debug(f"[DubAutoOptimize] S·ª≠ d·ª•ng dub_flow_config: {json.dumps(dub_flow_config, ensure_ascii=False)}")

        parsed_srt_data = self._parse_plain_text_to_srt_data(
            plain_text_content,
            force_plain_text_processing=True,
            split_config_override=dub_flow_config
        )

        if parsed_srt_data:
            srt_output_string = format_srt_data_to_string(parsed_srt_data)
            
            try:
                self.dub_script_textbox.configure(state="normal")
                self.dub_script_textbox.delete("1.0", "end")
                self.dub_script_textbox.insert("1.0", srt_output_string)
                # self.dub_script_textbox.configure(state="disabled") # ƒê·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ s·ª≠a ti·∫øp n·∫øu mu·ªën

                # QUAN TR·ªåNG: C·∫≠p nh·∫≠t d·ªØ li·ªáu t·∫°m th·ªùi cho h√†ng ch·ªù
                self.dub_temp_srt_data_for_queue = list(parsed_srt_data) # L∆∞u d·ªØ li·ªáu ƒë√£ parse
                self.dub_current_script_path_for_queue_temp = "text_input_auto_optimized" # ƒê√°nh d·∫•u ngu·ªìn
                self.dub_current_script_for_queue_display.set("(K·ªãch b·∫£n t·ª´ Textbox - ƒê√£ t·ªëi ∆∞u)")


                self.update_status("‚úÖ K·ªãch b·∫£n thuy·∫øt minh ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông t·ªëi ∆∞u v√† t·∫°o timing.")
                logging.info("[DubAutoOptimize] Chuy·ªÉn ƒë·ªïi v√† c·∫≠p nh·∫≠t textbox thuy·∫øt minh th√†nh c√¥ng.")
            except Exception as e_update_tb:
                logging.error(f"[DubAutoOptimize] L·ªói khi c·∫≠p nh·∫≠t textbox dub v·ªõi SRT/timed segments: {e_update_tb}")
                self.update_status("‚ö†Ô∏è L·ªói c·∫≠p nh·∫≠t textbox dub sau khi t·ªëi ∆∞u.")
        else:
            self.update_status("‚ö†Ô∏è Kh√¥ng th·ªÉ t·ª± ƒë·ªông t·ªëi ∆∞u k·ªãch b·∫£n thuy·∫øt minh (kh√¥ng c√≥ kh·ªëi n√†o ƒë∆∞·ª£c t·∫°o).")
            logging.warning("[DubAutoOptimize] Kh√¥ng c√≥ kh·ªëi n√†o ƒë∆∞·ª£c parsed_srt_data tr·∫£ v·ªÅ cho dub textbox.")
            
        self._update_dub_script_controls_state() # C·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c n√∫t Nghe th·ª≠, L∆∞u Script, v.v.



# H√†m hi·ªÉn th·ªã c√°c t√πy ch·ªçn chi ti·∫øt khi checkbox ch√≠nh ho·∫∑c checkbox "Chia l·∫°i vƒÉn b·∫£n" ƒë∆∞·ª£c thay ƒë·ªïi.
    def _toggle_dub_flow_options_visibility(self, *args):
        """Hi·ªán ho·∫∑c ·∫©n c√°c t√πy ch·ªçn chi ti·∫øt cho vi·ªác t·ªëi ∆∞u lu·ªìng ƒë·ªçc thuy·∫øt minh."""
        show_main_optimize_option = self.optimize_dub_flow_var.get()
        
        # Frame ch·ª©a c√°c t√πy ch·ªçn chi ti·∫øt (ƒë∆∞·ª£c t·∫°o trong DubbingTab)
        # L·∫•y t·ª´ dubbing_view_frame (DubbingTab instance)
        dubbing_tab = getattr(self, 'dubbing_view_frame', None)
        if not dubbing_tab:
            return
        details_frame = getattr(dubbing_tab, 'dub_flow_details_frame', None)
        # Frame cha l·ªõn (dub_flow_optimization_frame)
        main_optimize_frame = getattr(dubbing_tab, 'dub_flow_optimization_frame', None)

        if not details_frame or not main_optimize_frame or \
           not details_frame.winfo_exists() or not main_optimize_frame.winfo_exists():
            logging.warning("[DubFlowVisibility] Frame chi ti·∫øt ho·∫∑c frame ch√≠nh cho t·ªëi ∆∞u lu·ªìng ƒë·ªçc ch∆∞a s·∫µn s√†ng.")
            return

        if show_main_optimize_option:
            if not details_frame.winfo_ismapped():
                # Pack frame chi ti·∫øt v√†o b√™n trong frame ch√≠nh, sau checkbox ch√≠nh
                checkbox_widget = getattr(dubbing_tab, 'chk_optimize_dub_flow', None)
                if checkbox_widget and checkbox_widget.winfo_exists():
                    details_frame.pack(in_=main_optimize_frame, fill="x", padx=10, pady=(0, 10), after=checkbox_widget)
                else: # Fallback n·∫øu kh√¥ng t√¨m th·∫•y checkbox
                    details_frame.pack(in_=main_optimize_frame, fill="x", padx=10, pady=(0, 10))
                logging.debug("[DubFlowVisibility] ƒê√£ hi·ªÉn th·ªã c√°c t√πy ch·ªçn chi ti·∫øt t·ªëi ∆∞u lu·ªìng ƒë·ªçc.")
            # G·ªçi h√†m ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa c√°c control b√™n trong details_frame
            self._toggle_dub_flow_split_details_visibility()
        else:
            if details_frame.winfo_ismapped():
                details_frame.pack_forget()
                logging.debug("[DubFlowVisibility] ƒê√£ ·∫©n c√°c t√πy ch·ªçn chi ti·∫øt t·ªëi ∆∞u lu·ªìng ƒë·ªçc.")
        
        # L∆∞u c·∫•u h√¨nh khi checkbox ch√≠nh thay ƒë·ªïi
        if hasattr(self, 'cfg'):
             self.cfg["optimize_dub_flow_enabled"] = show_main_optimize_option
             # self.save_current_config() # C√¢n nh·∫Øc ch·ªâ g·ªçi khi ƒë√≥ng app ho·∫∑c c√≥ n√∫t "L∆∞u C·∫•u H√¨nh"

    def _toggle_dub_flow_split_details_visibility(self, *args):
        """Hi·ªán ho·∫∑c ·∫©n c√°c control nh·∫≠p k√Ω t·ª±, s·ªë d√≤ng, c√°ch chia CHO T·ªêI ∆ØU LU·ªíNG ƒê·ªåC."""
        if not (hasattr(self, 'optimize_dub_flow_var') and self.optimize_dub_flow_var.get()):
            return 

        # L·∫•y t·ª´ dubbing_view_frame
        dubbing_tab = getattr(self, 'dubbing_view_frame', None)
        if not dubbing_tab:
            return 

        enable_split_details = self.dub_split_enabled_for_flow_var.get()
        new_state = ctk.NORMAL if enable_split_details else ctk.DISABLED

        controls_to_toggle = [
            getattr(dubbing_tab, 'dub_max_chars_entry_flow', None),
            getattr(dubbing_tab, 'dub_max_lines_entry_flow', None),
            getattr(dubbing_tab, 'dub_split_mode_menu_flow', None),
            # TH√äM CHECKBOX M·ªöI V√ÄO ƒê√ÇY:
            getattr(dubbing_tab, 'chk_dub_auto_optimize_on_paste', None),
            # TH√äM C·∫¢ √î NH·∫¨P CPS V√ÄO ƒê√ÇY (n·∫øu b·∫°n mu·ªën n√≥ c≈©ng disable khi "Chia l·∫°i vƒÉn b·∫£n" t·∫Øt)
            # HO·∫∂C ƒë·ªÉ n√≥ lu√¥n NORMAL n·∫øu frame chi ti·∫øt ƒëang hi·ªÉn th·ªã. Hi·ªán t·∫°i, t√¥i s·∫Ω th√™m n√≥ v√†o:
            getattr(dubbing_tab, 'chk_force_recalculate_timing', None), # S·ª≠ d·ª•ng chk_force_recalculate_timing
        ]

        for control in controls_to_toggle:
            if control and hasattr(control, 'configure') and control.winfo_exists():
                try:
                    control.configure(state=new_state)
                except Exception as e:
                    logging.warning(f"L·ªói khi c·∫•u h√¨nh control chi ti·∫øt t·ªëi ∆∞u lu·ªìng ƒë·ªçc: {e}")

        # N·∫øu "Chia l·∫°i vƒÉn b·∫£n ƒë√£ g·ªôp" kh√¥ng ƒë∆∞·ª£c ch·ªçn, th√¨ "T·ª± ƒë·ªông t·ªëi ∆∞u khi d√°n" c≈©ng kh√¥ng n√™n ƒë∆∞·ª£c ch·ªçn
        if not enable_split_details:
            if hasattr(self, 'dub_auto_optimize_on_paste_var'):
                self.dub_auto_optimize_on_paste_var.set(False)

        # L∆∞u c·∫•u h√¨nh (t√πy ch·ªçn, c√≥ th·ªÉ b·∫°n ƒë√£ l∆∞u ·ªü ch·ªó kh√°c)
        # if hasattr(self, 'cfg'):
        #     self.cfg["dub_split_enabled_for_flow"] = enable_split_details
        #     # self.save_current_config()
    

# H√†m callback ƒë·ªÉ x·ª≠ l√Ω vi·ªác hi·ªÉn th·ªã/·∫©n frame n√¢ng cao khi checkbox thay ƒë·ªïi.
    def _toggle_advanced_dub_audio_settings_visibility(self, *args):
        """Hi·ªán ho·∫∑c ·∫©n khung t√πy ch·ªânh x·ª≠ l√Ω audio n√¢ng cao d·ª±a tr√™n checkbox."""
        show_advanced = self.dub_show_advanced_audio_settings_var.get()
        
        # Frame ch·ª©a c√°c t√πy ch·ªçn chi ti·∫øt - l·∫•y t·ª´ dubbing_view_frame
        dubbing_tab = getattr(self, 'dubbing_view_frame', None)
        if not dubbing_tab:
            return
        advanced_frame_widget = getattr(dubbing_tab, 'dub_advanced_audio_processing_frame', None)
        
        # Checkbox (d√πng ƒë·ªÉ tham chi·∫øu v·ªã tr√≠ pack)
        checkbox_widget = getattr(dubbing_tab, 'dub_chk_show_advanced_audio_settings', None)

        # Ki·ªÉm tra an to√†n
        if not advanced_frame_widget or not checkbox_widget:
            logging.warning("[DubAdvancedToggle] advanced_frame_widget ho·∫∑c checkbox_widget ch∆∞a s·∫µn s√†ng.")
            return

        if show_advanced:
            if not advanced_frame_widget.winfo_ismapped():
                # S·ª¨A ·ªû ƒê√ÇY: Pack n√≥ v√†o b√™n trong frame cha, ngay sau checkbox
                advanced_frame_widget.pack(pady=(0, 10), padx=0, fill="x", after=checkbox_widget)
        else:
            if advanced_frame_widget.winfo_ismapped():
                advanced_frame_widget.pack_forget()

        # L∆∞u c·∫•u h√¨nh (ch·ªâ khi kh√¥ng ph·∫£i ƒëang kh√¥i ph·ª•c t·ª´ task config)
        if not (hasattr(self, '_is_restoring_task_config') and self._is_restoring_task_config):
            if hasattr(self, 'cfg'):
                self.cfg["dub_show_advanced_audio_settings"] = show_advanced



# H√†m th√™m ·∫£nh v√† video
    def dub_load_video(self):
        """
        M·ªü dialog ch·ªçn file video HO·∫∂C M·ªòT/NHI·ªÄU FILE ·∫¢NH.
        N·∫øu ch·ªçn ·∫£nh, s·∫Ω ki·ªÉm tra k·ªãch b·∫£n/audio ngo√†i v√† c√≥ th·ªÉ g·ªçi popup y√™u c·∫ßu,
        sau ƒë√≥ g·ªçi h√†m t·∫°o video t·ª´ ·∫£nh.
        """
        # --- Ph·∫ßn 1: Ki·ªÉm tra xem c√≥ ƒëang ·ªü ch·∫ø ƒë·ªô ch·ªçn th∆∞ m·ª•c ·∫£nh kh√¥ng ---
        if hasattr(self, 'dub_use_image_folder_var') and self.dub_use_image_folder_var.get(): # [cite: 2]
            messagebox.showinfo("Ch·∫ø ƒë·ªô Th∆∞ m·ª•c ·∫¢nh ƒêang B·∫≠t",
                                "ƒê·ªÉ ch·ªçn video ho·∫∑c ·∫£nh ƒë∆°n l·∫ª, vui l√≤ng b·ªè ch·ªçn 'T·∫°o Slideshow t·ª´ Th∆∞ m·ª•c ·∫¢nh' tr∆∞·ªõc.",
                                parent=self) # [cite: 2, 3]
            return
        # --- K·∫øt th√∫c Ph·∫ßn 1 ---

        initial_dir_video = ""
        if hasattr(self, 'dub_current_video_path_for_queue_temp') and self.dub_current_video_path_for_queue_temp:
            initial_dir_video = os.path.dirname(self.dub_current_video_path_for_queue_temp)
        elif hasattr(self, 'dub_output_path_var'):
            initial_dir_video = self.dub_output_path_var.get() or get_default_downloads_folder()
        else: # [cite: 4]
            initial_dir_video = get_default_downloads_folder()

        file_options = [
            ("Image and Video files", "*.mp4 *.mkv *.mov *.avi *.png *.jpg *.jpeg *.bmp *.webp"),
            ("Video files", "*.mp4 *.mkv *.mov *.avi"),
            ("Image files", "*.png *.jpg *.jpeg *.bmp *.webp"),
            ("All files", "*.*") # [cite: 5]
        ]

        selected_paths = filedialog.askopenfilenames(
            title="Ch·ªçn Video ho·∫∑c M·ªôt/Nhi·ªÅu File ·∫¢nh cho Thuy·∫øt minh", # S·ª≠a title
            filetypes=file_options,
            initialdir=initial_dir_video,
            parent=self
        )

        if not selected_paths: # Ng∆∞·ªùi d√πng h·ªßy
            if not hasattr(self, 'dub_current_video_path_for_queue_temp') or not self.dub_current_video_path_for_queue_temp: # [cite: 6]
                 if hasattr(self, 'dub_current_video_for_queue_display'):
                    self.dub_current_video_for_queue_display.set("(Ch∆∞a ch·ªçn video/·∫£nh)")
            logging.info("[DubLoadVideo] Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn Video/·∫¢nh.")
            if hasattr(self, '_try_auto_add_to_dub_queue'):
                self._try_auto_add_to_dub_queue() # C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t th√™m v√†o h√†ng ch·ªù # [cite: 7]
            return

        # --- B·∫ÆT ƒê·∫¶U LOGIC X·ª¨ L√ù M·ªöI CHO selected_paths ---
        first_path = selected_paths[0]
        is_single_video_file = False
        is_single_image_file = False # C·ªù m·ªõi cho tr∆∞·ªùng h·ª£p ch·ªçn 1 ·∫£nh
        are_multiple_image_files = False # C·ªù m·ªõi cho tr∆∞·ªùng h·ª£p ch·ªçn nhi·ªÅu ·∫£nh

        video_extensions = ('.mp4', '.mkv', '.mov', '.avi', '.wmv', '.flv')
        image_extensions = ('.png', '.jpg', '.jpeg', '.bmp', '.webp', '.gif')

        if len(selected_paths) == 1:
            if first_path.lower().endswith(video_extensions):
                is_single_video_file = True # [cite: 8]
            elif first_path.lower().endswith(image_extensions):
                is_single_image_file = True # [cite: 9]
        elif len(selected_paths) > 1:
            all_are_images_check = True
            for spath_check in selected_paths:
                if not spath_check.lower().endswith(image_extensions):
                    all_are_images_check = False # [cite: 10]
                    break
            if all_are_images_check:
                are_multiple_image_files = True
            else:
                messagebox.showwarning("L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá",
                                       "N·∫øu ch·ªçn nhi·ªÅu file, t·∫•t c·∫£ ph·∫£i l√† file ·∫£nh ƒë∆∞·ª£c h·ªó tr·ª£.", # [cite: 11]
                                       parent=self)
                if hasattr(self, 'dub_current_video_for_queue_display'):
                     self.dub_current_video_for_queue_display.set("(L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá)") # [cite: 12]
                if hasattr(self, '_try_auto_add_to_dub_queue'): self._try_auto_add_to_dub_queue()
                return
        
        # X·ª≠ l√Ω d·ª±a tr√™n c√°c c·ªù ƒë√£ x√°c ƒë·ªãnh
        if is_single_video_file:
            self.dub_current_video_path_for_queue_temp = first_path
            video_filename = os.path.basename(first_path)
            if hasattr(self, 'dub_current_video_for_queue_display'): # [cite: 13]
                self.dub_current_video_for_queue_display.set(video_filename)
            logging.info(f"[DubLoadVideo] ƒê√£ ch·ªçn Video (ƒë∆°n l·∫ª): {video_filename}")
            self.update_status(f"‚ÑπÔ∏è ƒê√£ ch·ªçn Video: {video_filename}")
            # C√°c h√†m c·∫≠p nh·∫≠t UI s·∫Ω ƒë∆∞·ª£c g·ªçi ·ªü cu·ªëi
        
        elif is_single_image_file or are_multiple_image_files:
            # G·ªôp tr∆∞·ªùng h·ª£p 1 ·∫£nh v√† nhi·ªÅu ·∫£nh ƒë·ªÉ ƒë∆∞a v√†o t·∫°o slideshow
            image_paths_for_slideshow = list(selected_paths) # ƒê·∫£m b·∫£o l√† list m·ªõi
            
            num_images = len(image_paths_for_slideshow)
            type_selection_log = "1 file ·∫£nh" if is_single_image_file else f"{num_images} file ·∫£nh"
            logging.info(f"[DubLoadVideo] ƒê√£ ch·ªçn {type_selection_log} ƒë·ªÉ t·∫°o slideshow.")

            # Ki·ªÉm tra ngu·ªìn timing (SRT, audio ngo√†i, ho·∫∑c textbox)
            can_proceed_without_popup_imgs = False
            current_timing_source_for_log_imgs = "ch∆∞a x√°c ƒë·ªãnh"

            if hasattr(self, 'dub_audio_path_for_queue_temp') and \
               self.dub_audio_path_for_queue_temp and \
               os.path.exists(self.dub_audio_path_for_queue_temp) and \
               (self.dub_get_audio_duration_ms(self.dub_audio_path_for_queue_temp) or 0) > 0: # [cite: 15]
                can_proceed_without_popup_imgs = True
                current_timing_source_for_log_imgs = f"Audio ngo√†i ({os.path.basename(self.dub_audio_path_for_queue_temp)})" # [cite: 16]
                logging.info(f"[DubLoadVideo-CheckTimingImgs] Ngu·ªìn timing: {current_timing_source_for_log_imgs}")

            if not can_proceed_without_popup_imgs and \
               hasattr(self, 'dub_temp_srt_data_for_queue') and self.dub_temp_srt_data_for_queue:
                current_script_file_path_check_imgs = getattr(self, 'dub_current_script_path_for_queue_temp', None)
                if current_script_file_path_check_imgs and os.path.exists(current_script_file_path_check_imgs) and \
                   current_script_file_path_check_imgs != "text_input": # [cite: 17]
                    can_proceed_without_popup_imgs = True
                    current_timing_source_for_log_imgs = f"File SRT ({os.path.basename(current_script_file_path_check_imgs)})"
                    logging.info(f"[DubLoadVideo-CheckTimingImgs] Ngu·ªìn timing: {current_timing_source_for_log_imgs}")

            if not can_proceed_without_popup_imgs and \
               hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists(): # [cite: 18]
                textbox_content_check_imgs = self.dub_script_textbox.get("1.0", "end-1c").strip()
                if textbox_content_check_imgs and not self._is_textbox_content_invalid_for_script(textbox_content_check_imgs):
                    can_proceed_without_popup_imgs = True
                    current_timing_source_for_log_imgs = "N·ªôi dung Textbox" # [cite: 19]
                    logging.info(f"[DubLoadVideo-CheckTimingImgs] Ngu·ªìn timing: {current_timing_source_for_log_imgs}")
            
            if not can_proceed_without_popup_imgs: # [cite: 20]
                logging.info("[DubLoadVideo-SlideshowFromImgs] Ch∆∞a c√≥ ngu·ªìn timing. Hi·ªán popup.") # [cite: 21]
                self.prompt_for_script_for_slideshow(image_paths_for_slideshow) 
                return 

            logging.info(f"[DubLoadVideo-SlideshowFromImgs] ƒê√£ c√≥ ngu·ªìn timing ({current_timing_source_for_log_imgs}). T·∫°o slideshow.")
            self.update_status(f"ƒêang chu·∫©n b·ªã t·∫°o video t·ª´ {num_images} ·∫£nh (Timing: {current_timing_source_for_log_imgs[:30]}...).")

            if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists():
                 self.dub_load_video_button.configure(state="disabled") # [cite: 22]
            if hasattr(self, 'dub_btn_add_to_queue') and self.dub_btn_add_to_queue.winfo_exists():
                 self.dub_btn_add_to_queue.configure(state="disabled")
            
            # C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·∫°m th·ªùi
            display_text_for_video_queue = f"{num_images} ·∫£nh ƒë√£ ch·ªçn" if num_images > 1 else f"1 ·∫£nh: {os.path.basename(image_paths_for_slideshow[0])}"
            self.dub_current_video_for_queue_display.set(display_text_for_video_queue) # [cite: 23]

            thread = threading.Thread(target=self._create_video_from_images_thread,
                                     args=(image_paths_for_slideshow,), 
                                     daemon=True,
                                     name="CreateSlideshowFromMultiImagesThread") # [cite: 24]
            thread.start()
            return # Quan tr·ªçng: return sau khi start thread ƒë·ªÉ UI kh√¥ng b·ªã block
            
        else: # Tr∆∞·ªùng h·ª£p kh√¥ng ph·∫£i video ƒë∆°n l·∫ª, c≈©ng kh√¥ng ph·∫£i 1 hay nhi·ªÅu ·∫£nh
            if hasattr(self, 'dub_current_video_path_for_queue_temp'): self.dub_current_video_path_for_queue_temp = "" # [cite: 25]
            if hasattr(self, 'dub_current_video_for_queue_display'): self.dub_current_video_for_queue_display.set("(L·ªói: File kh√¥ng h·ª£p l·ªá)")
            first_file_display = os.path.basename(selected_paths[0]) if selected_paths else "N/A"
            logging.warning(f"[DubLoadVideo] File/C√°c file ƒë√£ ch·ªçn kh√¥ng ph·∫£i l√† video ho·∫∑c ·∫£nh ƒë∆∞·ª£c h·ªó tr·ª£: {first_file_display}")
            self.update_status(f"L·ªói: File '{first_file_display}' kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.")
        
        # G·ªçi c√°c h√†m c·∫≠p nh·∫≠t UI cu·ªëi c√πng n·∫øu kh√¥ng return s·ªõm (v√≠ d·ª• khi ch·ªçn video ƒë∆°n l·∫ª)
        if hasattr(self, '_try_auto_add_to_dub_queue'):
            self._try_auto_add_to_dub_queue() # [cite: 26]
        if hasattr(self, '_update_dub_start_batch_button_state'):
            self._update_dub_start_batch_button_state() # [cite: 14]
        # --- K·∫æT TH√öC LOGIC X·ª¨ L√ù M·ªöI ---
            

# H√†m T·∫°o Video T·ª´ ·∫¢nh
    def _create_video_from_images_thread(self, image_paths): # image_paths gi·ªù ƒë√¢y c√≥ th·ªÉ l√† list nhi·ªÅu ·∫£nh
        """
        Thread worker ƒë·ªÉ t·∫°o video slideshow t·ª´ danh s√°ch ƒë∆∞·ªùng d·∫´n ·∫£nh.
        ∆Øu ti√™n ngu·ªìn timing: 1. Audio ngo√†i -> 2. File SRT ƒë√£ t·∫£i -> 3. Textbox -> 4. M·∫∑c ƒë·ªãnh.
        ƒê√£ c·∫≠p nh·∫≠t ƒë·ªÉ x·ª≠ l√Ω ƒë√∫ng khi image_paths ch·ª©a nhi·ªÅu ·∫£nh.
        """
        thread_log_prefix = f"[{threading.current_thread().name}_CreateVideoFromImgs_V2]" # Th√™m V2
        logging.info(f"{thread_log_prefix} B·∫Øt ƒë·∫ßu v·ªõi {len(image_paths)} ·∫£nh.")
        
        # --- C√°c thi·∫øt l·∫≠p ban ƒë·∫ßu ---
        temp_slideshow_filename = f"slideshow_{int(time.time())}_{uuid.uuid4().hex[:4]}.mp4" # Th√™m uuid ƒë·ªÉ tr√°nh tr√πng l·∫∑p t·ªët h∆°n
        output_video_path = os.path.join(self.temp_folder, temp_slideshow_filename)
        video_resolution = self.cfg.get("slideshow_resolution", "1920x1080")
        video_fps = self.cfg.get("slideshow_fps", 25)
        default_duration_per_image_s_if_no_script_or_audio = 3.0
        num_images_original = len(image_paths)
        
        success = False
        final_message_for_status_bar = f"L·ªói t·∫°o video slideshow t·ª´ {num_images_original} ·∫£nh." #
        
        self.is_creating_slideshow = True #
        self.start_time = time.time()
        self.after(0, lambda: self.update_status(f"üõ† ƒêang chu·∫©n b·ªã t·∫°o video t·ª´ {num_images_original} ·∫£nh..."))
        self.after(100, self.update_time_realtime)

        duplicated_image_path_temp = None 
        image_paths_for_ffmpeg = list(image_paths) # Kh·ªüi t·∫°o image_paths_for_ffmpeg b·∫±ng danh s√°ch g·ªëc
        num_images_for_ffmpeg = num_images_original

        if num_images_original == 0:
            # ... (logic x·ª≠ l√Ω khi kh√¥ng c√≥ ·∫£nh gi·ªØ nguy√™n) ...
            logging.warning(f"{thread_log_prefix} Kh√¥ng c√≥ ·∫£nh n√†o ƒë∆∞·ª£c cung c·∫•p.") #
            self.is_creating_slideshow = False #
            self.after(0, lambda: self.update_status("L·ªói: Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ t·∫°o slideshow.")) #
            if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists(): #
                self.after(0, lambda: self.dub_load_video_button.configure(state="normal"))
            if hasattr(self, 'dub_select_image_folder_button') and self.dub_select_image_folder_button.winfo_exists() and \
               hasattr(self, 'dub_use_image_folder_var') and self.dub_use_image_folder_var.get(): #
                self.after(0, lambda: self.dub_select_image_folder_button.configure(state="normal"))
            return

        # --- X√ÅC ƒê·ªäNH T·ªîNG TH·ªúI L∆Ø·ª¢NG SLIDESHOW (PHI√äN B·∫¢N C√ì PADDING) ---
        total_slideshow_duration_s = 0.0
        timing_source_info_log = "Kh√¥ng x√°c ƒë·ªãnh"
        parsed_srt_data_for_duration_calc = [] 
        padding_duration_s = 3.0  # <<< TH√äM M·ªöI: ƒê·ªãnh nghƒ©a padding 3 gi√¢y

        # 1. ∆Øu ti√™n File Audio Ngo√†i
        external_audio_path_check = getattr(self, 'dub_audio_path_for_queue_temp', None)
        if external_audio_path_check and os.path.exists(external_audio_path_check):
            audio_duration_ms_check = self.dub_get_audio_duration_ms(external_audio_path_check)
            if audio_duration_ms_check and audio_duration_ms_check > 0:
                total_slideshow_duration_s = (audio_duration_ms_check / 1000.0) + padding_duration_s # <<< S·ª¨A ƒê·ªîI: C·ªông padding
                timing_source_info_log = f"File Audio Ngo√†i ({os.path.basename(external_audio_path_check)})"
                logging.info(f"{thread_log_prefix} Ngu·ªìn timing (∆Øu ti√™n 1 - Audio): {timing_source_info_log}, Duration (ƒë√£ padding): {total_slideshow_duration_s:.2f}s")

        # 2. ∆Øu ti√™n File SRT ƒë√£ t·∫£i
        if total_slideshow_duration_s <= 0:
            loaded_srt_file_path_check = getattr(self, 'dub_current_script_path_for_queue_temp', None)
            if loaded_srt_file_path_check and loaded_srt_file_path_check != "text_input" and \
               os.path.exists(loaded_srt_file_path_check) and \
               hasattr(self, 'dub_temp_srt_data_for_queue') and self.dub_temp_srt_data_for_queue:
                parsed_srt_data_for_duration_calc = list(self.dub_temp_srt_data_for_queue)
                timing_source_info_log = f"File SRT ({os.path.basename(loaded_srt_file_path_check)})"

        # 3. ∆Øu ti√™n N·ªôi dung t·ª´ Textbox
        if total_slideshow_duration_s <= 0 and not parsed_srt_data_for_duration_calc:
            if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
                current_textbox_content_check = self.dub_script_textbox.get("1.0", "end-1c").strip()
                if current_textbox_content_check and not self._is_textbox_content_invalid_for_script(current_textbox_content_check):
                    parsed_data_from_textbox_check = self._parse_plain_text_to_srt_data(current_textbox_content_check)
                    if parsed_data_from_textbox_check:
                        parsed_srt_data_for_duration_calc = parsed_data_from_textbox_check
                        timing_source_info_log = "N·ªôi dung Textbox"

        # T√≠nh total_slideshow_duration_s t·ª´ parsed_srt_data v√† c·ªông padding
        if total_slideshow_duration_s <= 0 and parsed_srt_data_for_duration_calc:
            try:
                valid_segments_for_timing = [seg for seg in parsed_srt_data_for_duration_calc if isinstance(seg.get('end_ms'), (int, float)) and seg.get('end_ms') > 0]
                if valid_segments_for_timing:
                    sorted_segments_for_timing = sorted(valid_segments_for_timing, key=lambda x: x['end_ms'])
                    last_segment_end_ms_calc = sorted_segments_for_timing[-1]['end_ms']
                    if last_segment_end_ms_calc > 0:
                        total_slideshow_duration_s = (last_segment_end_ms_calc / 1000.0) + padding_duration_s # <<< S·ª¨A ƒê·ªîI: C·ªông padding
                        logging.info(f"{thread_log_prefix} Th·ªùi l∆∞·ª£ng t·ª´ '{timing_source_info_log}' (ƒë√£ padding): {total_slideshow_duration_s:.2f}s.")
            except Exception as e_srt_timing_calc_detail:
                logging.error(f"{thread_log_prefix} L·ªói t√≠nh th·ªùi l∆∞·ª£ng t·ª´ '{timing_source_info_log}': {e_srt_timing_calc_detail}", exc_info=True)

        # 4. Th·ªùi l∆∞·ª£ng m·∫∑c ƒë·ªãnh
        if total_slideshow_duration_s <= 0:
            if num_images_original > 0: 
                total_slideshow_duration_s = (num_images_original * default_duration_per_image_s_if_no_script_or_audio) + padding_duration_s # <<< S·ª¨A ƒê·ªîI: C·ªông padding
                timing_source_info_log = "Th·ªùi l∆∞·ª£ng M·∫∑c ƒë·ªãnh"
                logging.info(f"{thread_log_prefix} Ngu·ªìn timing (M·∫∑c ƒë·ªãnh, ƒë√£ padding): {timing_source_info_log}, Duration: {total_slideshow_duration_s:.2f}s.")
            else:
                logging.critical(f"{thread_log_prefix} L·ªói logic: Kh√¥ng c√≥ ·∫£nh v√† kh√¥ng c√≥ ngu·ªìn timing.")
                self.is_creating_slideshow = False
                return

        # --- THAY ƒê·ªîI LOGIC NH√ÇN ƒê√îI ·∫¢NH ---
        DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S = 0.7 

        # Ch·ªâ nh√¢n ƒë√¥i ·∫£nh n·∫øu CH·ªà C√ì M·ªòT ·∫£nh ƒë·∫ßu v√†o v√† th·ªùi l∆∞·ª£ng cho ph√©p
        if num_images_original == 1 and total_slideshow_duration_s > (DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S + 0.1): #
            original_single_image_path = image_paths[0] #
            base_name, ext = os.path.splitext(os.path.basename(original_single_image_path)) #
            duplicated_image_path_temp = os.path.join(self.temp_folder, f"dup_{base_name}_{int(time.time())}{ext}") #
            try:
                shutil.copy2(original_single_image_path, duplicated_image_path_temp) #
                image_paths_for_ffmpeg.append(duplicated_image_path_temp) # Th√™m ·∫£nh nh√¢n ƒë√¥i v√†o list cho FFmpeg
                num_images_for_ffmpeg = 2 # S·ªë l∆∞·ª£ng ·∫£nh ƒë·ªÉ FFmpeg x·ª≠ l√Ω l√† 2
                logging.info(f"{thread_log_prefix} ƒê√£ nh√¢n b·∫£n ·∫£nh '{os.path.basename(original_single_image_path)}' (do ch·ªâ c√≥ 1 ·∫£nh ƒë·∫ßu v√†o).") #
            except Exception as e_copy_slideshow:
                logging.error(f"{thread_log_prefix} L·ªói nh√¢n b·∫£n ·∫£nh: {e_copy_slideshow}. X·ª≠ l√Ω nh∆∞ 1 ·∫£nh.") #
                duplicated_image_path_temp = None 
                num_images_for_ffmpeg = 1 # Quay l·∫°i x·ª≠ l√Ω 1 ·∫£nh
                image_paths_for_ffmpeg = list(image_paths) # Reset l·∫°i list ·∫£nh g·ªëc
        # N·∫øu num_images_original > 1, th√¨ num_images_for_ffmpeg s·∫Ω b·∫±ng num_images_original
        # v√† image_paths_for_ffmpeg s·∫Ω l√† list c√°c ·∫£nh ng∆∞·ªùi d√πng ƒë√£ ch·ªçn.
        # Kh√¥ng c·∫ßn kh·ªëi else ·ªü ƒë√¢y v√¨ gi√° tr·ªã kh·ªüi t·∫°o ƒë√£ ƒë√∫ng.
        # --- K·∫æT TH√öC THAY ƒê·ªîI LOGIC NH√ÇN ƒê√îI ·∫¢NH ---

        image_durations_s_list = [] #
        if num_images_for_ffmpeg > 0 and total_slideshow_duration_s > 0: #
            if num_images_for_ffmpeg == 2 and duplicated_image_path_temp: 
                # Tr∆∞·ªùng h·ª£p 1 ·∫£nh g·ªëc + 1 ·∫£nh nh√¢n ƒë√¥i (logic n√†y kh√¥ng ƒë·ªïi)
                duration_for_original_image_s = total_slideshow_duration_s - DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S #
                duration_for_original_image_s = max(0.1, duration_for_original_image_s) #
                image_durations_s_list = [duration_for_original_image_s, DURATION_FOR_FAKE_SECOND_IMAGE_AND_FADE_S] #
            elif num_images_for_ffmpeg == 1: 
                # Ch·ªâ 1 ·∫£nh (kh√¥ng nh√¢n b·∫£n, ho·∫∑c th·ªùi l∆∞·ª£ng qu√° ng·∫Øn ƒë·ªÉ nh√¢n b·∫£n)
                image_durations_s_list = [max(0.04, total_slideshow_duration_s)] #
            else: # num_images_for_ffmpeg > 1 V√Ä KH√îNG PH·∫¢I tr∆∞·ªùng h·ª£p nh√¢n ƒë√¥i (t·ª©c l√† ng∆∞·ªùi d√πng ch·ªçn nhi·ªÅu ·∫£nh)
                duration_per_image_s = total_slideshow_duration_s / float(num_images_for_ffmpeg) #
                safe_duration_per_image_s = max(0.04, duration_per_image_s) #
                image_durations_s_list = [safe_duration_per_image_s] * num_images_for_ffmpeg #
            
            logging.info(f"{thread_log_prefix} FFmpeg params: S·ªë ·∫£nh FFmpeg = {num_images_for_ffmpeg}, "
                         f"Durations (s) = {image_durations_s_list}, " #
                         f"Total calculated for FFmpeg = {sum(image_durations_s_list):.2f}s (Source: {timing_source_info_log})") #
        elif num_images_for_ffmpeg > 0 : #
             logging.error(f"{thread_log_prefix} L·ªói logic: total_slideshow_duration_s ({total_slideshow_duration_s}s) kh√¥ng h·ª£p l·ªá.") #
             self.after(0, lambda: self.update_status(f"L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ x√°c ƒë·ªãnh th·ªùi l∆∞·ª£ng slideshow t·ª´ {timing_source_info_log}.")) #
             self.is_creating_slideshow = False  #
             if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists(): #
                 self.after(0, lambda: self.dub_load_video_button.configure(state="normal"))
             if hasattr(self, 'dub_select_image_folder_button') and self.dub_select_image_folder_button.winfo_exists() and hasattr(self, 'dub_use_image_folder_var') and self.dub_use_image_folder_var.get(): #
                 self.after(0, lambda: self.dub_select_image_folder_button.configure(state="normal"))
             return 
        
        # --- G·ªçi FFmpeg ---
        try:
            self.after(0, lambda: self.update_status(f"üõ† ƒêang t·∫°o video t·ª´ {num_images_original} ·∫£nh (Ngu·ªìn: {timing_source_info_log}, T·ªïng: {sum(image_durations_s_list):.1f}s)...")) #            
            
            if self._ffmpeg_create_slideshow(image_paths=image_paths_for_ffmpeg, #
                                             output_video_path=output_video_path, #
                                             resolution=video_resolution, #
                                             fps=video_fps, #
                                             image_durations_list_seconds=image_durations_s_list): #

                if os.path.exists(output_video_path) and os.path.getsize(output_video_path) > 1000:  #
                    self.after(0, lambda: self.dub_current_video_path_for_queue_temp_setter(output_video_path)) #
                    actual_total_duration_display = sum(image_durations_s_list) #
                    display_name_slideshow = f"Slideshow ({num_images_original} ·∫£nh, {actual_total_duration_display:.1f}s)" #
                    self.after(0, lambda: self.dub_current_video_for_queue_display.set(display_name_slideshow)) #
                    final_message_for_status_bar = f"‚úÖ ƒê√£ t·∫°o Video t·ª´ {num_images_original} ·∫£nh: {os.path.basename(output_video_path)}" #
                    success = True #
                else:
                    final_message_for_status_bar = f"‚ùå L·ªói: FFmpeg xong nh∆∞ng file slideshow tr·ªëng/nh·ªè." #
                    logging.error(f"{thread_log_prefix} {final_message_for_status_bar} Path: {output_video_path}") #
            else: # _ffmpeg_create_slideshow tr·∫£ v·ªÅ False
                final_message_for_status_bar = f"‚ùå L·ªói FFmpeg t·∫°o slideshow (xem log)." #
                logging.error(f"{thread_log_prefix} H√†m _ffmpeg_create_slideshow tr·∫£ v·ªÅ False.") #
        except Exception as e_ffmpeg_call:
            final_message_for_status_bar = f"L·ªói nghi√™m tr·ªçng khi t·∫°o slideshow FFmpeg: {e_ffmpeg_call}" #
            logging.error(f"{thread_log_prefix} {final_message_for_status_bar}", exc_info=True) #
        finally:
            self.is_creating_slideshow = False #
            if duplicated_image_path_temp and os.path.exists(duplicated_image_path_temp): #
                try:
                    os.remove(duplicated_image_path_temp) #
                    logging.info(f"{thread_log_prefix} ƒê√£ x√≥a ·∫£nh nh√¢n b·∫£n t·∫°m: {duplicated_image_path_temp}") #
                except Exception as e_del_dup_final:
                    logging.warning(f"{thread_log_prefix} L·ªói x√≥a ·∫£nh nh√¢n b·∫£n t·∫°m '{duplicated_image_path_temp}': {e_del_dup_final}") #
            
            self.after(0, lambda msg=final_message_for_status_bar: self.update_status(msg)) #
            # K√≠ch ho·∫°t l·∫°i c√°c n√∫t li√™n quan
            if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists(): #
                self.after(0, lambda: self.dub_load_video_button.configure(state="normal"))
            if hasattr(self, 'dub_select_image_folder_button') and self.dub_select_image_folder_button.winfo_exists() and hasattr(self, 'dub_use_image_folder_var') and self.dub_use_image_folder_var.get(): #
                 self.after(0, lambda: self.dub_select_image_folder_button.configure(state="normal"))

            if hasattr(self, '_check_can_add_to_dub_queue'): #
                self.after(50, self._check_can_add_to_dub_queue)  #
            if hasattr(self, '_update_dub_start_batch_button_state'): #
                self.after(100, self._update_dub_start_batch_button_state)



# T·∫°o video slideshow t·ª´ danh s√°ch ·∫£nh.
    def _ffmpeg_create_slideshow(self, image_paths, output_video_path,
                                 resolution, fps,
                                 image_durations_list_seconds):
        """
        T·∫°o video slideshow t·ª´ danh s√°ch ·∫£nh.
        - H·ªó tr·ª£ 1 ·∫£nh (t·∫°o video tƒ©nh C√ì √ÇM THANH IM L·∫∂NG).
        - H·ªó tr·ª£ nhi·ªÅu ·∫£nh v·ªõi hi·ªáu ·ª©ng chuy·ªÉn c·∫£nh m∆∞·ª£t m√† (crossfade).
        - ƒê√É S·ª¨A L·ªñI: Lu√¥n t·∫°o audio im l·∫∑ng v√† ƒë·∫∑t ƒë√∫ng v·ªã tr√≠ input cho FFmpeg.
        """
        with keep_awake("Render slideshow (FFmpeg classic)"):

            ffmpeg_executable = find_ffmpeg()
            if not ffmpeg_executable:
                logging.error("[FFmpegSlideshow_v6] Kh√¥ng t√¨m th·∫•y FFmpeg.")
                self.after(0, lambda: messagebox.showerror("L·ªói FFmpeg", "Kh√¥ng t√¨m th·∫•y FFmpeg ƒë·ªÉ t·∫°o slideshow.", parent=self))
                return False

            if not image_paths or not image_durations_list_seconds or len(image_paths) != len(image_durations_list_seconds):
                logging.error(f"[FFmpegSlideshow_v6] ƒê·∫ßu v√†o kh√¥ng h·ª£p l·ªá: s·ªë l∆∞·ª£ng ·∫£nh v√† th·ªùi l∆∞·ª£ng kh√¥ng kh·ªõp.")
                return False
            
            num_images = len(image_paths)
            if num_images == 0:
                logging.warning("[FFmpegSlideshow_v6] Danh s√°ch ·∫£nh r·ªóng, kh√¥ng t·∫°o slideshow.")
                return False

            try:
                video_w_str, video_h_str = resolution.split('x')
                int(video_w_str); int(video_h_str)
            except ValueError:
                logging.error(f"[FFmpegSlideshow_v6] Resolution '{resolution}' kh√¥ng h·ª£p l·ªá.")
                return False

            command = [ffmpeg_executable, "-y"]

            # --- X·ª¨ L√ù TR∆Ø·ªúG H·ª¢P 1 ·∫¢NH (Code n√†y ƒë√£ ƒë√∫ng t·ª´ tr∆∞·ªõc, gi·ªØ nguy√™n) ---
            if num_images == 1:
                duration_s = float(image_durations_list_seconds[0])
                if duration_s <= 0: return False
                
                single_image_path_ffmpeg = str(Path(os.path.abspath(image_paths[0])).as_posix())
                base_vf_per_image = f"scale={video_w_str}:{video_h_str}:force_original_aspect_ratio=decrease,pad={video_w_str}:{video_h_str}:(ow-iw)/2:(oh-ih)/2:color=black,setsar=1,format=yuv420p"
                
                command.extend([
                    "-loop", "1", "-framerate", str(fps), "-t", f"{duration_s:.3f}", "-i", single_image_path_ffmpeg,
                    "-f", "lavfi", "-i", f"anullsrc=channel_layout=stereo:sample_rate={self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE}",
                    "-vf", base_vf_per_image,
                    "-c:v", "libx264", "-preset", "medium", "-profile:v", "main", "-level", "4.0", "-pix_fmt", "yuv420p", "-r", str(fps),
                    "-c:a", "aac", "-b:a", "192k",
                    "-shortest",
                    "-movflags", "+faststart",
                    os.path.abspath(output_video_path)
                ])
            
            # --- LOGIC CHO NHI·ªÄU ·∫¢NH (XFADE) - ƒê√É S·ª¨A L·ªñI S·∫ÆP X·∫æP L·ªÜNH ---
            else:
                crossfade_duration = 1.0
                
                # 1. Th√™m t·∫•t c·∫£ c√°c input ·∫£nh v√† input √¢m thanh im l·∫∑ng V√ÄO ƒê·∫¶U
                for img_path in image_paths:
                    command.extend(["-framerate", str(fps), "-loop", "1", "-i", os.path.abspath(img_path)])
                
                # ### THAY ƒê·ªîI CH√çNH: T√çNH TO√ÅN TH·ªúI L∆Ø·ª¢NG V√Ä TH√äM INPUT √ÇM THANH ·ªû ƒê√ÇY ###
                final_video_duration = sum(image_durations_list_seconds) - (num_images - 1) * crossfade_duration
                command.extend([
                    "-f", "lavfi", "-t", f"{final_video_duration:.3f}",
                    "-i", f"anullsrc=channel_layout=stereo:sample_rate={self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE}"
                ])
                # Gi·ªù ƒë√¢y, anullsrc l√† input cu·ªëi c√πng trong danh s√°ch input
                audio_input_index = num_images # Index c·ªßa anullsrc l√† `num_images` (b·∫Øt ƒë·∫ßu t·ª´ 0)
                
                # 2. X√¢y d·ª±ng filter_complex
                filter_complex_parts = []
                
                # Chu·∫©n b·ªã stream video cho t·ª´ng ·∫£nh
                for i in range(num_images):
                    stream_duration = image_durations_list_seconds[i]
                    filter_chain = (
                        f"[{i}:v]scale={video_w_str}:{video_h_str}:force_original_aspect_ratio=decrease,"
                        f"pad={video_w_str}:{video_h_str}:(ow-iw)/2:(oh-ih)/2:color=black,"
                        f"setsar=1,format=yuv420p,trim=duration={stream_duration}[v{i}];"
                    )
                    filter_complex_parts.append(filter_chain)
                
                # X√¢y d·ª±ng chu·ªói xfade cho video
                last_stream_tag = "v0"
                current_offset = 0.0
                for i in range(num_images - 1):
                    current_offset += image_durations_list_seconds[i] - crossfade_duration
                    next_stream_tag = f"v{i+1}"
                    output_tag = f"out{i}"
                    fade_command = (
                        f"[{last_stream_tag}][{next_stream_tag}]"
                        f"xfade=transition=fade:duration={crossfade_duration}:offset={current_offset}[{output_tag}];"
                    )
                    filter_complex_parts.append(fade_command)
                    last_stream_tag = output_tag

                final_filter_complex = "".join(filter_complex_parts)

                # 3. Th√™m c√°c t√πy ch·ªçn c√≤n l·∫°i
                command.extend(["-filter_complex", final_filter_complex])
                command.extend([
                    "-map", f"[{last_stream_tag}]", # Map lu·ªìng video ƒë√£ xfade
                    "-map", f"{audio_input_index}:a",      # ### TH√äM M·ªöI: Map lu·ªìng audio im l·∫∑ng ###
                    "-c:v", "libx264", "-preset", "medium",
                    "-profile:v", "main", "-level", "4.0",
                    "-pix_fmt", "yuv420p", "-r", str(fps),
                    "-c:a", "aac", "-b:a", "192k", # Encode audio
                    "-shortest",
                    "-movflags", "+faststart",
                    os.path.abspath(output_video_path)
                ])

            # --- Th·ª±c thi l·ªánh FFmpeg (gi·ªØ nguy√™n) ---
            logging.info(f"[FFmpegSlideshow_v6] L·ªánh FFmpeg ({('Single Image with Audio' if num_images == 1 else 'XFADE with Audio')}) s·∫Ω ch·∫°y: {' '.join(command)}")
            
            process_to_run = None
            ffmpeg_success = False
            try:
                creation_flags = subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                process_to_run = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=creation_flags)
                if hasattr(self, 'dub_current_ffmpeg_process'):
                     self.dub_current_ffmpeg_process = process_to_run 
                
                _, stderr = process_to_run.communicate(timeout=3600)
                if self.dub_stop_event.is_set():
                    if process_to_run.poll() is None: process_to_run.terminate()
                    return False
                
                if process_to_run.returncode == 0 and os.path.exists(output_video_path) and os.path.getsize(output_video_path) > 100:
                    ffmpeg_success = True
                else:
                     logging.error(f"[FFmpegSlideshow_v6] L·ªói FFmpeg (Code: {process_to_run.returncode}). STDERR: {stderr.decode('utf-8', 'ignore')[-1000:]}")
            except Exception as e_general:
                logging.error(f"[FFmpegSlideshow_v6] L·ªói kh√¥ng mong mu·ªën khi t·∫°o slideshow: {e_general}", exc_info=True)
                if process_to_run and process_to_run.poll() is None: process_to_run.kill()
            finally:
                if hasattr(self, 'dub_current_ffmpeg_process') and self.dub_current_ffmpeg_process is process_to_run:
                     self.dub_current_ffmpeg_process = None
            
            return ffmpeg_success


 
# ƒê·∫∑t h√†m n√†y b√™n trong l·ªõp SubtitleApp ƒë·ªÉ THAY TH·∫æ TO√ÄN B·ªò phi√™n b·∫£n b·ªã l·ªói tr∆∞·ªõc ƒë√≥
    def _ffmpeg_create_slideshow_with_motion(
        self,
        image_paths,
        output_video_path,
        resolution,
        fps,
        image_durations_list_seconds,
        motion_effect="Ng·∫´u nhi√™n",
        xfade_seconds=1.0,
        use_minterpolate=False,
        final_minterp_fps=60,
        use_motion_blur=True,
        blur_frames=3
    ):
        """
        v7.1 ‚Äî Phi√™n b·∫£n s·ª≠a l·ªói t∆∞∆°ng th√≠ch FFmpeg c≈©
        - Quay l·∫°i logic zoompan g·ªëc (t∆∞∆°ng th√≠ch r·ªông h∆°n)
        - Gi·ªØ l·∫°i t·ªëi ∆∞u encoder (preset + GPU)
        """
        import os, sys, subprocess, random, logging
        from pathlib import Path

        with keep_awake("Render slideshow (FFmpeg)"):   # <<< KEEP-AWAKE START

            ffmpeg = find_ffmpeg() if "find_ffmpeg" in globals() else None
            if not ffmpeg:
                logging.error("[Slideshow] Kh√¥ng t√¨m th·∫•y ffmpeg."); return False
            if not image_paths:
                logging.error("[Slideshow] Danh s√°ch ·∫£nh r·ªóng."); return False

            cfg = getattr(self, "cfg", {}) or {}
            
            # GI·ªÆ L·∫†I T·ªêI ∆ØU 1: S·ª≠ d·ª•ng preset nhanh h∆°n
            preset = str(cfg.get("ffmpeg_preset", "veryfast"))
            crf    = str(cfg.get("ffmpeg_crf", 23))

            try:
                W, H = map(int, str(resolution).lower().split("x"))
            except Exception:
                logging.exception("[Slideshow] resolution kh√¥ng h·ª£p l·ªá (v√≠ d·ª• '1920x1080').")
                return False

            # --- (To√†n b·ªô ph·∫ßn code c·∫•u h√¨nh hi·ªáu ·ª©ng c·ªßa b·∫°n gi·ªØ nguy√™n, kh√¥ng thay ƒë·ªïi) ---
            motion_speed = cfg.get("imagen_motion_speed", "V·ª´a")
            Z_map = {"Ch·∫≠m": 1.15, "V·ª´a": 1.30, "Nhanh": 1.50}; Z = Z_map.get(motion_speed, 1.30)
            slow_factor = float(cfg.get("imagen_motion_slowdown", 1.0))
            speed_to_zoom_secs = {"Ch·∫≠m": 8.5, "V·ª´a": 6.5, "Nhanh": 4.5}
            speed_to_pan_secs  = {"Ch·∫≠m": 10.0, "V·ª´a": 7.5, "Nhanh": 5.5}
            t_zoom_abs = float(cfg.get("imagen_motion_zoom_secs", speed_to_zoom_secs.get(motion_speed, 6.5))) * max(0.1, slow_factor)
            t_pan_abs  = float(cfg.get("imagen_motion_pan_secs", speed_to_pan_secs.get(motion_speed,  7.5))) * max(0.1, slow_factor)
            time_mode = str(cfg.get("imagen_motion_time_mode", "relative")).lower()
            zoom_ratio = float(cfg.get("imagen_motion_zoom_ratio", 1.0))
            pan_ratio  = float(cfg.get("imagen_motion_pan_ratio",  1.0))
            auto_short_thresh = float(cfg.get("imagen_motion_auto_short_threshold_secs", 3.0))
            pan_pingpong  = bool(cfg.get("imagen_pan_pingpong",  False))
            zoom_pingpong = bool(cfg.get("imagen_zoom_pingpong", True))
            lia_then_shrink = bool(cfg.get("imagen_lia_then_shrink", True))
            lia_half_ratio  = float(cfg.get("imagen_lia_shrink_after_ratio", 0.5)); lia_half_ratio  = max(0.1, min(0.9, lia_half_ratio))
            FPS = int(fps)
            # --- (K·∫øt th√∫c ph·∫ßn gi·ªØ nguy√™n) ---

            cmd = [ffmpeg, "-y"]
            for p in image_paths:
                cmd += ["-loop", "1", "-i", os.path.abspath(p)]

            n = len(image_paths)
            frames_per_img = [max(1, int(round(d * fps))) for d in image_durations_list_seconds]
            durations_sec  = [f / float(fps) for f in frames_per_img]

            min_frames = max(2, min(frames_per_img))
            xfade_f_raw = int(round(xfade_seconds * fps))
            xfade_f = max(1, min(xfade_f_raw, (min_frames // 2)))
            xfade_seconds_eff = xfade_f / float(fps)

            offsets = [0.0] * n
            acc = 0.0
            for i in range(1, n):
                acc += durations_sec[i-1] - xfade_seconds_eff
                offsets[i] = max(0.0, acc)

            scale_flags = "lanczos+accurate_rnd+full_chroma_int"
            if use_motion_blur and blur_frames >= 3 and (blur_frames % 2 == 0):
                blur_frames += 1

            def _tri_weights(k: int) -> str:
                mid = k // 2
                seq = [i+1 for i in range(mid)] + [mid+1] + [mid - i for i in range(mid)]
                return " ".join(str(x) for x in seq)

            filter_parts = []

            for i in range(n):
                eff = motion_effect
                if eff == "Ng·∫´u nhi√™n":
                    eff = random.choice(["Ph√≥ng to ch·∫≠m", "Thu nh·ªè ch·∫≠m", "Lia tr√°i sang ph·∫£i", "Lia ph·∫£i sang tr√°i", "Lia tr√™n xu·ªëng d∆∞·ªõi", "Lia d∆∞·ªõi l√™n tr√™n"])
                logging.info(f"[Slideshow] ·∫¢nh {i}: hi·ªáu ·ª©ng = {eff}")
                d_frames = frames_per_img[i]
                dur_i    = max(0.001, durations_sec[i])

                # --- (To√†n b·ªô ph·∫ßn logic t√≠nh to√°n zexpr, xexpr, yexpr c·ªßa b·∫°n gi·ªØ nguy√™n) ---
                if time_mode == "absolute": t_zoom_i, t_pan_i = t_zoom_abs, t_pan_abs
                elif time_mode == "auto":
                    if dur_i < auto_short_thresh: t_zoom_i, t_pan_i = min(t_zoom_abs, dur_i*0.9), min(t_pan_abs, dur_i*0.9)
                    else: t_zoom_i, t_pan_i = max(0.25, dur_i*zoom_ratio), max(0.25, dur_i*pan_ratio)
                else: t_zoom_i, t_pan_i = max(0.25, dur_i*zoom_ratio), max(0.25, dur_i*pan_ratio)
                if pan_pingpong: frac_pan=f"mod((on+0.5)/({FPS}*{t_pan_i:.6f}),1)";tri_pan=f"(1-abs(2*{frac_pan}-1))";ease_pan=f"(1-cos(PI*{tri_pan}))/2"
                else: p_pan=f"min(1,(on+0.5)/({FPS}*{t_pan_i:.6f}))";ease_pan=f"(1-cos(PI*{p_pan}))/2"
                if zoom_pingpong: frac_zoom=f"mod((on+0.5)/({FPS}*{t_zoom_i:.6f}),1)";tri_zoom=f"(1-abs(2*{frac_zoom}-1))";ease_zoom=f"(1-cos(PI*{tri_zoom}))/2"
                else: p_zoom=f"min(1,(on+0.5)/({FPS}*{t_zoom_i:.6f}))";ease_zoom=f"(1-cos(PI*{p_zoom}))/2"
                if eff=="Ph√≥ng to ch·∫≠m": zexpr=f"1+({Z}-1)*{ease_zoom}";xexpr="iw/2-(iw/zoom/2)";yexpr="ih/2-(ih/zoom/2)"
                elif eff=="Thu nh·ªè ch·∫≠m": zexpr=f"{Z}-({Z}-1)*{ease_zoom}";xexpr="iw/2-(iw/zoom/2)";yexpr="ih/2-(ih/zoom/2)"
                elif eff=="Lia tr√°i sang ph·∫£i":
                    if lia_then_shrink: p_all=f"min(1,(on+0.5)/({FPS}*{dur_i:.6f}))";p_pan=f"min(1,{p_all}/{lia_half_ratio:.6f})";p_zoom=f"max(0,({p_all}-{lia_half_ratio:.6f})/(1-{lia_half_ratio:.6f}))";ease_pan2=f"(1-cos(PI*{p_pan}))/2";ease_shrink=f"(1-cos(PI*{p_zoom}))/2";zexpr=f"{Z}-({Z}-1)*{ease_shrink}";xexpr=f"clip((iw - iw/zoom)*(1-{ease_pan2}), 0, iw - iw/zoom)";yexpr="ih/2-(ih/zoom/2)"
                    else: zexpr=f"{Z}";xexpr=f"clip((iw - iw/zoom)*(1-{ease_pan}), 0, iw - iw/zoom)";yexpr="ih/2-(ih/zoom/2)"
                elif eff=="Lia ph·∫£i sang tr√°i":
                    if lia_then_shrink: p_all=f"min(1,(on+0.5)/({FPS}*{dur_i:.6f}))";p_pan=f"min(1,{p_all}/{lia_half_ratio:.6f})";p_zoom=f"max(0,({p_all}-{lia_half_ratio:.6f})/(1-{lia_half_ratio:.6f}))";ease_pan2=f"(1-cos(PI*{p_pan}))/2";ease_shrink=f"(1-cos(PI*{p_zoom}))/2";zexpr=f"{Z}-({Z}-1)*{ease_shrink}";xexpr=f"clip((iw - iw/zoom)*{ease_pan2}, 0, iw - iw/zoom)";yexpr="ih/2-(ih/zoom/2)"
                    else: zexpr=f"{Z}";xexpr=f"clip((iw - iw/zoom)*{ease_pan}, 0, iw - iw/zoom)";yexpr="ih/2-(ih/zoom/2)"
                elif eff=="Lia tr√™n xu·ªëng d∆∞·ªõi":
                    if lia_then_shrink: p_all=f"min(1,(on+0.5)/({FPS}*{dur_i:.6f}))";p_pan=f"min(1,{p_all}/{lia_half_ratio:.6f})";p_zoom=f"max(0,({p_all}-{lia_half_ratio:.6f})/(1-{lia_half_ratio:.6f}))";ease_pan2=f"(1-cos(PI*{p_pan}))/2";ease_shrink=f"(1-cos(PI*{p_zoom}))/2";zexpr=f"{Z}-({Z}-1)*{ease_shrink}";xexpr="iw/2-(iw/zoom/2)";yexpr=f"clip((ih - ih/zoom)*(1-{ease_pan2}), 0, ih - ih/zoom)"
                    else: zexpr=f"{Z}";xexpr="iw/2-(iw/zoom/2)";yexpr=f"clip((ih - ih/zoom)*(1-{ease_pan}), 0, ih - ih/zoom)"
                elif eff=="Lia d∆∞·ªõi l√™n tr√™n":
                    if lia_then_shrink: p_all=f"min(1,(on+0.5)/({FPS}*{dur_i:.6f}))";p_pan=f"min(1,{p_all}/{lia_half_ratio:.6f})";p_zoom=f"max(0,({p_all}-{lia_half_ratio:.6f})/(1-{lia_half_ratio:.6f}))";ease_pan2=f"(1-cos(PI*{p_pan}))/2";ease_shrink=f"(1-cos(PI*{p_zoom}))/2";zexpr=f"{Z}-({Z}-1)*{ease_shrink}";xexpr="iw/2-(iw/zoom/2)";yexpr=f"clip((ih - ih/zoom)*{ease_pan2}, 0, ih - ih/zoom)"
                    else: zexpr=f"{Z}";xexpr="iw/2-(iw/zoom/2)";yexpr=f"clip((ih - ih/zoom)*{ease_pan}, 0, ih - ih/zoom)"
                else: zexpr="1";xexpr="iw/2-(ow/2)";yexpr="ih/2-(oh/2)"
                # --- (K·∫øt th√∫c ph·∫ßn logic hi·ªáu ·ª©ng gi·ªØ nguy√™n) ---

                # S·ª¨A L·ªñI: Quay l·∫°i chu·ªói filter g·ªëc, t∆∞∆°ng th√≠ch v·ªõi FFmpeg c≈©
                chain = (
                    f"[{i}:v]"
                    f"format=gbrp,"
                    f"gblur=sigma=0.5:steps=1,"
                    # S·ª¨A L·ªñI 1: X√≥a eval=frame kh·ªèi scale
                    f"scale=w='ceil({W}*{Z}/2)*2':h=-1:flags={scale_flags},"
                    f"setsar=1,"
                    # S·ª¨A L·ªñI 2: Quay l·∫°i zoompan g·ªëc, t√≠nh to√°n m·ªói frame
                    f"zoompan=z='{zexpr}':x='{xexpr}':y='{yexpr}':d={d_frames}:s={W}x{H},"
                )

                if use_motion_blur and blur_frames >= 3:
                    chain += f"tmix=frames={int(blur_frames)}:weights='{_tri_weights(int(blur_frames))}',"

                chain += (
                    f"setpts=N/({int(fps)}*TB),"
                    f"fps=fps={int(fps)},"
                    f"tpad=stop_mode=clone:stop_duration={xfade_seconds_eff:.6f},"
                    f"format=gbrp[v{i}]"
                )
                filter_parts.append(chain)

            # --- (Ph·∫ßn gh√©p xfade v√† minterpolate gi·ªØ nguy√™n) ---
            last = "v0"
            for i in range(n - 1):
                out = f"mix{i}"; filter_parts.append(f"[{last}][v{i+1}]xfade=transition=fade:duration={xfade_seconds_eff:.6f}:offset={offsets[i+1]:.6f}[{out}]"); last = out
            if use_minterpolate:
                target_fps = max(int(final_minterp_fps), int(fps)); filter_parts.append(f"[{last}]minterpolate=fps={target_fps}:mi_mode=mci:mc_mode=aobmc:me_mode=bidir:vsbmc=1[v_pre_format]"); vmap_base = "[v_pre_format]"
            else:
                vmap_base = f"[{last}]"
            # --- (K·∫øt th√∫c ph·∫ßn gi·ªØ nguy√™n) ---
            
            total_duration = sum(durations_sec) - (n - 1) * xfade_seconds_eff
            total_duration = max(0.01, total_duration)
            cmd += ["-f", "lavfi", "-i", f"anullsrc=channel_layout=stereo:sample_rate=44100:d={total_duration:.6f}"]
            a_idx = n

            # GI·ªÆ L·∫†I T·ªêI ∆ØU 4: L·ª±a ch·ªçn encoder (CPU ho·∫∑c GPU)
            encoder_choice = str(cfg.get("ffmpeg_encoder", "libx264")).lower()
            
            final_video_filters = []; vmap_final = "[v_for_encode]"
            if encoder_choice == "h264_nvenc": final_video_filters.append(f"{vmap_base}format=nv12[v_for_encode]")
            else: final_video_filters.append(f"{vmap_base}format=yuv420p[v_for_encode]")
            full_filter_complex = ";".join(filter_parts + final_video_filters)
            cmd += ["-filter_complex", full_filter_complex]
            cmd += ["-map", vmap_final, "-map", f"{a_idx}:a"]

            if encoder_choice == "h264_nvenc":
                logging.info("[Slideshow] S·ª≠ d·ª•ng encoder GPU: NVIDIA NVENC")
                cmd += ["-c:v", "h264_nvenc", "-preset", "p5", "-cq", "24", "-b:v", "0", "-pix_fmt", "yuv420p"]
            else:
                logging.info("[Slideshow] S·ª≠ d·ª•ng encoder CPU: libx264")
                cmd += ["-c:v", "libx264", "-preset", preset, "-crf", crf, "-pix_fmt", "yuv420p"]
            
            cmd += ["-movflags", "+faststart", "-fps_mode", "cfr", "-shortest", os.path.abspath(output_video_path)]
            # --- (K·∫øt th√∫c kh·ªëi Encoder) ---

            # --- (Ph·∫ßn logging v√† ch·∫°y subprocess gi·ªØ nguy√™n) ---
            logging.info(f"[Slideshow] mode={time_mode}, Z={Z}, slowdown={slow_factor}, ...")
            logging.info("FFmpeg cmd: " + " ".join(cmd))
            try:
                creation_flags = (subprocess.CREATE_NO_WINDOW if (sys.platform == "win32") else 0)
                self.current_process = subprocess.Popen(
                    cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding="utf-8", errors="ignore", creationflags=creation_flags
                )
                _, stderr = self.current_process.communicate(timeout=1800)
                if self.current_process.returncode != 0:
                    logging.error("[Slideshow] FFmpeg error:\n" + (stderr or ""))
                    return False
                return True
            except Exception as e:
                logging.exception("[Slideshow] Exception khi ch·∫°y FFmpeg: %s", e)
                return False
            finally:
                self.current_process = None



# H√†m h√†nh ƒë·ªông: T·∫£i v√† ph√¢n t√≠ch file k·ªãch b·∫£n/ph·ª• ƒë·ªÅ SRT cho thuy·∫øt minh
    def dub_load_script(self):
        initial_dir_script = os.path.dirname(self.dub_current_script_path_for_queue_temp) if self.dub_current_script_path_for_queue_temp else \
                             (self.dub_output_path_var.get() or os.getcwd())

        script_path = filedialog.askopenfilename(
            title="Ch·ªçn file K·ªãch b·∫£n (SRT, TXT...)",  # S·ª≠a l·∫°i title cho r√µ r√†ng h∆°n
            filetypes=[ # S·ª≠ d·ª•ng list gi·ªëng h·ªát n√∫t "M·ªü Sub"
                ("T·∫•t c·∫£ file k·ªãch b·∫£n", "*.srt *.txt"),
                ("File ph·ª• ƒë·ªÅ (Subrip)", "*.srt"),
                ("File vƒÉn b·∫£n (Text)", "*.txt"),
                ("T·∫•t c·∫£ file", "*.*")
            ],
            initialdir=initial_dir_script,
            parent=self
        )

        # --- B∆∞·ªõc 1: Chu·∫©n b·ªã Textbox ---
        if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
            self.dub_script_textbox.configure(state="normal")
            self.dub_script_textbox.delete("1.0", "end")
            logging.debug("[DubLoadScript] Textbox ƒë∆∞·ª£c ƒë·∫∑t normal v√† x√≥a n·ªôi dung c≈©.") # [cite: 2]
        else:
            logging.warning("[DubLoadScript] Textbox k·ªãch b·∫£n kh√¥ng t·ªìn t·∫°i ho·∫∑c ch∆∞a ƒë∆∞·ª£c t·∫°o.") # [cite: 3]
            # N·∫øu textbox kh√¥ng c√≥ th√¨ kh√¥ng th·ªÉ l√†m g√¨ th√™m v·ªõi vi·ªác hi·ªÉn th·ªã

        # --- X·ª≠ l√Ω n·∫øu ng∆∞·ªùi d√πng h·ªßy ho·∫∑c ch·ªçn file kh√¥ng h·ª£p l·ªá ---
        if not script_path or not os.path.exists(script_path): # [cite: 4]
            if script_path: # Ng∆∞·ªùi d√πng ch·ªçn nh∆∞ng file kh√¥ng t·ªìn t·∫°i
                self.dub_current_script_path_for_queue_temp = ""
                self.dub_temp_srt_data_for_queue = []
                self.dub_current_script_for_queue_display.set("(L·ªói: File script kh√¥ng t·ªìn t·∫°i)") # [cite: 4]
                if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
                    self.dub_script_textbox.insert("1.0", "[L·ªñI: File script ƒë√£ ch·ªçn kh√¥ng t·ªìn t·∫°i]") # [cite: 5]
                logging.warning(f"[DubLoadScript] Script ƒë√£ ch·ªçn kh√¥ng t·ªìn t·∫°i: {script_path}") # [cite: 5]
            else: # Ng∆∞·ªùi d√πng h·ªßy
                if not self.dub_current_script_path_for_queue_temp: # [cite: 6]
                    self.dub_current_script_for_queue_display.set("(Ch∆∞a ch·ªçn script)") # [cite: 6]
                    if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
                        self.dub_script_textbox.insert("1.0", "[N·ªôi dung file k·ªãch b·∫£n SRT ƒë√£ ch·ªçn s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...]") # [cite: 6]
                logging.info("[DubLoadScript] ƒê√£ h·ªßy ch·ªçn Script.") # [cite: 7]
            
            if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
                self.dub_script_textbox.configure(state="disabled") # [cite: 7]
            self._update_dub_script_controls_state() # [cite: 8]
            self._try_auto_add_to_dub_queue() # [cite: 8]
            return

        # --- N·∫øu ng∆∞·ªùi d√πng ch·ªçn file h·ª£p l·ªá ---
        self.dub_current_script_path_for_queue_temp = script_path # L∆∞u ƒë∆∞·ªùng d·∫´n g·ªëc
        script_filename = os.path.basename(script_path)
        # T·∫°m th·ªùi ch∆∞a set dub_current_script_for_queue_display, s·∫Ω set sau khi c√≥ n·ªôi dung cu·ªëi c√πng
        
        self.update_status(f"ƒêang ƒë·ªçc file k·ªãch b·∫£n: {script_filename}...") # [cite: 9]
        logging.info(f"[DubLoadScript] ƒê√£ ch·ªçn Script: {script_filename}") # [cite: 9]

        raw_srt_content_from_file = ""
        original_parsed_srt_data = [] # S·∫Ω l∆∞u d·ªØ li·ªáu parse t·ª´ file SRT g·ªëc
        self.dub_temp_srt_data_for_queue = [] # Reset l·∫°i tr∆∞·ªõc khi parse file m·ªõi

        try:
            # --- B∆∞·ªõc 2: ƒê·ªçc n·ªôi dung file ---
            with open(script_path, 'r', encoding='utf-8-sig') as f:
                raw_srt_content_from_file = f.read() # [cite: 9]
            
            # Parse file SRT g·ªëc ƒë·ªÉ l·∫•y d·ªØ li·ªáu ban ƒë·∫ßu v√† text
            # (Logic parse n√†y gi·ªëng v·ªõi source 13-17 c·ªßa b·∫°n)
            srt_block_pattern = re.compile(
                r"(\d+)\s*[\r\n]+"
                r"(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*[\r\n]+"
                r"((?:.|\n|\r)*?)(?=\n\s*\n\d+\s*[\r\n]+|\n\d+\s*[\r\n]+\d{2}:\d{2}:\d{2}[,.]\d{3}|\Z)",
                re.MULTILINE
            ) # [cite: 13]
            matches = list(srt_block_pattern.finditer(raw_srt_content_from_file))
            if not matches and raw_srt_content_from_file.strip(): # N·∫øu kh√¥ng c√≥ match SRT nh∆∞ng file c√≥ n·ªôi dung
                logging.warning(f"[DubLoadScript] File '{script_filename}' kh√¥ng c√≥ c·∫•u tr√∫c SRT h·ª£p l·ªá. S·∫Ω th·ª≠ x·ª≠ l√Ω nh∆∞ plain text n·∫øu auto-optimize b·∫≠t.")
                # Coi nh∆∞ original_parsed_data r·ªóng ƒë·ªÉ logic auto-optimize (n·∫øu b·∫≠t) x·ª≠ l√Ω raw_srt_content_from_file nh∆∞ plain text
            elif matches:
                for i, match in enumerate(matches): # [cite: 13]
                    try:
                        index_str, start_tc_str, end_tc_str, text_for_tts_raw = match.groups()
                        start_tc_str_clean = start_tc_str.replace('.', ',') # [cite: 14]
                        end_tc_str_clean = end_tc_str.replace('.', ',') # [cite: 15]
                        text_for_tts_and_storage = text_for_tts_raw.strip()
                        text_for_tts_and_storage = re.sub(r'<[^>]+>', '', text_for_tts_and_storage)
                        text_for_tts_and_storage = "\n".join([line.strip() for line in text_for_tts_and_storage.splitlines() if line.strip()]).strip()
                        if not text_for_tts_and_storage: continue
                        original_parsed_srt_data.append({ # [cite: 16]
                            "index": int(index_str), "start_str": start_tc_str_clean, "end_str": end_tc_str_clean,
                            "start_ms": parse_timecode(start_tc_str_clean), "end_ms": parse_timecode(end_tc_str_clean),
                            "text": text_for_tts_and_storage # [cite: 16]
                        }) # [cite: 16]
                    except Exception as e_parse_block:
                        logging.error(f"[DubLoadScript] L·ªói parse kh·ªëi SRT #{i+1} trong file '{script_filename}': {e_parse_block}")
                        continue
            # K·∫øt th√∫c parse SRT g·ªëc

            final_content_for_textbox = raw_srt_content_from_file
            final_parsed_data_for_queue = list(original_parsed_srt_data) # T·∫°o b·∫£n sao
            final_display_name_for_script = script_filename

            # --- LOGIC M·ªöI: KI·ªÇM TRA V√Ä √ÅP D·ª§NG T·ªêI ∆ØU H√ìA N·∫æU C·∫¶N ---
            should_auto_optimize_loaded_srt = (
                hasattr(self, 'optimize_dub_flow_var') and self.optimize_dub_flow_var.get() and
                hasattr(self, 'dub_auto_optimize_on_paste_var') and self.dub_auto_optimize_on_paste_var.get()
            )

            if should_auto_optimize_loaded_srt:
                logging.info(f"[DubLoadScript] T√πy ch·ªçn t·ª± ƒë·ªông t·ªëi ∆∞u ƒëang b·∫≠t cho SRT ƒë√£ t·∫£i: {script_filename}")
                self.update_status(f"‚è≥ ƒêang t·ª± ƒë·ªông t·ªëi ∆∞u SRT ƒë√£ t·∫£i: {script_filename}...")

                text_to_optimize = ""
                if original_parsed_srt_data: # ∆Øu ti√™n text t·ª´ c√°c segment ƒë√£ parse c·ªßa SRT g·ªëc
                    all_text_from_original_srt = " ".join([seg.get('text', '').strip() for seg in original_parsed_srt_data if seg.get('text', '').strip()])
                    text_to_optimize = all_text_from_original_srt.strip()
                elif raw_srt_content_from_file.strip(): # N·∫øu parse SRT g·ªëc kh√¥ng ra g√¨, nh∆∞ng file c√≥ text, d√πng raw text
                    logging.info(f"[DubLoadScript] SRT g·ªëc kh√¥ng parse ƒë∆∞·ª£c segment n√†o, s·ª≠ d·ª•ng raw content ƒë·ªÉ t·ªëi ∆∞u.")
                    text_to_optimize = raw_srt_content_from_file # _parse_plain_text_to_srt_data s·∫Ω t·ª± strip
                
                if text_to_optimize:
                    dub_flow_config = {
                        "split_enabled": self.dub_split_enabled_for_flow_var.get(),
                        "mode": self.dub_split_mode_for_flow_var.get(),
                        "max_chars": safe_int(self.dub_max_chars_for_flow_var.get(), 999),
                        "max_lines": safe_int(self.dub_max_lines_for_flow_var.get(), 1),
                        "DEFAULT_CPS_FOR_TIMING": safe_int(self.dub_cps_for_timing_var.get(), 17),
                        "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": getattr(self, 'app_pause_ms_for_plain_text_estimate', 1),
                        "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
                    }
                    logging.debug(f"[DubLoadScript] √Åp d·ª•ng config t·ªëi ∆∞u: {json.dumps(dub_flow_config, ensure_ascii=False)}")

                    newly_optimized_segments = self._parse_plain_text_to_srt_data(
                        text_to_optimize,
                        force_plain_text_processing=True, # Lu√¥n coi nh∆∞ plain text ƒë·ªÉ re-segment
                        split_config_override=dub_flow_config
                    )

                    if newly_optimized_segments:
                        # QUAN TR·ªåNG: √Ånh x·∫° l·∫°i timing ƒë·ªÉ gi·ªØ t·ªïng th·ªùi l∆∞·ª£ng g·ªëc n·∫øu c√≥ th·ªÉ
                        # N·∫øu original_parsed_srt_data r·ªóng (v√≠ d·ª• file SRT kh√¥ng ƒë√∫ng c·∫•u tr√∫c nh∆∞ng c√≥ text),
                        # th√¨ kh√¥ng th·ªÉ map v·ªõi timing g·ªëc, s·∫Ω d√πng timing ∆∞·ªõc t√≠nh.
                        if original_parsed_srt_data:
                            logging.info(f"[DubLoadScript] √Ånh x·∫° {len(newly_optimized_segments)} segment t·ªëi ∆∞u v·ªõi timing t·ª´ {len(original_parsed_srt_data)} segment SRT g·ªëc.")
                            segments_after_mapping = self._map_optimized_segments_to_original_srt_timings(
                                newly_optimized_segments,
                                original_parsed_srt_data
                            )
                            if segments_after_mapping:
                                final_parsed_data_for_queue = list(segments_after_mapping)
                                final_content_for_textbox = format_srt_data_to_string(final_parsed_data_for_queue)
                                logging.info(f"[DubLoadScript] √Ånh x·∫° timing th√†nh c√¥ng.")
                            else:
                                logging.warning(f"[DubLoadScript] √Ånh x·∫° timing th·∫•t b·∫°i. S·ª≠ d·ª•ng segment v·ªõi timing ∆∞·ªõc t√≠nh.")
                                final_parsed_data_for_queue = list(newly_optimized_segments)
                                final_content_for_textbox = format_srt_data_to_string(final_parsed_data_for_queue)
                        else: # Kh√¥ng c√≥ original_parsed_srt_data ƒë·ªÉ map
                            logging.info(f"[DubLoadScript] Kh√¥ng c√≥ d·ªØ li·ªáu SRT g·ªëc h·ª£p l·ªá ƒë·ªÉ map timing. S·ª≠ d·ª•ng timing ∆∞·ªõc t√≠nh.")
                            final_parsed_data_for_queue = list(newly_optimized_segments)
                            final_content_for_textbox = format_srt_data_to_string(final_parsed_data_for_queue)
                        
                        final_display_name_for_script = f"{script_filename} (ƒê√£ t·ªëi ∆∞u)"
                        self.update_status(f"‚úÖ SRT ƒë√£ t·∫£i ƒë∆∞·ª£c t·ª± ƒë·ªông t·ªëi ∆∞u: {script_filename}")
                        logging.info(f"[DubLoadScript] T·ª± ƒë·ªông t·ªëi ∆∞u SRT '{script_filename}' th√†nh c√¥ng.")
                    else:
                        logging.warning(f"[DubLoadScript] T·ªëi ∆∞u h√≥a (b∆∞·ªõc parse l·∫°i) kh√¥ng t·∫°o ra segment n√†o cho '{script_filename}'. S·ª≠ d·ª•ng SRT/text g·ªëc.")
                        # final_content_for_textbox v√† final_parsed_data_for_queue s·∫Ω gi·ªØ gi√° tr·ªã g·ªëc
                else:
                    logging.warning(f"[DubLoadScript] Kh√¥ng c√≥ text ƒë·ªÉ t·ªëi ∆∞u t·ª´ '{script_filename}'. S·ª≠ d·ª•ng SRT/text g·ªëc.")
            else: # Kh√¥ng t·ª± ƒë·ªông t·ªëi ∆∞u
                logging.info(f"[DubLoadScript] Kh√¥ng t·ª± ƒë·ªông t·ªëi ∆∞u SRT ƒë√£ t·∫£i (ƒëi·ªÅu ki·ªán kh√¥ng th·ªèa m√£n). Hi·ªÉn th·ªã SRT g·ªëc.")
            # --- K·∫æT TH√öC LOGIC M·ªöI ---

            # Hi·ªÉn th·ªã n·ªôi dung cu·ªëi c√πng l√™n Textbox
            if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
                if final_content_for_textbox.strip(): # [cite: 10]
                    self.dub_script_textbox.insert("1.0", final_content_for_textbox) # [cite: 11]
                    logging.info(f"[DubLoadScript] ƒê√£ insert n·ªôi dung cu·ªëi c√πng v√†o textbox (Ngu·ªìn: '{final_display_name_for_script}').") # [cite: 11]
                else:
                    self.dub_script_textbox.insert("1.0", f"[File '{script_filename}' kh√¥ng c√≥ n·ªôi dung ho·∫∑c l·ªói x·ª≠ l√Ω]") # [cite: 11]
                    logging.warning(f"[DubLoadScript] N·ªôi dung cu·ªëi c√πng cho textbox r·ªóng (File: '{script_filename}').") # [cite: 12]
            
            # C·∫≠p nh·∫≠t d·ªØ li·ªáu t·∫°m th·ªùi cho h√†ng ch·ªù v√† t√™n hi·ªÉn th·ªã
            self.dub_temp_srt_data_for_queue = final_parsed_data_for_queue
            self.dub_current_script_for_queue_display.set(final_display_name_for_script)
            
            if not final_parsed_data_for_queue and not final_content_for_textbox.strip() :
                 self.update_status(f"L·ªói ho·∫∑c file script r·ªóng: {script_filename}")
            elif final_display_name_for_script.endswith("(ƒê√£ t·ªëi ∆∞u)"):
                 pass # Status ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ·ªü tr√™n
            else:
                 self.update_status(f"ƒê√£ ƒë·ªçc k·ªãch b·∫£n: {script_filename} ({len(final_parsed_data_for_queue)} m·ª•c)") # [cite: 18]

        except Exception as e_read_file:
            error_msg = f"L·ªói ƒë·ªçc/ph√¢n t√≠ch file script '{script_filename}': {e_read_file}"
            logging.error(error_msg, exc_info=True)
            if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
                self.dub_script_textbox.insert("1.0", f"[L·ªñI KHI ƒê·ªåC SCRIPT]\n{error_msg}") # [cite: 19]
            self.update_status(f"L·ªói ƒë·ªçc file script: {script_filename}") # [cite: 19]
            self.dub_current_script_for_queue_display.set(f"(L·ªói: {script_filename})")
            self.dub_temp_srt_data_for_queue = [] # ƒê·∫£m b·∫£o r·ªóng khi l·ªói
            messagebox.showerror("L·ªói Script", error_msg, parent=self) # [cite: 19]

        finally:
            if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
                 if self.dub_temp_srt_data_for_queue : # [cite: 20]
                     self.dub_script_textbox.configure(state="disabled") # [cite: 20]
                     logging.debug("[DubLoadScript] Textbox ƒë∆∞·ª£c ƒë·∫∑t 'disabled' (c√≥ d·ªØ li·ªáu script).") # [cite: 20]
                 else: # [cite: 21]
                     self.dub_script_textbox.configure(state="normal") # [cite: 21]
                     current_textbox_text_final = self.dub_script_textbox.get("1.0", "end-1c").strip() # [cite: 21]
                     placeholder_text_final = "[N·ªôi dung file k·ªãch b·∫£n SRT ƒë√£ ch·ªçn s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...]" # [cite: 22]
                     # (Ph·∫ßn x·ª≠ l√Ω placeholder ph·ª©c t·∫°p h∆°n, t·∫°m gi·ªØ nguy√™n logic c≈© c·ªßa b·∫°n ·ªü ƒë√¢y n·∫øu n√≥ ho·∫°t ƒë·ªông)
                     # Ch·ªâ x√≥a v√† ch√®n l·∫°i n·∫øu n·ªôi dung hi·ªán t·∫°i kh√¥ng ph·∫£i l√† placeholder mong mu·ªën
                     if not current_textbox_text_final or current_textbox_text_final != placeholder_text_final: # [cite: 22]
                        is_error_message = False # [cite: 23]
                        # known_placeholders_or_errors c·∫ßn ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü ph·∫°m vi l·ªõp ho·∫∑c truy·ªÅn v√†o
                        known_placeholders_or_errors = getattr(self, 'known_dub_placeholders_or_errors', []) 
                        for ph_err in known_placeholders_or_errors: 
                            if ph_err in current_textbox_text_final and ph_err != placeholder_text_final: # [cite: 23]
                                is_error_message = True # [cite: 24]
                                break # [cite: 24]
                        if not is_error_message or not current_textbox_text_final: # [cite: 24]
                            self.dub_script_textbox.delete("1.0", "end") # [cite: 25]
                            self.dub_script_textbox.insert("1.0", placeholder_text_final) # [cite: 25]
                     logging.debug("[DubLoadScript] Textbox ƒë∆∞·ª£c ƒë·∫∑t 'normal' (kh√¥ng c√≥ k·ªãch b·∫£n h·ª£p l·ªá).") # [cite: 25]

            self._update_dub_script_controls_state() # [cite: 26]
            self._try_auto_add_to_dub_queue() # [cite: 26]
            # self._update_dub_start_batch_button_state() # _try_auto_add_to_dub_queue s·∫Ω g·ªçi _update_dub_start_batch_button_state


# H√†m ki·ªÉm tra ƒëi·ªÅu ki·ªán h√†ng ch·ªù
    def _check_can_add_to_dub_queue(self):
        """
        NEW: Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ ch·ªçn ƒë·ªß Video v√† Script hay ch∆∞a
        ƒë·ªÉ k√≠ch ho·∫°t/v√¥ hi·ªáu h√≥a n√∫t "Th√™m v√†o H√†ng ch·ªù Dubbing".
        """
        can_add = False
        # Ki·ªÉm tra xem ƒë∆∞·ªùng d·∫´n video v√† script t·∫°m th·ªùi c√≥ gi√° tr·ªã kh√¥ng
        # v√† d·ªØ li·ªáu script t·∫°m th·ªùi c√≥ n·ªôi dung kh√¥ng.
        if (hasattr(self, 'dub_current_video_path_for_queue_temp') and self.dub_current_video_path_for_queue_temp and \
            hasattr(self, 'dub_current_script_path_for_queue_temp') and self.dub_current_script_path_for_queue_temp and \
            hasattr(self, 'dub_temp_srt_data_for_queue') and self.dub_temp_srt_data_for_queue):
            can_add = True
        
        # K√≠ch ho·∫°t/V√¥ hi·ªáu h√≥a n√∫t "Th√™m v√†o H√†ng ch·ªù"
        if hasattr(self, 'dub_btn_add_to_queue') and self.dub_btn_add_to_queue and self.dub_btn_add_to_queue.winfo_exists():
            if can_add:
                self.dub_btn_add_to_queue.configure(state=ctk.NORMAL)
            else:
                self.dub_btn_add_to_queue.configure(state=ctk.DISABLED)
        # else: # Th√™m log n·∫øu c·∫ßn debug
            # logging.debug("[DubbingQueue] _check_can_add_to_dub_queue: N√∫t dub_btn_add_to_queue ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.")
            self._update_dub_script_controls_state()
            


# H√†m l√†m m·ªõi h√†ng ch·ªù DUNGBING
    def update_dub_queue_display(self):
        """
        C·∫≠p nh·∫≠t n·ªôi dung hi·ªÉn th·ªã trong CTkScrollableFrame c·ªßa h√†ng ch·ªù thuy·∫øt minh.
        ƒê√É S·ª¨A: M√†u ch·ªØ t·ª± ƒë·ªông t∆∞∆°ng th√≠ch v·ªõi giao di·ªán S√°ng/T·ªëi.
        """
        queue_widget = getattr(self, 'dub_queue_display_frame', None)
        if not queue_widget or not queue_widget.winfo_exists():
            logging.debug("[DubbingQueueUI] Widget h√†ng ch·ªù dub_queue_display_frame ch∆∞a s·∫µn s√†ng.")
            return

        for widget_child in queue_widget.winfo_children():
            widget_child.destroy()

        if not self.dub_processing_queue:
            if hasattr(self, 'placeholder_dub_queue') and self.placeholder_dub_queue.winfo_exists():
                self.placeholder_dub_queue.destroy()
            self.placeholder_dub_queue = ctk.CTkLabel(queue_widget, text="[H√†ng ch·ªù thuy·∫øt minh tr·ªëng]",
                                                      font=("Segoe UI", 11), text_color="gray")
            self.placeholder_dub_queue.pack(pady=20, anchor="center")
        else:
            if hasattr(self, 'placeholder_dub_queue') and self.placeholder_dub_queue.winfo_exists():
                self.placeholder_dub_queue.destroy()

            for index, task_data in enumerate(self.dub_processing_queue):
                task_id_q = task_data.get('id', f"no_id_q_{index}")
                is_currently_processing = (self.dub_is_processing and
                                           self.dub_currently_processing_task_id == task_id_q)

                # --- LOGIC M√ÄU CH·ªÆ V√Ä N·ªÄN ƒê√É S·ª¨A ---
                item_bg_color = "transparent"
                item_text_color = None  # ƒê·ªÉ l√† None ƒë·ªÉ d√πng m√†u m·∫∑c ƒë·ªãnh c·ªßa theme
                status_color_display = None

                if is_currently_processing:
                    item_bg_color = "#006933"
                    item_text_color = "white"
                    status_color_display = "white"
                elif task_data.get('status') == 'Ho√†n th√†nh ‚úÖ':
                    item_text_color = "lightgreen"
                    status_color_display = "lightgreen"
                elif 'L·ªói' in task_data.get('status', '') or 'ƒê√£ d·ª´ng' in task_data.get('status', ''):
                    item_text_color = "red"
                    status_color_display = "red"
                elif task_data.get('status') == 'Ch·ªù x·ª≠ l√Ω':
                    status_color_display = ("#E65100", "orange") # Cam ƒë·∫≠m cho n·ªÅn s√°ng, cam t∆∞∆°i cho n·ªÅn t·ªëi
                    item_text_color = None
                # ------------------------------------
                
                item_frame_q = ctk.CTkFrame(queue_widget, fg_color=item_bg_color, corner_radius=3 if is_currently_processing else 0)
                item_frame_q.pack(fill="x", padx=2, pady=(2, 1))

                status_frame_q = ctk.CTkFrame(item_frame_q, fg_color="transparent")
                status_frame_q.pack(side="left", padx=(5, 5), fill="y", pady=(1, 1) if is_currently_processing else 0)

                status_text_q = task_data.get('status', 'N/A')
                if is_currently_processing:
                    status_text_q = "‚ñ∂Ô∏è ƒêang x·ª≠ l√Ω..."
                
                ctk.CTkLabel(status_frame_q, text=f"{index + 1}.", font=("Segoe UI", 10, "bold"), text_color=item_text_color).pack(anchor="n", pady=(2,0))
                ctk.CTkLabel(status_frame_q, text=status_text_q, font=("Segoe UI", 9, "italic"),
                             text_color=status_color_display, wraplength=70).pack(anchor="n", pady=(0,2))

                info_frame_q = ctk.CTkFrame(item_frame_q, fg_color="transparent")
                info_frame_q.pack(side="left", fill="both", expand=True, padx=5, pady=(1, 1) if is_currently_processing else 0)

                video_name_disp_q = task_data.get('video_display_name', 'N/A')
                script_name_disp_q = task_data.get('script_display_name', 'N/A')

                ctk.CTkLabel(info_frame_q, text=f"üé¨ {video_name_disp_q}", anchor="w", font=("Segoe UI", 10), text_color=item_text_color).pack(fill="x")
                ctk.CTkLabel(info_frame_q, text=f"üìú {script_name_disp_q}", anchor="w", font=("Segoe UI", 10), text_color=item_text_color).pack(fill="x")

                controls_frame_q = ctk.CTkFrame(item_frame_q, fg_color="transparent")
                controls_frame_q.pack(side="right", padx=(5,5), fill="y", pady=(1,1) if is_currently_processing else 0, anchor="center")
                
                horizontal_buttons_frame = ctk.CTkFrame(controls_frame_q, fg_color="transparent")
                horizontal_buttons_frame.pack(expand=True, anchor="center")

                button_state_q = ctk.NORMAL if not self.dub_is_processing else ctk.DISABLED
                if is_currently_processing: button_state_q = ctk.DISABLED

                up_button_state_q = button_state_q if index > 0 else ctk.DISABLED
                up_button_q = ctk.CTkButton(horizontal_buttons_frame, text="‚Üë", width=26, height=26, font=("Segoe UI", 14, "bold"), command=lambda tid=task_id_q: self.dub_move_item_in_queue(tid, "up"), state=up_button_state_q)
                up_button_q.pack(side="left", padx=(0, 2))

                down_button_state_q = button_state_q if index < len(self.dub_processing_queue) - 1 else ctk.DISABLED
                down_button_q = ctk.CTkButton(horizontal_buttons_frame, text="‚Üì", width=26, height=26, font=("Segoe UI", 14, "bold"), command=lambda tid=task_id_q: self.dub_move_item_in_queue(tid, "down"), state=down_button_state_q)
                down_button_q.pack(side="left", padx=2)

                del_button_q = ctk.CTkButton(horizontal_buttons_frame, text="‚úï", width=26, height=26, font=("Segoe UI", 12, "bold"), command=lambda tid=task_id_q: self.dub_remove_from_queue(tid), fg_color="#E74C3C", hover_color="#C0392B", text_color="white", state=button_state_q)
                del_button_q.pack(side="left", padx=(2, 0))

        self._update_dub_start_batch_button_state()


# H√†m x√≥a hi·ªÉn th·ªã ·ªü h√†ng ch·ªù
    def dub_remove_from_queue(self, task_id_to_remove):
        """
        NEW: X√≥a m·ªôt t√°c v·ª• kh·ªèi h√†ng ch·ªù thuy·∫øt minh (self.dub_processing_queue)
        d·ª±a tr√™n ID c·ªßa t√°c v·ª•.
        """
        if self.dub_is_processing:
            messagebox.showwarning("ƒêang x·ª≠ l√Ω", 
                                 "Kh√¥ng th·ªÉ x√≥a t√°c v·ª• kh·ªèi h√†ng ch·ªù khi ƒëang x·ª≠ l√Ω h√†ng lo·∫°t.", 
                                 parent=self)
            return

        logging.info(f"[DubbingQueue] Y√™u c·∫ßu x√≥a t√°c v·ª• ID: {task_id_to_remove} kh·ªèi h√†ng ch·ªù thuy·∫øt minh.")
        
        initial_queue_length = len(self.dub_processing_queue)
        # L·ªçc ra danh s√°ch m·ªõi kh√¥ng ch·ª©a t√°c v·ª• c·∫ßn x√≥a
        self.dub_processing_queue = [task for task in self.dub_processing_queue if task.get('id') != task_id_to_remove]
        
        if len(self.dub_processing_queue) < initial_queue_length:
            removed_task_name = "m·ªôt t√°c v·ª•" # M·∫∑c ƒë·ªãnh
            
            logging.info(f"[DubbingQueue] ƒê√£ x√≥a th√†nh c√¥ng t√°c v·ª• ID: {task_id_to_remove}.")
            self.update_dub_queue_display() # C·∫≠p nh·∫≠t giao di·ªán
            self.update_status(f"ƒê√£ x√≥a {removed_task_name} kh·ªèi h√†ng ch·ªù thuy·∫øt minh.")
        else:
            logging.warning(f"[DubbingQueue] Kh√¥ng t√¨m th·∫•y t√°c v·ª• v·ªõi ID: {task_id_to_remove} ƒë·ªÉ x√≥a.")
            # Kh√¥ng c·∫ßn th√¥ng b√°o l·ªói cho ng∆∞·ªùi d√πng n·∫øu kh√¥ng t√¨m th·∫•y, c√≥ th·ªÉ do click nhanh
            
        # Ki·ªÉm tra l·∫°i tr·∫°ng th√°i n√∫t "B·∫Øt ƒë·∫ßu H√†ng lo·∫°t"
        self._update_dub_start_batch_button_state()


# H√†m di chuy·ªÉn th·ª© t·ª± h√†ng ch·ªù
    def dub_move_item_in_queue(self, task_id_to_move, direction):
        """
        NEW: Di chuy·ªÉn m·ªôt t√°c v·ª• trong h√†ng ch·ªù thuy·∫øt minh (self.dub_processing_queue)
        l√™n ("up") ho·∫∑c xu·ªëng ("down") d·ª±a tr√™n ID c·ªßa t√°c v·ª•.
        """
        if self.dub_is_processing:
            messagebox.showwarning("ƒêang x·ª≠ l√Ω", 
                                 "Kh√¥ng th·ªÉ s·∫Øp x·∫øp l·∫°i h√†ng ch·ªù khi ƒëang x·ª≠ l√Ω h√†ng lo·∫°t.", 
                                 parent=self)
            return

        logging.info(f"[DubbingQueue] Y√™u c·∫ßu di chuy·ªÉn t√°c v·ª• ID: {task_id_to_move}, H∆∞·ªõng: {direction}")

        current_index = -1
        for i, task in enumerate(self.dub_processing_queue):
            if task.get('id') == task_id_to_move:
                current_index = i
                break
        
        if current_index == -1:
            logging.warning(f"[DubbingQueue] Kh√¥ng t√¨m th·∫•y t√°c v·ª• ID: {task_id_to_move} ƒë·ªÉ di chuy·ªÉn.")
            return

        queue_len = len(self.dub_processing_queue)
        new_index = -1

        if direction == "up" and current_index > 0:
            new_index = current_index - 1
        elif direction == "down" and current_index < queue_len - 1:
            new_index = current_index + 1
        else:
            logging.debug(f"[DubbingQueue] Kh√¥ng th·ªÉ di chuy·ªÉn t√°c v·ª• ID: {task_id_to_move} theo h∆∞·ªõng '{direction}' (ƒë√£ ·ªü bi√™n).")
            return # Kh√¥ng th·ªÉ di chuy·ªÉn (ƒë√£ ·ªü ƒë·∫ßu/cu·ªëi ho·∫∑c h∆∞·ªõng kh√¥ng h·ª£p l·ªá)

        if new_index != -1:
            try:
                # L·∫•y t√°c v·ª• c·∫ßn di chuy·ªÉn ra kh·ªèi danh s√°ch
                item_to_move = self.dub_processing_queue.pop(current_index)
                # Ch√®n t√°c v·ª• ƒë√≥ v√†o v·ªã tr√≠ m·ªõi
                self.dub_processing_queue.insert(new_index, item_to_move)
                
                item_name = item_to_move.get('video_display_name', task_id_to_move) # L·∫•y t√™n video ƒë·ªÉ log
                logging.info(f"[DubbingQueue] ƒê√£ di chuy·ªÉn t√°c v·ª• '{item_name}' t·ª´ v·ªã tr√≠ {current_index} sang {new_index}.")
                
                self.update_dub_queue_display() # C·∫≠p nh·∫≠t giao di·ªán h√†ng ch·ªù
                self.update_status(f"ƒê√£ c·∫≠p nh·∫≠t th·ª© t·ª± h√†ng ch·ªù thuy·∫øt minh.")
                self._update_dub_start_batch_button_state()
            except IndexError:
                logging.error(f"[DubbingQueue] L·ªói IndexError khi di chuy·ªÉn t√°c v·ª•. Index: {current_index}, New Index: {new_index}")
            except Exception as e:
                logging.error(f"[DubbingQueue] L·ªói kh√¥ng x√°c ƒë·ªãnh khi di chuy·ªÉn t√°c v·ª•: {e}", exc_info=True)
                messagebox.showerror("L·ªói S·∫Øp x·∫øp H√†ng ch·ªù", f"ƒê√£ x·∫£y ra l·ªói khi s·∫Øp x·∫øp l·∫°i h√†ng ch·ªù:\n{e}", parent=self)


# H√†m h√†nh ƒë·ªông: Cho ph√©p ch·ªânh s·ª≠a textbox k·ªãch b·∫£n thuy·∫øt minh
    def dub_enable_script_editing(self):
        if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
            self.dub_script_textbox.configure(state="normal")
            self.update_status("Thuy·∫øt minh: ƒêang s·ª≠a k·ªãch b·∫£n...")
            logging.info("[Dubbing] ƒê√£ b·∫≠t ch·∫ø ƒë·ªô s·ª≠a k·ªãch b·∫£n thuy·∫øt minh.")
        else:
            logging.warning("[Dubbing] Kh√¥ng t√¨m th·∫•y dub_script_textbox ƒë·ªÉ b·∫≠t ch·∫ø ƒë·ªô s·ª≠a.")


# H√†m h√†nh ƒë·ªông: L∆∞u n·ªôi dung t·ª´ textbox k·ªãch b·∫£n thuy·∫øt minh ra file
    def dub_save_script_from_textbox(self):
        if not hasattr(self, 'dub_script_textbox') or not self.dub_script_textbox or not self.dub_script_textbox.winfo_exists():
            messagebox.showerror("L·ªói UI", "Textbox k·ªãch b·∫£n kh√¥ng t·ªìn t·∫°i.", parent=self)
            return
        
        script_content = self.dub_script_textbox.get("1.0", "end-1c")
        if not script_content.strip():
            messagebox.showinfo("N·ªôi dung r·ªóng", "Kh√¥ng c√≥ n·ªôi dung k·ªãch b·∫£n ƒë·ªÉ l∆∞u.", parent=self)
            return

        # G·ª£i √Ω th∆∞ m·ª•c l∆∞u d·ª±a tr√™n th∆∞ m·ª•c output c·ªßa tab dubbing ho·∫∑c th∆∞ m·ª•c l√†m vi·ªác hi·ªán t·∫°i
        initial_save_dir = self.dub_output_path_var.get() or os.getcwd()
        
        # N·∫øu c√≥ file script ƒëang ƒë∆∞·ª£c ch·ªçn (self.dub_current_script_path_for_queue_temp),
        # g·ª£i √Ω l∆∞u ƒë√® l√™n file ƒë√≥.
        initial_save_file = ""
        if self.dub_current_script_path_for_queue_temp and os.path.exists(self.dub_current_script_path_for_queue_temp):
            initial_save_dir = os.path.dirname(self.dub_current_script_path_for_queue_temp)
            initial_save_file = os.path.basename(self.dub_current_script_path_for_queue_temp)

        save_path = filedialog.asksaveasfilename(
            title="L∆∞u file K·ªãch b·∫£n SRT Thuy·∫øt Minh",
            defaultextension=".srt",
            filetypes=[("SRT files", "*.srt"), ("All files", "*.*")],
            initialdir=initial_save_dir,
            initialfile=initial_save_file, # G·ª£i √Ω t√™n file ƒë√£ ch·ªçn (n·∫øu c√≥)
            parent=self
        )
        
        if not save_path:
            self.update_status("ƒê√£ h·ªßy l∆∞u file k·ªãch b·∫£n thuy·∫øt minh.")
            return

        try:
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(script_content)

            self.dub_current_script_path_for_queue_temp = save_path
            self.dub_current_script_for_queue_display.set(os.path.basename(save_path))

            self.update_status(f"üíæ ƒê√£ l∆∞u k·ªãch b·∫£n thuy·∫øt minh: {os.path.basename(save_path)}")
            logging.info(f"[Dubbing] ƒê√£ l∆∞u n·ªôi dung k·ªãch b·∫£n thuy·∫øt minh t·ª´ textbox v√†o: {save_path}")
            messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ l∆∞u k·ªãch b·∫£n v√†o:\n{save_path}", parent=self)
            
            # T√πy ch·ªçn: ƒë·∫∑t l·∫°i textbox v·ªÅ state="disabled" sau khi l∆∞u
            # self.dub_script_textbox.configure(state="disabled")
            
        except Exception as e:
            logging.error(f"[Dubbing] L·ªói khi l∆∞u file k·ªãch b·∫£n thuy·∫øt minh '{save_path}': {e}", exc_info=True)
            messagebox.showerror("L·ªói L∆∞u File", f"Kh√¥ng th·ªÉ l∆∞u file k·ªãch b·∫£n:\n{save_path}\n\nL·ªói: {e}", parent=self)
            self.update_status(f"‚ùå L·ªói l∆∞u k·ªãch b·∫£n thuy·∫øt minh: {os.path.basename(save_path)}")


# H√†m c·∫≠p nh·∫≠t n√∫t m·ªôt c√°ch t·∫≠p trung
    def _update_dub_script_controls_state(self):
        """
        Tr·∫°ng th√°i n√∫t panel ph·∫£i trong tab Thuy·∫øt Minh.
        - CH∆ØA k√≠ch ho·∫°t: kh√≥a to√†n b·ªô (gi·ªØ text 'üîí K√≠ch ho·∫°t').
        - ƒê√É k√≠ch ho·∫°t: b·∫≠t lu√¥n 4 n√∫t (S·ª≠a/L∆∞u/Nghe th·ª≠/L∆∞u Audio) n·∫øu KH√îNG b·∫≠n; 
          kh√¥ng c√≤n ph·ª• thu·ªôc n·ªôi dung script ƒë·ªÉ tr√°nh flicker.
        - Textbox k·ªãch b·∫£n: m·ªü khi kh√¥ng b·∫≠n; kh√≥a khi ƒëang b·∫≠n.
        - N√∫t 'üé¨ Video/·∫¢nh...': m·ªü khi ƒë√£ k√≠ch ho·∫°t & kh√¥ng batch; kh√≥a khi batch.
        """
        import os

        # --- tr·∫°ng th√°i k√≠ch ho·∫°t ---
        try:
            is_active = self._is_app_fully_activated()
        except Exception:
            is_active = False

        # tham chi·∫øu widget
        btn_edit   = getattr(self, 'dub_btn_edit_script', None)
        btn_save   = getattr(self, 'dub_btn_save_script', None)
        btn_prev   = getattr(self, 'dub_preview_button', None)
        btn_audio  = getattr(self, 'dub_btn_save_audio_from_text', None)
        tb         = getattr(self, 'dub_script_textbox', None)
        btn_video  = getattr(self, 'dub_load_video_button', None)

        # --- CH∆ØA k√≠ch ho·∫°t -> kh√≥a v√† tho√°t ---
        if not is_active:
            for w in (btn_edit, btn_save, btn_prev, btn_audio, btn_video):
                if w and hasattr(w, 'configure') and w.winfo_exists():
                    try:
                        w.configure(state=ctk.DISABLED, text="üîí K√≠ch ho·∫°t")
                    except Exception:
                        pass
            if tb and hasattr(tb, 'configure') and tb.winfo_exists():
                try:
                    tb.configure(state=ctk.DISABLED)
                except Exception:
                    pass
            if hasattr(self, '_update_dub_start_batch_button_state'):
                self._update_dub_start_batch_button_state()
            return

        # --- ƒê√É k√≠ch ho·∫°t: x√°c ƒë·ªãnh 'ƒëang b·∫≠n' ---
        is_batch   = bool(getattr(self, 'dub_is_processing', False))
        is_gpt     = bool(getattr(self, 'is_gpt_processing_script', False))
        is_dalle   = bool(getattr(self, 'is_dalle_processing', False))
        is_preview = bool(getattr(self, 'is_performing_single_task', False))
        is_busy    = is_batch or is_gpt or is_dalle or is_preview

        # Textbox: m·ªü khi kh√¥ng b·∫≠n
        if tb and tb.winfo_exists():
            try:
                tb.configure(state=(ctk.NORMAL if not is_busy else ctk.DISABLED))
            except Exception:
                pass

        # Reset text m·∫∑c ƒë·ªãnh n·∫øu c√≤n "üîí K√≠ch ho·∫°t"
        def _reset_text(w, default_text):
            if w and hasattr(w, 'configure') and hasattr(w, 'cget') and w.winfo_exists():
                try:
                    if w.cget("text") == "üîí K√≠ch ho·∫°t":
                        w.configure(text=default_text)
                except Exception:
                    pass

        _reset_text(btn_edit,  "‚úç S·ª≠a Script")
        _reset_text(btn_save,  "üíæ L∆∞u Script")
        _reset_text(btn_prev,  "üîä Nghe th·ª≠ Script")
        _reset_text(btn_audio, "üíæ L∆∞u Audio")

        # üîÜ B·∫¨T LU√îN 4 N√öT khi ƒë√£ k√≠ch ho·∫°t (mi·ªÖn l√† kh√¥ng b·∫≠n)
        state_btn = ctk.NORMAL if not is_busy else ctk.DISABLED
        if btn_edit  and btn_edit.winfo_exists():   btn_edit.configure(state=state_btn)
        if btn_save  and btn_save.winfo_exists():   btn_save.configure(state=state_btn)
        if btn_prev  and btn_prev.winfo_exists():   btn_prev.configure(state=state_btn)
        if btn_audio and btn_audio.winfo_exists():  btn_audio.configure(state=state_btn)

        # N√∫t 'üé¨ Video/·∫¢nh...': m·ªü khi kh√¥ng batch (ƒë√£ k√≠ch ho·∫°t)
        if btn_video and btn_video.winfo_exists():
            btn_video.configure(
                state=(ctk.DISABLED if is_batch else ctk.NORMAL),
                text="üé¨ Video/·∫¢nh..."
            )

        logging.debug("[DubbingUI] update script controls: active=%s, busy=%s", is_active, is_busy)

        # ƒê·ªìng b·ªô n√∫t Start theo ƒëi·ªÅu ki·ªán m·ªõi
        self._update_dub_start_batch_button_state()


# H√†m n√†y s·∫Ω nh·∫≠n ƒë·∫ßu v√†o l√† m·ªôt chu·ªói vƒÉn b·∫£n (m·ªôt d√≤ng ho·∫∑c m·ªôt ƒëo·∫°n nh·ªè) v√† tr·∫£ v·ªÅ th·ªùi gian ∆∞·ªõc l∆∞·ª£ng (t√≠nh b·∫±ng gi√¢y) ƒë·ªÉ ƒë·ªçc chu·ªói ƒë√≥. 
    DEFAULT_CHARACTERS_PER_SECOND = 12 # K√Ω t·ª± m·ªói gi√¢y

    def _estimate_reading_time_for_text(self, text_block: str) -> float:
        """
        ∆Ø·ªõc l∆∞·ª£ng th·ªùi gian ƒë·ªçc (b·∫±ng gi√¢y) cho m·ªôt kh·ªëi vƒÉn b·∫£n.

        Args:
            text_block (str): Kh·ªëi vƒÉn b·∫£n c·∫ßn ∆∞·ªõc l∆∞·ª£ng.

        Returns:
            float: Th·ªùi gian ∆∞·ªõc l∆∞·ª£ng ƒë·ªÉ ƒë·ªçc vƒÉn b·∫£n, t√≠nh b·∫±ng gi√¢y.
        """
        if not text_block:
            return 0.0

        char_count = len(text_block)


        try:
            if hasattr(self, 'app_settings') and 'reading_speed_cps' in self.app_settings:
                 # ƒê·∫£m b·∫£o gi√° tr·ªã ƒë·ªçc ƒë∆∞·ª£c l√† s·ªë h·ª£p l·ªá
                configured_cps = float(self.app_settings.get('reading_speed_cps', self.DEFAULT_CHARACTERS_PER_SECOND))
                cps = configured_cps if configured_cps > 0 else self.DEFAULT_CHARACTERS_PER_SECOND
            else:
                cps = self.DEFAULT_CHARACTERS_PER_SECOND
        except (ValueError, TypeError): # B·∫Øt l·ªói n·∫øu gi√° tr·ªã config kh√¥ng h·ª£p l·ªá
            cps = self.DEFAULT_CHARACTERS_PER_SECOND
        except AttributeError: # B·∫Øt l·ªói n·∫øu self.app_settings ch∆∞a t·ªìn t·∫°i
            cps = self.DEFAULT_CHARACTERS_PER_SECOND


        if cps == 0: # Tr√°nh l·ªói chia cho 0
            return 0.0 if char_count == 0 else 60.0 # N·∫øu cps l√† 0, tr·∫£ v·ªÅ 0 n·∫øu kh√¥ng c√≥ text, ho·∫∑c m·ªôt gi√° tr·ªã l·ªõn n·∫øu c√≥ text

        seconds = char_count / cps
        return seconds


# ƒê·∫£m b·∫£o h√†m _estimate_reading_time_for_text ƒë√£ ƒë∆∞·ª£c th√™m v√†o
# c√≥ th·ªÉ th√™m m·ªôt h·∫±ng s·ªë cho kho·∫£ng ngh·ªâ gi·ªØa c√°c d√≤ng ph·ª• ƒë·ªÅ (n·∫øu mu·ªën)
    DEFAULT_PAUSE_BETWEEN_SEGMENTS = 0.2  # gi√¢y (t√πy ch·ªçn)

    def _generate_timed_segments_from_text(self, plain_text: str) -> list[dict]:
        """
        Chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n thu·∫ßn th√†nh danh s√°ch c√°c ƒëo·∫°n c√≥ th√¥ng tin th·ªùi gian.
        M·ªói ƒëo·∫°n l√† m·ªôt dictionary ch·ª©a 'start' (timedelta), 'end' (timedelta), 'content' (str).

        Args:
            plain_text (str): VƒÉn b·∫£n thu·∫ßn c·∫ßn x·ª≠ l√Ω.

        Returns:
            list[dict]: Danh s√°ch c√°c dictionary, m·ªói dict ƒë·∫°i di·ªán cho m·ªôt ƒëo·∫°n ph·ª• ƒë·ªÅ
                        v·ªõi th·ªùi gian v√† n·ªôi dung. V√≠ d·ª•:
                        [
                            {'start': timedelta(seconds=0.0), 'end': timedelta(seconds=2.5), 'content': 'D√≤ng ƒë·∫ßu ti√™n.'},
                            {'start': timedelta(seconds=2.7), 'end': timedelta(seconds=5.0), 'content': 'D√≤ng th·ª© hai.'}
                        ]
        """
        timed_segments = []
        if not plain_text:
            return timed_segments

        raw_lines = plain_text.strip().split('\n')
        text_lines = [line.strip() for line in raw_lines if line.strip()] # L·ªçc b·ªè d√≤ng tr·ªëng

        if not text_lines:
            return timed_segments

        current_time_seconds = 0.0
        
        # L·∫•y kho·∫£ng ngh·ªâ t·ª´ config n·∫øu c√≥
        try:
            if hasattr(self, 'app_settings') and 'pause_between_segments' in self.app_settings:
                pause_duration = float(self.app_settings.get('pause_between_segments', self.DEFAULT_PAUSE_BETWEEN_SEGMENTS))
                pause_duration = pause_duration if pause_duration >= 0 else self.DEFAULT_PAUSE_BETWEEN_SEGMENTS
            else:
                pause_duration = self.DEFAULT_PAUSE_BETWEEN_SEGMENTS
        except (ValueError, TypeError, AttributeError):
            pause_duration = self.DEFAULT_PAUSE_BETWEEN_SEGMENTS


        for i, line_content in enumerate(text_lines):
            estimated_duration_seconds = self._estimate_reading_time_for_text(line_content)

            # B·ªè qua c√°c d√≤ng kh√¥ng c√≥ th·ªùi gian ƒë·ªçc (v√≠ d·ª•: d√≤ng r·∫•t ng·∫Øn ho·∫∑c ch·ªâ c√≥ k√Ω t·ª± ƒë·∫∑c bi·ªát)
            # Ho·∫∑c g√°n m·ªôt th·ªùi gian t·ªëi thi·ªÉu n·∫øu c·∫ßn
            if estimated_duration_seconds <= 0:
                # logging.debug(f"B·ªè qua d√≤ng kh√¥ng c√≥ th·ªùi gian ƒë·ªçc: '{line_content}'")
                continue

            start_time = timedelta(seconds=current_time_seconds)
            end_time = timedelta(seconds=current_time_seconds + estimated_duration_seconds)

            timed_segments.append({
                'start_time': start_time, # S·ª≠ d·ª•ng 'start_time' v√† 'end_time' cho nh·∫•t qu√°n
                'end_time': end_time,     # v·ªõi c√°c h√†m x·ª≠ l√Ω SRT hi·ªán t·∫°i (n·∫øu c√≥)
                'content': line_content
            })

            # C·∫≠p nh·∫≠t th·ªùi gian hi·ªán t·∫°i cho d√≤ng ti·∫øp theo
            current_time_seconds += estimated_duration_seconds
            
            # Th√™m kho·∫£ng ngh·ªâ sau m·ªói d√≤ng (tr·ª´ d√≤ng cu·ªëi c√πng n·∫øu kh√¥ng mu·ªën)
            if i < len(text_lines) - 1: # Kh√¥ng th√™m pause sau d√≤ng cu·ªëi c√πng
                current_time_seconds += pause_duration


        return timed_segments



# H√†m ph√¢n t√≠ch vƒÉn b·∫£n thu·∫ßn t·ª´ textbox th√†nh c·∫•u tr√∫c d·ªØ li·ªáu
    def _parse_plain_text_to_srt_data(self, text_content, force_plain_text_processing=False, split_config_override=None):
        """
        Ph√¢n t√≠ch vƒÉn b·∫£n th√†nh c·∫•u tr√∫c d·ªØ li·ªáu gi·ªëng SRT.
        force_plain_text_processing: N·∫øu True, b·ªè qua parse SRT v√† x·ª≠ l√Ω nh∆∞ plain text.
        split_config_override: Dictionary ch·ª©a c√°c c√†i ƒë·∫∑t chia d√≤ng v√† timing t·ª´ UI.
        """
        parsed_blocks = []
        text_content_stripped = text_content.strip()
        if not text_content_stripped:
            logging.debug("[DubParseText] N·ªôi dung vƒÉn b·∫£n r·ªóng, kh√¥ng c√≥ g√¨ ƒë·ªÉ parse.")
            return parsed_blocks

        attempt_srt_parse = not force_plain_text_processing

        if attempt_srt_parse:
            try:
                srt_block_pattern = re.compile(
                    r"(\d+)\s*[\r\n]+"
                    r"(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*[\r\n]+"
                    r"((?:.|\n|\r)*?)"
                    r"(?=\n\s*\n\d+\s*[\r\n]+|\n\d+\s*[\r\n]+\d{2}:\d{2}:\d{2}[,.]\d{3}|\Z)",
                    re.MULTILINE
                )
                matches = list(srt_block_pattern.finditer(text_content_stripped))
                if matches:
                    logging.info(f"[DubParseText] Ph√°t hi·ªán {len(matches)} kh·ªëi gi·ªëng SRT, ƒëang parse...")
                    for i, match in enumerate(matches):
                        index_str, start_tc_str, end_tc_str, text_raw = match.groups()
                        start_tc_str_clean = start_tc_str.replace('.', ',')
                        end_tc_str_clean = end_tc_str.replace('.', ',')
                        text_clean = re.sub(r'<[^>]+>', '', text_raw.strip())
                        text_clean = "\n".join([line.strip() for line in text_clean.splitlines() if line.strip()]).strip()
                        if not text_clean:
                            continue
                        try:
                            start_ms = parse_timecode(start_tc_str_clean)
                            end_ms = parse_timecode(end_tc_str_clean)
                        except Exception as e_tc:
                            logging.warning(f"[DubParseText] L·ªói parse timecode cho kh·ªëi SRT (index {index_str}) t·ª´ input: {e_tc}. B·ªè qua kh·ªëi n√†y.")
                            continue
                        if end_ms <= start_ms:
                            logging.warning(f"[DubParseText] B·ªè qua kh·ªëi SRT (index {index_str}) t·ª´ input do timing kh√¥ng h·ª£p l·ªá: {start_tc_str_clean} --> {end_tc_str_clean}")
                            continue
                        parsed_blocks.append({
                            "index": int(index_str),
                            "start_str": start_tc_str_clean, "end_str": end_tc_str_clean,
                            "start_ms": start_ms, "end_ms": end_ms,
                            "text": text_clean
                        })
                    if parsed_blocks:
                        logging.info(f"[DubParseText] Parse th√†nh c√¥ng {len(parsed_blocks)} kh·ªëi SRT.")
                        return parsed_blocks
                    else:
                        logging.warning("[DubParseText] ƒê√£ t√¨m th·∫•y match SRT nh∆∞ng kh√¥ng parse ƒë∆∞·ª£c kh·ªëi h·ª£p l·ªá n√†o. S·∫Ω x·ª≠ l√Ω nh∆∞ plain text.")
                else:
                    logging.info("[DubParseText] Kh√¥ng t√¨m th·∫•y pattern SRT n√†o. S·∫Ω x·ª≠ l√Ω nh∆∞ plain text.")
            except Exception as e_parse_srt_text:
                logging.warning(f"[DubParseText] L·ªói khi c·ªë parse nh∆∞ SRT: {e_parse_srt_text}. S·∫Ω x·ª≠ l√Ω nh∆∞ plain text.")

        # --- LOGIC X·ª¨ L√ù PLAIN TEXT ---
        logging.info(f"[DubParseText] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω nh∆∞ plain text. Force mode: {force_plain_text_processing}")
        if split_config_override:
            logging.debug(f"[DubParseText] S·ª≠ d·ª•ng split_config_override: {json.dumps(split_config_override, ensure_ascii=False)}")

        split_enabled_cfg = False
        split_mode_cfg = "char"
        max_chars_cfg = 90
        max_lines_cfg = 1
        cps_for_timing = 17
        pause_ms_for_timing = 200
        min_duration_ms_cfg = 1000

        if split_config_override and isinstance(split_config_override, dict):
            split_enabled_cfg = split_config_override.get("split_enabled", False)
            split_mode_cfg = split_config_override.get("mode", "char")
            max_chars_cfg = split_config_override.get("max_chars", 90)
            max_lines_cfg = split_config_override.get("max_lines", 1)
            cps_for_timing = split_config_override.get("DEFAULT_CPS_FOR_TIMING", 17)
            pause_ms_for_timing = split_config_override.get("PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING", 1)
            min_duration_ms_cfg = split_config_override.get("ABSOLUTE_MIN_DURATION_PER_CHUNK_MS", self.min_duration_per_segment_ms)

        final_text_chunks_for_timing = []

        if force_plain_text_processing and split_enabled_cfg:
            logging.info(f"[DubParseText] √Åp d·ª•ng chia d√≤ng n√¢ng cao: mode={split_mode_cfg}, max_chars={max_chars_cfg}, max_lines={max_lines_cfg}")
            
            candidate_lines = []
            normalized_text_for_splitting = ' '.join(text_content_stripped.split())

            if split_mode_cfg == "underthesea (Ti·∫øng Vi·ªát)" and HAS_UNDERTHESEA and callable(sent_tokenize):
                try:
                    candidate_lines = sent_tokenize(normalized_text_for_splitting)
                    logging.debug(f"[DubParseText] Underthesea t√°ch ƒë∆∞·ª£c: {candidate_lines}")
                except Exception as e_uts:
                    logging.error(f"[DubParseText] L·ªói underthesea: {e_uts}. Fallback v·ªÅ t√°ch theo ƒëo·∫°n.")
                    candidate_lines = [para.strip() for para in text_content_stripped.split('\n\n') if para.strip()]
            elif split_mode_cfg == "sentence":
                titles_plain = ["Mr", "Ms", "Mrs", "Dr", "Prof", "Rev", "Gen", "Sen", "Rep", "St", "ThS", "TS", "PGS", "GS", "BS", "KS", "CN", "C√¥", "Th·∫ßy", "Cha", "S∆∞", "√îng", "B√†", "No", "Nos", "Art", "vs", "etc", "Co", "Corp", "Inc", "Ltd", "eg", "ie", "viz", "cf", "et al"]
                escaped_titles = [re.escape(title) for title in titles_plain]
                titles_pattern_for_lookbehind = "|".join(escaped_titles)
                delimiter_regex_str = (
                    r"[?!‚Ä¶](?=\s|$)|"
                    r"(?<!\b(?:{titles_pattern_for_lookbehind}))"
                    r"(?<!\b[A-Z])" 
                    r"\."   
                    r"(?!\d)"  
                    r"(?![a-z])" 
                    r"(?=\s|$)" 
                )
                sentence_parts = re.split(f'({delimiter_regex_str})', normalized_text_for_splitting)
                current_sentence_buffer = ""
                if sentence_parts:
                    for i, part in enumerate(sentence_parts):
                        if part is None: continue
                        current_sentence_buffer += part
                        is_delimiter_captured_and_valid = (i % 2 == 1 and part.strip())
                        is_last_part_of_split = (i == len(sentence_parts) - 1)
                        if is_delimiter_captured_and_valid or is_last_part_of_split:
                            trimmed_sentence = current_sentence_buffer.strip()
                            if trimmed_sentence: candidate_lines.append(trimmed_sentence)
                            current_sentence_buffer = ""
                if not candidate_lines and normalized_text_for_splitting:
                    candidate_lines = [normalized_text_for_splitting]
                logging.debug(f"[DubParseText] Sentence regex t√°ch ƒë∆∞·ª£c: {candidate_lines}")
            else: 
                candidate_lines = [para.strip() for para in text_content_stripped.split('\n\n') if para.strip()]
                if not candidate_lines and text_content_stripped: 
                     candidate_lines = [text_content_stripped]
                logging.debug(f"[DubParseText] Ch·∫ø ƒë·ªô 'char' ho·∫∑c fallback, candidate_lines (t√°ch theo ƒëo·∫°n): {candidate_lines}")
            
            all_wrapped_lines_for_chunks = []
            
            if split_mode_cfg in ["underthesea (Ti·∫øng Vi·ªát)", "sentence"] and max_chars_cfg <= 0:
                logging.info(f"[DubParseText] Ch·∫ø ƒë·ªô '{split_mode_cfg}' v√† max_chars <= 0. B·ªè qua textwrap, d√πng tr·ª±c ti·∫øp c√¢u ƒë√£ t√°ch.")
                all_wrapped_lines_for_chunks = [line.strip() for line in candidate_lines if line.strip()]
            
            else: 
                logging.info(f"[DubParseText] √Åp d·ª•ng textwrap. Ch·∫ø ƒë·ªô: '{split_mode_cfg}', max_chars_cfg: {max_chars_cfg}")
                effective_max_chars_for_textwrap = max_chars_cfg
                if max_chars_cfg <= 0:
                    logging.warning(f"[DubParseText] Gi√° tr·ªã max_chars_cfg ({max_chars_cfg}) kh√¥ng h·ª£p l·ªá cho textwrap. S·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh l√† 42.")
                    effective_max_chars_for_textwrap = 45

                for cand_line in candidate_lines:
                    if not cand_line.strip(): continue
                    wrapped_lines = textwrap.wrap(cand_line, width=effective_max_chars_for_textwrap,
                                                  break_long_words=True, replace_whitespace=False,
                                                  drop_whitespace=True, break_on_hyphens=True)
                    all_wrapped_lines_for_chunks.extend([wl.strip() for wl in wrapped_lines if wl.strip()])
            
            logging.debug(f"[DubParseText] C√°c d√≤ng con cu·ªëi c√πng tr∆∞·ªõc khi g·ªôp th√†nh chunk: {all_wrapped_lines_for_chunks}")
            
            current_chunk_build = []
            for line_wr in all_wrapped_lines_for_chunks:
                if len(current_chunk_build) < max_lines_cfg:
                    current_chunk_build.append(line_wr)
                else:
                    final_text_chunks_for_timing.append("\n".join(current_chunk_build))
                    current_chunk_build = [line_wr]
            if current_chunk_build:
                final_text_chunks_for_timing.append("\n".join(current_chunk_build))
            
            if not final_text_chunks_for_timing and text_content_stripped:
                final_text_chunks_for_timing = [text_content_stripped]
            logging.debug(f"[DubParseText] C√°c chunks cu·ªëi c√πng ƒë·ªÉ t√≠nh timing: {final_text_chunks_for_timing}")

        else: 
            logging.info("[DubParseText] S·ª≠ d·ª•ng logic t√°ch segment plain text ƒë∆°n gi·∫£n (theo d√≤ng tr·ªëng ho·∫∑c t·ª´ng d√≤ng).")
            segments_raw_by_double_newline = text_content_stripped.split('\n\n')
            for seg_para in segments_raw_by_double_newline:
                seg_para_stripped = seg_para.strip()
                if seg_para_stripped:
                    lines_in_para = [line.strip() for line in seg_para_stripped.split('\n') if line.strip()]
                    if lines_in_para:
                        final_text_chunks_for_timing.extend(lines_in_para)
            
            if not final_text_chunks_for_timing and text_content_stripped:
                final_text_chunks_for_timing = [text_content_stripped]

        if not final_text_chunks_for_timing:
            logging.warning("[DubParseText] Kh√¥ng c√≥ text chunks n√†o ƒë·ªÉ ∆∞·ªõc l∆∞·ª£ng th·ªùi gian.")
            return []

        # <<< B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI: ƒê·ªåC GI√Å TR·ªä T·ª™ C√ÅC BI·∫æN M·ªöI >>>
        logging.info(f"[DubParseText] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω nh∆∞ plain text (ƒê√£ n√¢ng c·∫•p logic ng·∫Øt ngh·ªâ chi ti·∫øt).")
        try:
            # ƒê·ªçc gi√° tr·ªã t·ª´ c√°c bi·∫øn giao di·ªán, s·ª≠ d·ª•ng safe_int ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n
            pause_period = safe_int(self.sub_pacing_pause_period_ms_var.get(), 300)
            pause_question = safe_int(self.sub_pacing_pause_question_ms_var.get(), 450)
            pause_medium = safe_int(self.sub_pacing_pause_medium_ms_var.get(), 150)
        except AttributeError:
            # Fallback n·∫øu c√°c bi·∫øn ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o (tr∆∞·ªùng h·ª£p hi·∫øm)
            logging.warning("[DubParseText] Kh√¥ng t√¨m th·∫•y bi·∫øn StringVar cho nh·ªãp ƒëi·ªáu, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh.")
            pause_period = 300
            pause_question = 450
            pause_medium = 150
        # <<< K·∫æT TH√öC THAY ƒê·ªîI >>>

        current_time_ms_plain = 0
        for i, chunk_text_content in enumerate(final_text_chunks_for_timing):
            if not chunk_text_content.strip():
                continue
            
            duration_ms_chunk = self._calculate_weighted_duration_ms(
                text_chunk=chunk_text_content,
                cps=cps_for_timing,
                min_duration_ms=min_duration_ms_cfg
            )
            
            start_ms_plain = current_time_ms_plain
            end_ms_plain = current_time_ms_plain + duration_ms_chunk

            parsed_blocks.append({
                "index": i + 1,
                "start_str": ms_to_tc(start_ms_plain),
                "end_str": ms_to_tc(end_ms_plain),
                "start_ms": start_ms_plain,
                "end_ms": end_ms_plain,
                "text": chunk_text_content
            })

            # <<< B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI: S·ª¨ D·ª§NG C√ÅC BI·∫æN PAUSE M·ªöI >>>
            pause_to_add_ms = 0 # M·∫∑c ƒë·ªãnh kh√¥ng ngh·ªâ
            text_for_check = chunk_text_content.strip().rstrip("\"'‚Äù‚Äô")
            if text_for_check:
                last_char = text_for_check[-1]
                if last_char in ['.', '‚Ä¶']:
                    pause_to_add_ms = pause_period
                elif last_char in ['?', '!']:
                    pause_to_add_ms = pause_question
                elif last_char in [',', ';', ':']:
                    pause_to_add_ms = pause_medium
            # <<< K·∫æT TH√öC THAY ƒê·ªîI >>>

            current_time_ms_plain = end_ms_plain + pause_to_add_ms
        
        if parsed_blocks:
             logging.info(f"[DubParseText] Parse plain text th√†nh c√¥ng, t·∫°o {len(parsed_blocks)} kh·ªëi (Force: {force_plain_text_processing}, SplitEnabledConfig: {split_enabled_cfg}).")
        return parsed_blocks


#---------------------

# Nh·∫≠n m·ªôt danh s√°ch c√°c ƒëo·∫°n k·ªãch b·∫£n v√† tr·∫£ v·ªÅ m·ªôt danh s√°ch th·ªùi l∆∞·ª£ng t∆∞∆°ng ·ª©ng        
    def _calculate_durations_for_scenes(self, scene_scripts: list[str]) -> list[float]:
        """
        (PHI√äN B·∫¢N 3 - S·ª¨A L·ªñI KI·ªÇU D·ªÆ LI·ªÜU)
        Nh·∫≠n m·ªôt danh s√°ch c√°c ƒëo·∫°n k·ªãch b·∫£n v√† tr·∫£ v·ªÅ m·ªôt danh s√°ch
        th·ªùi l∆∞·ª£ng t∆∞∆°ng ·ª©ng (t√≠nh b·∫±ng gi√¢y), ƒë·∫£m b·∫£o ki·ªÉu d·ªØ li·ªáu l√† float.
        """
        log_prefix_calc = f"[{threading.current_thread().name}_CalculateDurations_v3]"
        if not scene_scripts:
            return []

        durations_in_seconds = []

        timing_config = {
            "split_enabled": self.enable_split_var.get(),
            "mode": self.split_mode_var.get(),
            "max_chars": safe_int(self.max_chars_var.get(), 90),
            "max_lines": safe_int(self.max_lines_var.get(), 4),
            "DEFAULT_CPS_FOR_TIMING": safe_int(self.sub_cps_for_timing_var.get(), 17),
            "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1,
            "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
        }

        logging.info(f"{log_prefix_calc} B·∫Øt ƒë·∫ßu t√≠nh th·ªùi l∆∞·ª£ng cho {len(scene_scripts)} c·∫£nh ri√™ng l·∫ª.")

        for i, scene_text in enumerate(scene_scripts):
            if not scene_text.strip():
                durations_in_seconds.append(1.5) 
                logging.warning(f"{log_prefix_calc} C·∫£nh #{i+1} r·ªóng, g√°n th·ªùi l∆∞·ª£ng m·∫∑c ƒë·ªãnh 1.5s.")
                continue

            timed_segments = self._parse_plain_text_to_srt_data(
                scene_text, True, timing_config
            )

            if timed_segments:
                total_duration_ms_for_scene = 0
                for segment in timed_segments:
                    duration_ms = float(segment.get('end_ms', 0)) - float(segment.get('start_ms', 0)) # Chuy·ªÉn sang float
                    total_duration_ms_for_scene += duration_ms

                # <<< THAY ƒê·ªîI ·ªû ƒê√ÇY: ƒê·∫£m b·∫£o append float >>>
                durations_in_seconds.append(max(0.1, total_duration_ms_for_scene / 1000.0))
            else:
                fallback_duration = max(1.5, len(scene_text) / float(timing_config["DEFAULT_CPS_FOR_TIMING"])) # Chuy·ªÉn sang float
                durations_in_seconds.append(fallback_duration)
                logging.warning(f"{log_prefix_calc} Kh√¥ng parse ƒë∆∞·ª£c segment cho c·∫£nh #{i+1}. Fallback v·ªÅ: {fallback_duration:.2f}s")

        # Log k·∫øt qu·∫£ ƒë√£ ƒë∆∞·ª£c l√†m tr√≤n ƒë·ªÉ d·ªÖ ƒë·ªçc
        logging.info(f"ƒê√£ t√≠nh to√°n ƒë∆∞·ª£c {len(durations_in_seconds)} th·ªùi l∆∞·ª£ng cho c√°c c·∫£nh: {[f'{d:.3f}' for d in durations_in_seconds]}")

        return durations_in_seconds



# H√†m n√†y s·∫Ω l√† trung t√¢m c·ªßa logic chuy·ªÉn ƒë·ªïi khi checkbox ƒë∆∞·ª£c b·∫≠t.
    def _convert_textbox_to_srt_if_needed(self):
        """
        Ki·ªÉm tra checkbox v√† chuy·ªÉn ƒë·ªïi n·ªôi dung textbox sang SRT n·∫øu c·∫ßn.
        ƒê∆∞·ª£c g·ªçi sau khi d√°n ho·∫∑c b·ªüi c√°c h√†nh ƒë·ªông kh√°c.
        """
        # Ch·ªâ th·ª±c hi·ªán n·∫øu checkbox ƒë∆∞·ª£c tick v√† textbox t·ªìn t·∫°i
        subtitle_textbox = getattr(self.subtitle_view_frame, 'subtitle_textbox', None) if hasattr(self, 'subtitle_view_frame') else None
        if not (hasattr(self, 'auto_format_plain_text_to_srt_var') and \
                self.auto_format_plain_text_to_srt_var.get() and \
                subtitle_textbox and subtitle_textbox.winfo_exists()):
            return

        plain_text_content = subtitle_textbox.get("1.0", "end-1c").strip()

        if not plain_text_content:
            logging.debug("[AutoFormatSRT] Textbox r·ªóng, kh√¥ng chuy·ªÉn ƒë·ªïi.")
            return

        # Ki·ªÉm tra nhanh xem n·ªôi dung c√≥ v·∫ª ƒë√£ l√† SRT ch∆∞a (ƒë·ªÉ tr√°nh x·ª≠ l√Ω l·∫°i)
        # Pattern n√†y c√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh cho ch√≠nh x√°c h∆°n n·∫øu c·∫ßn
        srt_quick_check_pattern = r"^\d+\s*[\r\n]+\d{2}:\d{2}:\d{2}[,.]\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}[,.]\d{3}"
        if re.match(srt_quick_check_pattern, plain_text_content, re.MULTILINE):
            logging.info("[AutoFormatSRT] N·ªôi dung textbox c√≥ v·∫ª ƒë√£ l√† ƒë·ªãnh d·∫°ng SRT. B·ªè qua t·ª± ƒë·ªông chuy·ªÉn ƒë·ªïi.")
            return

        logging.info("[AutoFormatSRT] B·∫Øt ƒë·∫ßu t·ª± ƒë·ªông chuy·ªÉn ƒë·ªïi plain text trong textbox sang SRT...")
        self.update_status("‚è≥ ƒêang ƒë·ªãnh d·∫°ng vƒÉn b·∫£n th√†nh SRT...")

        # Thu th·∫≠p c·∫•u h√¨nh chia d√≤ng v√† timing t·ª´ UI
        split_cfg_for_conversion = {
            "split_enabled": self.enable_split_var.get(),
            "mode": self.split_mode_var.get(),
            "max_chars": safe_int(self.max_chars_var.get(), 90), # D√πng h√†m safe_int
            "max_lines": safe_int(self.max_lines_var.get(), 1), # D√πng h√†m safe_int
            "DEFAULT_CPS_FOR_TIMING": safe_int(self.sub_cps_for_timing_var.get(), 17),
            "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1, # ms
            "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
        }
        logging.debug(f"[AutoFormatSRT] S·ª≠ d·ª•ng split_config: {json.dumps(split_cfg_for_conversion, ensure_ascii=False)}")

        # G·ªçi h√†m parse ƒë√£ ƒë∆∞·ª£c n√¢ng c·∫•p
        parsed_srt_data = self._parse_plain_text_to_srt_data(
            plain_text_content,
            force_plain_text_processing=True, # √âp x·ª≠ l√Ω nh∆∞ plain text
            split_config_override=split_cfg_for_conversion
        )

        if parsed_srt_data:
            # S·ª≠ d·ª•ng h√†m helper ƒë·ªÉ t·∫°o chu·ªói SRT
            srt_output_string = format_srt_data_to_string(parsed_srt_data)
            
            try:
                subtitle_textbox.configure(state="normal")
                subtitle_textbox.delete("1.0", "end")
                subtitle_textbox.insert("1.0", srt_output_string)
                self.allow_edit_sub = True # Cho ph√©p l∆∞u l·∫°i sau khi ƒë·ªãnh d·∫°ng
                self.current_srt_path = None
                self.update_status("‚úÖ VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông ƒë·ªãnh d·∫°ng th√†nh SRT.")
                logging.info("[AutoFormatSRT] Chuy·ªÉn ƒë·ªïi th√†nh c√¥ng v√† c·∫≠p nh·∫≠t textbox.")
            except Exception as e_update_tb:
                logging.error(f"[AutoFormatSRT] L·ªói khi c·∫≠p nh·∫≠t textbox v·ªõi SRT ƒë√£ ƒë·ªãnh d·∫°ng: {e_update_tb}")
                self.update_status("‚ö†Ô∏è L·ªói c·∫≠p nh·∫≠t textbox sau khi ƒë·ªãnh d·∫°ng SRT.")
        else:
            self.update_status("‚ö†Ô∏è Kh√¥ng th·ªÉ t·ª± ƒë·ªông ƒë·ªãnh d·∫°ng vƒÉn b·∫£n th√†nh SRT (kh√¥ng c√≥ kh·ªëi n√†o ƒë∆∞·ª£c t·∫°o).")
            logging.warning("[AutoFormatSRT] Kh√¥ng c√≥ kh·ªëi n√†o ƒë∆∞·ª£c parsed_srt_data tr·∫£ v·ªÅ.")


# H√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi khi c√≥ s·ª± ki·ªán d√°n.
    def handle_paste_and_format_srt(self, event=None):
        """
        X·ª≠ l√Ω s·ª± ki·ªán d√°n v√†o subtitle_textbox.
        G·ªçi h√†m chuy·ªÉn ƒë·ªïi sang SRT sau m·ªôt kho·∫£ng tr·ªÖ nh·ªè.
        """
        if hasattr(self, 'auto_format_plain_text_to_srt_var') and \
           self.auto_format_plain_text_to_srt_var.get():
            # G·ªçi h√†m chuy·ªÉn ƒë·ªïi sau 50ms ƒë·ªÉ ƒë·∫£m b·∫£o text ƒë√£ ƒë∆∞·ª£c d√°n v√†o textbox
            self.after(50, self._convert_textbox_to_srt_if_needed)
            

# === H√ÄM B·ªî TR·ª¢ T√çNH NƒÇNG T·∫†O VIDEO T·ª™ ·∫¢NH ===
# H√†m Popup hi·ªÉn th·ªã cho t√≠nh nƒÉng t·∫°o video t·ª´ ·∫£nh
    def prompt_for_script_for_slideshow(self, image_paths_for_slideshow):
        """
        Hi·ªÉn th·ªã m·ªôt c·ª≠a s·ªï Toplevel t√πy ch·ªânh ƒë·ªÉ y√™u c·∫ßu ng∆∞·ªùi d√πng cung c·∫•p
        k·ªãch b·∫£n (SRT, nh·∫≠p text, HO·∫∂C FILE AUDIO NGO√ÄI) cho slideshow ·∫£nh ƒë√£ ch·ªçn.
        C·ª≠a s·ªï n√†y s·∫Ω ƒë∆∞·ª£c cƒÉn gi·ªØa so v·ªõi c·ª≠a s·ªï ch√≠nh.
        """
        # Ki·ªÉm tra xem c·ª≠a s·ªï ƒë√£ m·ªü ch∆∞a
        if hasattr(self, '_script_prompt_slideshow_win') and \
           self._script_prompt_slideshow_win and \
           self._script_prompt_slideshow_win.winfo_exists():
            self._script_prompt_slideshow_win.focus()
            logging.warning("[PromptScriptSlideshow] C·ª≠a s·ªï y√™u c·∫ßu k·ªãch b·∫£n/audio cho slideshow ƒë√£ ƒë∆∞·ª£c hi·ªÉn th·ªã.")
            return

        self._script_prompt_slideshow_win = ctk.CTkToplevel(self)
        win = self._script_prompt_slideshow_win
        win.title("Y√™u c·∫ßu K·ªãch b·∫£n/Audio cho Slideshow")
        
        # ƒê·∫∑t k√≠ch th∆∞·ªõc ban ƒë·∫ßu (c√≥ th·ªÉ s·∫Ω ƒë∆∞·ª£c ƒëi·ªÅu ch·ªânh sau khi pack widget)
        initial_popup_width = 520
        initial_popup_height = 250 # TƒÉng nh·∫π n·∫øu c·∫ßn
        win.geometry(f"{initial_popup_width}x{initial_popup_height}")
        
        win.resizable(False, False)
        win.attributes("-topmost", True)
        win.grab_set() # NgƒÉn t∆∞∆°ng t√°c v·ªõi c·ª≠a s·ªï ch√≠nh

        # --- Frame v√† c√°c widget con ---
        main_prompt_frame = ctk.CTkFrame(win, fg_color="transparent")
        main_prompt_frame.pack(expand=True, fill="both", padx=20, pady=15)

        instructions_text = (
            "B·∫°n ƒë√£ ch·ªçn ·∫£nh ƒë·ªÉ t·∫°o slideshow.\n"
            "ƒê·ªÉ video c√≥ th·ªùi l∆∞·ª£ng ph√π h·ª£p, vui l√≤ng cung c·∫•p m·ªôt trong c√°c ngu·ªìn sau:\n\n"
            "1. Ch·ªçn m·ªôt file ph·ª• ƒë·ªÅ (.SRT).\n"
            "2. HO·∫∂C, ch·ªçn m·ªôt file Audio (.mp3, .wav,...) ƒë·ªÉ l·∫•y th·ªùi l∆∞·ª£ng.\n"
            "3. HO·∫∂C, nh·∫≠p/d√°n tr·ª±c ti·∫øp n·ªôi dung vƒÉn b·∫£n v√†o √¥ 'K·ªãch b·∫£n (Xem tr∆∞·ªõc/S·ª≠a)' ·ªü c·ª≠a s·ªï ch√≠nh (th·ªùi l∆∞·ª£ng s·∫Ω ƒë∆∞·ª£c ∆∞·ªõc t√≠nh)."
        )
        ctk.CTkLabel(main_prompt_frame,
                     text=instructions_text,
                     justify=ctk.LEFT,
                     wraplength=initial_popup_width - 40, # ƒê·ªÉ text kh√¥ng b·ªã tr√†n
                     font=("Segoe UI", 13)
                     ).pack(pady=(0, 15), anchor="w")

        button_area_prompt = ctk.CTkFrame(main_prompt_frame, fg_color="transparent")
        button_area_prompt.pack(fill="x", pady=(10,0))
        button_area_prompt.grid_columnconfigure((0, 1, 2, 3), weight=1, uniform="popup_btn")

        # --- ƒê·ªãnh nghƒ©a c√°c h√†nh ƒë·ªông cho n√∫t ---
        def _on_select_srt_for_slideshow_prompt():
            logging.debug("[PromptScriptSlideshow] Ng∆∞·ªùi d√πng ch·ªçn 'Ch·ªçn file SRT...'.")
            win.destroy()
            self.after(10, self.dub_load_script) # G·ªçi sau m·ªôt ch√∫t ƒë·ªÉ c·ª≠a s·ªï popup k·ªãp ƒë√≥ng h·∫≥n
            self.after(200, lambda paths=image_paths_for_slideshow:
                       self._check_and_start_slideshow_creation_after_script_action(paths, "srt_file"))

        def _on_select_audio_for_slideshow_prompt():
            logging.debug("[PromptScriptSlideshow] Ng∆∞·ªùi d√πng ch·ªçn 'Ch·ªçn file Audio...'.")
            win.destroy()
            self.after(10, self.dub_load_audio_file)
            self.after(200, lambda paths=image_paths_for_slideshow:
                       self._check_and_start_slideshow_creation_after_script_action(paths, "audio_file"))

        def _on_go_to_textbox_prompt():
            # ... (gi·ªØ nguy√™n nh∆∞ code c·ªßa b·∫°n)
            logging.debug("[PromptScriptSlideshow] Ng∆∞·ªùi d√πng ch·ªçn 'ƒê·∫øn √¥ Nh·∫≠p VƒÉn b·∫£n'.")
            win.destroy()
            if hasattr(self, 'view_switcher') and self.view_switcher.get() != "‚ô™ Thuy·∫øt Minh":
                self.view_switcher.set("‚ô™ Thuy·∫øt Minh")
                self.switch_view("‚ô™ Thuy·∫øt Minh")
            if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
                self.dub_script_textbox.focus_set()
                self.dub_script_textbox.configure(state="normal")
            messagebox.showinfo("Nh·∫≠p K·ªãch b·∫£n",
                                "Vui l√≤ng nh·∫≠p ho·∫∑c d√°n n·ªôi dung k·ªãch b·∫£n v√†o √¥ b√™n d∆∞·ªõi.\n"
                                "Sau khi ho√†n t·∫•t, h√£y th·ª≠ l·∫°i thao t√°c ch·ªçn ·∫£nh/th∆∞ m·ª•c ·∫£nh.",
                                parent=self)


        def _on_cancel_prompt():
            logging.debug("[PromptScriptSlideshow] Ng∆∞·ªùi d√πng ch·ªçn 'H·ªßy'.")
            win.destroy()
            # K√≠ch ho·∫°t l·∫°i c√°c n√∫t ch·ªçn media tr√™n c·ª≠a s·ªï ch√≠nh n·∫øu c·∫ßn
            if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists():
                 if not (hasattr(self, 'dub_is_processing') and self.dub_is_processing): # Ch·ªâ b·∫≠t n·∫øu kh√¥ng ƒëang x·ª≠ l√Ω
                    self.dub_load_video_button.configure(state="normal")
            if hasattr(self, 'dub_select_image_folder_button') and self.dub_select_image_folder_button.winfo_exists():
                 if hasattr(self, 'dub_use_image_folder_var') and self.dub_use_image_folder_var.get() and \
                    not (hasattr(self, 'dub_is_processing') and self.dub_is_processing):
                    self.dub_select_image_folder_button.configure(state="normal")

        btn_select_srt = ctk.CTkButton(button_area_prompt, text="Ch·ªçn file SRT...",
                                       command=_on_select_srt_for_slideshow_prompt)
        btn_select_srt.grid(row=0, column=0, padx=(0,5), pady=5, sticky="ew")

        btn_select_audio = ctk.CTkButton(button_area_prompt, text="Ch·ªçn file Audio...",
                                         command=_on_select_audio_for_slideshow_prompt)
        btn_select_audio.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        btn_go_to_textbox = ctk.CTkButton(button_area_prompt, text="ƒê·∫øn √¥ Nh·∫≠p Text",
                                          command=_on_go_to_textbox_prompt)
        btn_go_to_textbox.grid(row=0, column=2, padx=5, pady=5, sticky="ew")

        btn_cancel_prompt = ctk.CTkButton(button_area_prompt, text="H·ªßy",
                                          command=_on_cancel_prompt,
                                          fg_color="gray", hover_color="#555555")
        btn_cancel_prompt.grid(row=0, column=3, padx=(5,0), pady=5, sticky="ew")

        win.protocol("WM_DELETE_WINDOW", _on_cancel_prompt)

        # --- CƒÉn gi·ªØa c·ª≠a s·ªï popup ---
        # G·ªçi update_idletasks ƒë·ªÉ ƒë·∫£m b·∫£o c√°c widget ƒë√£ ƒë∆∞·ª£c t√≠nh to√°n k√≠ch th∆∞·ªõc
        self.update_idletasks() # C·ª≠a s·ªï ch√≠nh
        win.update_idletasks()   # C·ª≠a s·ªï popup

        try:
            main_app_x = self.winfo_x()
            main_app_y = self.winfo_y()
            main_app_width = self.winfo_width()
            main_app_height = self.winfo_height()
            
            # L·∫•y k√≠ch th∆∞·ªõc th·ª±c t·∫ø c·ªßa popup sau khi ƒë√£ pack widget
            popup_width = win.winfo_width()
            popup_height = win.winfo_height()

            # Fallback n·∫øu winfo_width/height ch∆∞a c·∫≠p nh·∫≠t (ƒë√¥i khi x·∫£y ra)
            if popup_width <= 1: popup_width = initial_popup_width 
            if popup_height <= 1: popup_height = initial_popup_height
            
            # T√≠nh to√°n v·ªã tr√≠ ƒë·ªÉ cƒÉn gi·ªØa
            position_x = main_app_x + (main_app_width // 2) - (popup_width // 2)
            position_y = main_app_y + (main_app_height // 2) - (popup_height // 2)
            
            # ƒê·∫£m b·∫£o popup kh√¥ng b·ªã ra ngo√†i m√†n h√¨nh (ƒë·∫∑c bi·ªát quan tr·ªçng v·ªõi ƒëa m√†n h√¨nh ho·∫∑c c·ª≠a s·ªï ch√≠nh ·ªü r√¨a)
            screen_width = win.winfo_screenwidth()
            screen_height = win.winfo_screenheight()
            
            if position_x + popup_width > screen_width:
                position_x = screen_width - popup_width
            if position_y + popup_height > screen_height:
                position_y = screen_height - popup_height
            if position_x < 0:
                position_x = 0
            if position_y < 0:
                position_y = 0
                
            win.geometry(f"{popup_width}x{popup_height}+{position_x}+{position_y}")
            logging.info(f"[PromptScriptSlideshow] ƒê√£ cƒÉn gi·ªØa popup t·∫°i: {position_x}, {position_y} v·ªõi k√≠ch th∆∞·ªõc {popup_width}x{popup_height}")

        except Exception as e_center_final:
            logging.warning(f"[PromptScriptSlideshow] Kh√¥ng th·ªÉ cƒÉn gi·ªØa c·ª≠a s·ªï popup (l·ªói cu·ªëi): {e_center_final}")
            # N·∫øu l·ªói, √≠t nh·∫•t n√≥ s·∫Ω xu·∫•t hi·ªán ·ªü v·ªã tr√≠ m·∫∑c ƒë·ªãnh g·∫ßn c·ª≠a s·ªï ch√≠nh

        
# Trong l·ªõp SubtitleApp:
    def _check_and_start_slideshow_creation_after_script_action(self, image_paths_for_slideshow, action_taken="unknown"):
        """
        Ki·ªÉm tra xem k·ªãch b·∫£n/audio ƒë√£ s·∫µn s√†ng ch∆∞a sau h√†nh ƒë·ªông c·ªßa ng∆∞·ªùi d√πng t·ª´ popup.
        N·∫øu ƒë√£ s·∫µn s√†ng (·∫£nh + ngu·ªìn timing), th√¨ b·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫°o slideshow.
        action_taken: "srt_file", "audio_file", "textbox_focused" (ho·∫∑c b·ªè qua n·∫øu kh√¥ng c·∫ßn)
        """
        logging.debug(f"[CheckAfterScriptAction] Ki·ªÉm tra ƒëi·ªÅu ki·ªán t·∫°o slideshow (Action: {action_taken}).")
        has_timing_source = False
        timing_source_log = "ch∆∞a c√≥"

        # ∆Øu ti√™n 1: Ki·ªÉm tra file audio ngo√†i ƒë√£ ƒë∆∞·ª£c ch·ªçn (quan tr·ªçng v√¨ n√≥ c√≥ th·ªÉ ƒë∆∞·ª£c ch·ªçn qua popup)
        if hasattr(self, 'dub_audio_path_for_queue_temp') and self.dub_audio_path_for_queue_temp and \
           os.path.exists(self.dub_audio_path_for_queue_temp) and \
           (self.dub_get_audio_duration_ms(self.dub_audio_path_for_queue_temp) or 0) > 0:
            has_timing_source = True
            timing_source_log = f"file Audio ({os.path.basename(self.dub_audio_path_for_queue_temp)})"
            logging.info(f"[CheckAfterScriptAction] ƒê√£ c√≥ file audio h·ª£p l·ªá: {timing_source_log}")

        # ∆Øu ti√™n 2: Ki·ªÉm tra file SRT ƒë√£ ƒë∆∞·ª£c load v√† parse th√†nh c√¥ng (n·∫øu ch∆∞a c√≥ audio)
        if not has_timing_source and \
           hasattr(self, 'dub_temp_srt_data_for_queue') and self.dub_temp_srt_data_for_queue:
            current_script_file = getattr(self, 'dub_current_script_path_for_queue_temp', None)
            if current_script_file and os.path.exists(current_script_file):
                has_timing_source = True
                timing_source_log = f"file SRT ({os.path.basename(current_script_file)})"
                logging.info(f"[CheckAfterScriptAction] ƒê√£ c√≥ file SRT h·ª£p l·ªá: {timing_source_log}")

        # ∆Øu ti√™n 3: Ki·ªÉm tra textbox (n·∫øu ch∆∞a c√≥ audio ho·∫∑c SRT)
        if not has_timing_source and \
           hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
            textbox_content = self.dub_script_textbox.get("1.0", "end-1c").strip()
            if textbox_content and not self._is_textbox_content_invalid_for_script(textbox_content):
                has_timing_source = True
                timing_source_log = "n·ªôi dung textbox"
                logging.info(f"[CheckAfterScriptAction] ƒê√£ c√≥ n·ªôi dung textbox h·ª£p l·ªá: {timing_source_log}")


        if has_timing_source and image_paths_for_slideshow:
            logging.info(f"[CheckAfterScriptAction] ƒê√£ c√≥ ·∫£nh ({len(image_paths_for_slideshow)}) v√† ngu·ªìn timing ({timing_source_log}). "
                         "B·∫Øt ƒë·∫ßu t·∫°o slideshow.")

            self.update_status(f"ƒêang chu·∫©n b·ªã t·∫°o video t·ª´ {len(image_paths_for_slideshow)} ·∫£nh (Timing: {timing_source_log})...")
            if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists():
                self.dub_load_video_button.configure(state="disabled")
            if hasattr(self, 'dub_select_image_folder_button') and self.dub_select_image_folder_button.winfo_exists() and self.dub_use_image_folder_var.get():
                self.dub_select_image_folder_button.configure(state="disabled")
            if hasattr(self, 'dub_btn_add_to_queue') and self.dub_btn_add_to_queue.winfo_exists():
                self.dub_btn_add_to_queue.configure(state="disabled")

            thread = threading.Thread(target=self._create_video_from_images_thread,
                                     args=(image_paths_for_slideshow,),
                                     daemon=True,
                                     name="CreateSlideshowThreadPostAction")
            thread.start()
        elif not image_paths_for_slideshow:
            logging.warning("[CheckAfterScriptAction] Kh√¥ng c√≥ ·∫£nh n√†o ƒë∆∞·ª£c ch·ªçn (danh s√°ch ·∫£nh r·ªóng).")
            if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists():
                self.dub_load_video_button.configure(state="normal")
            if hasattr(self, 'dub_select_image_folder_button') and self.dub_select_image_folder_button.winfo_exists() and self.dub_use_image_folder_var.get():
                self.dub_select_image_folder_button.configure(state="normal")
        else: # V·∫´n ch∆∞a c√≥ ngu·ªìn timing h·ª£p l·ªá
            logging.warning("[CheckAfterScriptAction] Ngu·ªìn timing v·∫´n ch∆∞a s·∫µn s√†ng. Kh√¥ng th·ªÉ t·∫°o slideshow.")
            messagebox.showwarning("Thi·∫øu K·ªãch b·∫£n/Audio",
                                   "V·∫´n ch∆∞a c√≥ K·ªãch b·∫£n ho·∫∑c file Audio h·ª£p l·ªá ƒë∆∞·ª£c cung c·∫•p. "
                                   "Vui l√≤ng ch·ªçn m·ªôt trong c√°c ngu·ªìn ƒë·ªÉ x√°c ƒë·ªãnh th·ªùi l∆∞·ª£ng slideshow.",
                                   parent=self)
            # B·∫≠t l·∫°i c√°c n√∫t ch·ªçn ngu·ªìn video/·∫£nh
            if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists():
                self.dub_load_video_button.configure(state="normal")
            if hasattr(self, 'dub_select_image_folder_button') and self.dub_select_image_folder_button.winfo_exists() and self.dub_use_image_folder_var.get():
                self.dub_select_image_folder_button.configure(state="normal")


# B·∫°n c·∫ßn m·ªôt h√†m helper nh·ªè ƒë·ªÉ ki·ªÉm tra n·ªôi dung textbox
    def _is_textbox_content_invalid_for_script(self, text_val):
        """Ki·ªÉm tra xem n·ªôi dung textbox c√≥ ph·∫£i l√† placeholder/l·ªói hay kh√¥ng."""
        stripped_text_val = text_val.strip() # Strip m·ªôt l·∫ßn ·ªü ƒë√¢y
        if not stripped_text_val:
            return True # R·ªóng l√† kh√¥ng h·ª£p l·ªá

        # L·∫•y c√°c placeholder ƒë√£ ƒë·ªãnh nghƒ©a t·ª´ self
        placeholders_to_check = []
        if hasattr(self, 'subtitle_textbox_placeholder'):
            placeholders_to_check.append(self.subtitle_textbox_placeholder.strip())
        if hasattr(self, 'dub_script_textbox_placeholder'):
            placeholders_to_check.append(self.dub_script_textbox_placeholder.strip())
        
        # Th√™m c√°c chu·ªói th√¥ng b√°o l·ªói c·ªë ƒë·ªãnh kh√°c n·∫øu c√≥
        error_messages = [
            "[Ch∆∞a c√≥ k·ªãch b·∫£n n√†o ƒë∆∞·ª£c t·∫£i]", # N·∫øu ƒë√¢y l√† m·ªôt th√¥ng b√°o b·∫°n t·ª± ƒë·∫∑t
            "[L·ªñI KHI ƒê·ªåC SCRIPT]",
            "[L·ªñI: File script ƒë√£ ch·ªçn kh√¥ng t·ªìn t·∫°i]",
            "[L·ªói hi·ªÉn th·ªã k·ªãch b·∫£n t√°c v·ª•]",
        ]
        placeholders_to_check.extend([msg.strip() for msg in error_messages])
        
        # Log ƒë·ªÉ debug
        logging.debug(f"[_is_textbox_content_invalid_for_script] text_val (stripped) = '{stripped_text_val}'")
        # logging.debug(f"[_is_textbox_content_invalid_for_script] Checking against: {placeholders_to_check}")

        for ph_val_check in placeholders_to_check:
            if stripped_text_val == ph_val_check: # SO S√ÅNH CH√çNH X√ÅC
                logging.debug(f"[_is_textbox_content_invalid_for_script] MATCHED with: '{ph_val_check}'")
                return True
        
        logging.debug(f"[_is_textbox_content_invalid_for_script] NO MATCH found with predefined placeholders/errors.")
        return False


# H√ÄM M·ªöI ƒê·ªÇ SETTER AN TO√ÄN CHO THU·ªòC T√çNH VIDEO T·∫†M TH·ªúI ===
    def dub_current_video_path_for_queue_temp_setter(self, path_to_set):
        """
        H√†m setter an to√†n ƒë·ªÉ c·∫≠p nh·∫≠t self.dub_current_video_path_for_queue_temp.
        Th∆∞·ªùng ƒë∆∞·ª£c g·ªçi t·ª´ self.after() ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫°y tr√™n lu·ªìng ch√≠nh.
        H√†m n√†y c≈©ng s·∫Ω ki·ªÉm tra l·∫°i ƒëi·ªÅu ki·ªán ƒë·ªÉ th√™m v√†o h√†ng ch·ªù dubbing.
        """
        if hasattr(self, 'dub_current_video_path_for_queue_temp'):
            self.dub_current_video_path_for_queue_temp = path_to_set
            logging.info(f"[SetterSlideshowVideo] ƒê√£ c·∫≠p nh·∫≠t dub_current_video_path_for_queue_temp th√†nh: {path_to_set}")
            
            # G·ªçi _try_auto_add_to_dub_queue tr·ª±c ti·∫øp t·ª´ ƒë√¢y
            if hasattr(self, '_try_auto_add_to_dub_queue'):
                logging.debug("[SetterSlideshowVideo] G·ªçi _try_auto_add_to_dub_queue tr·ª±c ti·∫øp t·ª´ setter.")
                self._try_auto_add_to_dub_queue() # G·ªåI TR·ª∞C TI·∫æP
            else:
                logging.warning("[SetterSlideshowVideo] Kh√¥ng t√¨m th·∫•y _try_auto_add_to_dub_queue ƒë·ªÉ g·ªçi.")
        else:
            logging.error("[SetterSlideshowVideo] L·ªói nghi√™m tr·ªçng: Thu·ªôc t√≠nh 'dub_current_video_path_for_queue_temp' kh√¥ng t·ªìn t·∫°i tr√™n self.")


# H√†m Ki·ªÉm tra v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa n√∫t "B·∫Øt ƒë·∫ßu Dubbing H√†ng lo·∫°t
    def _update_dub_start_batch_button_state(self):
        """
        C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t 'B·∫Øt ƒë·∫ßu Dubbing H√†ng lo·∫°t' m·ªôt c√°ch an to√†n:
        - N·∫øu ƒëang x·ª≠ l√Ω:     ‚è≥ v√† disable
        - N·∫øu ch∆∞a k√≠ch ho·∫°t: üîí v√† disable
        - N·∫øu ƒë√£ k√≠ch ho·∫°t:   enable khi queue c√≥ item HO·∫∂C UI ƒë·ªß ƒëi·ªÅu ki·ªán b·∫Øt ƒë·∫ßu
        """
        import os
        btn = getattr(self, 'dub_start_batch_button', None)
        if not btn or not hasattr(btn, "configure") or not btn.winfo_exists():
            return

        # --- NGU·ªíN S·ª∞ TH·∫¨T: tr·∫°ng th√°i k√≠ch ho·∫°t ---
        try:
            is_active = self._is_app_fully_activated()
        except Exception:
            is_active = False

        is_processing = bool(getattr(self, 'dub_is_processing', False))
        unactivated_text = "üîí K√≠ch ho·∫°t (Dub)"

        # ∆Øu ti√™n 1: ƒëang x·ª≠ l√Ω ‚Üí kho√°
        if is_processing:
            try:
                btn.configure(state=ctk.DISABLED, text="‚è≥ ƒêang x·ª≠ l√Ω...")
            except Exception:
                pass
            return

        # ∆Øu ti√™n 2: ch∆∞a k√≠ch ho·∫°t ‚Üí kho√° c·ª©ng
        if not is_active:
            try:
                btn.configure(state=ctk.DISABLED, text=unactivated_text)
            except Exception:
                pass
            return

        # --- ƒê√É k√≠ch ho·∫°t & kh√¥ng x·ª≠ l√Ω: t√≠nh ƒëi·ªÅu ki·ªán b·∫≠t n√∫t ---
        queue_has_items = bool(getattr(self, 'dub_processing_queue', []))
        can_start_from_ui = False

        if not queue_has_items:
            # video/·∫£nh h·ª£p l·ªá?
            has_valid_video = bool(
                getattr(self, 'dub_current_video_path_for_queue_temp', "") and
                os.path.exists(getattr(self, 'dub_current_video_path_for_queue_temp'))
            )

            # script h·ª£p l·ªá? (file SRT t·∫°m ho·∫∑c n·ªôi dung textbox)
            has_valid_script = False
            if (getattr(self, 'dub_current_script_path_for_queue_temp', "") and
                os.path.exists(getattr(self, 'dub_current_script_path_for_queue_temp')) and
                getattr(self, 'dub_temp_srt_data_for_queue', None)):
                has_valid_script = True
            else:
                tb = getattr(self, 'dub_script_textbox', None)
                if tb and tb.winfo_exists():
                    try:
                        content = tb.get("1.0", "end-1c").strip()
                    except Exception:
                        content = ""
                    if content and not self._is_textbox_content_invalid_for_script(content):
                        has_valid_script = True

            # audio ngo√†i h·ª£p l·ªá?
            has_valid_ext_audio = False
            audio_path = getattr(self, 'dub_audio_path_for_queue_temp', "")
            if audio_path and os.path.exists(audio_path):
                try:
                    dur_ms = self.dub_get_audio_duration_ms(audio_path) or 0
                except Exception:
                    dur_ms = 0
                has_valid_ext_audio = dur_ms > 0

            if has_valid_video and (has_valid_script or has_valid_ext_audio):
                can_start_from_ui = True

        # Quy·∫øt ƒë·ªãnh cu·ªëi c√πng
        try:
            if queue_has_items or can_start_from_ui:
                btn.configure(state=ctk.NORMAL, text="üöÄ B·∫Øt ƒë·∫ßu Dubbing H√†ng lo·∫°t")
            else:
                btn.configure(state=ctk.DISABLED, text="üöÄ B·∫Øt ƒë·∫ßu Dubbing H√†ng lo·∫°t")
        except Exception:
            pass

        logging.debug(
            "[DubUIState_StartBtn] Final: is_active=%s, is_processing=%s, "
            "queue_has_items=%s, can_start_from_ui=%s, btn_state=%s, btn_text='%s'",
            is_active, is_processing, queue_has_items, can_start_from_ui,
            getattr(btn, "cget", lambda *_: "?")("state"),
            getattr(btn, "cget", lambda *_: "?")("text")
        )
                


# H√†m chuy·ªÉn giao h√†ng ch·ªù Sub sang Dub
    def _initiate_chained_dubbing(self, list_of_video_script_pairs, is_from_gpt_chain_with_plain_text=False):
        """
        (PHI√äN B·∫¢N HO√ÄN CH·ªàNH)
        B·∫Øt ƒë·∫ßu chu·ªói Thuy·∫øt Minh t·ª± ƒë·ªông. Chuy·ªÉn giao c√°c file video/script ƒë√£ x·ª≠ l√Ω
        t·ª´ c√°c b∆∞·ªõc tr∆∞·ªõc (Download, Sub, AI) v√†o h√†ng ch·ªù thuy·∫øt minh.
        S·ª≠ d·ª•ng c·ªù '_is_in_chaining_process' ƒë·ªÉ ngƒÉn c√°c h√†nh ƒë·ªông t·ª± ƒë·ªông kh√¥ng mong mu·ªën.
        """
        log_prefix_init_dub = "[InitiateChainedDubbing_v3_Final]"
        logging.info(f"{log_prefix_init_dub} B·∫Øt ƒë·∫ßu. S·ªë c·∫∑p: {len(list_of_video_script_pairs)}. FromGPTPlainText: {is_from_gpt_chain_with_plain_text}")

        # B·∫¨T C·ªú B√ÅO HI·ªÜU V√Ä B·ªåC TRONG TRY...FINALLY
        self._is_in_chaining_process = True # B·∫≠t "kh√≥a"
        try:
            # --- To√†n b·ªô code x·ª≠ l√Ω logic g·ªëc c·ªßa b·∫°n s·∫Ω n·∫±m ·ªü ƒë√¢y ---

            logging.info(f"{log_prefix_init_dub} Reset l·∫°i giao di·ªán Tab Ph·ª• ƒê·ªÅ khi b·∫Øt ƒë·∫ßu chu·ªói Thuy·∫øt Minh...")
            if hasattr(self, '_set_subtitle_tab_ui_state'):
                self.after(50, self._set_subtitle_tab_ui_state, False)
            else:
                logging.error(f"{log_prefix_init_dub} L·ªói: Kh√¥ng th·ªÉ reset UI tab Sub, h√†m _set_subtitle_tab_ui_state kh√¥ng t·ªìn t·∫°i.")

            if not list_of_video_script_pairs:
                logging.warning(f"{log_prefix_init_dub} Kh√¥ng c√≥ c·∫∑p video/script n√†o ƒë·ªÉ x·ª≠ l√Ω.")
                self.update_status("‚ÑπÔ∏è Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c chuy·ªÉn sang ƒë·ªÉ thuy·∫øt minh t·ª± ƒë·ªông.")
                self.pending_auto_dub_after_current_sub_batch = False
                self.files_for_chained_dubbing = [] # V·∫´n reset ·ªü ƒë√¢y cho an to√†n
                return

            try:
                dubbing_tab_value = "‚ô™ Thuy·∫øt Minh"
                if hasattr(self, 'view_switcher') and self.view_switcher and self.view_switcher.winfo_exists():
                    if self.view_switcher.get() != dubbing_tab_value:
                        self.view_switcher.set(dubbing_tab_value)
                        self.switch_view(dubbing_tab_value)
                        logging.info(f"{log_prefix_init_dub}   ƒê√£ t·ª± ƒë·ªông chuy·ªÉn sang tab '{dubbing_tab_value}'.")
            except Exception as switch_e:
                logging.error(f"{log_prefix_init_dub}   L·ªói khi t·ª± ƒë·ªông chuy·ªÉn sang tab Thuy·∫øt Minh: {switch_e}")

            added_to_dub_queue_count = 0
            for pair_index, pair_data in enumerate(list_of_video_script_pairs):
                # L·∫§Y IDENTIFIER T·ª™ D·ªÆ LI·ªÜU C·ª¶A CHU·ªñI TR∆Ø·ªöC ƒê√ì
                identifier_from_chain = pair_data.get('identifier')
                video_path_for_dub_task = pair_data.get('video_to_dub')
                script_content_type = pair_data.get('script_content_type')
                raw_script_data_from_pair = pair_data.get('script_data')
                script_display_name_from_pair = pair_data.get('script_display_name_override')
                output_dir_override_from_chain = pair_data.get('chain_output_dir_override', None)
                optimize_tts_flag_from_sub = pair_data.get('optimize_whisper_tts_voice_enabled', False)

                log_prefix_pair = f"{log_prefix_init_dub} Pair {pair_index+1}/{len(list_of_video_script_pairs)}:"
                logging.info(f"{log_prefix_pair} Video: '{os.path.basename(video_path_for_dub_task if video_path_for_dub_task else 'N/A')}', ScriptType: {script_content_type}, OptimizeTTSFlag: {optimize_tts_flag_from_sub}")

                if not (video_path_for_dub_task and os.path.exists(video_path_for_dub_task)):
                    logging.warning(f"{log_prefix_pair} B·ªè qua: Video kh√¥ng h·ª£p l·ªá '{video_path_for_dub_task}'.")
                    continue
                if not raw_script_data_from_pair:
                    logging.warning(f"{log_prefix_pair} B·ªè qua: Kh√¥ng c√≥ d·ªØ li·ªáu script.")
                    continue

                self.update_status(f"Chu·∫©n b·ªã Dub (T·ª± ƒë·ªông): {os.path.basename(video_path_for_dub_task)}...")

                self.dub_current_video_path_for_queue_temp = video_path_for_dub_task
                self.dub_temp_srt_data_for_queue = []
                parsed_or_optimized_successfully_for_this_pair = False
                script_already_optimized_for_dubbing_flow = False
                
                # --- B·∫ÆT ƒê·∫¶U KH·ªêI LOGIC X·ª¨ L√ù SCRIPT HO√ÄN CH·ªàNH ---
                if script_content_type == 'dual_srt_paths':
                    script_data_dict = raw_script_data_from_pair
                    path_to_actually_use = None

                    if optimize_tts_flag_from_sub:
                        path_to_actually_use = script_data_dict.get('tts_srt_path')
                        logging.info(f"{log_prefix_pair}   OptimizeTTSFlag=True. ∆Øu ti√™n d√πng file TTS: {os.path.basename(path_to_actually_use if path_to_actually_use else 'N/A')}")
                    else:
                        path_to_actually_use = script_data_dict.get('display_srt_path')
                        logging.info(f"{log_prefix_pair}   OptimizeTTSFlag=False. ∆Øu ti√™n d√πng file Display: {os.path.basename(path_to_actually_use if path_to_actually_use else 'N/A')}")

                    if not (path_to_actually_use and os.path.exists(path_to_actually_use)):
                        fallback_path = script_data_dict.get('display_srt_path') if optimize_tts_flag_from_sub else script_data_dict.get('tts_srt_path')
                        logging.warning(f"{log_prefix_pair}   File ∆∞u ti√™n ('{path_to_actually_use}') kh√¥ng t·ªìn t·∫°i. Th·ª≠ d√πng file fallback: '{fallback_path}'")
                        path_to_actually_use = fallback_path
                    
                    if path_to_actually_use and os.path.exists(path_to_actually_use):
                        self.dub_current_script_path_for_queue_temp = path_to_actually_use
                        if script_display_name_from_pair: self.dub_current_script_for_queue_display.set(script_display_name_from_pair)
                        else: self.dub_current_script_for_queue_display.set(os.path.basename(path_to_actually_use))
                        
                        parsed_or_optimized_successfully_for_this_pair = self._parse_script_for_dub_data_internal(path_to_actually_use)
                        script_already_optimized_for_dubbing_flow = False
                    else:
                        logging.error(f"{log_prefix_pair}   L·ªói: C·∫£ hai file SRT (TTS v√† Display) ƒë·ªÅu kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i.")
                        parsed_or_optimized_successfully_for_this_pair = False
                
                elif script_content_type == 'srt_string_for_timed_reoptimization':
                    srt_string_content = raw_script_data_from_pair
                    logging.info(f"{log_prefix_pair}   X·ª≠ l√Ω 'srt_string_for_timed_reoptimization' t·ª´ chu·ªói tr∆∞·ªõc.")
                    parsed_data_from_string = self._parse_plain_text_to_srt_data(srt_string_content, force_plain_text_processing=False)
                    if parsed_data_from_string:
                        self.dub_temp_srt_data_for_queue = parsed_data_from_string
                        self.dub_current_script_path_for_queue_temp = "srt_string_from_chain"
                        if script_display_name_from_pair: self.dub_current_script_for_queue_display.set(script_display_name_from_pair)
                        parsed_or_optimized_successfully_for_this_pair = True
                        script_already_optimized_for_dubbing_flow = False
                    else:
                        logging.error(f"{log_prefix_pair}   L·ªói khi parse srt_string_for_timed_reoptimization.")
                
                elif script_content_type == 'plain_text_gpt':
                    plain_gpt_text = raw_script_data_from_pair
                    logging.info(f"{log_prefix_pair}   X·ª≠ l√Ω plain text g·ªëc t·ª´ AI. √Åp d·ª•ng config t·ªëi ∆∞u c·ªßa tab Thuy·∫øt Minh.")
                    dub_flow_config_for_gpt_text = {
                        'split_enabled': self.dub_split_enabled_for_flow_var.get(),
                        'mode': self.dub_split_mode_for_flow_var.get(),
                        'max_chars': safe_int(self.dub_max_chars_for_flow_var.get(), 999),
                        'max_lines': safe_int(self.dub_max_lines_for_flow_var.get(), 1),
                        "DEFAULT_CPS_FOR_TIMING": safe_int(self.dub_cps_for_timing_var.get(), 17),
                        "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1,
                        "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
                    }
                    parsed_data_from_gpt_plain = self._parse_plain_text_to_srt_data(
                        plain_gpt_text, force_plain_text_processing=True, split_config_override=dub_flow_config_for_gpt_text
                    )
                    if parsed_data_from_gpt_plain:
                        self.dub_temp_srt_data_for_queue = parsed_data_from_gpt_plain
                        self.dub_current_script_path_for_queue_temp = "gpt_plain_text_optimized_in_initiate_dub"
                        if script_display_name_from_pair: 
                            self.dub_current_script_for_queue_display.set(script_display_name_from_pair)
                        else: 
                            self.dub_current_script_for_queue_display.set("K·ªãch b·∫£n AI (ƒê√£ t·ªëi ∆∞u cho Dub)")
                        parsed_or_optimized_successfully_for_this_pair = True
                        script_already_optimized_for_dubbing_flow = True
                    else:
                        logging.error(f"{log_prefix_pair}   L·ªói khi t·ªëi ∆∞u v√† parse plain text t·ª´ AI.")
                
                elif script_content_type == 'srt_file':
                    path_to_use_for_tts_dub = raw_script_data_from_pair
                    if not os.path.exists(path_to_use_for_tts_dub):
                        logging.warning(f"{log_prefix_pair} B·ªè qua: File SRT '{path_to_use_for_tts_dub}' kh√¥ng t·ªìn t·∫°i.")
                        continue
                    logging.info(f"{log_prefix_pair}   X·ª≠ l√Ω file SRT (th√¥ng th∆∞·ªùng): {os.path.basename(path_to_use_for_tts_dub)}")
                    self.dub_current_script_path_for_queue_temp = path_to_use_for_tts_dub
                    if script_display_name_from_pair: self.dub_current_script_for_queue_display.set(script_display_name_from_pair)
                    else: self.dub_current_script_for_queue_display.set(os.path.basename(path_to_use_for_tts_dub))
                    parsed_or_optimized_successfully_for_this_pair = self._parse_script_for_dub_data_internal(path_to_use_for_tts_dub)
                    script_already_optimized_for_dubbing_flow = False
                
                else:
                    logging.warning(f"{log_prefix_pair} B·ªè qua: Lo·∫°i script kh√¥ng x√°c ƒë·ªãnh '{script_content_type}'.")
                    continue

                if parsed_or_optimized_successfully_for_this_pair:
                    # TRUY·ªÄN IDENTIFIER V√ÄO H√ÄM dub_add_to_processing_queue
                    self.dub_add_to_processing_queue(
                        is_already_optimized_for_dub=script_already_optimized_for_dubbing_flow,
                        optimize_tts_source_flag_from_sub=optimize_tts_flag_from_sub,
                        output_dir_override=output_dir_override_from_chain,
                        identifier_from_chain=identifier_from_chain
                    )
                    added_to_dub_queue_count += 1
                else:
                    logging.error(f"{log_prefix_pair}   L·ªói parse/optimize script. B·ªè qua t√°c v·ª• n√†y.")

            # D·ªåN D·∫∏P H√ÄNG CH·ªú TRUNG GIAN NGAY L·∫¨P T·ª®C >>>
            self.files_for_chained_dubbing = []
            logging.info(f"{log_prefix_init_dub} ƒê√£ x·ª≠ l√Ω v√† d·ªçn d·∫πp h√†ng ch·ªù trung gian `files_for_chained_dubbing`.")

            self.dub_current_video_path_for_queue_temp = ""
            self.dub_current_script_path_for_queue_temp = ""
            self.dub_temp_srt_data_for_queue = []
            if hasattr(self, 'dub_current_video_for_queue_display'): self.dub_current_video_for_queue_display.set("(Ch∆∞a ch·ªçn video/·∫£nh)")
            if hasattr(self, 'dub_current_script_for_queue_display'): self.dub_current_script_for_queue_display.set("(Ch∆∞a ch·ªçn script)")

            if added_to_dub_queue_count > 0:
                logging.info(f"{log_prefix_init_dub}   ƒê√£ th√™m {added_to_dub_queue_count} t√°c v·ª• v√†o h√†ng ch·ªù thuy·∫øt minh.")
                if not self.dub_is_processing: 
                    self.after(500, self.dub_start_batch_processing)
                self.after(100, self.update_dub_queue_display)
            else:
                logging.warning(f"{log_prefix_init_dub}   Kh√¥ng c√≥ t√°c v·ª• thuy·∫øt minh n√†o ƒë∆∞·ª£c th√™m v√†o h√†ng ch·ªù.")
                self.update_status("‚ÑπÔ∏è Kh√¥ng th·ªÉ t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu thuy·∫øt minh (kh√¥ng c√≥ file/script h·ª£p l·ªá).")
            
            logging.info(f"{log_prefix_init_dub} --- K·∫øt th√∫c chu·ªói Thuy·∫øt Minh t·ª± ƒë·ªông ---")

        finally:
            self._is_in_chaining_process = False # T·∫Øt "kh√≥a"
            logging.debug(f"{log_prefix_init_dub} ƒê√£ gi·∫£i ph√≥ng c·ªù _is_in_chaining_process.")



# H√†m n√†y s·∫Ω ƒë√≥ng vai tr√≤ l√† m·ªôt "wrapper" (tr√¨nh bao b·ªçc) cho h√†m _initiate_chained_dubbing
    def _initiate_chained_dubbing_with_lock_reset(self, list_of_video_script_pairs, chain_active_flag):
        """
        H√†m wrapper ƒë·ªÉ g·ªçi _initiate_chained_dubbing v√† ƒë·∫£m b·∫£o reset c·ªù kh√≥a.
        """
        log_prefix_wrapper = f"[{threading.current_thread().name}_InitChainedDubWithLock]"
        logging.info(f"{log_prefix_wrapper} B·∫Øt ƒë·∫ßu. S·ªë c·∫∑p video/script: {len(list_of_video_script_pairs) if list_of_video_script_pairs else 0}, C·ªù chain_active: {chain_active_flag}")
        try:
            # G·ªçi h√†m _initiate_chained_dubbing g·ªëc c·ªßa b·∫°n
            if hasattr(self, '_initiate_chained_dubbing'):
                self._initiate_chained_dubbing(list_of_video_script_pairs, chain_active_flag)
            else:
                logging.error(f"{log_prefix_wrapper} L·ªói nghi√™m tr·ªçng: H√†m _initiate_chained_dubbing kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y tr√™n self.")
                # X·ª≠ l√Ω l·ªói n·∫øu c·∫ßn, v√≠ d·ª•: hi·ªÉn th·ªã messagebox ho·∫∑c ƒë·∫∑t l·∫°i c√°c tr·∫°ng th√°i
                if hasattr(self, '_dub_trigger_initiated_for_current_batch'):
                    self._dub_trigger_initiated_for_current_batch = False # V·∫´n c·ªë g·∫Øng reset c·ªù kh√≥a
                # C√≥ th·ªÉ b·∫°n mu·ªën g·ªçi m·ªôt h√†m d·ªçn d·∫πp chung ·ªü ƒë√¢y
                return 
        except Exception as e_init_dub:
            logging.error(f"{log_prefix_wrapper} L·ªói trong qu√° tr√¨nh g·ªçi _initiate_chained_dubbing: {e_init_dub}", exc_info=True)
            # X·ª≠ l√Ω l·ªói n·∫øu c·∫ßn thi·∫øt
        finally:
            # ƒê·∫£m b·∫£o c·ªù kh√≥a ƒë∆∞·ª£c reset sau khi _initiate_chained_dubbing ƒë√£ ƒë∆∞·ª£c g·ªçi
            # (d√π n√≥ th√†nh c√¥ng hay th·∫•t b·∫°i b√™n trong, ho·∫∑c n·∫øu h√†m kh√¥ng t·ªìn t·∫°i)
            if hasattr(self, '_dub_trigger_initiated_for_current_batch'): # Ki·ªÉm tra an to√†n
                if self._dub_trigger_initiated_for_current_batch: # Ch·ªâ log n·∫øu n√≥ ƒëang l√† True
                    logging.info(f"{log_prefix_wrapper} Gi·∫£i ph√≥ng kh√≥a k√≠ch ho·∫°t thuy·∫øt minh (_dub_trigger_initiated_for_current_batch = False).")
                self._dub_trigger_initiated_for_current_batch = False
            else:
                # ƒêi·ªÅu n√†y kh√¥ng n√™n x·∫£y ra n·∫øu B∆∞·ªõc 1 ƒë√£ ƒë∆∞·ª£c th·ª±c hi·ªán ƒë√∫ng
                logging.error(f"{log_prefix_wrapper} L·ªói: Thu·ªôc t√≠nh _dub_trigger_initiated_for_current_batch kh√¥ng t·ªìn t·∫°i ƒë·ªÉ reset.")
                


# H√†m ch·ª©a logic parse file SRT t·ª´ Sub sang Dub
    def _parse_script_for_dub_data_internal(self, srt_path):
        logging.debug(f"   >>> _parse_script_for_dub_data_internal: B·∫Øt ƒë·∫ßu parse file SRT '{srt_path}'")
        self.dub_temp_srt_data_for_queue = [] # Reset tr∆∞·ªõc khi parse

        if not (srt_path and os.path.exists(srt_path)):
            logging.error(f"      L·ªói: File SRT '{srt_path}' kh√¥ng t·ªìn t·∫°i ƒë·ªÉ parse cho dub.")
            return False
        try:
            with open(srt_path, 'r', encoding='utf-8-sig') as f:
                content = f.read()

            # Pattern regex t·ª´ dub_load_script (ho·∫∑c d√πng chung n·∫øu c√≥)
            srt_block_pattern = re.compile(
                r"(\d+)\s*[\r\n]+"
                r"(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*[\r\n]+"
                r"((?:.|\n|\r)*?)(?=\n\s*\n\d+\s*[\r\n]+|\n\d+\s*[\r\n]+\d{2}:\d{2}:\d{2}[,.]\d{3}|\Z)",
                re.MULTILINE
            )
            matches = list(srt_block_pattern.finditer(content))
            if not matches:
                logging.warning(f"      Kh√¥ng t√¨m th·∫•y kh·ªëi SRT n√†o trong file '{srt_path}'.")
                return False # Coi nh∆∞ parse kh√¥ng th√†nh c√¥ng n·∫øu kh√¥ng c√≥ match

            for i, match in enumerate(matches):
                try:
                    index_str, start_tc_str, end_tc_str, text_for_tts_raw = match.groups()
                    start_tc_str_clean = start_tc_str.replace('.', ',')
                    end_tc_str_clean = end_tc_str.replace('.', ',')

                    text_for_tts_and_storage = text_for_tts_raw.strip()
                    text_for_tts_and_storage = re.sub(r'<[^>]+>', '', text_for_tts_and_storage) # Lo·∫°i b·ªè tag HTML/XML
                    text_for_tts_and_storage = "\n".join([line.strip() for line in text_for_tts_and_storage.splitlines() if line.strip()]).strip()

                    if not text_for_tts_and_storage: continue # B·ªè qua n·∫øu text r·ªóng sau khi l√†m s·∫°ch

                    self.dub_temp_srt_data_for_queue.append({
                        "index": int(index_str),
                        "start_str": start_tc_str_clean,
                        "end_str": end_tc_str_clean,
                        "start_ms": parse_timecode(start_tc_str_clean), # parse_timecode l√† h√†m to√†n c·ª•c c·ªßa b·∫°n
                        "end_ms": parse_timecode(end_tc_str_clean),
                        "text": text_for_tts_and_storage
                    })
                except Exception as e_parse_block_internal:
                    logging.error(f"      L·ªói parse kh·ªëi SRT #{i+1} trong file '{os.path.basename(srt_path)}' (internal): {e_parse_block_internal}")
                    continue

            if self.dub_temp_srt_data_for_queue:
                logging.debug(f"      Parse SRT internal th√†nh c√¥ng, {len(self.dub_temp_srt_data_for_queue)} m·ª•c.")
                return True
            else:
                logging.warning(f"      Parse SRT internal kh√¥ng thu ƒë∆∞·ª£c m·ª•c h·ª£p l·ªá n√†o t·ª´ '{os.path.basename(srt_path)}'.")
                return False

        except Exception as e_read_file_internal:
            logging.error(f"      L·ªói ƒë·ªçc file SRT '{srt_path}' (internal): {e_read_file_internal}", exc_info=True)
            return False


# H√†m b·∫Øt ƒë·∫ßu Dub h√†ng lo·∫°t
    def dub_start_batch_processing(self):
        """
        B·∫Øt ƒë·∫ßu qu√° tr√¨nh x·ª≠ l√Ω h√†ng lo·∫°t. N·∫øu h√†ng ch·ªù r·ªóng,
        s·∫Ω th·ª≠ th√™m t√°c v·ª• hi·ªán t·∫°i t·ª´ UI (video + script t·ª´ file/textbox)
        v√†o h√†ng ch·ªù tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu.
        """
        logging.info("[DubBatchStart] N√∫t 'B·∫Øt ƒë·∫ßu Dubbing H√†ng lo·∫°t' ƒë∆∞·ª£c nh·∫•n.")
        if self.dub_is_processing:
            messagebox.showwarning("ƒêang x·ª≠ l√Ω", 
                                 "Qu√° tr√¨nh thuy·∫øt minh h√†ng lo·∫°t ƒë√£ v√† ƒëang ch·∫°y.", 
                                 parent=self)
            return

        # B∆∞·ªõc 1: N·∫øu h√†ng ch·ªù r·ªóng, th·ª≠ th√™m t√°c v·ª• hi·ªán t·∫°i t·ª´ UI
        if not self.dub_processing_queue:
            logging.info("[DubBatchStart] H√†ng ch·ªù ƒëang r·ªóng. Ki·ªÉm tra UI ƒë·ªÉ th·ª≠ th√™m t√°c v·ª• hi·ªán t·∫°i...")
            
            # --- Ki·ªÉm tra video/·∫£nh ƒë√£ ch·ªçn t·ª´ UI ---
            current_video_file_ui = getattr(self, 'dub_current_video_path_for_queue_temp', None)
            has_valid_video_ui = False
            if current_video_file_ui and os.path.exists(current_video_file_ui):
                has_valid_video_ui = True
            logging.debug(f"[DubBatchStart-UICheck] Video path UI: '{current_video_file_ui}', Exists: {os.path.exists(current_video_file_ui) if current_video_file_ui else 'N/A'}, ValidVideoUI: {has_valid_video_ui}")

            # --- Ki·ªÉm tra ngu·ªìn k·ªãch b·∫£n t·ª´ UI (file ho·∫∑c textbox) ---
            has_valid_script_ui = False # Reset l·∫°i ƒë·ªÉ ki·ªÉm tra ch√≠nh x√°c
            script_source_for_ui_log = "Kh√¥ng c√≥ t·ª´ UI"

            # ∆Øu ti√™n ki·ªÉm tra script t·ª´ file ƒë√£ ch·ªçn (n·∫øu c√≥)
            current_script_file_ui = getattr(self, 'dub_current_script_path_for_queue_temp', None)
            current_script_data_from_file_ui = getattr(self, 'dub_temp_srt_data_for_queue', [])
            if current_script_file_ui and os.path.exists(current_script_file_ui) and current_script_data_from_file_ui:
                has_valid_script_ui = True
                script_source_for_ui_log = f"File SRT UI ({os.path.basename(current_script_file_ui)})"
                logging.debug(f"[DubBatchStart-UICheck-Detail] UI Script: File h·ª£p l·ªá ƒë∆∞·ª£c ch·ªçn '{current_script_file_ui}'.")
            
            # N·∫øu kh√¥ng c√≥ file script h·ª£p l·ªá, ki·ªÉm tra textbox
            elif hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
                textbox_content_ui = self.dub_script_textbox.get("1.0", "end-1c").strip()
                logging.debug(f"[DubBatchStart-UICheck-Detail] UI Script: Textbox content = '{textbox_content_ui[:100].replace(os.linesep, ' ')}...'")
                
                if textbox_content_ui: 
                    # DANH S√ÅCH N√ÄY C·∫¶N CH√çNH X√ÅC TUY·ªÜT ƒê·ªêI V·ªöI C√ÅC PLACEHOLDER
                    exact_placeholders_ui = [
                       "[N·ªôi dung file k·ªãch b·∫£n SRT ƒë√£ ch·ªçn s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...]",
                       "[Ch∆∞a c√≥ k·ªãch b·∫£n n√†o ƒë∆∞·ª£c t·∫£i]",
                       # Th√™m c√°c chu·ªói placeholder ƒë·∫ßy ƒë·ªß v√† ch√≠nh x√°c kh√°c n·∫øu c√≥
                    ]
                    # C√°c ti·ªÅn t·ªë c·ªßa th√¥ng b√°o l·ªói m√† kh√¥ng ph·∫£i l√† k·ªãch b·∫£n
                    error_message_prefixes_ui = [
                        "[L·ªñI", # V√≠ d·ª•: "[L·ªñI KHI ƒê·ªåC SCRIPT]"
                        "[File script ƒë√£ ch·ªçn kh√¥ng t·ªìn t·∫°i]", 
                        # Th√™m c√°c ti·ªÅn t·ªë l·ªói kh√°c n·∫øu c√≥
                    ]
                    
                    is_content_exactly_placeholder_ui = textbox_content_ui in exact_placeholders_ui
                    is_content_error_message_ui = any(textbox_content_ui.startswith(err_prefix) for err_prefix in error_message_prefixes_ui)

                    logging.debug(f"[DubBatchStart-UICheck-Detail] UI Script: Textbox is_exactly_placeholder = {is_content_exactly_placeholder_ui}")
                    logging.debug(f"[DubBatchStart-UICheck-Detail] UI Script: Textbox is_error_message = {is_content_error_message_ui}")

                    if not is_content_exactly_placeholder_ui and not is_content_error_message_ui:
                        has_valid_script_ui = True
                        script_source_for_ui_log = "Textbox UI"
                        logging.debug("[DubBatchStart-UICheck-Detail] UI Script: Textbox content ƒë∆∞·ª£c coi l√† k·ªãch b·∫£n h·ª£p l·ªá.")
                    else:
                        logging.debug("[DubBatchStart-UICheck-Detail] UI Script: Textbox content b·ªã coi l√† placeholder ho·∫∑c l·ªói.")
                else:
                    logging.debug("[DubBatchStart-UICheck-Detail] UI Script: Textbox r·ªóng sau khi strip.")
            else:
                logging.debug("[DubBatchStart-UICheck-Detail] UI Script: Kh√¥ng c√≥ dub_script_textbox ho·∫∑c kh√¥ng t·ªìn t·∫°i.")
            
            # Log cu·ªëi c√πng cho ki·ªÉm tra UI tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh
            logging.info(f"[DubBatchStart-UICheckResults] Video h·ª£p l·ªá t·ª´ UI: {has_valid_video_ui}. K·ªãch b·∫£n h·ª£p l·ªá t·ª´ UI ({script_source_for_ui_log}): {has_valid_script_ui}.")

            # G·ªçi dub_add_to_processing_queue n·∫øu ƒë·ªß ƒëi·ªÅu ki·ªán
            if has_valid_video_ui and has_valid_script_ui:

                self.dub_add_to_processing_queue() 
                # Sau khi g·ªçi, self.dub_processing_queue c√≥ th·ªÉ ƒë√£ c√≥ 1 m·ª•c n·∫øu dub_add_to_processing_queue() th√†nh c√¥ng.
            elif not has_valid_video_ui:
                messagebox.showinfo("Thi·∫øu Video/·∫¢nh", 
                                    "Vui l√≤ng ch·ªçn m·ªôt Video ho·∫∑c file ·∫¢nh h·ª£p l·ªá ƒë·ªÉ b·∫Øt ƒë·∫ßu thuy·∫øt minh.", 
                                    parent=self)
                logging.warning("[DubBatchStart] Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu: Thi·∫øu video/·∫£nh t·ª´ UI khi h√†ng ch·ªù r·ªóng.")
                return 
            elif not has_valid_script_ui: 
                messagebox.showinfo("Thi·∫øu K·ªãch b·∫£n", 
                                    "Vui l√≤ng ch·ªçn m·ªôt file Script SRT h·ª£p l·ªá ho·∫∑c nh·∫≠p k·ªãch b·∫£n v√†o √¥ vƒÉn b·∫£n.", 
                                    parent=self)
                logging.warning("[DubBatchStart] Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu: Thi·∫øu k·ªãch b·∫£n t·ª´ UI khi h√†ng ch·ªù r·ªóng.")
                return

        # B∆∞·ªõc 2: Ki·ªÉm tra l·∫°i h√†ng ch·ªù sau khi ƒë√£ th·ª≠ th√™m t·ª´ UI (n·∫øu h√†ng ch·ªù ban ƒë·∫ßu r·ªóng)
        if not self.dub_processing_queue:
            messagebox.showinfo("H√†ng ch·ªù tr·ªëng", 
                                "Kh√¥ng c√≥ t√°c v·ª• n√†o trong h√†ng ch·ªù thuy·∫øt minh ƒë·ªÉ b·∫Øt ƒë·∫ßu. "
                                "H√£y ƒë·∫£m b·∫£o b·∫°n ƒë√£ ch·ªçn Video/·∫¢nh v√† cung c·∫•p K·ªãch b·∫£n (t·ª´ file ho·∫∑c nh·∫≠p tr·ª±c ti·∫øp).", 
                                parent=self)
            logging.info("[DubBatchStart] H√†ng ch·ªù v·∫´n tr·ªëng sau khi th·ª≠ th√™m t√°c v·ª• t·ª´ UI (ho·∫∑c ban ƒë·∫ßu ƒë√£ c√≥ nh∆∞ng gi·ªù l·∫°i r·ªóng). Kh√¥ng b·∫Øt ƒë·∫ßu.")
            return
        
        # B∆∞·ªõc 3: Ki·ªÉm tra FFmpeg
        ffmpeg_path_check = find_ffmpeg()
        if not ffmpeg_path_check:
            logging.error("[DubBatchStart] Kh√¥ng t√¨m th·∫•y FFmpeg. Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu thuy·∫øt minh h√†ng lo·∫°t.")
            self.update_status("L·ªói: Kh√¥ng t√¨m th·∫•y FFmpeg ƒë·ªÉ x·ª≠ l√Ω thuy·∫øt minh.")
            messagebox.showerror("L·ªói FFmpeg", 
                                 "Kh√¥ng t√¨m th·∫•y FFmpeg. Vui l√≤ng c√†i ƒë·∫∑t ho·∫∑c ƒë·∫£m b·∫£o n√≥ n·∫±m trong PATH h·ªá th·ªëng.", 
                                 parent=self)
            return

        # === TH√äM C√ÅC D√íNG RESET C·ªú ·ªû ƒê√ÇY ===
        self.dub_batch_first_api_error_msg_shown = False 
        self.dub_batch_accumulated_api_error_details = None
        self.dub_batch_had_api_key_errors = False # Reset c·∫£ c·ªù l·ªói API key

        # B∆∞·ªõc 4: Chu·∫©n b·ªã b·∫Øt ƒë·∫ßu x·ª≠ l√Ω h√†ng lo·∫°t
        logging.info(f"[DubBatchStart] === B·∫Øt ƒë·∫ßu X·ª≠ l√Ω H√†ng lo·∫°t {len(self.dub_processing_queue)} T√°c v·ª• Thuy·∫øt minh ===")
        self.save_current_config()
        # --- LOGIC GHI NH·∫¨N Y√äU C·∫¶U T·∫ÆT M√ÅY ---
        if not (hasattr(self, 'chain_download_sub_dub_active') and self.chain_download_sub_dub_active):
            # Ch·ªâ ƒë·∫∑t/reset shutdown_requested_by_task n·∫øu ƒë√¢y l√† m·ªôt l√¥ dubbing ƒê·ªòC L·∫¨P,
            # kh√¥ng ph·∫£i l√† m·ªôt ph·∫ßn c·ªßa chu·ªói D-S-D ho·∫∑c S-D ƒëang di·ªÖn ra.
            if self.download_shutdown_var.get(): # Gi·∫£ s·ª≠ c·ªù n√†y v·∫´n d√πng chung
                self.shutdown_requested_by_task = True
                logging.info(f"[DubBatchStart] T√°c v·ª• Dub-Only: 'T·∫Øt m√°y khi ho√†n th√†nh' B·∫¨T. Ghi nh·∫≠n y√™u c·∫ßu.")
            else:
                self.shutdown_requested_by_task = False
                logging.info(f"[DubBatchStart] T√°c v·ª• Dub-Only: 'T·∫Øt m√°y khi ho√†n th√†nh' T·∫ÆT.")
        else:
            # N·∫øu l√† m·ªôt ph·∫ßn c·ªßa chu·ªói, gi·ªØ nguy√™n gi√° tr·ªã shutdown_requested_by_task
            # ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p ·ªü ƒë·∫ßu chu·ªói (v√≠ d·ª•, b·ªüi start_download_and_sub).
            logging.info(f"[DubBatchStart] L√† m·ªôt ph·∫ßn c·ªßa chu·ªói D-S-D/S-D. Gi·ªØ nguy√™n tr·∫°ng th√°i shutdown_requested_by_task: {getattr(self, 'shutdown_requested_by_task', 'Ch∆∞a ƒë·∫∑t')}")
        
        self.dub_is_processing = True
        self.dub_stop_event.clear()
        self.dub_batch_had_api_key_errors = False
        self.start_time = time.time()
        self.update_time_realtime()
        
        # C·∫≠p nh·∫≠t tr·∫°ng th√°i UI
        if hasattr(self, 'dub_btn_add_to_queue') and self.dub_btn_add_to_queue:
            self.dub_btn_add_to_queue.configure(state=ctk.DISABLED)
        if hasattr(self, 'dub_start_batch_button') and self.dub_start_batch_button:
            self.dub_start_batch_button.configure(state=ctk.DISABLED, text="‚è≥ ƒêang x·ª≠ l√Ω...")
        if hasattr(self, 'dub_stop_button') and self.dub_stop_button:
            self.dub_stop_button.configure(state=ctk.NORMAL)
        
        # V√¥ hi·ªáu h√≥a c√°c n√∫t ch·ªçn file v√† c√°c control c√†i ƒë·∫∑t
        controls_to_disable = [
            getattr(self, 'dub_load_video_button', None),
            getattr(self, 'dub_load_audio_button', None),
            getattr(self, 'dub_load_script_button', None),
            getattr(self, 'dub_tts_engine_menu', None),
            getattr(self, 'dub_voice_option_menu', None),
            getattr(self, 'dub_api_settings_button_dub_tab', None), # N√∫t API Keys
            getattr(self, 'dub_background_audio_menu', None),
            getattr(self, 'dub_slider_mix_level', None),
            getattr(self, 'dub_chk_use_custom_bg_music', None),
            getattr(self, 'dub_entry_custom_bg_music_volume', None),
            getattr(self, 'dub_btn_browse_bg_music', None),
            # Th√™m c√°c n√∫t S·ª≠a/L∆∞u/Nghe th·ª≠ script
            getattr(self, 'dub_btn_edit_script', None),
            getattr(self, 'dub_btn_save_script', None),
            getattr(self, 'dub_preview_button', None),
            getattr(self, 'dub_btn_save_audio_from_text', None),
            # TH√äM 3 D√íNG N√ÄY V√ÄO
            getattr(self, 'ai_edit_dub_script_button', None), # N√∫t Bi√™n t·∫≠p (AI)
            getattr(self, 'dalle_button_dub_tab', None),      # N√∫t T·∫°o ·∫¢nh AI (DALL-E)
            getattr(self, 'imagen_button_dub_tab', None)     # N√∫t ·∫¢nh(Imagen)            
        ]
        for control in controls_to_disable:
            if control and hasattr(control, 'configure') and control.winfo_exists():
                try:
                    control.configure(state="disabled")
                except Exception as e_disable:
                    logging.warning(f"[DubBatchStart] L·ªói khi disable control {control}: {e_disable}")
        
        self.update_status(f"B·∫Øt ƒë·∫ßu x·ª≠ l√Ω h√†ng lo·∫°t {len(self.dub_processing_queue)} t√°c v·ª• thuy·∫øt minh...")
        
        # B∆∞·ªõc 5: B·∫Øt ƒë·∫ßu x·ª≠ l√Ω v·ªõi t√°c v·ª• ƒë·∫ßu ti√™n
        self._dub_process_next_item_in_queue()


# H√†m ki·ªÉm tra v√† th√™m t√°c v·ª• v√†o h√†ng ch·ªù thuy·∫øt minh
    def dub_add_to_processing_queue(self, is_already_optimized_for_dub=False, 
                                    optimize_tts_source_flag_from_sub=False,
                                    output_dir_override=None,
                                    identifier_from_chain=None): # <<< TH√äM V√ÄO ƒê√ÇY

        log_prefix_add_q = "[DubQueueAdd_V_Final_Updated]" 
        logging.info(f"{log_prefix_add_q} Y√™u c·∫ßu th√™m t√°c v·ª•. Identifier t·ª´ chu·ªói: {identifier_from_chain}")
        self.update_idletasks()

        current_video_file_for_task = self.dub_current_video_path_for_queue_temp
        if not (current_video_file_for_task and os.path.exists(current_video_file_for_task)):
            messagebox.showerror("Thi·∫øu Video/·∫¢nh",
                                 "Vui l√≤ng ch·ªçn m·ªôt file Video ho·∫∑c ·∫¢nh h·ª£p l·ªá tr∆∞·ªõc khi th√™m v√†o h√†ng ch·ªù.",
                                 parent=self)
            logging.warning(f"{log_prefix_add_q} Kh√¥ng th·ªÉ th√™m: thi·∫øu video/·∫£nh ho·∫∑c file kh√¥ng t·ªìn t·∫°i.")
            return

        initial_srt_data_from_ui = []
        script_path_for_task_config = self.dub_current_script_path_for_queue_temp
        script_display_name_for_task_config = self.dub_current_script_for_queue_display.get()

        # 2. X√ÅC ƒê·ªäNH IDENTIFIER CU·ªêI C√ôNG S·∫º D√ôNG
        final_identifier_for_task = identifier_from_chain
        if not final_identifier_for_task:
            # N·∫øu h√†m ƒë∆∞·ª£c g·ªçi th·ªß c√¥ng (kh√¥ng c√≥ identifier t·ª´ chu·ªói), t·∫°o m·ªôt c√°i m·ªõi
            logging.info(f"{log_prefix_add_q} Kh√¥ng c√≥ identifier t·ª´ chu·ªói, s·∫Ω t·∫°o m·ªõi t·ª´ media.")
            final_identifier_for_task = get_identifier_from_source(current_video_file_for_task)

        # --- LOGIC L·∫§Y K·ªäCH B·∫¢N ---
        # 1. ∆Øu ti√™n self.dub_temp_srt_data_for_queue (ƒë√£ ƒë∆∞·ª£c parse/chu·∫©n b·ªã t·ª´ file ho·∫∑c b∆∞·ªõc tr∆∞·ªõc)
        if hasattr(self, 'dub_temp_srt_data_for_queue') and self.dub_temp_srt_data_for_queue:
            initial_srt_data_from_ui = list(self.dub_temp_srt_data_for_queue)
            if not script_path_for_task_config:
                script_path_for_task_config = "data_from_temp_queue"
            if not script_display_name_for_task_config or script_display_name_for_task_config == "(Ch∆∞a ch·ªçn script)":
                script_display_name_for_task_config = "K·ªãch b·∫£n t·ª´ d·ªØ li·ªáu t·∫°m"
            logging.info(f"{log_prefix_add_q} S·ª≠ d·ª•ng {len(initial_srt_data_from_ui)} seg t·ª´ self.dub_temp_srt_data_for_queue. Ngu·ªìn: {script_path_for_task_config}")
        
        # 2. N·∫øu self.dub_temp_srt_data_for_queue r·ªóng, th·ª≠ l·∫•y v√† parse t·ª´ self.dub_script_textbox
        #    ƒêi·ªÅu n√†y r·∫•t quan tr·ªçng cho tr∆∞·ªùng h·ª£p t·∫°o slideshow t·ª´ ·∫£nh + k·ªãch b·∫£n t·ª´ textbox.
        elif hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
            textbox_content = self.dub_script_textbox.get("1.0", "end-1c").strip()
            if textbox_content and not self._is_textbox_content_invalid_for_script(textbox_content):
                logging.info(f"{log_prefix_add_q} self.dub_temp_srt_data_for_queue r·ªóng. Th·ª≠ parse k·ªãch b·∫£n t·ª´ textbox.")
                # Parse "th√¥" t·ª´ textbox, cho ph√©p n√≥ l√† SRT ho·∫∑c plain text.
                # H√†m _parse_plain_text_to_srt_data s·∫Ω t·ª± quy·∫øt ƒë·ªãnh.
                # Kh√¥ng d√πng split_config_override ·ªü ƒë√¢y, ƒë·ªÉ logic t·ªëi ∆∞u sau quy·∫øt ƒë·ªãnh.
                parsed_from_textbox = self._parse_plain_text_to_srt_data(
                    textbox_content, 
                    force_plain_text_processing=False # Cho ph√©p parse SRT n·∫øu textbox ch·ª©a SRT
                )
                if parsed_from_textbox:
                    initial_srt_data_from_ui = list(parsed_from_textbox)
                    script_path_for_task_config = "text_input_parsed_in_add_q"
                    script_display_name_for_task_config = "K·ªãch b·∫£n t·ª´ Textbox (M·ªõi Parse)"
                    logging.info(f"{log_prefix_add_q} Parse th√†nh c√¥ng {len(initial_srt_data_from_ui)} seg t·ª´ textbox.")
                else:
                    logging.warning(f"{log_prefix_add_q} Kh√¥ng parse ƒë∆∞·ª£c d·ªØ li·ªáu h·ª£p l·ªá t·ª´ textbox. Textbox content: '{textbox_content[:100]}...'")
            else:
                logging.info(f"{log_prefix_add_q} Textbox r·ªóng ho·∫∑c ch·ª©a placeholder/l·ªói, kh√¥ng d√πng cho h√†ng ch·ªù.")
        # --- K·∫æT TH√öC LOGIC L·∫§Y K·ªäCH B·∫¢N ---

        selected_audio_file_path_for_task = None
        if hasattr(self, 'dub_audio_path_for_queue_temp') and self.dub_audio_path_for_queue_temp and \
           os.path.exists(self.dub_audio_path_for_queue_temp) and \
           (self.dub_get_audio_duration_ms(self.dub_audio_path_for_queue_temp) or 0) > 0:
            selected_audio_file_path_for_task = self.dub_audio_path_for_queue_temp

        srt_data_for_task_creation = list(initial_srt_data_from_ui) # ƒê√¢y s·∫Ω l√† d·ªØ li·ªáu ƒë·∫ßu v√†o cho logic t·ªëi ∆∞u (n·∫øu c√≥)
        worker_should_run_optimization = False # S·∫Ω ƒë∆∞·ª£c ƒë·∫∑t th√†nh True n·∫øu worker c·∫ßn t·ª± t·ªëi ∆∞u

        # QUY·∫æT ƒê·ªäNH T·ªêI ∆ØU H√ìA
        if is_already_optimized_for_dub:
            logging.info(f"{log_prefix_add_q} K·ªãch b·∫£n ƒë√£ ƒë∆∞·ª£c t·ªëi ∆∞u cho dub ·ªü b∆∞·ªõc tr∆∞·ªõc. Kh√¥ng t·ªëi ∆∞u l·∫°i b·ªüi UI.")

        # THAY TH·∫æ B·∫∞NG KH·ªêI `elif` SAU:
        elif self.optimize_dub_flow_var.get(): # Checkbox "T·ªëi ∆∞u lu·ªìng ƒë·ªçc" tr√™n UI c·ªßa tab Thuy·∫øt Minh ƒëang B·∫¨T
            logging.info(f"{log_prefix_add_q} 'T·ªëi ∆∞u lu·ªìng ƒë·ªçc' (UI) B·∫¨T. Th·ª±c hi·ªán t·ªëi ∆∞u k·ªãch b·∫£n t·∫°i ƒë√¢y...")
            
            text_to_optimize_ui = ""
            if srt_data_for_task_creation: # S·ª≠ d·ª•ng srt_data_for_task_creation ƒë√£ ƒë∆∞·ª£c l·∫•y ·ªü tr√™n
                # G·ªôp to√†n b·ªô text t·ª´ c√°c segment SRT g·ªëc l·∫°i ƒë·ªÉ chia c√¢u b·∫±ng underthesea
                all_text_parts_ui = [seg.get('text', '').strip() for seg in srt_data_for_task_creation if seg.get('text', '').strip()]
                text_to_optimize_ui = " ".join(all_text_parts_ui)
                logging.info(f"{log_prefix_add_q}   Text ƒë·ªÉ t·ªëi ∆∞u (t·ª´ srt_data_for_task_creation, {len(all_text_parts_ui)} ph·∫ßn): '{text_to_optimize_ui[:100]}...'")
            
            if text_to_optimize_ui.strip():
                # L·∫•y config t·ªëi ∆∞u t·ª´ UI c·ªßa tab Thuy·∫øt Minh
                ui_dub_flow_config_for_reprocess = {
                    'split_enabled': self.dub_split_enabled_for_flow_var.get(),
                    'mode': self.dub_split_mode_for_flow_var.get(),
                    'max_chars': safe_int(self.dub_max_chars_for_flow_var.get(), 999),
                    'max_lines': safe_int(self.dub_max_lines_for_flow_var.get(), 1),
                    "DEFAULT_CPS_FOR_TIMING": safe_int(self.dub_cps_for_timing_var.get(), 17),
                    "PAUSE_BETWEEN_SEGMENTS_MS_FOR_TIMING": 1,
                    "ABSOLUTE_MIN_DURATION_PER_CHUNK_MS": self.min_duration_per_segment_ms
                }
                logging.info(f"{log_prefix_add_q}   Config t·ªëi ∆∞u t·ª´ UI ƒë·ªÉ x·ª≠ l√Ω l·∫°i: {ui_dub_flow_config_for_reprocess}")

                # Chia l·∫°i vƒÉn b·∫£n th√†nh c√°c segment m·ªõi v·ªõi timing ∆∞·ªõc t√≠nh
                optimized_segments_temp_timing_ui = self._parse_plain_text_to_srt_data(
                    text_to_optimize_ui,
                    force_plain_text_processing=True,
                    split_config_override=ui_dub_flow_config_for_reprocess
                )

                if optimized_segments_temp_timing_ui:
                    # <<< LOGIC QUAN TR·ªåNG: √ÅNH X·∫† L·∫†I TIMING >>>
                    # D√πng d·ªØ li·ªáu SRT ban ƒë·∫ßu (initial_srt_data_from_ui) l√†m khung th·ªùi gian g·ªëc
                    has_real_initial_timings_add_q = any('start_str' in seg for seg in initial_srt_data_from_ui) if initial_srt_data_from_ui else False
                    
                    if has_real_initial_timings_add_q:
                        final_optimized_segments_for_task = self._map_optimized_segments_to_original_srt_timings(
                            optimized_segments_temp_timing_ui,
                            initial_srt_data_from_ui
                        )
                        description_for_ui_update_add_q = "K·ªãch b·∫£n t·ªëi ∆∞u (Gi·ªØ timing g·ªëc)"
                        if not final_optimized_segments_for_task:
                            logging.warning(f"{log_prefix_add_q}   √Ånh x·∫° timing th·∫•t b·∫°i. D√πng timing ∆∞·ªõc l∆∞·ª£ng l√†m d·ª± ph√≤ng.")
                            final_optimized_segments_for_task = optimized_segments_temp_timing_ui
                            description_for_ui_update_add_q = "K·ªãch b·∫£n t·ªëi ∆∞u (Timing ∆∞·ªõc l∆∞·ª£ng - Map l·ªói)"
                    else:
                        logging.info(f"{log_prefix_add_q}   Kh√¥ng c√≥ timing g·ªëc ƒë·ªÉ √°nh x·∫°. S·ª≠ d·ª•ng timing ∆∞·ªõc t√≠nh.")
                        final_optimized_segments_for_task = optimized_segments_temp_timing_ui
                        description_for_ui_update_add_q = "K·ªãch b·∫£n t·ªëi ∆∞u (Timing ∆∞·ªõc l∆∞·ª£ng)"
                    
                    if final_optimized_segments_for_task:
                        self._update_dub_textbox_post_processing(list(final_optimized_segments_for_task), description_for_ui_update_add_q)
                        srt_data_for_task_creation = list(final_optimized_segments_for_task) # G√°n d·ªØ li·ªáu ƒë√£ t·ªëi ∆∞u
                        if script_display_name_for_task_config and "K·ªãch b·∫£n GPT" not in script_display_name_for_task_config and "(T·ªëi ∆∞u" not in script_display_name_for_task_config:
                            script_display_name_for_task_config += " (T·ªëi ∆∞u Dub)"
                        logging.info(f"{log_prefix_add_q}   ƒê√£ t·ªëi ∆∞u v√† c·∫≠p nh·∫≠t UI. Worker s·∫Ω kh√¥ng t·ªëi ∆∞u l·∫°i.")
                    else:
                        logging.warning(f"{log_prefix_add_q}   Kh√¥ng c√≥ segment n√†o sau t·ªëi ∆∞u h√≥a v√†/ho·∫∑c √°nh x·∫°. Gi·ªØ k·ªãch b·∫£n g·ªëc.")
                else:
                    logging.warning(f"{log_prefix_add_q}   Parse text ƒë·ªÉ t·ªëi ∆∞u h√≥a tr·∫£ v·ªÅ r·ªóng. Gi·ªØ k·ªãch b·∫£n g·ªëc.")
            else:
                logging.info(f"{log_prefix_add_q}   Kh√¥ng c√≥ n·ªôi dung text ƒë·ªÉ t·ªëi ∆∞u h√≥a. Gi·ªØ k·ªãch b·∫£n g·ªëc.")
                
        else: # UI "T·ªëi ∆∞u lu·ªìng ƒë·ªçc" T·∫ÆT v√† is_already_optimized_for_dub c≈©ng l√† False
            logging.info(f"{log_prefix_add_q} 'T·ªëi ∆∞u lu·ªìng ƒë·ªçc' (UI) T·∫ÆT v√† kh√¥ng c√≥ c·ªù t·ªëi ∆∞u tr∆∞·ªõc. S·ª≠ d·ª•ng k·ªãch b·∫£n g·ªëc.")
            # N·∫øu k·ªãch b·∫£n g·ªëc (initial_srt_data_from_ui) ch∆∞a ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë√∫ng tr√™n textbox, c·∫≠p nh·∫≠t l·∫°i
            current_textbox_text_addq_no_opt = self.dub_script_textbox.get("1.0", "end-1c")
            formatted_initial_srt_addq_no_opt = format_srt_data_to_string(initial_srt_data_from_ui)
            if initial_srt_data_from_ui and current_textbox_text_addq_no_opt.strip() != formatted_initial_srt_addq_no_opt.strip():
                 self._update_dub_textbox_post_processing(list(initial_srt_data_from_ui), "K·ªãch b·∫£n g·ªëc (T·ªëi ∆∞u Dub T·∫Øt)")
                 logging.info(f"{log_prefix_add_q}   ƒê√£ l√†m m·ªõi textbox v·ªõi k·ªãch b·∫£n g·ªëc (do Optimize T·∫ÆT v√† textbox c√≥ th·ªÉ kh√°c).")
            # Trong tr∆∞·ªùng h·ª£p n√†y, worker_should_run_optimization m·∫∑c ƒë·ªãnh l√† False, nghƒ©a l√† worker s·∫Ω d√πng srt_data_for_task_creation (l√† b·∫£n g·ªëc)
            # N·∫øu b·∫°n mu·ªën worker t·ª± t·ªëi ∆∞u khi UI t·∫Øt, b·∫°n c·∫ßn ƒë·∫∑t worker_should_run_optimization = True ·ªü ƒë√¢y.
            # Tuy nhi√™n, logic hi·ªán t·∫°i l√† n·∫øu UI t·∫Øt th√¨ worker c≈©ng kh√¥ng t·ªëi ∆∞u.

        is_direct_audio_mux_for_task = False
        if not srt_data_for_task_creation and selected_audio_file_path_for_task: # Ki·ªÉm tra srt_data_for_task_creation sau khi ƒë√£ t·ªëi ∆∞u
            is_direct_audio_mux_for_task = True
            if not script_display_name_for_task_config or script_display_name_for_task_config == "(Ch∆∞a ch·ªçn script)" or script_display_name_for_task_config == "K·ªãch b·∫£n hi·ªán t·∫°i":
                script_display_name_for_task_config = "(Ch·ªâ gh√©p Audio ngo√†i)"
        
        if not srt_data_for_task_creation and not selected_audio_file_path_for_task:
            messagebox.showerror("Thi·∫øu K·ªãch b·∫£n ho·∫∑c Audio",
                                 "Vui l√≤ng cung c·∫•p K·ªãch b·∫£n (SRT/text) HO·∫∂C m·ªôt file Audio ngo√†i h·ª£p l·ªá.",
                                 parent=self)
            logging.warning(f"{log_prefix_add_q} Kh√¥ng th·ªÉ th√™m: Thi·∫øu c·∫£ K·ªãch b·∫£n (sau t·ªëi ∆∞u) v√† Audio ngo√†i.")
            return

        # --- LOGIC L·∫§Y TH∆Ø M·ª§C OUTPUT ---
        # ∆Øu ti√™n 1: L·∫•y ƒë∆∞·ªùng d·∫´n ghi ƒë√® t·ª´ chu·ªói tr∆∞·ªõc ƒë√≥ (v√≠ d·ª•: th∆∞ m·ª•c Imagen)
        if output_dir_override and os.path.isdir(output_dir_override):
            output_path_for_task = output_dir_override
            logging.info(f"{log_prefix_add_q} ∆Øu ti√™n 1: S·ª≠ d·ª•ng th∆∞ m·ª•c output ƒë∆∞·ª£c ghi ƒë√® t·ª´ chu·ªói tr∆∞·ªõc ƒë√≥: {output_path_for_task}")
        # ∆Øu ti√™n 2: N·∫øu kh√¥ng c√≥ ghi ƒë√®, d√πng ƒë∆∞·ªùng d·∫´n t·ª´ UI c·ªßa tab Thuy·∫øt Minh
        elif self.dub_output_path_var.get() and os.path.isdir(self.dub_output_path_var.get()):
            output_path_for_task = self.dub_output_path_var.get()
            logging.info(f"{log_prefix_add_q} ∆Øu ti√™n 2: S·ª≠ d·ª•ng th∆∞ m·ª•c output t·ª´ UI tab Thuy·∫øt Minh: {output_path_for_task}")
        # ∆Øu ti√™n 3: Fallback cu·ªëi c√πng l√† th∆∞ m·ª•c Downloads m·∫∑c ƒë·ªãnh
        else:
            output_path_for_task = get_default_downloads_folder()
            logging.warning(f"{log_prefix_add_q} ∆Øu ti√™n 3: Fallback v·ªÅ th∆∞ m·ª•c Downloads m·∫∑c ƒë·ªãnh: {output_path_for_task}")

        task_config = {
            'id': str(uuid.uuid4()),
            'identifier': final_identifier_for_task,
            'video_path': current_video_file_for_task,
            'video_display_name': os.path.basename(current_video_file_for_task),
            'script_path': script_path_for_task_config, # ƒê∆∞·ªùng d·∫´n g·ªëc ho·∫∑c "text_input..."
            'script_display_name': script_display_name_for_task_config, # T√™n hi·ªÉn th·ªã ƒë√£ c√≥ th·ªÉ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
            'srt_data_content': list(srt_data_for_task_creation), # D·ªØ li·ªáu SRT cu·ªëi c√πng cho worker
            'audio_path_config': selected_audio_file_path_for_task,
            'audio_display_name': os.path.basename(selected_audio_file_path_for_task) if selected_audio_file_path_for_task else None,
            'is_direct_audio_mux': is_direct_audio_mux_for_task,
            'status': 'Ch·ªù x·ª≠ l√Ω',
            'output_path_config': output_path_for_task,
            'tts_engine_config': self.dub_selected_tts_engine_var.get(),
            'voice_id_config': self.dub_selected_voice_id_var.get(),
            'voice_display_name_config': self.dub_selected_voice_display_name_var.get(),
            'google_ssml_config': self.dub_use_google_ssml_var.get(),
            'openai_tts_model_config': self.dub_openai_tts_model,
            'background_audio_option_config': self.dub_background_audio_option_var.get(),
            'background_mix_level_config': self.dub_background_mix_level_var.get(),
            'use_custom_bg_music_config': self.dub_use_custom_bg_music_var.get(),
            'custom_bg_music_path_config': self.dub_custom_bg_music_path_var.get(),
            'custom_bg_music_volume_config': self.get_validated_custom_bg_volume_float(),
            'sync_tolerance_ms_config': safe_int(self.dub_sync_tolerance_ms_var.get(), 20),
            'sync_max_speed_up_config': float(self.dub_sync_max_speed_up_var.get()) if self.dub_sync_max_speed_up_var.get() else 1.50,
            'sync_min_speed_down_val_config': self.dub_sync_min_speed_down_var.get(),
            'sync_force_cut_config': self.dub_sync_force_cut_if_over_srt_duration_var.get(),
            'sync_min_srt_duration_config': safe_int(self.dub_sync_min_srt_duration_for_adjust_ms_var.get(), 200),
            'sync_pad_short_tts_config': self.dub_sync_pad_short_tts_var.get(),
            'min_gap_between_segments_ms_config': safe_int(self.dub_min_gap_between_segments_ms_var.get(), 0),
            'audio_fade_in_duration_s_config': float(self.dub_audio_fade_in_duration_s_var.get()) if self.dub_audio_fade_in_duration_s_var.get() else 0.05,
            'audio_fade_out_duration_s_config': float(self.dub_audio_fade_out_duration_s_var.get()) if self.dub_audio_fade_out_duration_s_var.get() else 0.03,
            'optimize_flow_requested_in_worker': worker_should_run_optimization, # S·∫Ω lu√¥n False n·∫øu UI t·ªëi ∆∞u
            'dub_flow_parameters_from_ui': { 
                'dub_flow_split_enabled': self.dub_split_enabled_for_flow_var.get(),
                'dub_flow_max_chars': safe_int(self.dub_max_chars_for_flow_var.get(), 999),
                'dub_flow_max_lines': safe_int(self.dub_max_lines_for_flow_var.get(), 1),
                'dub_flow_split_mode': self.dub_split_mode_for_flow_var.get(),
                'DEFAULT_CPS_FOR_TIMING': safe_int(self.dub_cps_for_timing_var.get(), 17)
            },
            'result_video_path': None,
            'error_message': None,
            'is_part_of_sub_dub_chain': self.chain_download_sub_dub_active,
            'was_optimize_tts_source_enabled_in_sub_step': optimize_tts_source_flag_from_sub 
        }
        logging.info(f"{log_prefix_add_q} Task config s·∫Ω ƒë∆∞·ª£c th√™m. OptimizeInWorker: {task_config['optimize_flow_requested_in_worker']}, isAlreadyOptimizedForDubInput: {is_already_optimized_for_dub}")

        self.dub_processing_queue.append(task_config)
        
        # Reset c√°c l·ª±a ch·ªçn t·∫°m th·ªùi tr√™n UI
        self.dub_current_video_path_for_queue_temp = ""
        if hasattr(self, 'dub_current_video_for_queue_display'):
            self.dub_current_video_for_queue_display.set("(Ch∆∞a ch·ªçn video/·∫£nh)")
        
        self.dub_audio_path_for_queue_temp = ""
        if hasattr(self, 'dub_current_audio_for_queue_display'):
            self.dub_current_audio_for_queue_display.set("(Ch∆∞a ch·ªçn audio)")

        self.dub_current_script_path_for_queue_temp = "" 
        self.dub_temp_srt_data_for_queue = [] # QUAN TR·ªåNG: Reset d·ªØ li·ªáu t·∫°m sau khi ƒë√£ th√™m v√†o task config
        if hasattr(self, 'dub_current_script_for_queue_display'):
            self.dub_current_script_for_queue_display.set("(Ch∆∞a ch·ªçn script)")
        
        # Gi·ªØ l·∫°i n·ªôi dung textbox sau khi th√™m v√†o h√†ng ch·ªù, thay v√¨ x√≥a v√† ƒë·∫∑t placeholder
        # (Logic n√†y kh√¥ng thay ƒë·ªïi)
        
        self.update_dub_queue_display()
        task_display_name_for_status_add = task_config.get('video_display_name', 'T√°c v·ª• m·ªõi')
        self.update_status(f"‚ÑπÔ∏è ƒê√£ th√™m '{task_display_name_for_status_add}' v√†o h√†ng ch·ªù thuy·∫øt minh.")
        
        self._update_dub_script_controls_state() 
        self._update_dub_start_batch_button_state() 

        logging.info(f"{log_prefix_add_q} ƒê√£ th√™m t√°c v·ª•. H√†ng ch·ªù: {len(self.dub_processing_queue)} m·ª•c. C√°c l·ª±a ch·ªçn UI ƒë√£ ƒë∆∞·ª£c reset.")


# H√ÄM TR√ÅI TIM C·ª¶A TI·∫æN TR√åNH THUY·∫æT MINH H√ÄNG LO·∫†T
# H√†m thu th·∫≠p th√¥ng tin h√†ng ch·ªù
    def _dub_process_next_item_in_queue(self):
        if self.dub_stop_event.is_set():
            logging.info("[DubBatch] Ph√°t hi·ªán y√™u c·∫ßu d·ª´ng (ƒë·∫ßu _dub_process_next_item_in_queue). K·∫øt th√∫c x·ª≠ l√Ω h√†ng lo·∫°t.")
            self.dub_on_batch_finished(stopped=True)
            return

        if not self.dub_processing_queue:
            logging.info("[DubBatch] H√†ng ch·ªù thuy·∫øt minh tr·ªëng (trong _dub_process_next_item_in_queue). K·∫øt th√∫c x·ª≠ l√Ω h√†ng lo·∫°t.")
            self.dub_on_batch_finished(stopped=False)
            return

        current_task = self.dub_processing_queue[0]
        self.dub_currently_processing_task_id = current_task.get('id')

        current_task['status'] = 'ƒêang x·ª≠ l√Ω...'
        if hasattr(self, 'update_dub_queue_display'):
            self.update_dub_queue_display()

        video_name_log = current_task.get('video_display_name', 'N/A')
        script_name_log_display = current_task.get('script_display_name', 'N/A')
        audio_name_log_display = current_task.get('audio_display_name', 'Kh√¥ng c√≥')
        
        logging.info(f"[DubBatch] === B·∫Øt ƒë·∫ßu x·ª≠ l√Ω t√°c v·ª• ID: {self.dub_currently_processing_task_id} ===")
        logging.info(f"[DubBatch] Video: {video_name_log}, Script: {script_name_log_display}, Audio ngo√†i: {audio_name_log_display}")
        self.update_status(f"Dub H√†ng lo·∫°t: ƒêang x·ª≠ l√Ω '{video_name_log}'...")
        # --- KH√îI PH·ª§C C·∫§U H√åNH T√ÅC V·ª§ ---
        self._is_restoring_task_config = True # C·ªù b√°o hi·ªáu ƒëang kh√¥i ph·ª•c config   
        try:
            logging.debug(f"[DubBatchRestore] B·∫Øt ƒë·∫ßu kh√¥i ph·ª•c UI config cho task ID: {self.dub_currently_processing_task_id}")

            # === L·∫§Y TH√îNG TIN T·ªêI ∆ØU LU·ªíNG ƒê·ªåC T·ª™ TASK CONFIG ===
            self.current_task_optimize_flow_requested = current_task.get('optimize_flow_requested', False)
            self.current_task_dub_flow_parameters = current_task.get('dub_flow_parameters', {})
            # >>> TH√äM D√íNG N√ÄY ƒê·ªÇ ƒê·ªåC C·ªú M·ªöI T·ª™ SUB STEP <<<
            self.current_task_was_optimize_tts_source_enabled_in_sub = current_task.get('was_optimize_tts_source_enabled_in_sub_step', False)
            # Log tr·∫°ng th√°i c√°c c·ªù t·ªëi ∆∞u
            if self.current_task_optimize_flow_requested:
                logging.info(f"[DubBatchRestore] T√°c v·ª• n√†y Y√äU C·∫¶U t·ªëi ∆∞u lu·ªìng ƒë·ªçc (do UI tab Dubbing). Params: {self.current_task_dub_flow_parameters}")
            elif self.current_task_was_optimize_tts_source_enabled_in_sub:
                logging.info(f"[DubBatchRestore] T√°c v·ª• n√†y KH√îNG y√™u c·∫ßu t·ªëi ∆∞u lu·ªìng ƒë·ªçc b·ªüi UI tab Dubbing, NH∆ØNG c·ªù t·ªëi ∆∞u ngu·ªìn TTS t·ª´ SUB step ƒë√£ ƒë∆∞·ª£c B·∫¨T.")
            else:
                logging.info(f"[DubBatchRestore] T√°c v·ª• n√†y KH√îNG y√™u c·∫ßu t·ªëi ∆∞u lu·ªìng ƒë·ªçc (c·∫£ t·ª´ UI Dub v√† Sub step).")
            # ======================================================
            
            # 1. Kh√¥i ph·ª•c th∆∞ m·ª•c output (chung cho task)
            self.dub_output_path_var.set(
                current_task.get('output_path_config', self.cfg.get("dub_output_path", get_default_downloads_folder()))
            )

            # 2. Kh√¥i ph·ª•c Engine TTS v√† Gi·ªçng ƒë·ªçc
            task_engine_config = current_task.get('tts_engine_config', self.cfg.get("dub_tts_engine", "Google Translate (gTTS)"))
            self.dub_selected_tts_engine_var.set(task_engine_config)
            # G·ªçi dub_on_tts_engine_selected ƒë·ªÉ c·∫≠p nh·∫≠t danh s√°ch gi·ªçng ƒë·ªçc cho engine n√†y
            # v√† n√≥ s·∫Ω t·ª± x·ª≠ l√Ω vi·ªác ch·ªçn gi·ªçng t·ª´ self.dub_selected_voice_id_var (ƒë∆∞·ª£c set ngay sau ƒë√¢y)
            if hasattr(self, 'dub_on_tts_engine_selected'):
                 # Truy·ªÅn _from_task_setup=True ƒë·ªÉ dub_on_tts_engine_selected kh√¥ng t·ª± √Ω ch·ªçn gi·ªçng m·∫∑c ƒë·ªãnh/l∆∞u chung
                self.dub_on_tts_engine_selected(task_engine_config, _from_task_setup=True)
            
            task_voice_id_config = current_task.get('voice_id_config', self.cfg.get("dub_selected_voice_id", ""))
            self.dub_selected_voice_id_var.set(task_voice_id_config)
            
            # ƒêo·∫°n code n√†y s·∫Ω ƒë∆∞·ª£c th·ª±c thi sau khi dub_on_tts_engine_selected ƒë√£ c·∫≠p nh·∫≠t menu
            def _set_voice_display_name_after_menu_update():
                found_display_name_for_task = ""
                if hasattr(self, 'dub_current_engine_voice_display_to_id_map') and task_voice_id_config:
                    for disp_name, v_id in self.dub_current_engine_voice_display_to_id_map.items():
                        if v_id == task_voice_id_config:
                            found_display_name_for_task = disp_name
                            break
                if found_display_name_for_task and hasattr(self, 'dub_voice_option_menu') and hasattr(self.dub_voice_option_menu, 'values_dict') and found_display_name_for_task in getattr(self.dub_voice_option_menu, 'values_dict', {}):
                    self.dub_selected_voice_display_name_var.set(found_display_name_for_task)
                elif current_task.get('voice_display_name_config'):
                    # Fallback n·∫øu ID kh√¥ng t√¨m th·∫•y nh∆∞ng display name c√≥ trong task config
                    # (h·ªØu √≠ch n·∫øu map gi·ªçng ƒë·ªçc thay ƒë·ªïi nh∆∞ng mu·ªën gi·ªØ l·∫°i t√™n g·∫ßn ƒë√∫ng)
                    self.dub_selected_voice_display_name_var.set(current_task.get('voice_display_name_config'))
                else:
                    # Fallback cu·ªëi c√πng, ch·ªçn c√°i ƒë·∫ßu ti√™n h·ª£p l·ªá n·∫øu c√≥
                    first_choice = None
                    try:
                        if hasattr(self, 'dub_voice_option_menu'):
                            if hasattr(self.dub_voice_option_menu, 'filtered_list') and self.dub_voice_option_menu.filtered_list:
                                candidates = [n for n in self.dub_voice_option_menu.filtered_list if not n.startswith('---')]
                                if candidates:
                                    first_choice = candidates[0]
                            elif hasattr(self.dub_voice_option_menu, 'values_dict') and self.dub_voice_option_menu.values_dict:
                                candidates = [n for n in self.dub_voice_option_menu.values_dict.keys() if not n.startswith('---')]
                                if candidates:
                                    first_choice = candidates[0]
                    except Exception:
                        pass
                    if first_choice:
                        self.dub_selected_voice_display_name_var.set(first_choice)
                    else:
                        self.dub_selected_voice_display_name_var.set("N/A")
                logging.debug(f"[DubBatchRestore] Voice Display Name set to: {self.dub_selected_voice_display_name_var.get()} (ID was: {task_voice_id_config})")
            
            self.after(50, _set_voice_display_name_after_menu_update) # Ch·ªù m·ªôt ch√∫t ƒë·ªÉ menu gi·ªçng ƒë·ªçc c·∫≠p nh·∫≠t

            # 3. Kh√¥i ph·ª•c c√†i ƒë·∫∑t SSML (Google) v√† Model (OpenAI)
            if hasattr(self, 'dub_use_google_ssml_var'):
                self.dub_use_google_ssml_var.set(
                    current_task.get('google_ssml_config', self.cfg.get("dub_use_google_ssml", False))
                )
            if hasattr(self, 'dub_openai_tts_model'): # ƒê√¢y l√† thu·ªôc t√≠nh, kh√¥ng ph·∫£i StringVar
                self.dub_openai_tts_model = current_task.get('openai_tts_model_config', self.cfg.get("dub_openai_tts_model", "tts-1"))

            # 4. Kh√¥i ph·ª•c c√†i ƒë·∫∑t √Çm thanh n·ªÅn
            restored_bg_audio_option = current_task.get('background_audio_option_config', self.cfg.get("dub_background_audio_option", self.dub_background_audio_options[0]))
            self.dub_background_audio_option_var.set(restored_bg_audio_option)
            # G·ªçi h√†m c·∫≠p nh·∫≠t UI cho ph·∫ßn √¢m thanh n·ªÅn
            if hasattr(self, 'dub_on_background_audio_option_changed'):
                 self.after(60, lambda opt=restored_bg_audio_option: self.dub_on_background_audio_option_changed(opt, update_status=False)) # G·ªçi sau ƒë·ªÉ c√°c widget kh√°c k·ªãp t·∫°o

            self.dub_background_mix_level_var.set(
                current_task.get('background_mix_level_config', self.cfg.get("dub_background_mix_level", 0.30))
            )
            self.dub_use_custom_bg_music_var.set(
                current_task.get('use_custom_bg_music_config', self.cfg.get("dub_use_custom_bg_music", False))
            )
            self.dub_custom_bg_music_path_var.set(
                current_task.get('custom_bg_music_path_config', self.cfg.get("dub_custom_bg_music_path", ""))
            )
            custom_bg_vol_float_task = current_task.get('custom_bg_music_volume_config', self.cfg.get("dub_custom_bg_volume", 0.25))
            self.dub_custom_bg_music_volume_percent_str_var.set(str(int(custom_bg_vol_float_task * 100)))
            # G·ªçi h√†m c·∫≠p nh·∫≠t UI cho ph·∫ßn nh·∫°c n·ªÅn t√πy ch·ªânh
            if hasattr(self, 'dub_update_custom_bg_music_controls_visibility'):
                self.after(70, self.dub_update_custom_bg_music_controls_visibility)

            # 5. Kh√¥i ph·ª•c C√ÅC THAM S·ªê AUDIO N√ÇNG CAO V√ÄO StringVars/BooleanVars
            self.dub_sync_tolerance_ms_var.set(str(current_task.get('sync_tolerance_ms_config', self.cfg.get("dub_sync_tolerance_ms", 20))))
            self.dub_sync_max_speed_up_var.set(str(current_task.get('sync_max_speed_up_config', self.cfg.get("dub_sync_max_speed_up", "1.50"))))
            self.dub_sync_min_speed_down_var.set(str(current_task.get('sync_min_speed_down_val_config', self.cfg.get("dub_sync_min_speed_down_val", "1.0"))))
            self.dub_sync_force_cut_if_over_srt_duration_var.set(current_task.get('sync_force_cut_config', self.cfg.get("dub_sync_force_cut_if_over_srt_duration", True)))
            self.dub_sync_min_srt_duration_for_adjust_ms_var.set(str(current_task.get('sync_min_srt_duration_config', self.cfg.get("dub_sync_min_srt_duration_for_adjust_ms", 200))))            
            self.dub_sync_pad_short_tts_var.set(current_task.get('sync_pad_short_tts_config', self.cfg.get("dub_sync_pad_short_tts", True)))
            self.dub_min_gap_between_segments_ms_var.set(str(current_task.get('min_gap_between_segments_ms_config', self.cfg.get("dub_min_gap_between_segments_ms", 0))))
            self.dub_audio_fade_in_duration_s_var.set(str(current_task.get('audio_fade_in_duration_s_config', self.cfg.get("dub_audio_fade_in_duration_s", "0.05"))))
            self.dub_audio_fade_out_duration_s_var.set(str(current_task.get('audio_fade_out_duration_s_config', self.cfg.get("dub_audio_fade_out_duration_s", "0.03"))))
                                    
            # 6. Kh√¥i ph·ª•c ƒë∆∞·ªùng d·∫´n audio ngo√†i (n·∫øu c√≥) v√†o bi·∫øn t·∫°m th·ªùi cho worker
            self.dub_audio_path_for_queue_temp = current_task.get('audio_path_config', None)
            if self.dub_audio_path_for_queue_temp and os.path.exists(self.dub_audio_path_for_queue_temp):
                if hasattr(self, 'dub_current_audio_for_queue_display'):
                    self.dub_current_audio_for_queue_display.set(os.path.basename(self.dub_audio_path_for_queue_temp))
            elif hasattr(self, 'dub_current_audio_for_queue_display'):
                 self.dub_current_audio_for_queue_display.set("(Kh√¥ng c√≥/L·ªói)")

            self.is_current_task_direct_audio_mux = current_task.get('is_direct_audio_mux', False)

            # KH√îI PH·ª§C UI CHO CPS:
            # L·∫•y t·ª´ dub_flow_parameters_from_ui c·ªßa task, ho·∫∑c t·ª´ cfg chung n·∫øu kh√¥ng c√≥ trong task
            task_dub_flow_params = current_task.get('dub_flow_parameters_from_ui', {})
            cps_val_from_task_or_cfg = task_dub_flow_params.get('DEFAULT_CPS_FOR_TIMING', self.cfg.get("dub_cps_for_timing", 17))
            self.dub_cps_for_timing_var.set(str(cps_val_from_task_or_cfg))

            logging.info(f"[DubBatchRestore] Kh√¥i ph·ª•c UI config cho task {self.dub_currently_processing_task_id} th√†nh c√¥ng.")
        
        except Exception as e_restore_cfg:
            self._is_restoring_task_config = False 
            error_msg_restore = f"L·ªói kh√¥i ph·ª•c c·∫•u h√¨nh cho t√°c v·ª•: {e_restore_cfg}"
            logging.error(f"[DubBatch] {error_msg_restore}", exc_info=True)
            current_task['status'] = 'L·ªói C·∫•u h√¨nh Task' 
            current_task['error_message'] = error_msg_restore
            self.after(100, self._handle_single_dub_task_completion, False, None, error_msg_restore, False)
            return 
        finally:
            self._is_restoring_task_config = False # R·∫•t quan tr·ªçng: ƒê·∫∑t l·∫°i c·ªù n√†y
            logging.debug(f"[DubBatchRestore] ƒê√£ ƒë·∫∑t _is_restoring_task_config = False")

        # --- CHU·∫®N B·ªä D·ªÆ LI·ªÜU CHO WORKER ---
        self.dub_video_path = current_task.get('video_path')
        self.dub_srt_data = []
        
        # Chu·∫©n b·ªã c√°c tham s·ªë ƒë√£ x·ª≠ l√Ω (ki·ªÉu s·ªë) cho lu·ªìng worker
        # b·∫±ng c√°ch ƒë·ªçc t·ª´ current_task (l√† t·ª´ ƒëi·ªÉn c·∫•u h√¨nh c·ªßa t√°c v·ª•)
        logging.debug(f"[{threading.current_thread().name}] Chu·∫©n b·ªã tham s·ªë s·ªë cho worker t·ª´ current_task ID: {current_task.get('id')}")
        self._worker_cfg_sync_tolerance_ms = current_task.get('sync_tolerance_ms_config', 20)
        self._worker_cfg_sync_max_speed_up = current_task.get('sync_max_speed_up_config', 1.50)
        try:
            # ƒê·∫£m b·∫£o gi√° tr·ªã t·ª´ config ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi ƒë√∫ng sang float
            min_speed_down_val_str = str(current_task.get('sync_min_speed_down_val_config', "1.0"))
            self._worker_cfg_sync_min_speed_down = float(min_speed_down_val_str)
        except ValueError:
            logging.warning(f"Gi√° tr·ªã sync_min_speed_down_val_config kh√¥ng h·ª£p l·ªá: '{current_task.get('sync_min_speed_down_val_config', 'N/A')}'. D√πng m·∫∑c ƒë·ªãnh 1.0")
            self._worker_cfg_sync_min_speed_down = 1.0

        self._worker_cfg_sync_force_cut = current_task.get('sync_force_cut_config', True)
        self._worker_cfg_sync_min_srt_duration_ms = current_task.get('sync_min_srt_duration_config', 200) # T√™n key ƒë√∫ng l√† 'sync_min_srt_duration_config'
        self._worker_cfg_sync_pad_short_tts = current_task.get('sync_pad_short_tts_config', True)
        
        self._worker_cfg_audio_fade_in_s = current_task.get('audio_fade_in_duration_s_config', 0.05) # S·ª≠ d·ª•ng default t·ª´ c√¢u tr·∫£ l·ªùi tr∆∞·ªõc c·ªßa b·∫°n
        self._worker_cfg_audio_fade_out_s = current_task.get('audio_fade_out_duration_s_config', 0.03) # S·ª≠ d·ª•ng default t·ª´ c√¢u tr·∫£ l·ªùi tr∆∞·ªõc c·ªßa b·∫°n
        
        self._worker_cfg_allow_overflow_ms = getattr(self, 'CFG_ALLOW_OVERFLOW_MS', 100) 
        self._worker_cfg_min_silence_after_overflow_ms = getattr(self, 'CFG_MIN_SILENCE_AFTER_OVERFLOW_MS', 0)

        self._worker_cfg_selected_tts_engine = current_task.get('tts_engine_config', "Google Translate (gTTS)")
        self._worker_cfg_selected_voice_id = current_task.get('voice_id_config', "")
        self._worker_cfg_use_google_ssml = current_task.get('google_ssml_config', False)
        self._worker_cfg_openai_tts_model = current_task.get('openai_tts_model_config', "tts-1")

        # Ph·∫ßn chu·∫©n b·ªã self.dub_video_path, self.dub_srt_data v√† kh·ªüi ch·∫°y worker gi·ªØ nguy√™n
        self.dub_video_path = current_task.get('video_path')
        self.dub_srt_data = [] # Reset tr∆∞·ªõc khi g√°n

        srt_data_content_from_task_config = current_task.get('srt_data_content')
        error_preparing_script = False
        error_msg_script = ""

        if not self.is_current_task_direct_audio_mux: # Ch·ªâ c·∫ßn srt_data n·∫øu kh√¥ng ph·∫£i direct mux
            if srt_data_content_from_task_config and isinstance(srt_data_content_from_task_config, list):
                self.dub_srt_data = list(srt_data_content_from_task_config) # T·∫°o b·∫£n sao
                logging.info(f"[DubBatch] S·ª≠ d·ª•ng {len(self.dub_srt_data)} m·ª•c k·ªãch b·∫£n ƒë√£ l∆∞u trong task cho TTS.")
            else:
                error_msg_script = "T√°c v·ª• y√™u c·∫ßu TTS nh∆∞ng kh√¥ng c√≥ 'srt_data_content' h·ª£p l·ªá trong task_config."
                error_preparing_script = True
        else: # L√† direct audio mux
            logging.info(f"[DubBatch] T√°c v·ª• Direct Audio Mux, kh√¥ng y√™u c·∫ßu 'srt_data_content'.")
            self.dub_srt_data = [] # ƒê·∫£m b·∫£o r·ªóng
        
        if error_preparing_script:
            logging.error(f"[DubBatch] {error_msg_script}")
            current_task['status'] = 'L·ªói Script Task'; current_task['error_message'] = error_msg_script
            self.after(100, self._handle_single_dub_task_completion, False, None, error_msg_script, False)
            return
            
        # Ki·ªÉm tra l·∫°i n·∫øu c·∫ßn TTS m√† srt_data v·∫´n r·ªóng (v√≠ d·ª•: l·ªói logic ·ªü tr√™n)
        if not self.is_current_task_direct_audio_mux and not self.dub_srt_data:
            final_error_msg_empty_script = "Kh√¥ng c√≥ d·ªØ li·ªáu k·ªãch b·∫£n h·ª£p l·ªá ƒë·ªÉ t·∫°o TTS cho t√°c v·ª• n√†y."
            logging.error(f"[DubBatch] {final_error_msg_empty_script}")
            current_task['status'] = 'L·ªói Script (R·ªóng)'; current_task['error_message'] = final_error_msg_empty_script
            self.after(100, self._handle_single_dub_task_completion, False, None, final_error_msg_empty_script, False)
            return

        # Hi·ªÉn th·ªã script ƒëang x·ª≠ l√Ω l√™n textbox (n·∫øu c√≥)
        if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
            try:
                self.dub_script_textbox.configure(state="normal"); self.dub_script_textbox.delete("1.0", "end")
                script_content_for_display_processing = ""
                if self.dub_srt_data: # N·∫øu c√≥ script cho TTS
                    for item_idx, item_data in enumerate(self.dub_srt_data):
                        script_content_for_display_processing += f"{item_data.get('index', item_idx + 1)}\n{item_data.get('start_str', '00:00:00,000')} --> {item_data.get('end_str', '00:00:00,000')}\n{item_data.get('text', '')}\n\n"
                    self.dub_script_textbox.insert("1.0", script_content_for_display_processing.strip() + "\n")
                elif self.is_current_task_direct_audio_mux and audio_name_log_display != 'Kh√¥ng c√≥':
                    # Hi·ªÉn th·ªã th√¥ng tin v·ªÅ audio ngo√†i n·∫øu l√† direct mux
                    self.dub_script_textbox.insert("1.0", f"[T√°c v·ª• s·ª≠ d·ª•ng audio ngo√†i: {audio_name_log_display}. Kh√¥ng t·∫°o TTS t·ª´ script.]")
                else: # Tr∆∞·ªùng h·ª£p kh√¥ng c√≥ script v√† c≈©ng kh√¥ng ph·∫£i direct mux (l·ªói)
                     self.dub_script_textbox.insert("1.0", "[L·ªói: Kh√¥ng c√≥ k·ªãch b·∫£n ho·∫∑c audio ngo√†i cho t√°c v·ª• n√†y.]")
                self.dub_script_textbox.configure(state="disabled")
            except Exception as e_display_script_processing: 
                logging.error(f"[DubBatch] L·ªói hi·ªÉn th·ªã k·ªãch b·∫£n ƒëang x·ª≠ l√Ω: {e_display_script_processing}", exc_info=True)
        
        log_detail_for_worker = f"(DirectMux: {self.is_current_task_direct_audio_mux}, ScriptItems: {len(self.dub_srt_data)}, AudioNgo√†i: {os.path.basename(self.dub_audio_path_for_queue_temp) if self.dub_audio_path_for_queue_temp else 'Kh√¥ng'})"
        logging.info(f"[DubBatch] Chu·∫©n b·ªã ch·∫°y worker cho task ID: {self.dub_currently_processing_task_id} {log_detail_for_worker}.")
        dub_processing_thread = threading.Thread(target=self._execute_dub_task_worker_wrapper, daemon=True, name=f"DubTaskWorker_{self.dub_currently_processing_task_id[:8]}")
        dub_processing_thread.start()


# B√™n trong l·ªõp SubtitleApp
    def _execute_dub_task_worker_wrapper(self):

        task_id = self.dub_currently_processing_task_id
        if not task_id:
            logging.error("[DubTaskWorker_UnknownID] Kh√¥ng c√≥ ID t√°c v·ª• hi·ªán t·∫°i. Ng·ª´ng x·ª≠ l√Ω.")
            self.after(0, self._handle_single_dub_task_completion, False, None, "L·ªói n·ªôi b·ªô: Thi·∫øu ID t√°c v·ª•", False)
            return

        worker_log_prefix = f"[DubTaskWorker_{task_id[:6]}]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu x·ª≠ l√Ω t√°c v·ª•.")
        
        logging.info(f"{worker_log_prefix} === KI·ªÇM TRA ƒê·∫¶U V√ÄO WORKER ===")
        logging.info(f"{worker_log_prefix}   Video Path (self.dub_video_path): {getattr(self, 'dub_video_path', 'N/A')}")
        logging.info(f"{worker_log_prefix}   Direct Audio Mux (self.is_current_task_direct_audio_mux): {getattr(self, 'is_current_task_direct_audio_mux', 'N/A')}")
        # L·∫•y gi√° tr·ªã t·ª´ self.attribute ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p
        logging.info(f"{worker_log_prefix}   Optimize Flow Requested (self.current_task_optimize_flow_requested): {getattr(self, 'current_task_optimize_flow_requested', 'N/A')}")
        logging.info(f"{worker_log_prefix}   Dub Flow Parameters (self.current_task_dub_flow_parameters): {getattr(self, 'current_task_dub_flow_parameters', 'N/A')}")
        
        num_srt_segments = 0
        # self.dub_srt_data ƒë√£ ƒë∆∞·ª£c set b·ªüi _dub_process_next_item_in_queue v·ªõi srt_data_content t·ª´ task_config
        if hasattr(self, 'dub_srt_data') and self.dub_srt_data: 
            num_srt_segments = len(self.dub_srt_data)
            if num_srt_segments > 0:
                logging.debug(f"{worker_log_prefix}     SRT g·ªëc (t·ª´ task config) - Seg 1 Text: '{self.dub_srt_data[0].get('text', 'N/A')[:50].replace(chr(10),' ')}...'")
        logging.info(f"{worker_log_prefix}   S·ªë l∆∞·ª£ng segment SRT (t·ª´ task config cho worker): {num_srt_segments}")
        logging.info(f"{worker_log_prefix} ================================")

        _worker_stopped_by_user = False
        _final_video_output_path_worker = None
        _error_message_worker = None
        _overall_success_worker = False
        
        video_input_path_task_worker = self.dub_video_path
        
        # C√°c th∆∞ m·ª•c t·∫°m cho t√°c v·ª• n√†y
        dub_temp_base_for_this_task = os.path.join(self.temp_folder, f"PiuDubTask_{task_id}")
        raw_tts_output_folder_for_this_task = os.path.join(dub_temp_base_for_this_task, "01_RawTTS")
        adjusted_segments_output_folder_for_this_task = os.path.join(dub_temp_base_for_this_task, "02_Adjusted")
        
        final_audio_track_for_muxing_worker = None

        video_basename = os.path.basename(video_input_path_task_worker) if video_input_path_task_worker else f"Task_{task_id[:6]}"
        with keep_awake(f"Dubbing: {video_basename}"):
            try:
                logging.info(f"{worker_log_prefix} Chu·∫©n b·ªã th∆∞ m·ª•c t·∫°m t·∫°i: {dub_temp_base_for_this_task}")
                if os.path.exists(dub_temp_base_for_this_task):
                    shutil.rmtree(dub_temp_base_for_this_task)
                os.makedirs(raw_tts_output_folder_for_this_task, exist_ok=True)
                os.makedirs(adjusted_segments_output_folder_for_this_task, exist_ok=True)
                
                if not video_input_path_task_worker or not os.path.exists(video_input_path_task_worker):
                    _error_message_worker = f"File video input '{video_input_path_task_worker}' cho t√°c v·ª• kh√¥ng t·ªìn t·∫°i."
                    logging.error(f"{worker_log_prefix} {_error_message_worker}")
                    raise FileNotFoundError(_error_message_worker)

                # --- A. CHU·∫®N B·ªä K·ªäCH B·∫¢N CHO VI·ªÜC T·∫†O TTS ---
                segments_for_tts_engine_processing = [] 

                # L·∫•y c√°c c·ªù v√† tham s·ªë t·ªëi ∆∞u t·ª´ c√°c thu·ªôc t√≠nh self 
                # (ƒë√£ ƒë∆∞·ª£c _dub_process_next_item_in_queue thi·∫øt l·∫≠p t·ª´ task_config c·ªßa t√°c v·ª• hi·ªán t·∫°i)
                should_worker_run_its_own_optimization = self.current_task_optimize_flow_requested 
                dub_flow_params_for_worker_optimization = self.current_task_dub_flow_parameters
                
                # self.dub_srt_data ƒë√£ ch·ª©a n·ªôi dung script (c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c t·ªëi ∆∞u ·ªü UI 
                # ho·∫∑c l√† b·∫£n g·ªëc, t√πy theo logic c·ªßa dub_add_to_processing_queue 
                # v√† gi√° tr·ªã 'srt_data_content' trong task_config khi t√°c v·ª• ƒë∆∞·ª£c t·∫°o)
                # ƒê√¢y l√† d·ªØ li·ªáu m√† worker s·∫Ω l√†m vi·ªác v·ªõi.
                script_data_worker_received_from_task = list(self.dub_srt_data) # T·∫°o b·∫£n sao

                if self.is_current_task_direct_audio_mux: # Bi·∫øn n√†y c≈©ng ƒë√£ ƒë∆∞·ª£c set t·ª´ task_config
                    logging.info(f"{worker_log_prefix} T√°c v·ª• Direct Audio Mux. S·∫Ω kh√¥ng t·∫°o TTS t·ª´ k·ªãch b·∫£n.")
                    segments_for_tts_engine_processing = [] # ƒê·∫£m b·∫£o r·ªóng
                
                elif should_worker_run_its_own_optimization and script_data_worker_received_from_task:
                    # Worker s·∫Ω ch·ªâ ch·∫°y t·ªëi ∆∞u h√≥a N·∫æU c·ªù 'optimize_flow_requested_in_worker' trong task_config l√† True
                    # V√Ä c√≥ d·ªØ li·ªáu script g·ªëc ƒë·ªÉ l√†m vi·ªác.
                    logging.info(f"{worker_log_prefix} WORKER: C·ªù t·ªëi ∆∞u ('optimize_flow_requested_in_worker') ƒëang B·∫¨T. B·∫Øt ƒë·∫ßu g·ªôp v√† chia l·∫°i k·ªãch b·∫£n...")
                    
                    all_original_text_parts_worker = [seg.get('text', '').strip() for seg in script_data_worker_received_from_task if seg.get('text', '').strip()]
                    merged_plain_text_for_dub_worker = " ".join(all_original_text_parts_worker)
                    
                    # G·ªçi h√†m l√†m s·∫°ch ƒë·ªÉ lo·∫°i b·ªè metadata SRT n·∫øu c√≥
                    merged_plain_text_for_dub_worker = extract_dialogue_from_srt_string(merged_plain_text_for_dub_worker)

                    logging.debug(f"{worker_log_prefix} WORKER: VƒÉn b·∫£n ƒë√£ g·ªôp V√Ä L√ÄM S·∫†CH (d√†i {len(merged_plain_text_for_dub_worker)} chars): '{merged_plain_text_for_dub_worker[:100].replace(chr(10),' ')}...'")

                    if not merged_plain_text_for_dub_worker.strip():
                        _error_message_worker = "T·ªëi ∆∞u lu·ªìng ƒë·ªçc (Worker): VƒÉn b·∫£n sau g·ªôp v√† l√†m s·∫°ch t·ª´ SRT g·ªëc c·ªßa task b·ªã r·ªóng." # S·ª≠a l·∫°i log
                        logging.error(f"{worker_log_prefix} {_error_message_worker}")
                        raise ValueError(_error_message_worker)

                    # S·ª≠ d·ª•ng dub_flow_params_for_worker_optimization ƒë√£ l·∫•y t·ª´ task_config
                    logging.info(f"{worker_log_prefix} WORKER: Config t·ªëi ∆∞u t·ª´ task_config (dub_flow_parameters_from_ui): {dub_flow_params_for_worker_optimization}")
                    
                    optimized_segments_temp_timing_worker = self._parse_plain_text_to_srt_data(
                        merged_plain_text_for_dub_worker,
                        force_plain_text_processing=True, 
                        split_config_override=dub_flow_params_for_worker_optimization # S·ª≠ d·ª•ng params t·ª´ task
                    )

                    if not optimized_segments_temp_timing_worker:
                        _error_message_worker = "T·ªëi ∆∞u lu·ªìng ƒë·ªçc (Worker): Kh√¥ng th·ªÉ chia l·∫°i vƒÉn b·∫£n ƒë√£ g·ªôp."
                        logging.error(f"{worker_log_prefix} {_error_message_worker}")
                        raise ValueError(_error_message_worker)
                    
                    logging.info(f"{worker_log_prefix} WORKER: VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c chia l·∫°i th√†nh {len(optimized_segments_temp_timing_worker)} segment t·ªëi ∆∞u (v·ªõi timing t·∫°m th·ªùi).")

                    # √Ånh x·∫° timing t·ª´ script_data_worker_received_from_task (l√† d·ªØ li·ªáu g·ªëc m√† worker nh·∫≠n ƒë∆∞·ª£c cho task n√†y,
                    # n√≥ c√≥ th·ªÉ ch·ª©a timing g·ªëc n·∫øu ban ƒë·∫ßu l√† file SRT)
                    segments_for_tts_engine_processing = self._map_optimized_segments_to_original_srt_timings(
                        optimized_segments_temp_timing_worker, 
                        script_data_worker_received_from_task 
                    )

                    if not segments_for_tts_engine_processing:
                        _error_message_worker = "T·ªëi ∆∞u lu·ªìng ƒë·ªçc (Worker): L·ªói khi √°nh x·∫° timing g·ªëc."
                        logging.error(f"{worker_log_prefix} {_error_message_worker}")
                        raise RuntimeError(_error_message_worker)
                    
                    logging.info(f"{worker_log_prefix} WORKER: ƒê√£ t·ªëi ∆∞u v√† √°nh x·∫°. S·ªë segment cu·ªëi c√πng cho TTS: {len(segments_for_tts_engine_processing)}")
                    if segments_for_tts_engine_processing: # Log chi ti·∫øt
                        log_snippet_optimized_worker = "\n".join([
                            f"  Worker Seg {idx+1}: Start={s.get('start_ms',0):.0f}ms, End={s.get('end_ms',0):.0f}ms, Text='{s.get('text','')[:50].replace(chr(10),' ')}...'" 
                            for idx, s in enumerate(segments_for_tts_engine_processing[:3])
                        ])
                        logging.debug(f"{worker_log_prefix} WORKER: 3 segment ƒë·∫ßu sau khi t·ªëi ∆∞u v√† √°nh x·∫°:\n{log_snippet_optimized_worker}")
                    
                    # G·ªçi c·∫≠p nh·∫≠t UI n·∫øu worker th·ª±c s·ª± ƒë√£ thay ƒë·ªïi k·ªãch b·∫£n
                    # (Quan tr·ªçng: ƒë·∫£m b·∫£o ms_to_tc ƒë√£ ƒë∆∞·ª£c s·ª≠a)
                    self.after(0, self._update_dub_textbox_post_processing, list(segments_for_tts_engine_processing), "K·ªãch b·∫£n ƒë√£ t·ªëi ∆∞u (b·ªüi Worker)")


                elif script_data_worker_received_from_task: 
                    # Kh√¥ng t·ªëi ∆∞u trong worker (v√¨ c·ªù y√™u c·∫ßu l√† False, nghƒ©a l√† UI ƒë√£ x·ª≠ l√Ω HO·∫∂C UI t·∫Øt t·ªëi ∆∞u),
                    # v√† c√≥ d·ªØ li·ªáu script -> d√πng tr·ª±c ti·∫øp d·ªØ li·ªáu script n√†y.
                    logging.info(f"{worker_log_prefix} WORKER: C·ªù t·ªëi ∆∞u T·∫ÆT. S·ª≠ d·ª•ng {len(script_data_worker_received_from_task)} segment ƒë√£ c√≥ trong self.dub_srt_data cho TTS.")
                    segments_for_tts_engine_processing = list(script_data_worker_received_from_task)
                    # Textbox ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·ªüi _dub_process_next_item_in_queue v·ªõi n·ªôi dung n√†y r·ªìi,
                    # kh√¥ng c·∫ßn g·ªçi _update_dub_textbox_post_processing l·∫°i ·ªü ƒë√¢y tr·ª´ khi b·∫°n mu·ªën m·ªôt m√¥ t·∫£ kh√°c.
                
                else: # Kh√¥ng direct mux, kh√¥ng t·ªëi ∆∞u trong worker, v√† kh√¥ng c√≥ script_data_worker_received_from_task (l·ªói logic)
                    if not self.is_current_task_direct_audio_mux: # Ki·ªÉm tra l·∫°i ƒë·ªÉ ch·∫Øc ch·∫Øn
                        _error_message_worker = "L·ªói logic (Worker): Y√™u c·∫ßu TTS nh∆∞ng kh√¥ng c√≥ d·ªØ li·ªáu k·ªãch b·∫£n h·ª£p l·ªá t·ª´ task_config."
                        logging.error(f"{worker_log_prefix} {_error_message_worker}")
                        raise ValueError(_error_message_worker)
                
                # === K·∫æT TH√öC PH·∫¶N A: CHU·∫®N B·ªä K·ªäCH B·∫¢N CHO TTS ===
                
                # --- B. L·∫§Y C√ÅC C√ÄI ƒê·∫∂T X·ª¨ L√ù AUDIO ƒê√É ƒê∆Ø·ª¢C CHU·∫®N B·ªä CHO WORKER ---
                cfg_sync_tolerance_ms = getattr(self, '_worker_cfg_sync_tolerance_ms', 20)
                cfg_sync_max_speed_up = getattr(self, '_worker_cfg_sync_max_speed_up', 1.50)
                cfg_sync_min_speed_down = getattr(self, '_worker_cfg_sync_min_speed_down', 1.0)
                cfg_sync_force_cut = getattr(self, '_worker_cfg_sync_force_cut', True)
                cfg_sync_min_srt_duration_ms = getattr(self, '_worker_cfg_sync_min_srt_duration_ms', 200)
                cfg_sync_pad_short_tts = getattr(self, '_worker_cfg_sync_pad_short_tts', True)

                cfg_audio_fade_in_s = getattr(self, '_worker_cfg_audio_fade_in_s', 0.05)
                cfg_audio_fade_out_s = getattr(self, '_worker_cfg_audio_fade_out_s', 0.03)            
                cfg_allow_overflow_ms = getattr(self, '_worker_cfg_allow_overflow_ms', 100)
                cfg_min_silence_after_overflow_ms = getattr(self, '_worker_cfg_min_silence_after_overflow_ms', 0)

                # L·∫•y th√¥ng tin engine v√† voice cho worker
                selected_tts_engine_for_task = getattr(self, '_worker_cfg_selected_tts_engine', "Google Translate (gTTS)")
                logging.debug(f"{worker_log_prefix} C√°c config cho x·ª≠ l√Ω audio: Tol={cfg_sync_tolerance_ms}, MaxSpeed={cfg_sync_max_speed_up}, AllowOverflow={cfg_allow_overflow_ms}ms...")
                
                # --- C. X·ª¨ L√ù AUDIO (T·∫†O TTS HO·∫∂C D√ôNG AUDIO NGO√ÄI) ---
                if self.is_current_task_direct_audio_mux:
                    # C.1 X·ª¨ L√ù AUDIO NGO√ÄI (DIRECT MUX)
                    if self.dub_audio_path_for_queue_temp and os.path.exists(self.dub_audio_path_for_queue_temp):
                        logging.info(f"{worker_log_prefix} Direct Audio Mux. Chu·∫©n h√≥a audio ngo√†i: {os.path.basename(self.dub_audio_path_for_queue_temp)}")
                        standardized_external_audio_wav = os.path.join(adjusted_segments_output_folder_for_this_task, f"external_audio_std_{task_id[:6]}.wav")
                        if not self.dub_ffmpeg_standardize_to_wav(self.dub_audio_path_for_queue_temp, standardized_external_audio_wav):
                            _error_message_worker = "L·ªói chu·∫©n h√≥a file audio ngo√†i sang WAV."; raise RuntimeError(_error_message_worker)
                        
                        path_for_processing_external = standardized_external_audio_wav
                        external_audio_duration_s_for_fade = (self.dub_get_audio_duration_ms(path_for_processing_external) or 0) / 1000.0

                        # √Åp d·ª•ng fade cho audio ngo√†i n·∫øu c·∫ßn
                        if (cfg_audio_fade_in_s > 0 or cfg_audio_fade_out_s > 0) and \
                           external_audio_duration_s_for_fade > (cfg_audio_fade_in_s + cfg_audio_fade_out_s + cfg_fade_in_start_delay_s + 0.02):
                            faded_external_wav = os.path.join(adjusted_segments_output_folder_for_this_task, f"external_audio_faded_{task_id[:6]}.wav")
                            if self.dub_ffmpeg_apply_fade(path_for_processing_external, faded_external_wav, 
                                                         external_audio_duration_s_for_fade, 
                                                         cfg_audio_fade_in_s, cfg_audio_fade_out_s, cfg_fade_in_start_delay_s):
                                path_for_processing_external = faded_external_wav
                        
                        normalized_external_audio_mp3 = os.path.join(dub_temp_base_for_this_task, f"external_audio_norm_{task_id[:6]}.mp3")
                        if not self.dub_ffmpeg_convert_wav_to_mp3_normalized(path_for_processing_external, normalized_external_audio_mp3):
                            _error_message_worker = "L·ªói chu·∫©n h√≥a ƒë·ªô l·ªõn/chuy·ªÉn MP3 cho audio ngo√†i."; raise RuntimeError(_error_message_worker)
                        final_audio_track_for_muxing_worker = normalized_external_audio_mp3
                    else:
                        _error_message_worker = "L·ªói Direct Audio Mux: Kh√¥ng t√¨m th·∫•y file audio ngo√†i h·ª£p l·ªá trong t√°c v·ª•."
                        raise ValueError(_error_message_worker)
                
                elif segments_for_tts_engine_processing: # C.2 T·∫†O TTS T·ª™ K·ªäCH B·∫¢N
                    _total_segments_worker = len(segments_for_tts_engine_processing)
                    final_processed_audio_files_for_concat_task = []
                    selected_tts_engine_for_task = self.dub_selected_tts_engine_var.get()
                    _segments_successfully_processed_worker = 0
                    accumulated_timeline_ms = 0.0 # Theo d√µi timeline c·ªßa audio ƒë√£ gh√©p

                    logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu t·∫°o TTS cho {_total_segments_worker} segment(s) v·ªõi engine: {selected_tts_engine_for_task}")
                    if self.dub_stop_event.is_set(): _worker_stopped_by_user = True; raise InterruptedError("D·ª´ng tr∆∞·ªõc v√≤ng l·∫∑p segments TTS")

                    for segment_index_loop, current_segment_data in enumerate(segments_for_tts_engine_processing):
                        current_segment_display_index_loop = current_segment_data.get('index', segment_index_loop + 1)
                        if self.dub_stop_event.is_set(): _worker_stopped_by_user = True; break
                        
                        segment_log_prefix_tts_loop = f"{worker_log_prefix} Seg#{current_segment_display_index_loop}:"
                        
                        self.after(0, lambda ci=current_segment_display_index_loop, ts=_total_segments_worker, vn=os.path.basename(video_input_path_task_worker): \
                                self.update_status(f"üé§ ƒêang Thuy·∫øt Minh TTS: {vn[:20]}... - Seg {ci}/{ts}"))
                        
                        text_content_for_tts_loop = current_segment_data["text"]
                        # ƒê√¢y l√† timing c·ªßa NH√ìM SRT G·ªêC (n·∫øu ƒë√£ optimize) ho·∫∑c c·ªßa segment SRT g·ªëc (n·∫øu kh√¥ng optimize)
                        target_srt_start_time_ms = float(current_segment_data["start_ms"]) 
                        target_srt_end_time_ms = float(current_segment_data["end_ms"])
                        target_srt_duration_ms = target_srt_end_time_ms - target_srt_start_time_ms

                        logging.info(f"{segment_log_prefix_tts_loop} Target Timing: {target_srt_start_time_ms:.0f}ms -> {target_srt_end_time_ms:.0f}ms (Dur: {target_srt_duration_ms:.0f}ms)")
                        logging.info(f"{segment_log_prefix_tts_loop} Text cho TTS: '{text_content_for_tts_loop[:60].replace(chr(10),' ')}...'")

                        # --- C.2.i. B·ªè qua n·∫øu text r·ªóng ho·∫∑c duration m·ª•c ti√™u qu√° ng·∫Øn ---
                        if not text_content_for_tts_loop.strip() or target_srt_duration_ms < cfg_sync_min_srt_duration_ms :
                            logging.info(f"{segment_log_prefix_tts_loop} B·ªè qua (text r·ªóng ho·∫∑c duration m·ª•c ti√™u < {cfg_sync_min_srt_duration_ms}ms).")
                            silence_to_fill_skipped_segment_ms_loop = target_srt_end_time_ms - accumulated_timeline_ms
                            if silence_to_fill_skipped_segment_ms_loop > 10: # Ch·ªâ th√™m n·∫øu kho·∫£ng l·∫∑ng ƒë√°ng k·ªÉ
                                skipped_gap_file_loop = os.path.join(adjusted_segments_output_folder_for_this_task, f"gap_skipped_{current_segment_display_index_loop:04d}.wav")
                                if self.dub_ffmpeg_create_silence_file(skipped_gap_file_loop, silence_to_fill_skipped_segment_ms_loop):
                                    final_processed_audio_files_for_concat_task.append(skipped_gap_file_loop)
                                    accumulated_timeline_ms += silence_to_fill_skipped_segment_ms_loop
                                else: logging.error(f"{segment_log_prefix_tts_loop} (Skipped) L·ªói t·∫°o file silence l·∫•p ƒë·∫ßy.")
                            elif silence_to_fill_skipped_segment_ms_loop < -cfg_sync_tolerance_ms : # Timeline ƒë√£ v∆∞·ª£t qu√° nhi·ªÅu
                                 logging.warning(f"{segment_log_prefix_tts_loop} (Skipped) Timeline ({accumulated_timeline_ms:.0f}ms) ƒë√£ v∆∞·ª£t SRT end m·ª•c ti√™u ({target_srt_end_time_ms:.0f}ms) c·ªßa segment n√†y.")
                                 accumulated_timeline_ms = target_srt_end_time_ms # C·∫≠p nh·∫≠t timeline theo SRT end
                            else: # Kho·∫£ng l·∫∑ng qu√° nh·ªè ho·∫∑c timeline g·∫ßn kh·ªõp
                                 accumulated_timeline_ms = target_srt_end_time_ms # ƒê·ªìng b·ªô timeline v·ªõi ƒëi·ªÉm k·∫øt th√∫c SRT c·ªßa segment n√†y
                            logging.debug(f"{segment_log_prefix_tts_loop} (Skipped) Timeline sau khi l·∫•p ƒë·∫ßy/c·∫≠p nh·∫≠t: {accumulated_timeline_ms:.0f}ms")
                            continue

                        # --- C.2.ii. T·∫†O TTS TH√î ---
                        raw_tts_filepath_seg, duration_of_raw_tts_ms_seg = None, None
                        _tts_raw_ext_seg = ".mp3"; _tts_raw_fn_seg = f"rawtts_{current_segment_display_index_loop:04d}{_tts_raw_ext_seg}"
                        if selected_tts_engine_for_task == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)": _tts_raw_ext_seg = ".wav"; _tts_raw_fn_seg = f"rawtts_{current_segment_display_index_loop:04d}.wav"
                        raw_tts_filepath_seg = os.path.join(raw_tts_output_folder_for_this_task, _tts_raw_fn_seg)
                        
                        _text_for_engine_seg = text_content_for_tts_loop
                        if selected_tts_engine_for_task == "Google Cloud TTS" and self.dub_use_google_ssml_var.get():
                            if not (_text_for_engine_seg.strip().lower().startswith("<speak>") and _text_for_engine_seg.strip().lower().endswith("</speak>")):
                                _text_for_engine_seg = self.dub_generate_basic_ssml(_text_for_engine_seg)
                                logging.info(f"{segment_log_prefix_tts_loop} SSML ƒë∆∞·ª£c t·∫°o: {_text_for_engine_seg[:100]}...")
                        
                        _tts_call_res_seg = False
                        if selected_tts_engine_for_task == "OpenAI TTS": _tts_call_res_seg = self.dub_speak_with_openai(_text_for_engine_seg, raw_tts_filepath_seg, is_preview=False)
                        elif selected_tts_engine_for_task == "Google Cloud TTS": _tts_call_res_seg = self.dub_speak_with_google(_text_for_engine_seg, raw_tts_filepath_seg, is_preview=False)
                        elif selected_tts_engine_for_task == "Google Translate (gTTS)": _tts_call_res_seg = self.dub_speak_with_gtts(_text_for_engine_seg, raw_tts_filepath_seg, is_preview=False)
                        elif selected_tts_engine_for_task == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)":
                            if HAS_PYTTSX3 and callable(getattr(self, 'dub_speak_with_system_tts', None)): _tts_call_res_seg = self.dub_speak_with_system_tts(_text_for_engine_seg, raw_tts_filepath_seg, is_preview=False)
                            else: _tts_call_res_seg = "ERROR_SYSTEM_TTS_UNAVAILABLE"
                        
                        if isinstance(_tts_call_res_seg, str) and "ERROR_" in _tts_call_res_seg: # M√£ l·ªói API
                            _error_message_worker = f"L·ªói API ({_tts_call_res_seg}) (Seg #{current_segment_display_index_loop})."; self.dub_batch_had_api_key_errors = True; break
                        if _tts_call_res_seg == "STOPPED_BY_USER": _worker_stopped_by_user = True; _error_message_worker = "D·ª´ng b·ªüi ng∆∞·ªùi d√πng khi t·∫°o TTS."; break
                        if not _tts_call_res_seg: logging.error(f"{segment_log_prefix_tts_loop} L·ªói t·∫°o TTS th√¥."); continue # L·ªói TTS, b·ªè qua segment
                        
                        duration_of_raw_tts_ms_seg = self.dub_get_audio_duration_ms(raw_tts_filepath_seg)
                        if duration_of_raw_tts_ms_seg is None or duration_of_raw_tts_ms_seg <= 30: # 30ms l√† ng∆∞·ª°ng r·∫•t nh·ªè
                            logging.error(f"{segment_log_prefix_tts_loop} L·ªói l·∫•y duration TTS th√¥ ({duration_of_raw_tts_ms_seg}ms) ho·∫∑c duration qu√° ng·∫Øn. B·ªè qua segment."); continue
                        logging.info(f"{segment_log_prefix_tts_loop} TTS th√¥: {duration_of_raw_tts_ms_seg:.0f}ms")
                        
                        current_processed_audio_path_seg = raw_tts_filepath_seg
                        current_audio_duration_ms_seg = duration_of_raw_tts_ms_seg
                        if self.dub_stop_event.is_set(): _worker_stopped_by_user = True; break

                        # --- C.2.iii. ƒêI·ªÄU CH·ªàNH T·ªêC ƒê·ªò (n·∫øu c·∫ßn) ---
                        # (S·ª≠ d·ª•ng current_audio_duration_ms_seg v√† target_srt_duration_ms)
                        # current_processed_audio_path_seg v√† current_audio_duration_ms_seg ƒë∆∞·ª£c c·∫≠p nh·∫≠t
                        if abs(current_audio_duration_ms_seg - target_srt_duration_ms) > cfg_sync_tolerance_ms and \
                           target_srt_duration_ms >= cfg_sync_min_srt_duration_ms: # Ch·ªâ ƒëi·ªÅu ch·ªânh n·∫øu ch√™nh l·ªách ƒë√°ng k·ªÉ v√† SRT ƒë·ªß d√†i
                            speed_factor_seg = 1.0
                            if current_audio_duration_ms_seg > target_srt_duration_ms: # TTS d√†i h∆°n SRT -> tƒÉng t·ªëc TTS
                                calculated_speed_seg = current_audio_duration_ms_seg / float(target_srt_duration_ms)
                                speed_factor_seg = min(calculated_speed_seg, cfg_sync_max_speed_up)
                                speed_factor_seg = max(speed_factor_seg, 1.001) # ƒê·∫£m b·∫£o > 1
                            else: # TTS ng·∫Øn h∆°n SRT -> gi·∫£m t·ªëc TTS
                                calculated_speed_seg = current_audio_duration_ms_seg / float(target_srt_duration_ms)
                                speed_factor_seg = max(calculated_speed_seg, cfg_sync_min_speed_down)
                                if speed_factor_seg < 1.0: speed_factor_seg = min(speed_factor_seg, 0.999) # ƒê·∫£m b·∫£o < 1

                            if abs(speed_factor_seg - 1.0) > 0.001: # Ch·ªâ √°p d·ª•ng n·∫øu speed_factor th·ª±c s·ª± thay ƒë·ªïi
                                adj_speed_fn_seg = f"adj_speed_{current_segment_display_index_loop:04d}{os.path.splitext(current_processed_audio_path_seg)[1]}"
                                adj_speed_fp_seg = os.path.join(adjusted_segments_output_folder_for_this_task, adj_speed_fn_seg)
                                if self.dub_ffmpeg_adjust_audio_speed(current_processed_audio_path_seg, adj_speed_fp_seg, speed_factor_seg):
                                    current_processed_audio_path_seg = adj_speed_fp_seg
                                    current_audio_duration_ms_seg = self.dub_get_audio_duration_ms(current_processed_audio_path_seg) or 0
                                    logging.info(f"{segment_log_prefix_tts_loop} Sau ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô (x{speed_factor_seg:.3f}), duration m·ªõi: {current_audio_duration_ms_seg:.0f}ms")
                                else:
                                    logging.warning(f"{segment_log_prefix_tts_loop} L·ªói ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô. Gi·ªØ nguy√™n audio tr∆∞·ªõc ƒë√≥.")
                        if self.dub_stop_event.is_set(): _worker_stopped_by_user = True; break
                        
                        # --- C.2.iv. X·ª¨ L√ù C·∫ÆT/OVERFLOW V√Ä QUY·∫æT ƒê·ªäNH TH·ªúI L∆Ø·ª¢NG CU·ªêI CHO AUDIO ---
                        path_for_audio_segment_content_loop = current_processed_audio_path_seg
                        duration_of_audio_segment_content_ms_loop = current_audio_duration_ms_seg
                        final_effective_duration_for_this_segment_on_timeline_ms_loop = target_srt_duration_ms # M·∫∑c ƒë·ªãnh
                        this_segment_overflowed_ms_loop = 0.0

                        if cfg_sync_force_cut: # N·∫øu b·∫≠t "Lu√¥n c·∫Øt..."
                            time_difference_ms_loop = duration_of_audio_segment_content_ms_loop - target_srt_duration_ms
                            if time_difference_ms_loop > cfg_sync_tolerance_ms: # Audio d√†i h∆°n SRT ƒë√°ng k·ªÉ
                                if time_difference_ms_loop <= cfg_allow_overflow_ms: # Trong ng∆∞·ª°ng cho ph√©p overflow
                                    logging.info(f"{segment_log_prefix_tts_loop} Audio d√†i h∆°n SRT ({time_difference_ms_loop:.0f}ms) nh∆∞ng TRONG ng∆∞·ª°ng overflow ({cfg_allow_overflow_ms}ms). KH√îNG C·∫ÆT.")
                                    final_effective_duration_for_this_segment_on_timeline_ms_loop = duration_of_audio_segment_content_ms_loop # Th·ªùi l∆∞·ª£ng hi·ªáu d·ª•ng s·∫Ω l√† c·ªßa audio
                                    this_segment_overflowed_ms_loop = time_difference_ms_loop
                                else: # V∆∞·ª£t ng∆∞·ª°ng overflow -> PH·∫¢I C·∫ÆT
                                    logging.info(f"{segment_log_prefix_tts_loop} Audio d√†i h∆°n SRT ({time_difference_ms_loop:.0f}ms) v√† V∆Ø·ª¢T ng∆∞·ª°ng overflow ({cfg_allow_overflow_ms}ms). S·∫º C·∫ÆT.")
                                    duration_to_cut_to_ms_loop = target_srt_duration_ms # C·∫Øt v·ªÅ b·∫±ng SRT target
                                    
                                    # (Logic c·∫Øt b·∫±ng FFmpeg c·ªßa b·∫°n ·ªü ƒë√¢y, t∆∞∆°ng t·ª± nh∆∞ trong code g·ªëc,
                                    #  nh∆∞ng output l√† path_for_audio_segment_content_loop m·ªõi v√† c·∫≠p nh·∫≠t duration_of_audio_segment_content_ms_loop)
                                    # V√≠ d·ª•:
                                    cut_fn_loop = f"cut_{current_segment_display_index_loop:04d}{os.path.splitext(path_for_audio_segment_content_loop)[1]}"
                                    cut_fp_loop = os.path.join(adjusted_segments_output_folder_for_this_task, cut_fn_loop)
                                    if self.dub_ffmpeg_cut_audio(path_for_audio_segment_content_loop, cut_fp_loop, 0, duration_to_cut_to_ms_loop): # C·∫ßn h√†m dub_ffmpeg_cut_audio
                                         path_for_audio_segment_content_loop = cut_fp_loop
                                         duration_of_audio_segment_content_ms_loop = self.dub_get_audio_duration_ms(path_for_audio_segment_content_loop) or duration_to_cut_to_ms_loop
                                         logging.info(f"{segment_log_prefix_tts_loop} ƒê√£ c·∫Øt audio, th·ªùi l∆∞·ª£ng m·ªõi: {duration_of_audio_segment_content_ms_loop:.0f}ms.")
                                    else:
                                         logging.warning(f"{segment_log_prefix_tts_loop} L·ªói c·∫Øt audio. S·ª≠ d·ª•ng audio ch∆∞a c·∫Øt.")
                                    # final_effective_duration_for_this_segment_on_timeline_ms_loop v·∫´n l√† target_srt_duration_ms v√¨ ƒë√£ c·∫Øt
                        else: # Kh√¥ng b·∫≠t "Lu√¥n c·∫Øt..."
                            final_effective_duration_for_this_segment_on_timeline_ms_loop = duration_of_audio_segment_content_ms_loop # Th·ªùi l∆∞·ª£ng hi·ªáu d·ª•ng l√† c·ªßa audio
                            this_segment_overflowed_ms_loop = max(0, duration_of_audio_segment_content_ms_loop - target_srt_duration_ms)
                            if this_segment_overflowed_ms_loop > 0:
                                logging.info(f"{segment_log_prefix_tts_loop} Kh√¥ng c·∫Øt (do config). Audio d√†i h∆°n SRT ({this_segment_overflowed_ms_loop:.0f}ms). Th·ªùi l∆∞·ª£ng hi·ªáu d·ª•ng s·∫Ω l√† c·ªßa audio.")
                        
                        current_processed_audio_path_seg = path_for_audio_segment_content_loop # C·∫≠p nh·∫≠t l·∫°i sau khi c√≥ th·ªÉ ƒë√£ c·∫Øt
                        current_audio_duration_ms_seg = duration_of_audio_segment_content_ms_loop
                        if self.dub_stop_event.is_set(): _worker_stopped_by_user = True; break
                        
                        # --- C.2.v. CHU·∫®N B·ªä FILE AUDIO SEGMENT CU·ªêI C√ôNG (WAV, ƒê√É FADE) ---
                        # (Logic chu·∫©n h√≥a WAV, th√™m leading silence, fade in/out c·ªßa b·∫°n nh∆∞ tr∆∞·ªõc)
                        # path_after_fade v√† actual_duration_of_this_processed_segment_ms ƒë∆∞·ª£c tr·∫£ v·ªÅ
                        path_for_processing_further_loop = current_processed_audio_path_seg
                        duration_after_any_processing_loop = current_audio_duration_ms_seg

                        std_wav_fn_loop = f"std_{current_segment_display_index_loop:04d}.wav"
                        std_wav_fp_loop = os.path.join(adjusted_segments_output_folder_for_this_task, std_wav_fn_loop)
                        if not path_for_processing_further_loop.lower().endswith(".wav"):
                            if not self.dub_ffmpeg_standardize_to_wav(path_for_processing_further_loop, std_wav_fp_loop):
                                logging.error(f"{segment_log_prefix_tts_loop} L·ªói chu·∫©n h√≥a WAV. B·ªè qua segment."); continue
                            path_for_processing_further_loop = std_wav_fp_loop
                        elif os.path.abspath(path_for_processing_further_loop) != os.path.abspath(std_wav_fp_loop):
                            try: shutil.copy2(path_for_processing_further_loop, std_wav_fp_loop); path_for_processing_further_loop = std_wav_fp_loop
                            except Exception as e_copy_std_wav: logging.error(f"L·ªói copy WAV (std): {e_copy_std_wav}"); continue
                        duration_after_any_processing_loop = self.dub_get_audio_duration_ms(path_for_processing_further_loop) or 0
                        if duration_after_any_processing_loop <= 0: logging.error(f"{segment_log_prefix_tts_loop} L·ªói: Duration sau chu·∫©n h√≥a WAV l√† 0. B·ªè qua."); continue                    
                        
                        path_after_fade_loop = path_for_processing_further_loop # Kh·ªüi t·∫°o
                        duration_for_fade_input_s_loop = duration_after_any_processing_loop / 1000.0
                        min_dur_for_fade_loop = (cfg_audio_fade_in_s + cfg_audio_fade_out_s) + 0.0 + 0.02 
                        if duration_for_fade_input_s_loop > min_dur_for_fade_loop:
                            faded_wav_fn_loop = f"final_seg_{current_segment_display_index_loop:04d}.wav"
                            faded_wav_fp_loop = os.path.join(adjusted_segments_output_folder_for_this_task, faded_wav_fn_loop)
                            if self.dub_ffmpeg_apply_fade(path_for_processing_further_loop, faded_wav_fp_loop, 
                                                          duration_for_fade_input_s_loop, cfg_audio_fade_in_s, cfg_audio_fade_out_s, 
                                                          0.0):
                                path_after_fade_loop = faded_wav_fp_loop
                            else: logging.warning(f"{segment_log_prefix_tts_loop} L·ªói √°p d·ª•ng fade.")
                        
                        actual_duration_of_this_processed_segment_ms_loop = self.dub_get_audio_duration_ms(path_after_fade_loop) or 0
                        if actual_duration_of_this_processed_segment_ms_loop <= 0: logging.error(f"{segment_log_prefix_tts_loop} L·ªói: Duration sau fade l√† 0. B·ªè qua."); continue
                        logging.info(f"{segment_log_prefix_tts_loop} Audio segment ƒë√£ x·ª≠ l√Ω: {actual_duration_of_this_processed_segment_ms_loop:.0f}ms. Path: {os.path.basename(path_after_fade_loop)}")
                        if self.dub_stop_event.is_set(): _worker_stopped_by_user = True; break

                        # --- C.2.vi. T√çNH TO√ÅN V√Ä TH√äM KHO·∫¢NG L·∫∂NG ƒê·ªÇ KH·ªöP TIMELINE ---
                        # Kho·∫£ng l·∫∑ng TR∆Ø·ªöC segment n√†y (so v·ªõi timeline ƒë√£ t√≠ch l≈©y)
                        silence_needed_before_ms = target_srt_start_time_ms - accumulated_timeline_ms
                        if this_segment_overflowed_ms_loop > 0: # N·∫øu segment n√†y ƒë∆∞·ª£c ph√©p d√†i h∆°n SRT
                            # V√† n·∫øu segment TR∆Ø·ªöC ƒê√ì c≈©ng overflow, th√¨ kho·∫£ng l·∫∑ng tr∆∞·ªõc ƒë√≥ c√≥ th·ªÉ ƒë√£ b·ªã gi·∫£m
                            # C·∫ßn ƒë·∫£m b·∫£o c√≥ √≠t nh·∫•t `cfg_min_silence_after_overflow_ms` n·∫øu c√≥ th·ªÉ
                            # Ph·∫ßn n√†y ph·ª©c t·∫°p, t·∫°m th·ªùi gi·ªØ logic ƒë∆°n gi·∫£n: n·∫øu overflow th√¨ c√≥ th·ªÉ kh√¥ng c·∫ßn th√™m nhi·ªÅu silence tr∆∞·ªõc.
                            pass
                        
                        if silence_needed_before_ms > 10:
                            # ... (logic t·∫°o v√† th√™m file silence TR∆Ø·ªöC, c·∫≠p nh·∫≠t accumulated_timeline_ms)
                            gap_before_file_name_loop = f"gap_before_{current_segment_display_index_loop:04d}.wav"
                            gap_before_file_path_loop = os.path.join(adjusted_segments_output_folder_for_this_task, gap_before_file_name_loop)
                            if self.dub_ffmpeg_create_silence_file(gap_before_file_path_loop, silence_needed_before_ms):
                                final_processed_audio_files_for_concat_task.append(gap_before_file_path_loop)
                                accumulated_timeline_ms += silence_needed_before_ms
                        elif silence_needed_before_ms < -cfg_sync_tolerance_ms and not (this_segment_overflowed_ms_loop > 0):
                            logging.warning(f"{segment_log_prefix_tts_loop} Timeline b·ªã √¢m ({silence_needed_before_ms:.0f}ms) TR∆Ø·ªöC segment. Accumulated: {accumulated_timeline_ms:.0f}, TargetStart: {target_srt_start_time_ms:.0f}")
                            # N·∫øu timeline ƒë√£ v∆∞·ª£t qu√° ƒëi·ªÉm b·∫Øt ƒë·∫ßu mong mu·ªën, c√≥ th·ªÉ c·∫ßn c·∫Øt b·ªõt audio tr∆∞·ªõc ƒë√≥ ho·∫∑c ch·∫•p nh·∫≠n l·ªách
                            # Hi·ªán t·∫°i, s·∫Ω ch·ªâ log v√† ti·∫øp t·ª•c, audio n√†y s·∫Ω b·∫Øt ƒë·∫ßu mu·ªôn h∆°n d·ª± ki·∫øn tr√™n timeline
                            # Ho·∫∑c, ƒë·∫∑t l·∫°i accumulated_timeline_ms v·ªÅ target_srt_start_time_ms n·∫øu mu·ªën "reset" t·∫°i ƒëi·ªÉm n√†y
                            # accumulated_timeline_ms = target_srt_start_time_ms


                        final_processed_audio_files_for_concat_task.append(path_after_fade_loop)
                        accumulated_timeline_ms += actual_duration_of_this_processed_segment_ms_loop
                        
                        # Kho·∫£ng l·∫∑ng SAU segment (ƒë·ªÉ pad n·∫øu audio ng·∫Øn h∆°n v√† cfg_sync_pad_short_tts=True)
                        # ƒêi·ªÉm k·∫øt th√∫c MONG MU·ªêN tr√™n timeline cho segment n√†y
                        target_end_point_for_segment_on_timeline_ms = target_srt_start_time_ms + final_effective_duration_for_this_segment_on_timeline_ms_loop

                        if cfg_sync_pad_short_tts:
                            silence_needed_after_ms = target_end_point_for_segment_on_timeline_ms - accumulated_timeline_ms
                            if silence_needed_after_ms > 10:
                                # ... (logic t·∫°o v√† th√™m file silence SAU, c·∫≠p nh·∫≠t accumulated_timeline_ms)
                                gap_after_file_name_loop = f"gap_after_{current_segment_display_index_loop:04d}.wav"
                                gap_after_file_path_loop = os.path.join(adjusted_segments_output_folder_for_this_task, gap_after_file_name_loop)
                                if self.dub_ffmpeg_create_silence_file(gap_after_file_path_loop, silence_needed_after_ms):
                                    final_processed_audio_files_for_concat_task.append(gap_after_file_path_loop)
                                    accumulated_timeline_ms += silence_needed_after_ms
                        
                        # ƒê·∫£m b·∫£o accumulated_timeline_ms kh√¥ng nh·ªè h∆°n ƒëi·ªÉm k·∫øt th√∫c mong mu·ªën c·ªßa segment n√†y
                        accumulated_timeline_ms = max(accumulated_timeline_ms, target_end_point_for_segment_on_timeline_ms)

                        # N·∫øu segment n√†y ƒë√£ overflow, v√† segment ti·∫øp theo kh√¥ng qu√° g·∫ßn,
                        # c√≥ th·ªÉ c·∫ßn th√™m m·ªôt kho·∫£ng l·∫∑ng nh·ªè sau overflow
                        if this_segment_overflowed_ms_loop > 0 and cfg_min_silence_after_overflow_ms > 0:
                            # Ki·ªÉm tra xem segment ti·∫øp theo c√≥ b·∫Øt ƒë·∫ßu ngay sau kh√¥ng
                            is_last_segment = (segment_index_loop == _total_segments_worker - 1)
                            if not is_last_segment:
                                next_segment_target_start_ms = float(segments_for_tts_engine_processing[segment_index_loop + 1]["start_ms"])
                                gap_to_next_target_start = next_segment_target_start_ms - accumulated_timeline_ms
                                # Ch·ªâ th√™m silence sau overflow n·∫øu n√≥ kh√¥ng l√†m l·∫•n sang segment ti·∫øp theo qu√° nhi·ªÅu
                                if gap_to_next_target_start > cfg_min_silence_after_overflow_ms:
                                    silence_after_overflow_file = os.path.join(adjusted_segments_output_folder_for_this_task, f"gap_after_overflow_{current_segment_display_index_loop:04d}.wav")
                                    if self.dub_ffmpeg_create_silence_file(silence_after_overflow_file, cfg_min_silence_after_overflow_ms):
                                        final_processed_audio_files_for_concat_task.append(silence_after_overflow_file)
                                        accumulated_timeline_ms += cfg_min_silence_after_overflow_ms
                                        logging.info(f"{segment_log_prefix_tts_loop} ƒê√£ th√™m {cfg_min_silence_after_overflow_ms}ms silence sau overflow.")
                        
                        if self.dub_stop_event.is_set(): _worker_stopped_by_user = True; break
                        _segments_successfully_processed_worker += 1
                        logging.info(f"{segment_log_prefix_tts_loop} Xong. Timeline cu·ªëi sau segment n√†y: {accumulated_timeline_ms / 1000.0:.3f}s (Target End: {target_srt_end_time_ms / 1000.0:.3f}s)")

                    # ---- K·∫øt th√∫c v√≤ng l·∫∑p for segments_for_tts_engine_processing ----
                    if _worker_stopped_by_user: raise InterruptedError("D·ª´ng trong v√≤ng l·∫∑p x·ª≠ l√Ω segments TTS.")
                    if not final_processed_audio_files_for_concat_task:
                        _error_message_worker = "Kh√¥ng c√≥ audio segments TTS n√†o ƒë∆∞·ª£c x·ª≠ l√Ω th√†nh c√¥ng ƒë·ªÉ gh√©p."
                        raise ValueError(_error_message_worker)
                    
                    # --- C.2.vii. GH√âP C√ÅC FILE AUDIO ƒê√É X·ª¨ L√ù TH√ÄNH TRACK TTS HO√ÄN CH·ªàNH ---
                    intermediate_concat_wav_path = os.path.join(dub_temp_base_for_this_task, "dub_tts_intermediate_all.wav")
                    concat_list_file_tts_path = os.path.join(adjusted_segments_output_folder_for_this_task, "concat_list_tts.txt")
                    with open(concat_list_file_tts_path, 'w', encoding='utf-8') as f_cl_tts:
                        for wav_item_path_tts in final_processed_audio_files_for_concat_task:
                            f_cl_tts.write(f"file '{os.path.abspath(wav_item_path_tts).replace(os.sep, '/')}'\n") # D√πng ƒë∆∞·ªùng d·∫´n tuy·ªát ƒë·ªëi
                    
                    if not self.dub_ffmpeg_concatenate_audios(concat_list_file_tts_path, intermediate_concat_wav_path):
                        _error_message_worker = "L·ªói gh√©p c√°c segment TTS th√†nh track WAV trung gian."; raise RuntimeError(_error_message_worker)
                    
                    # --- C.2.viii. CHU·∫®N H√ìA V√Ä CHUY·ªÇN SANG MP3 CU·ªêI C√ôNG CHO TRACK TTS ---
                    # Tr∆∞·ªùng h·ª£p c√≥ c·∫£ TTS v√† audio ngo√†i -> track TTS n√†y s·∫Ω ƒë∆∞·ª£c d√πng ƒë·ªÉ tr·ªôn
                    if self.dub_audio_path_for_queue_temp and os.path.exists(self.dub_audio_path_for_queue_temp):
                        normalized_tts_mp3_for_mixing_path = os.path.join(dub_temp_base_for_this_task, "dub_tts_normalized_for_mix.mp3")
                        if not self.dub_ffmpeg_convert_wav_to_mp3_normalized(intermediate_concat_wav_path, normalized_tts_mp3_for_mixing_path):
                            _error_message_worker = "L·ªói chu·∫©n h√≥a MP3 cho track TTS (khi c√≥ audio ngo√†i)."; raise RuntimeError(_error_message_worker)
                        final_audio_track_for_muxing_worker = normalized_tts_mp3_for_mixing_path # ƒê√¢y s·∫Ω l√† input "dub_audio_path" cho h√†m mux
                    else: # Ch·ªâ c√≥ TTS, kh√¥ng c√≥ audio ngo√†i
                        final_mp3_track_normalized_path = os.path.join(dub_temp_base_for_this_task, "dub_tts_final_normalized_track.mp3")
                        if not self.dub_ffmpeg_convert_wav_to_mp3_normalized(intermediate_concat_wav_path, final_mp3_track_normalized_path):
                            _error_message_worker = "L·ªói chuy·ªÉn WAV (TTS) sang MP3 (normalized) cu·ªëi c√πng."; raise RuntimeError(_error_message_worker)
                        final_audio_track_for_muxing_worker = final_mp3_track_normalized_path
                
                else: # is_current_task_direct_audio_mux is False V√Ä segments_for_tts_engine_processing c≈©ng r·ªóng (l·ªói logic)
                    _error_message_worker = "L·ªói logic: Y√™u c·∫ßu t·∫°o TTS nh∆∞ng kh√¥ng c√≥ k·ªãch b·∫£n n√†o ƒë∆∞·ª£c chu·∫©n b·ªã."
                    raise RuntimeError(_error_message_worker)

                # --- D. GH√âP VIDEO (B∆∞·ªõc cu·ªëi c√πng c·ªßa worker) ---
                if _worker_stopped_by_user: raise InterruptedError("D·ª´ng tr∆∞·ªõc khi mux video.")
                if not final_audio_track_for_muxing_worker or not os.path.exists(final_audio_track_for_muxing_worker):
                    _error_message_worker = _error_message_worker or "Kh√¥ng c√≥ track audio cu·ªëi c√πng ƒë·ªÉ gh√©p v√†o video."
                    raise RuntimeError(_error_message_worker)

                # X√°c ƒë·ªãnh th∆∞ m·ª•c output v√† t√™n file output
                output_dir_mux_final = self.dub_output_path_var.get() # L·∫•y t·ª´ self v√¨ ƒë√£ ƒë∆∞·ª£c restore
                os.makedirs(output_dir_mux_final, exist_ok=True)
                video_base_mux_final = os.path.splitext(os.path.basename(video_input_path_task_worker))[0]
                
                engine_display_name_for_file_final = "audio_custom" # M·∫∑c ƒë·ªãnh n·∫øu kh√¥ng r√µ
                if segments_for_tts_engine_processing and not self.is_current_task_direct_audio_mux : # N·∫øu c√≥ t·∫°o TTS
                    engine_name_raw_final = self.dub_selected_tts_engine_var.get()
                    engine_display_name_for_file_final = engine_name_raw_final.split('(')[0].strip().lower().replace(" ", "_").replace("-","_")
                elif self.is_current_task_direct_audio_mux:
                    engine_display_name_for_file_final = "external_audio"
                
                final_video_filename_mux_output = f"{create_safe_filename(video_base_mux_final)}_{engine_display_name_for_file_final}_PiuDub.mp4"
                _final_video_output_path_worker = os.path.join(output_dir_mux_final, final_video_filename_mux_output)

                # Chu·∫©n b·ªã tham s·ªë cho h√†m mux
                external_audio_for_final_mux_if_any = None
                # Ch·ªâ truy·ªÅn audio ngo√†i v√†o h√†m mux n·∫øu t√°c v·ª• g·ªëc c√≥ c·∫£ TTS V√Ä audio ngo√†i (ƒë·ªÉ tr·ªôn)
                # N·∫øu l√† direct_audio_mux, th√¨ audio ngo√†i ƒë√£ tr·ªü th√†nh final_audio_track_for_muxing_worker r·ªìi.
                if segments_for_tts_engine_processing and \
                   self.dub_audio_path_for_queue_temp and \
                   os.path.exists(self.dub_audio_path_for_queue_temp):
                    external_audio_for_final_mux_if_any = self.dub_audio_path_for_queue_temp
                
                mux_parameters = {
                    "video_input_path": video_input_path_task_worker,
                    "dub_audio_path": final_audio_track_for_muxing_worker, # ƒê√¢y l√† track MP3 ƒë√£ chu·∫©n h√≥a (t·ª´ TTS ho·∫∑c t·ª´ audio ngo√†i)
                    "output_video_path": _final_video_output_path_worker,
                    "action": self.dub_background_audio_option_var.get(), # L·∫•y t·ª´ self ƒë√£ restore
                    "original_audio_mix_level": self.dub_background_mix_level_var.get(),
                    "custom_bgm_path": self.dub_custom_bg_music_path_var.get() if self.dub_use_custom_bg_music_var.get() else None,
                    "custom_bgm_level": self.get_validated_custom_bg_volume_float(),
                    "external_audio_path": external_audio_for_final_mux_if_any # Ch·ªâ d√πng n·∫øu c√≥ c·∫£ TTS v√† audio ngo√†i c·∫ßn tr·ªôn
                }
                
                # X·ª≠ l√Ω l·∫°i "action" cho h√†m mux d·ª±a tr√™n logic b·∫°n ƒë√£ c√≥
                current_action_from_ui_mux = mux_parameters["action"]
                if current_action_from_ui_mux == "T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh (Audio Ducking)":
                    mux_parameters["action"] = "audio_ducking" # C·∫ßn ƒë·∫£m b·∫£o h√†m mux hi·ªÉu "audio_ducking"
                elif current_action_from_ui_mux == self.dub_background_audio_options[0]: # "Tr·ªôn v·ªõi √¢m thanh g·ªëc (m·ª©c nh·ªè)"
                    mux_parameters["action"] = "mix_dub_and_original"
                elif current_action_from_ui_mux == self.dub_background_audio_options[1]: # "Thay th·∫ø √¢m thanh g·ªëc"
                    if mux_parameters["custom_bgm_path"] and os.path.exists(mux_parameters["custom_bgm_path"]):
                        mux_parameters["action"] = "replace_with_custom_bgm"
                    elif external_audio_for_final_mux_if_any and not (mux_parameters["custom_bgm_path"] and os.path.exists(mux_parameters["custom_bgm_path"])):
                        # N·∫øu action l√† "Thay th·∫ø", kh√¥ng c√≥ BGM t√πy ch·ªânh, NH∆ØNG c√≥ audio ngo√†i ƒë∆∞·ª£c truy·ªÅn v√†o (t·ª©c l√† c√≥ c·∫£ TTS v√† audio ngo√†i)
                        # Tr∆∞·ªùng h·ª£p n√†y c√≥ th·ªÉ coi l√† "tr·ªôn TTS v·ªõi audio ngo√†i l√†m n·ªÅn" thay v√¨ "thay th·∫ø ho√†n to√†n b·∫±ng TTS"
                        # Ho·∫∑c b·∫°n c·∫ßn m·ªôt action m·ªõi v√≠ d·ª• "mix_tts_and_external_as_bgm"
                        # Hi·ªán t·∫°i, ƒë·ªÉ ƒë∆°n gi·∫£n, n·∫øu c√≥ external_audio_for_final_mux_if_any, n√≥ s·∫Ω ƒë∆∞·ª£c tr·ªôn.
                        # N·∫øu kh√¥ng, th√¨ ch·ªâ c√≥ dub_audio_path (t·ª´ TTS).
                        # Logic n√†y c·∫ßn xem l·∫°i c·∫©n th·∫≠n xem c√≥ kh·ªõp v·ªõi √Ω ƒë·ªì c·ªßa self.dub_ffmpeg_mux_video_audio kh√¥ng.
                        # Gi·∫£ s·ª≠ n·∫øu c√≥ external_audio_for_final_mux_if_any, n√≥ s·∫Ω ƒë∆∞·ª£c d√πng l√†m n·ªÅn.
                        mux_parameters["action"] = "replace_with_dub_and_external_bgm" # T·∫°o action m·ªõi n·∫øu c·∫ßn
                    else: # Ch·ªâ c√≥ TTS, kh√¥ng c√≥ nh·∫°c n·ªÅn t√πy ch·ªânh, kh√¥ng c√≥ audio ngo√†i (ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω th√†nh dub_audio_path)
                        mux_parameters["action"] = "replace_with_dub_only"
                else: # Fallback
                    mux_parameters["action"] = "replace_with_dub_only"


                if not self.dub_ffmpeg_mux_video_audio(**mux_parameters):
                    _error_message_worker = _error_message_worker or "L·ªói gh√©p video thuy·∫øt minh cu·ªëi c√πng."; raise RuntimeError(_error_message_worker)
                
                if not _worker_stopped_by_user:
                    _overall_success_worker = True
                logging.info(f"{worker_log_prefix} Ho√†n t·∫•t t√°c v·ª• th√†nh c√¥ng (tr∆∞·ªõc finally): {_final_video_output_path_worker}")

            except InterruptedError:
                _worker_stopped_by_user = True
                if not _error_message_worker: _error_message_worker = "T√°c v·ª• thuy·∫øt minh b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng."
                logging.info(f"{worker_log_prefix} {_error_message_worker}")
            except (FileNotFoundError, ValueError, RuntimeError) as e_task_flow:
                # B·∫Øt c√°c l·ªói ƒë√£ raise c·ª• th·ªÉ trong try-block
                if not _error_message_worker: _error_message_worker = f"L·ªói quy tr√¨nh thuy·∫øt minh: {str(e_task_flow)[:150]}"
                logging.error(f"{worker_log_prefix} {_error_message_worker}", exc_info=False) # Kh√¥ng c·∫ßn full exc_info n·∫øu ƒë√£ c√≥ msg
            except Exception as e_general_worker:
                # B·∫Øt t·∫•t c·∫£ c√°c l·ªói kh√¥ng mong mu·ªën kh√°c
                if not _error_message_worker: _error_message_worker = f"L·ªói kh√¥ng mong mu·ªën trong worker: {str(e_general_worker)[:150]}"
                logging.critical(f"{worker_log_prefix} {_error_message_worker}", exc_info=True) # Full exc_info cho l·ªói l·∫°
            finally:
                # D·ªçn d·∫πp th∆∞ m·ª•c t·∫°m c·ªßa t√°c v·ª•
                try:
                    if os.path.exists(dub_temp_base_for_this_task):
                        shutil.rmtree(dub_temp_base_for_this_task)
                        logging.info(f"{worker_log_prefix} ƒê√£ d·ªçn d·∫πp th∆∞ m·ª•c t·∫°m c·ªßa t√°c v·ª•: {dub_temp_base_for_this_task}")
                except Exception as e_cleanup_task_temp:
                    logging.warning(f"{worker_log_prefix} L·ªói d·ªçn d·∫πp th∆∞ m·ª•c t·∫°m c·ªßa t√°c v·ª•: {e_cleanup_task_temp}")

                # G·ªçi callback tr√™n lu·ªìng ch√≠nh ƒë·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£
                final_success_for_callback_ui = _overall_success_worker and not _worker_stopped_by_user
                video_path_for_callback_ui = _final_video_output_path_worker if final_success_for_callback_ui else None
                
                # ƒê·∫£m b·∫£o _error_message_worker c√≥ gi√° tr·ªã n·∫øu kh√¥ng th√†nh c√¥ng v√† kh√¥ng b·ªã d·ª´ng
                if not final_success_for_callback_ui and not _worker_stopped_by_user and not _error_message_worker:
                    _error_message_worker = "L·ªói kh√¥ng x√°c ƒë·ªãnh trong qu√° tr√¨nh x·ª≠ l√Ω thuy·∫øt minh."

                self.after(0, self._handle_single_dub_task_completion, 
                           final_success_for_callback_ui, 
                           video_path_for_callback_ui, 
                           _error_message_worker, 
                           _worker_stopped_by_user)
                logging.info(f"{worker_log_prefix} K·∫øt th√∫c worker. G·ªçi Callback v·ªõi: Success={final_success_for_callback_ui}, Video={video_path_for_callback_ui}, ErrMsg='{_error_message_worker}', StoppedByUser={_worker_stopped_by_user}")


#----------------------

# H√†m n√†y s·∫Ω l√† tr√°i tim c·ªßa vi·ªác √°nh x·∫°.
    def _map_optimized_segments_to_original_srt_timings(self, optimized_segments_with_estimated_timings, original_srt_data):
        """
        (PHI√äN B·∫¢N N√ÇNG C·∫§P v5 - T·ª∞ ƒê·ªòNG T√çNH CPS V√Ä ƒê·ªåC UI)
        √Ånh x·∫° c√°c segment ƒë√£ t·ªëi ∆∞u v√†o timing c·ªßa SRT g·ªëc.
        - T√≠nh to√°n t·ªëc ƒë·ªô ƒë·ªçc (CPS) trung b√¨nh t·ª´ SRT g·ªëc.
        - S·ª≠ d·ª•ng CPS ƒë√≥ ƒë·ªÉ ∆∞·ªõc t√≠nh th·ªùi l∆∞·ª£ng cho c√°c segment m·ªõi.
        - ƒê·ªçc c√°c gi√° tr·ªã ng·∫Øt ngh·ªâ ƒë·ªông t·ª´ giao di·ªán ng∆∞·ªùi d√πng.
        """
        worker_log_prefix = f"[{threading.current_thread().name}_MapTimings_v5_ReadUI]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu √°nh x·∫° (V5 - ƒê·ªçc UI) {len(optimized_segments_with_estimated_timings)} segment t·ªëi ∆∞u v·ªõi {len(original_srt_data)} segment SRT g·ªëc.")

        # 1. Ki·ªÉm tra v√† l·∫•y t·ªïng th·ªùi l∆∞·ª£ng + t·ªïng k√Ω t·ª± t·ª´ SRT g·ªëc (Kh√¥ng ƒë·ªïi)
        if not optimized_segments_with_estimated_timings or not original_srt_data:
            return []
        try:
            valid_original_segments = [s for s in original_srt_data if isinstance(s.get('start_ms'), (int, float)) and isinstance(s.get('end_ms'), (int, float)) and s['start_ms'] <= s['end_ms']]
            if not valid_original_segments: return []
            
            first_original_start_ms = float(min(s['start_ms'] for s in valid_original_segments))
            last_original_end_ms = float(max(s['end_ms'] for s in valid_original_segments))
            total_original_duration_ms = last_original_end_ms - first_original_start_ms
            
            total_original_chars = sum(len(s.get('text', '')) for s in valid_original_segments)

        except Exception as e:
            logging.error(f"{worker_log_prefix} L·ªói khi x·ª≠ l√Ω timing/text t·ª´ SRT g·ªëc: {e}.", exc_info=True)
            return []

        if total_original_duration_ms <= 0 or total_original_chars == 0:
            logging.error(f"{worker_log_prefix} D·ªØ li·ªáu t·ª´ SRT g·ªëc kh√¥ng h·ª£p l·ªá (Duration: {total_original_duration_ms:.2f}ms, Chars: {total_original_chars}).")
            return []

        # 2. T√≠nh CPS g·ªëc (Kh√¥ng ƒë·ªïi)
        original_avg_cps = (total_original_chars / total_original_duration_ms) * 1000.0
        logging.info(f"{worker_log_prefix} Timeline g·ªëc: {first_original_start_ms:.2f}ms -> {last_original_end_ms:.2f}ms (T·ªïng: {total_original_duration_ms:.2f}ms).")
        logging.info(f"{worker_log_prefix} T·ªëc ƒë·ªô ƒë·ªçc trung b√¨nh g·ªëc ƒë∆∞·ª£c t√≠nh to√°n: {original_avg_cps:.2f} k√Ω t·ª±/gi√¢y.")

        # <<< B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI: ƒê·ªåC GI√Å TR·ªä NG·∫ÆT NGH·ªà T·ª™ UI >>>
        try:
            pause_period = safe_int(self.sub_pacing_pause_period_ms_var.get(), 300)
            pause_question = safe_int(self.sub_pacing_pause_question_ms_var.get(), 450)
            pause_medium = safe_int(self.sub_pacing_pause_medium_ms_var.get(), 150)
        except AttributeError:
            logging.warning(f"[{worker_log_prefix}] Kh√¥ng t√¨m th·∫•y bi·∫øn StringVar cho nh·ªãp ƒëi·ªáu, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh c·ª©ng.")
            pause_period = 300
            pause_question = 450
            pause_medium = 150

        # 3. T√≠nh t·ªïng "tr·ªçng s·ªë" v√† t·ªïng th·ªùi gian ngh·ªâ ƒë·ªông t·ª´ c√°c segment m·ªõi
        total_estimated_weight_optimized = 0.0
        total_dynamic_pause_time_ms = 0.0
        valid_optimized_segments_for_weight = []
        num_segments = len(optimized_segments_with_estimated_timings)

        for i, opt_seg in enumerate(optimized_segments_with_estimated_timings):
            text_chunk = opt_seg.get('text', '')
            if not text_chunk.strip(): continue

            weight = self._calculate_weighted_duration_ms(
                text_chunk=text_chunk,
                cps=original_avg_cps,
                min_duration_ms=self.min_duration_per_segment_ms
            )
            
            final_weight = max(1.0, weight)
            valid_optimized_segments_for_weight.append({'text': text_chunk, 'weight': final_weight})
            total_estimated_weight_optimized += final_weight

            if i < num_segments - 1:
                # <<< THAY ƒê·ªîI: S·ª¨ D·ª§NG BI·∫æN ƒê√É ƒê·ªåC T·ª™ UI >>>
                pause_to_add_ms = 0
                text_for_check = text_chunk.strip().rstrip("\"'‚Äù‚Äô")
                if text_for_check:
                    last_char = text_for_check[-1]
                    if last_char in ['.', '‚Ä¶']: pause_to_add_ms = pause_period
                    elif last_char in ['?', '!']: pause_to_add_ms = pause_question
                    elif last_char in [',', ';', ':']: pause_to_add_ms = pause_medium
                total_dynamic_pause_time_ms += pause_to_add_ms
                # <<< K·∫æT TH√öC THAY ƒê·ªîI >>>
        
        if not valid_optimized_segments_for_weight: return []
        logging.info(f"{worker_log_prefix} T·ªïng tr·ªçng s·ªë (d·ª±a tr√™n CPS g·ªëc): {total_estimated_weight_optimized:.2f}ms. T·ªïng th·ªùi gian ngh·ªâ ƒë·ªông: {total_dynamic_pause_time_ms:.2f}ms.")

        # 4. Ph√¢n b·ªï th·ªùi gian (Kh√¥ng ƒë·ªïi)
        final_mapped_segments = []
        current_timeline_ms_output = float(first_original_start_ms)
        available_speaking_duration_ms = total_original_duration_ms - total_dynamic_pause_time_ms
        
        if available_speaking_duration_ms <= 0:
            logging.warning(f"{worker_log_prefix} T·ªïng th·ªùi l∆∞·ª£ng g·ªëc qu√° ng·∫Øn ƒë·ªÉ ch√®n kho·∫£ng ngh·ªâ. S·∫Ω kh√¥ng ch√®n kho·∫£ng ngh·ªâ.")
            available_speaking_duration_ms = total_original_duration_ms
            total_dynamic_pause_time_ms = 0

        if total_estimated_weight_optimized > 0:
            scaling_factor = available_speaking_duration_ms / total_estimated_weight_optimized
            logging.info(f"{worker_log_prefix} H·ªá s·ªë co gi√£n th·ªùi gian n√≥i: {scaling_factor:.4f}")

            for i, opt_seg_data in enumerate(valid_optimized_segments_for_weight):
                new_duration_ms = opt_seg_data['weight'] * scaling_factor
                start_ms_mapped = current_timeline_ms_output
                end_ms_mapped = current_timeline_ms_output + new_duration_ms
                
                if i == len(valid_optimized_segments_for_weight) - 1:
                    end_ms_mapped = float(last_original_end_ms)
                
                if end_ms_mapped <= start_ms_mapped: end_ms_mapped = start_ms_mapped + 1.0

                final_mapped_segments.append({
                    'index': i + 1, 'text': opt_seg_data['text'],
                    'start_ms': start_ms_mapped, 'end_ms': end_ms_mapped,
                    'start_str': ms_to_tc(start_ms_mapped), 'end_str': ms_to_tc(end_ms_mapped)
                })

                if i < len(valid_optimized_segments_for_weight) - 1:
                    # <<< THAY ƒê·ªîI: S·ª¨ D·ª§NG BI·∫æN ƒê√É ƒê·ªåC T·ª™ UI (L·∫¶N 2) >>>
                    pause_for_this_segment_ms = 0 # S·ª≠ d·ª•ng 0 thay v√¨ self.pause_default_ms
                    text_for_check_2 = opt_seg_data['text'].strip().rstrip("\"'‚Äù‚Äô")
                    if text_for_check_2:
                        last_char_for_pause = text_for_check_2[-1]
                        if last_char_for_pause in ['.', '‚Ä¶']: pause_for_this_segment_ms = pause_period
                        elif last_char_for_pause in ['?', '!']: pause_for_this_segment_ms = pause_question
                        elif last_char_for_pause in [',', ';', ':']: pause_for_this_segment_ms = pause_medium
                    # <<< K·∫æT TH√öC THAY ƒê·ªîI >>>
                    
                    current_timeline_ms_output = end_ms_mapped + (pause_for_this_segment_ms if total_dynamic_pause_time_ms > 0 else 0)
                else:
                    current_timeline_ms_output = end_ms_mapped

        logging.info(f"{worker_log_prefix} √Ånh x·∫° (V5) ho√†n t·∫•t. T·∫°o ra {len(final_mapped_segments)} segment cu·ªëi c√πng.")
        return final_mapped_segments


# --- H√ÄM M·ªöI: ∆Ø·ªõc t√≠nh th·ªùi gian ƒë·ªçc cho m·ªôt chu·ªói s·ªë v√† ƒë∆°n v·ªã ---
    def _estimate_number_reading_time_ms(self, number_text):
        """
        ∆Ø·ªõc t√≠nh th·ªùi gian ƒë·ªçc (ms) cho m·ªôt chu·ªói ch·ª©a s·ªë v√† ƒë∆°n v·ªã (v√≠ d·ª•: "27km", "1.234,5").
        H√†m n√†y kh√¥ng chuy·ªÉn s·ªë th√†nh ch·ªØ ƒë·∫ßy ƒë·ªß (v√¨ ph·ª©c t·∫°p) m√† d√πng m·ªôt thu·∫≠t to√°n ∆∞·ªõc t√≠nh:
        - C·ªông th·ªùi gian th∆∞·ªüng cho m·ªói ch·ªØ s·ªë (v√¨ "m·ªôt ngh√¨n" d√†i h∆°n "m·ªôt").
        - C·ªông th·ªùi gian th∆∞·ªüng n·∫øu c√≥ ƒë∆°n v·ªã ƒëi k√®m (v√≠ d·ª•: "km", "kg", "m").
        """
        # C√°c h·∫±ng s·ªë n√†y b·∫°n c√≥ th·ªÉ tinh ch·ªânh ƒë·ªÉ thay ƒë·ªïi nh·ªãp ƒëi·ªáu ƒë·ªçc s·ªë
        BONUS_PER_DIGIT_MS = 80  # Th·ªùi gian th∆∞·ªüng th√™m cho m·ªói ch·ªØ s·ªë
        BONUS_PER_UNIT_MS = 300  # Th·ªùi gian th∆∞·ªüng th√™m n·∫øu c√≥ ƒë∆°n v·ªã (km, kg, m...)

        # Regex ƒë·ªÉ t√¨m s·ªë (c√≥ th·ªÉ c√≥ d·∫•u ph·∫©y/ch·∫•m) v√† ƒë∆°n v·ªã (t√πy ch·ªçn)
        # V√≠ d·ª•: kh·ªõp v·ªõi "1,234.56" v√† "km" trong "1,234.56km"
        match = re.search(r'(\d+([.,]\d+)*)\s*([a-zA-Z]+)?', number_text)

        if not match:
            return 0

        number_part = match.group(1).replace(",", "").replace(".", "") # L·∫•y ph·∫ßn s·ªë v√† b·ªè d·∫•u ngƒÉn c√°ch
        unit_part = match.group(3)

        bonus_ms = 0
        # C·ªông th∆∞·ªüng cho m·ªói ch·ªØ s·ªë
        bonus_ms += len(number_part) * BONUS_PER_DIGIT_MS
        # C·ªông th∆∞·ªüng n·∫øu c√≥ ƒë∆°n v·ªã
        if unit_part:
            bonus_ms += BONUS_PER_UNIT_MS
        
        return bonus_ms


# H√ÄM N√ÄY S·∫º THAY TH·∫æ TO√ÄN B·ªò N·ªòI DUNG C·ª¶A _calculate_weighted_duration_ms
    def _calculate_weighted_duration_ms(self, text_chunk, cps, min_duration_ms):
        """
        (PHI√äN B·∫¢N HO√ÄN THI·ªÜN NH·∫§T) ∆Ø·ªõc t√≠nh th·ªùi l∆∞·ª£ng ƒë·ªçc (ms) v·ªõi logic to√†n di·ªán:
        - T·ªëc ƒë·ªô ƒë·ªçc ƒë·ªông (nhanh h∆°n cho c√¢u d√†i).
        - T√≠nh to√°n th·ªùi gian ngh·ªâ cho d·∫•u c√¢u B√äN TRONG kh·ªëi sub.
        - X·ª≠ l√Ω ch·ªØ IN HOA v√† s·ªë.
        """
        if not text_chunk or not text_chunk.strip():
            return 0

        # <<< B·∫ÆT ƒê·∫¶U THAY ƒê·ªîI: ƒê·ªåC GI√Å TR·ªä T·ª™ C√ÅC BI·∫æN M·ªöI >>>
        try:
            # ƒê·ªçc c√°c gi√° tr·ªã t·ª´ giao di·ªán, c√≥ fallback an to√†n
            long_sentence_threshold = safe_int(self.sub_pacing_long_sentence_threshold_var.get(), 55)
            fast_cps_multiplier = float(self.sub_pacing_fast_cps_multiplier_var.get())
            
            # ƒê·ªçc c√°c gi√° tr·ªã pause t·ª´ giao di·ªán
            pause_comma_ms = safe_int(self.sub_pacing_pause_medium_ms_var.get(), 100) # Gi·∫£ ƒë·ªãnh pause medium cho d·∫•u ph·∫©y
            pause_semicolon_ms = safe_int(self.sub_pacing_pause_medium_ms_var.get(), 130) # V√† c·∫£ d·∫•u ch·∫•m ph·∫©y
            pause_sentence_end_ms = safe_int(self.sub_pacing_pause_period_ms_var.get(), 160) # Gi·∫£ ƒë·ªãnh pause period cho c√°c d·∫•u k·∫øt th√∫c c√¢u
            
        except (AttributeError, ValueError, TypeError):
            # Fallback n·∫øu c√°c bi·∫øn ch∆∞a t·ªìn t·∫°i ho·∫∑c gi√° tr·ªã kh√¥ng h·ª£p l·ªá
            logging.warning("L·ªói ƒë·ªçc c√†i ƒë·∫∑t t·ªëc ƒë·ªô ƒë·ªçc t·ª´ UI, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh.")
            long_sentence_threshold = 55
            fast_cps_multiplier = 1.10
            pause_comma_ms = 100
            pause_semicolon_ms = 130
            pause_sentence_end_ms = 160
        # <<< K·∫æT TH√öC THAY ƒê·ªîI >>>
            
        # C√°c h·∫±ng s·ªë kh√°c c√≥ th·ªÉ gi·ªØ l·∫°i
        PAUSE_QUOTE_MS = 80
        ACRONYM_MAX_LENGTH = 4
        SPELLING_BONUS_PER_CHAR_MS = 200
        EMPHASIS_BONUS_PER_WORD_MS = 150
        
        try:
            char_count = len(text_chunk)
            
            effective_cps = cps
            if char_count > long_sentence_threshold: # S·ª≠ d·ª•ng bi·∫øn ƒë√£ ƒë·ªçc t·ª´ UI
                effective_cps = cps * fast_cps_multiplier # S·ª≠ d·ª•ng bi·∫øn ƒë√£ ƒë·ªçc t·ª´ UI

            base_duration_ms = (char_count / float(effective_cps)) * 1000.0 if effective_cps > 0 else 0

            punctuation_pause_ms = 0
            punctuation_pause_ms += text_chunk.count(',') * pause_comma_ms
            punctuation_pause_ms += text_chunk.count(';') * pause_semicolon_ms
            punctuation_pause_ms += text_chunk.count('.') * pause_sentence_end_ms
            punctuation_pause_ms += text_chunk.count('?') * pause_sentence_end_ms
            punctuation_pause_ms += text_chunk.count('!') * pause_sentence_end_ms
            punctuation_pause_ms += text_chunk.count('‚Ä¶') * pause_sentence_end_ms
            punctuation_pause_ms += text_chunk.count('"') * PAUSE_QUOTE_MS

            uppercase_bonus_ms = 0
            number_bonus_ms = 0
            tokens = re.findall(r'\b\w+\b|[^\w\s]+', text_chunk)
            for token in tokens:
                if len(token) > 1 and token.isalpha() and token.isupper():
                    if len(token) <= ACRONYM_MAX_LENGTH:
                        uppercase_bonus_ms += len(token) * SPELLING_BONUS_PER_CHAR_MS
                    else:
                        uppercase_bonus_ms += EMPHASIS_BONUS_PER_WORD_MS
                elif any(char.isdigit() for char in token):
                    number_bonus_ms += self._estimate_number_reading_time_ms(token)

            total_estimated_duration_ms = base_duration_ms + punctuation_pause_ms + uppercase_bonus_ms + number_bonus_ms
            final_duration_ms = max(min_duration_ms, total_estimated_duration_ms)

            logging.debug(
                f"[_calculate_weighted_duration(v_comprehensive)] Text: '{text_chunk[:30]}...' | "
                f"BaseDur: {base_duration_ms:.0f}ms, PunctPause: {punctuation_pause_ms:.0f}ms, "
                f"Upper: {uppercase_bonus_ms:.0f}ms, Num: {number_bonus_ms:.0f}ms, "
                f"TotalEst: {total_estimated_duration_ms:.0f}ms -> Final: {final_duration_ms:.0f}ms"
            )
            return int(final_duration_ms)
        except Exception as e:
            logging.error(f"L·ªói trong _calculate_weighted_duration_ms (v_comprehensive): {e}", exc_info=True)
            return max(min_duration_ms, len(text_chunk) * 60)

#-------------------------
# H√†m n√†y s·∫Ω ch·ªãu tr√°ch nhi·ªám c·∫≠p nh·∫≠t dub_script_textbox m·ªôt c√°ch an to√†n t·ª´ lu·ªìng worker
    def _update_dub_textbox_post_processing(self, segments_to_display, source_description):
        """
        C·∫≠p nh·∫≠t dub_script_textbox v·ªõi k·ªãch b·∫£n ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω.
        Ch·∫°y tr√™n lu·ªìng UI ch√≠nh.
        """
        worker_log_prefix_ui_update = f"[{threading.current_thread().name}_DubTextboxUpdate_UI]" # S·ª≠a t√™n bi·∫øn log
        logging.info(f"{worker_log_prefix_ui_update} C·∫≠p nh·∫≠t dub_script_textbox v·ªõi k·ªãch b·∫£n t·ª´: {source_description}")
        
        # Ki·ªÉm tra xem self.dub_script_textbox c√≥ t·ªìn t·∫°i v√† l√† m·ªôt widget h·ª£p l·ªá kh√¥ng
        if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and \
           hasattr(self.dub_script_textbox, 'winfo_exists') and self.dub_script_textbox.winfo_exists():
            try:
                # ƒê·ªãnh d·∫°ng danh s√°ch c√°c segment th√†nh m·ªôt chu·ªói SRT c√≥ th·ªÉ hi·ªÉn th·ªã
                # S·ª≠ d·ª•ng h√†m _format_srt_data_to_string b·∫°n ƒë√£ c√≥
                display_content = format_srt_data_to_string(segments_to_display)
                
                if not display_content.strip() and segments_to_display: 
                    # Tr∆∞·ªùng h·ª£p _format_srt_data_to_string tr·∫£ v·ªÅ r·ªóng d√π c√≥ segments (l·ªói ƒë·ªãnh d·∫°ng?)
                    display_content = f"[L·ªói ƒë·ªãnh d·∫°ng {len(segments_to_display)} segment ({source_description}) ƒë·ªÉ hi·ªÉn th·ªã]"
                    logging.warning(f"{worker_log_prefix_ui_update} _format_srt_data_to_string tr·∫£ v·ªÅ r·ªóng cho {len(segments_to_display)} segment.")
                elif not display_content.strip():
                    display_content = f"[{source_description} - Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ hi·ªÉn th·ªã]"
                    logging.info(f"{worker_log_prefix_ui_update} Kh√¥ng c√≥ n·ªôi dung t·ª´ '{source_description}' ƒë·ªÉ hi·ªÉn th·ªã.")

                self.dub_script_textbox.configure(state="normal")
                self.dub_script_textbox.delete("1.0", "end")
                self.dub_script_textbox.insert("1.0", display_content.strip() + "\n\n") # Th√™m 2 d√≤ng m·ªõi cu·ªëi cho SRT
                
                # Gi·ªØ Textbox ·ªü tr·∫°ng th√°i 'disabled' trong qu√° tr√¨nh x·ª≠ l√Ω h√†ng lo·∫°t
                # ƒë·ªÉ ng∆∞·ªùi d√πng kh√¥ng v√¥ t√¨nh s·ª≠a ƒë·ªïi trong khi worker ƒëang ch·∫°y v·ªõi d·ªØ li·ªáu ƒë√≥.
                if hasattr(self, 'dub_is_processing') and self.dub_is_processing:
                    self.dub_script_textbox.configure(state="disabled")
                else: # N·∫øu kh√¥ng trong batch processing, c√≥ th·ªÉ ƒë·ªÉ normal ho·∫∑c theo logic kh√°c
                    self.dub_script_textbox.configure(state="normal") 

                logging.info(f"{worker_log_prefix_ui_update} ƒê√£ c·∫≠p nh·∫≠t dub_script_textbox v·ªõi n·ªôi dung t·ª´ '{source_description}'.")
                
                # C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt (t√πy ch·ªçn)
                # self.update_status(f"Hi·ªÉn th·ªã k·ªãch b·∫£n: {source_description}")
            except Exception as e_update_tb:
                logging.error(f"{worker_log_prefix_ui_update} L·ªói khi c·∫≠p nh·∫≠t dub_script_textbox: {e_update_tb}", exc_info=True)
        else:
            logging.warning(f"{worker_log_prefix_ui_update} Thu·ªôc t√≠nh dub_script_textbox kh√¥ng t·ªìn t·∫°i, ƒë√£ b·ªã h·ªßy, ho·∫∑c kh√¥ng ph·∫£i l√† widget h·ª£p l·ªá.")


# H√†m qu·∫£n l√Ω t√°c v·ª• chuy·ªÉn ti·∫øp trong h√†ng ch·ªù
    def _handle_single_dub_task_completion(self, was_successful, result_video_path, error_message, stopped_by_user):
        """
        Callback x·ª≠ l√Ω khi m·ªôt t√°c v·ª• thuy·∫øt minh ho√†n th√†nh.
        - C·∫≠p nh·∫≠t UI h√†ng ch·ªù.
        - Quy·∫øt ƒë·ªãnh c√≥ √°p d·ª•ng branding kh√¥ng.
        - G·ªçi h√†m th√™m v√†o h√†ng ch·ªù upload.
        - X·ª≠ l√Ω c√°c b∆∞·ªõc ti·∫øp theo trong h√†ng ch·ªù thuy·∫øt minh.
        """
        task_id_just_completed = self.dub_currently_processing_task_id
        log_prefix_cb = f"[DubBatchCallback_{str(task_id_just_completed)[:6]}]"

        logging.info(f"{log_prefix_cb} X·ª≠ l√Ω ho√†n th√†nh. Success: {was_successful}, Video: {result_video_path}, Error: {error_message}, Stopped: {stopped_by_user}")

        # L·∫•y b·∫£n sao c·ªßa task object ƒë·ªÉ s·ª≠ d·ª•ng
        original_task_data = None
        if task_id_just_completed and self.dub_processing_queue and self.dub_processing_queue[0].get('id') == task_id_just_completed:
            original_task_data = self.dub_processing_queue[0].copy()

        # N·∫øu t√°c v·ª• th√†nh c√¥ng, ch√∫ng ta c·∫ßn quy·∫øt ƒë·ªãnh video cu·ªëi c√πng l√† g√¨ v√† c√≥ branding kh√¥ng
        if was_successful and result_video_path and original_task_data:
            any_branding_enabled = self.branding_intro_enabled_var.get() or self.branding_outro_enabled_var.get() or self.branding_logo_enabled_var.get()

            # C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n video ƒë√£ l·ªìng ti·∫øng v√†o task object
            original_task_data['dubbed_video_path'] = result_video_path

            # A. N·∫æU BRANDING ƒê∆Ø·ª¢C B·∫¨T
            if any_branding_enabled:
                logging.info(f"{log_prefix_cb} T√°c v·ª• dub th√†nh c√¥ng. Branding ƒë∆∞·ª£c b·∫≠t. B·∫Øt ƒë·∫ßu branding.")
                self.update_status(f"üé® Dub xong. Chu·∫©n b·ªã Branding: {os.path.basename(result_video_path)}...")

                # H√†m callback n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi SAU KHI branding xong
                def _callback_after_branding(branding_success, branded_video_path, branding_error_msg, context_data):
                    task_object_from_branding = context_data.get("original_context_data", {})
                    log_prefix_brand_cb = f"[BrandingCb_ForDub_{str(task_object_from_branding.get('id',''))[:6]}]"
                    logging.info(f"{log_prefix_brand_cb} Branding ho√†n t·∫•t. Success: {branding_success}")

                    # C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n ƒë√£ branding v√†o task object
                    if branding_success and branded_video_path:
                        task_object_from_branding['branded_path'] = branded_video_path

                        # X√ìA FILE TRUNG GIAN
                        # L·∫•y ƒë∆∞·ªùng d·∫´n file thuy·∫øt minh trung gian (ch∆∞a c√≥ branding)
                        intermediate_dubbed_file = task_object_from_branding.get('dubbed_video_path')
                        
                        # Ki·ªÉm tra an to√†n tr∆∞·ªõc khi x√≥a
                        if intermediate_dubbed_file and os.path.exists(intermediate_dubbed_file) and \
                           os.path.abspath(intermediate_dubbed_file) != os.path.abspath(branded_video_path):
                            try:
                                os.remove(intermediate_dubbed_file)
                                logging.info(f"{log_prefix_brand_cb} ƒê√£ x√≥a file thuy·∫øt minh trung gian th√†nh c√¥ng: {os.path.basename(intermediate_dubbed_file)}")
                            except Exception as e_del:
                                logging.warning(f"{log_prefix_brand_cb} L·ªói khi x√≥a file thuy·∫øt minh trung gian '{os.path.basename(intermediate_dubbed_file)}': {e_del}")

                    # G·ªçi h√†m th√™m v√†o h√†ng ch·ªù upload v·ªõi task object ƒë√£ c·∫≠p nh·∫≠t ƒë·∫ßy ƒë·ªß
                    self._add_completed_video_to_upload_queue(task_object_from_branding)
                    
                    # X·ª≠ l√Ω t√°c v·ª• dub ti·∫øp theo
                    self._continue_to_next_dub_task_or_finish(task_id_just_completed, stopped_by_user)

                context_for_branding = {
                    "source_view": "dubbing_final_brand",
                    "original_context_data": original_task_data, # Truy·ªÅn to√†n b·ªô task object ƒëi
                }
                
                # B·∫Øt ƒë·∫ßu lu·ªìng branding v√† truy·ªÅn callback ·ªü tr√™n
                self._start_branding_thread(
                    video_path_from_previous_step=result_video_path,
                    callback_after_branding=_callback_after_branding,
                    original_context_data=context_for_branding
                )
                return # D·ª´ng h√†m n√†y ·ªü ƒë√¢y, v√¨ callback c·ªßa branding s·∫Ω x·ª≠ l√Ω ph·∫ßn c√≤n l·∫°i

            # B. N·∫æU BRANDING KH√îNG ƒê∆Ø·ª¢C B·∫¨T
            else:
                logging.info(f"{log_prefix_cb} Branding kh√¥ng b·∫≠t. Th√™m video ƒë√£ l·ªìng ti·∫øng v√†o h√†ng ch·ªù upload.")
                # G·ªçi tr·ª±c ti·∫øp h√†m th√™m v√†o h√†ng ch·ªù upload v·ªõi task object hi·ªán t·∫°i
                self._add_completed_video_to_upload_queue(original_task_data)

        # C. X·ª¨ L√ù KHI T√ÅC V·ª§ L·ªñI HO·∫∂C SAU KHI ƒê√É TH√äM V√ÄO H√ÄNG CH·ªú UPLOAD (KH√îNG BRANDING)
        self._continue_to_next_dub_task_or_finish(task_id_just_completed, stopped_by_user)


    def _continue_to_next_dub_task_or_finish(self, completed_task_id, stopped_by_user):
        """H√†m helper ƒë·ªÉ d·ªçn d·∫πp task ƒë√£ xong v√† x·ª≠ l√Ω task ti·∫øp theo ho·∫∑c k·∫øt th√∫c l√¥."""
        log_prefix_continue = f"[_ContinueDub_{str(completed_task_id)[:6]}]"

        # X√≥a t√°c v·ª• ƒë√£ ho√†n th√†nh kh·ªèi ƒë·∫ßu h√†ng ch·ªù
        if self.dub_processing_queue and self.dub_processing_queue[0].get('id') == completed_task_id:
            self.dub_processing_queue.pop(0)

        self.dub_currently_processing_task_id = None
        self.update_dub_queue_display()

        if not stopped_by_user and self.dub_is_processing:
            if self.dub_processing_queue: # N·∫øu v·∫´n c√≤n t√°c v·ª• trong h√†ng ch·ªù
                logging.info(f"{log_prefix_continue} L√™n l·ªãch x·ª≠ l√Ω t√°c v·ª• thuy·∫øt minh ti·∫øp theo.")
                self.after(100, self._dub_process_next_item_in_queue)
            else: # N·∫øu h√†ng ch·ªù ƒë√£ h·∫øt
                logging.info(f"{log_prefix_continue} H√†ng ch·ªù thuy·∫øt minh ƒë√£ h·∫øt. Ho√†n t·∫•t l√¥.")
                self.dub_on_batch_finished(stopped=False)
        else: # N·∫øu b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng ho·∫∑c c·ªù dub_is_processing ƒë√£ t·∫Øt
            logging.info(f"{log_prefix_continue} H√†ng lo·∫°t b·ªã d·ª´ng ho·∫∑c ƒë√£ k·∫øt th√∫c. Ho√†n t·∫•t l√¥.")
            self.dub_on_batch_finished(stopped=True)
             

# H√†m qu·∫£n l√Ω to√†n b·ªô h√†ng ch·ªù thuy·∫øt m√¨nh khi ƒë∆∞·ª£c x·ª≠ l√Ω song
    def dub_on_batch_finished(self, stopped=False):
        """
        (PHI√äN B·∫¢N 3.0 - ƒê√É S·ª¨A L·ªñI POPUP V√Ä T√çCH H·ª¢P UPLOAD)
        X·ª≠ l√Ω sau khi to√†n b·ªô h√†ng ch·ªù thuy·∫øt minh ho√†n t·∫•t.
        - Ch·ªâ hi·ªÉn th·ªã popup ho√†n th√†nh n·∫øu kh√¥ng t·ª± ƒë·ªông chuy·ªÉn sang upload.
        - K√≠ch ho·∫°t h√†ng ch·ªù upload n·∫øu c√≥ y√™u c·∫ßu.
        """
        log_prefix_bf = "[DubBatchFinished_v3_UploadChainFix]"
        logging.info(f"{log_prefix_bf} X·ª≠ l√Ω h√†ng lo·∫°t thuy·∫øt minh k·∫øt th√∫c. B·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng: {stopped}")

        # --- A. L∆ØU L·∫†I N·ªòI DUNG K·ªäCH B·∫¢N HI·ªÜN T·∫†I (N·∫æU C√ì) ---
        last_processed_script_content_for_display = ""
        if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
            current_textbox_text = self.dub_script_textbox.get("1.0", "end-1c")
            if not self._is_textbox_content_invalid_for_script(current_textbox_text.strip()):
                last_processed_script_content_for_display = current_textbox_text
                logging.debug(f"{log_prefix_bf} N·ªôi dung textbox ƒë∆∞·ª£c xem x√©t ƒë·ªÉ gi·ªØ l·∫°i: '{last_processed_script_content_for_display[:70].replace(chr(10),' ')}...'")

        # --- B. RESET C√ÅC TR·∫†NG TH√ÅI CHUNG ---
        self.dub_is_processing = False
        if hasattr(self, 'dub_current_ffmpeg_process') and self.dub_current_ffmpeg_process:
            try:
                if self.dub_current_ffmpeg_process.poll() is None:
                    self.dub_current_ffmpeg_process.terminate()
                    self.dub_current_ffmpeg_process.wait(timeout=1.0)
            except Exception as e_term_ffmpeg_final:
                logging.warning(f"{log_prefix_bf} L·ªói khi c·ªë d·ª´ng FFmpeg process c√≤n s√≥t l·∫°i: {e_term_ffmpeg_final}")
            finally:
                self.dub_current_ffmpeg_process = None
        
        self.dub_currently_processing_task_id = None
        
        # --- C. KH√îI PH·ª§C TR·∫†NG TH√ÅI GIAO DI·ªÜN ---
        try:
            is_app_active_final = self._is_app_fully_activated()
        except Exception:
            is_app_active_final = False

        # _set_dubbing_tab_ui_state t·ª± ki·ªÉm tra k√≠ch ho·∫°t, kh√¥ng c·∫ßn truy·ªÅn tham s·ªë
        self._set_dubbing_tab_ui_state()

        # C·∫≠p nh·∫≠t l·∫°i textbox v·ªõi n·ªôi dung cu·ªëi c√πng ho·∫∑c placeholder
        if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
            self.dub_script_textbox.configure(state="normal")
            self.dub_script_textbox.delete("1.0", "end")
            if last_processed_script_content_for_display.strip():
                self.dub_script_textbox.insert("1.0", last_processed_script_content_for_display)
            else:
                self.dub_script_textbox.insert("1.0", "[N·ªôi dung file k·ªãch b·∫£n SRT ƒë√£ ch·ªçn s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...]")
        
        # C·∫≠p nh·∫≠t c√°c n√∫t li√™n quan ƒë·∫øn script v√† h√†ng ch·ªù
        if hasattr(self, 'update_dub_queue_display'): self.update_dub_queue_display()
        if hasattr(self, '_update_dub_script_controls_state'): self.after(50, self._update_dub_script_controls_state)
        if hasattr(self, '_update_dub_start_batch_button_state'): self.after(100, self._update_dub_start_batch_button_state)

        # --- D. QUY·∫æT ƒê·ªäNH H√ÄNH ƒê·ªòNG TI·∫æP THEO ---
        
        # 1. Ki·ªÉm tra xem c√≥ c·∫ßn t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu upload kh√¥ng
        should_start_upload_now = not stopped and self.auto_upload_to_youtube_var.get() and self.youtube_upload_queue
        
        if should_start_upload_now:
            # N·∫øu C√ì, c·∫≠p nh·∫≠t tr·∫°ng th√°i v√† chu·∫©n b·ªã chuy·ªÉn giao
            success_message = f"‚úÖ Ho√†n t·∫•t thuy·∫øt minh! Chu·∫©n b·ªã upload {len(self.youtube_upload_queue)} video..."
            logging.info(f"{log_prefix_bf} {success_message}")
            self.update_status(success_message)
            
            try:
                upload_tab_value = "üì§ Upload YT" 
                if hasattr(self, 'view_switcher') and self.view_switcher.get() != upload_tab_value:
                    self.view_switcher.set(upload_tab_value)
                    self.switch_view(upload_tab_value)
            except Exception as e_switch:
                logging.error(f"{log_prefix_bf} L·ªói khi t·ª± ƒë·ªông chuy·ªÉn sang tab Upload: {e_switch}")

            # G·ªçi h√†m b·∫Øt ƒë·∫ßu upload sau m·ªôt kho·∫£ng tr·ªÖ nh·ªè
            self.after(500, self._start_youtube_batch_upload)

        else:
            # N·∫øu KH√îNG upload, ƒë√¢y l√† ƒëi·ªÉm k·∫øt th√∫c th·ª±c s·ª± c·ªßa chu·ªói.
            # X·ª≠ l√Ω th√¥ng b√°o, ph√°t nh·∫°c v√† ki·ªÉm tra shutdown.
            had_api_key_errors_in_this_batch = getattr(self, 'dub_batch_had_api_key_errors', False)
            if not stopped and not had_api_key_errors_in_this_batch:
                try:
                    sound_enabled_for_dub = self.download_sound_var.get()
                    sound_path_for_dub = self.download_sound_path_var.get()
                    if sound_enabled_for_dub and sound_path_for_dub and os.path.isfile(sound_path_for_dub) and PLAYSOUND_AVAILABLE:
                        play_sound_async(sound_path_for_dub)
                except Exception as sound_err_dub_final:
                    logging.error(f"{log_prefix_bf} L·ªói khi th·ª≠ ph√°t √¢m thanh: {sound_err_dub_final}")

            final_status_message_ui = ""
            title_messagebox = "Th√¥ng b√°o Thuy·∫øt minh"
            should_show_popup = True
            
            if stopped:
                final_status_message_ui = "üõë Qu√° tr√¨nh thuy·∫øt minh h√†ng lo·∫°t ƒë√£ b·ªã d·ª´ng b·ªüi ng∆∞·ªùi d√πng."
                should_show_popup = False # Kh√¥ng c·∫ßn popup khi ng∆∞·ªùi d√πng ch·ªß ƒë·ªông d·ª´ng
            elif had_api_key_errors_in_this_batch:
                final_status_message_ui = "‚ö†Ô∏è Ho√†n t·∫•t v·ªõi m·ªôt s·ªë l·ªói c·∫•u h√¨nh API Key. Vui l√≤ng ki·ªÉm tra l·∫°i."
                messagebox.showwarning("Ho√†n th√†nh v·ªõi l·ªói API Key", final_status_message_ui, parent=self)
                should_show_popup = False # ƒê√£ hi·ªán popup l·ªói, kh√¥ng hi·ªán popup th√†nh c√¥ng n·ªØa
            elif self.dub_batch_first_api_error_msg_shown:
                detailed_error_for_popup_summary = str(self.dub_batch_accumulated_api_error_details).split('\n')[0]
                final_status_message_ui = f"‚ö†Ô∏è Ho√†n t·∫•t v·ªõi m·ªôt s·ªë l·ªói API. L·ªói ƒë·∫ßu ti√™n: '{detailed_error_for_popup_summary[:100]}...'"
                messagebox.showwarning("Ho√†n th√†nh v·ªõi l·ªói API", final_status_message_ui, parent=self)
                should_show_popup = False
            elif not self.dub_processing_queue:
                final_status_message_ui = "‚úÖ Ho√†n t·∫•t t·∫•t c·∫£ t√°c v·ª• thuy·∫øt minh trong h√†ng ch·ªù!"
                # Kh√¥ng hi·ªán popup ngay, s·∫Ω ki·ªÉm tra shutdown tr∆∞·ªõc
            else:
                final_status_message_ui = f"‚ÑπÔ∏è X·ª≠ l√Ω k·∫øt th√∫c. C√≤n {len(self.dub_processing_queue)} t√°c v·ª• trong h√†ng ch·ªù."
                messagebox.showwarning("K·∫øt th√∫c v·ªõi m·ª•c ch·ªù", final_status_message_ui, parent=self)
                should_show_popup = False

            self.update_status(final_status_message_ui or "S·∫µn s√†ng cho t√°c v·ª• thuy·∫øt minh m·ªõi.")
            
            # 1. G·ªåI H√ÄM KI·ªÇM TRA T·∫ÆT M√ÅY TR∆Ø·ªöC
            self.after(500, self._check_completion_and_shutdown)

            # 2. CH·ªà HI·ªÜN POPUP "HO√ÄN TH√ÄNH" N·∫æU C·∫¶N THI·∫æT
            #    (T·ª©c l√† kh√¥ng b·ªã d·ª´ng, kh√¥ng c√≥ l·ªói, v√† KH√îNG h·∫πn gi·ªù t·∫Øt m√°y)
            shutdown_is_pending = hasattr(self, 'shutdown_requested_by_task') and self.shutdown_requested_by_task
            if should_show_popup and not stopped and not shutdown_is_pending:
                self.after(600, lambda: messagebox.showinfo("Ho√†n th√†nh H√†ng lo·∫°t", final_status_message_ui, parent=self))

        # --- E. RESET C√ÅC C·ªú D√ôNG CHUNG ---
        # Lu√¥n reset c√°c c·ªù n√†y sau khi m·ªôt l√¥ dubbing k·∫øt th√∫c, b·∫•t k·ªÉ c√≥ upload hay kh√¥ng.
        self.dub_batch_had_api_key_errors = False 
        self.dub_batch_first_api_error_msg_shown = False
        self.dub_batch_accumulated_api_error_details = None
        
        if self.chain_download_sub_dub_active:
            logging.info(f"{log_prefix_bf} L√¥ l·ªìng ti·∫øng ƒë√£ ho√†n th√†nh v√† l√† m·ªôt ph·∫ßn c·ªßa chu·ªói. Reset c·ªù chu·ªói.")
            self.chain_download_sub_dub_active = False
            self.pending_auto_dub_after_current_sub_batch = False
            self.files_for_chained_dubbing = []

        logging.info(f"{log_prefix_bf} UI v√† tr·∫°ng th√°i ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ho√†n ch·ªânh.")
            

# H√†m ti·ªán √≠ch: L√†m m·ªõi n·ªôi dung textbox hi·ªÉn th·ªã k·ªãch b·∫£n thuy·∫øt minh
    def dub_refresh_script_textbox(self):
        """L√†m m·ªõi n·ªôi dung c·ªßa self.dub_script_textbox t·ª´ self.dub_srt_data."""
        # self.dub_script_textbox ƒë∆∞·ª£c t·∫°o trong DubbingTab (ui/tabs/dubbing_tab.py)
        if not hasattr(self, 'dub_script_textbox') or not self.dub_script_textbox:
            logging.warning("[Dubbing] dub_script_textbox ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.")
            return

        try:
            self.dub_script_textbox.configure(state="normal") 
            self.dub_script_textbox.delete("1.0", "end")

            if not self.dub_srt_data: # S·ª≠ d·ª•ng self.dub_srt_data
                self.dub_script_textbox.insert("1.0", "[Ch∆∞a c√≥ k·ªãch b·∫£n n√†o ƒë∆∞·ª£c t·∫£i]")
                # self.dub_script_textbox.configure(state="disabled") # T√πy ch·ªçn: v√¥ hi·ªáu h√≥a n·∫øu tr·ªëng
                return

            raw_text_to_display = ""
            for sub_item in self.dub_srt_data: # S·ª≠ d·ª•ng self.dub_srt_data
                index = sub_item.get('index', 'N/A')
                start_str = sub_item.get('start_str', '00:00:00,000')
                end_str = sub_item.get('end_str', '00:00:00,000')
                text_content = sub_item.get('text', '') # ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ r√µ r√†ng

                # ƒê·ªãnh d·∫°ng hi·ªÉn th·ªã trong textbox
                raw_text_to_display += f"--- M·ª•c #{index} [{start_str} --> {end_str}] ---\n"
                raw_text_to_display += text_content + "\n\n"
            
            self.dub_script_textbox.insert("1.0", raw_text_to_display)
            
        except Exception as e:
            logging.error(f"[Dubbing] L·ªói khi l√†m m·ªõi script textbox: {e}", exc_info=True)
            if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox:
                try:
                    self.dub_script_textbox.delete("1.0", "end")
                    self.dub_script_textbox.insert("1.0", f"L·ªñI HI·ªÇN TH·ªä K·ªäCH B·∫¢N:\n{e}")
                except:
                    pass # B·ªè qua n·∫øu kh√¥ng th·ªÉ c·∫≠p nh·∫≠t l·ªói v√†o textbox


# H√†m s·ª± ki·ªán: X·ª≠ l√Ω khi ng∆∞·ªùi d√πng ch·ªçn m·ªôt gi·ªçng ƒë·ªçc c·ª• th·ªÉ cho thuy·∫øt minh
    def dub_on_voice_selected(self, selected_display_name):
        """
        C·∫≠p nh·∫≠t self.dub_selected_voice_id_var v·ªõi ID th·ª±c t·∫ø c·ªßa gi·ªçng ƒë·ªçc ƒë∆∞·ª£c ch·ªçn.
        >>> ƒê√É C·∫¨P NH·∫¨T: T·ª± ƒë·ªông v√¥ hi·ªáu h√≥a checkbox SSML cho gi·ªçng kh√¥ng t∆∞∆°ng th√≠ch (Chirp). <<<
        """
        is_placeholder_or_error_voice = False
        if not selected_display_name or selected_display_name.startswith("--"):
            is_placeholder_or_error_voice = True
        elif hasattr(self, 'dub_current_engine_voice_display_to_id_map'):
            first_item_lower = selected_display_name.lower()
            placeholders_check = ["kh√¥ng t√¨m th·∫•y gi·ªçng", "l·ªói l·∫•y gi·ªçng", "ch∆∞a c√†i ƒë·∫∑t", "engine kh√¥ng h·ªó tr·ª£", "ch·ªçn engine tr∆∞·ªõc", "ƒëang t·∫£i danh s√°ch"]
            if any(ph in first_item_lower for ph in placeholders_check):
                is_placeholder_or_error_voice = True
        
        if is_placeholder_or_error_voice:
            if hasattr(self, 'dub_selected_voice_id_var'):
                self.dub_selected_voice_id_var.set("")
            logging.debug(f"[Dubbing] Kh√¥ng c√≥ gi·ªçng ƒë·ªçc h·ª£p l·ªá ƒë∆∞·ª£c ch·ªçn t·ª´ menu: '{selected_display_name}'")
            return

        voice_id = self.dub_current_engine_voice_display_to_id_map.get(selected_display_name)
        
        if voice_id is not None:
            if hasattr(self, 'dub_selected_voice_id_var'):
                self.dub_selected_voice_id_var.set(voice_id)
            
            current_engine_for_log = self.dub_selected_tts_engine_var.get() if hasattr(self, 'dub_selected_tts_engine_var') else "N/A"
            logging.info(f"[Dubbing] Gi·ªçng ƒë·ªçc ƒë∆∞·ª£c ch·ªçn: Display='{selected_display_name}', ID='{voice_id}', Engine: '{current_engine_for_log}'")
            
            # G·ªçi h√†m helper trung t√¢m ƒë·ªÉ c·∫≠p nh·∫≠t UI c·ªßa checkbox SSML
            self._update_ssml_checkbox_state()
            
            if self.initial_ui_setup_complete:
                self.update_status(f"‚ÑπÔ∏è Thuy·∫øt Minh - Gi·ªçng: {selected_display_name} (Engine: {current_engine_for_log})")
            else:
                logging.debug(f"[Dubbing Status Startup] initial_ui_setup_complete=False, b·ªè qua update status ban ƒë·∫ßu cho Dubbing Voice: {selected_display_name}")
            
            if not (hasattr(self, '_is_restoring_task_config') and self._is_restoring_task_config):
                if voice_id or (current_engine_for_log == "Google Translate (gTTS)" and selected_display_name.lower() == "m·∫∑c ƒë·ªãnh ti·∫øng vi·ªát"):
                    self.save_current_config()
                    logging.info(f"ƒê√£ l∆∞u c·∫•u h√¨nh sau khi ng∆∞·ªùi d√πng thay ƒë·ªïi gi·ªçng ƒë·ªçc sang ID: '{voice_id}' (Restoring: False)")
                else:
                    logging.debug(f"Kh√¥ng l∆∞u config cho l·ª±a ch·ªçn gi·ªçng '{selected_display_name}' (ID: {voice_id})")
            else:
                 logging.debug(f"B·ªè qua l∆∞u config cho gi·ªçng ID: '{voice_id}' v√¨ ƒëang kh√¥i ph·ª•c c·∫•u h√¨nh.")
        
        else:
            if hasattr(self, 'dub_selected_voice_id_var'):
                self.dub_selected_voice_id_var.set("")
            logging.error(f"[Dubbing] L·ªói: Kh√¥ng t√¨m th·∫•y ID cho gi·ªçng hi·ªÉn th·ªã '{selected_display_name}' trong map c·ªßa engine hi·ªán t·∫°i.")
            if not (self.is_subbing or self.is_downloading or self.is_loading_model_for_timer or self.dub_is_processing):
                self.start_time = None
            self.update_status(f"Thuy·∫øt Minh - L·ªói ch·ªçn gi·ªçng: Kh√¥ng t√¨m th·∫•y ID cho '{selected_display_name}'")
            

# === H√ÄM HELPER M·ªöI: C·∫≠p nh·∫≠t tr·∫°ng th√°i v√† text c·ªßa checkbox SSML ===
    def _update_ssml_checkbox_state(self):
        """
        H√†m trung t√¢m ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i (b·∫≠t/t·∫Øt) v√† nh√£n (text)
        c·ªßa checkbox SSML d·ª±a tr√™n engine v√† gi·ªçng ƒë·ªçc hi·ªán t·∫°i.
        """
        ssml_checkbox = getattr(self, 'dub_chk_use_google_ssml', None)
        if not (ssml_checkbox and ssml_checkbox.winfo_exists()):
            return # Tho√°t n·∫øu widget ch∆∞a t·ªìn t·∫°i

        current_engine = self.dub_selected_tts_engine_var.get()
        
        # M·∫∑c ƒë·ªãnh l√† b·∫≠t v√† hi·ªÉn th·ªã text chu·∫©n
        final_state = "normal"
        final_text = "T·∫°o SSML c∆° b·∫£n (Google TTS)"

        if current_engine != "Google Cloud TTS":
            # N·∫øu kh√¥ng ph·∫£i Google Cloud, lu√¥n v√¥ hi·ªáu h√≥a
            final_state = "disabled"
        else:
            # N·∫øu l√† Google Cloud, ki·ªÉm tra gi·ªçng ƒë·ªçc
            current_voice_id = self.dub_selected_voice_id_var.get()
            if "chirp" in current_voice_id.lower():
                final_state = "disabled"
                final_text = "SSML kh√¥ng h·ªó tr·ª£ cho gi·ªçng Chirp"
                # T·ª± ƒë·ªông b·ªè tick n·∫øu gi·ªçng kh√¥ng h·ªó tr·ª£
                self.dub_use_google_ssml_var.set(False)

        # √Åp d·ª•ng tr·∫°ng th√°i v√† text cu·ªëi c√πng
        ssml_checkbox.configure(state=final_state, text=final_text)


# H√†m t·∫°o TTS: S·ª≠ d·ª•ng OpenAI TTS API
    def dub_speak_with_openai(self, text_to_speak, output_mp3_path, is_preview=False, max_retries=3, initial_retry_delay_s=20): # Gi·∫£m initial_retry_delay_s m·ªôt ch√∫t
        """T·∫°o file √¢m thanh MP3 t·ª´ text b·∫±ng OpenAI TTS API."""
        
        context_is_batch = hasattr(self, 'dub_is_processing') and self.dub_is_processing and not is_preview
        base_log_prefix = f"[Dubbing_OpenAI_Batch(Seg:{os.path.basename(output_mp3_path)})]" if context_is_batch else f"[Dubbing_OpenAI_Preview(File:{os.path.basename(output_mp3_path)})]"
        
        logging.info(f"{base_log_prefix} Chu·∫©n b·ªã cho text: '{text_to_speak[:40].replace(os.linesep, ' ')}...'")

        if self.dub_stop_event.is_set():
            logging.info(f"{base_log_prefix} Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu v·ªõi OpenAI.")
            return "STOPPED_BY_USER" # Tr·∫£ v·ªÅ m√£ l·ªói d·ª´ng

        current_openai_api_key = self.openai_key_var.get()
        if not current_openai_api_key:
            error_msg_ui = "L·ªói c·∫•u h√¨nh: OpenAI API Key ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p trong ·ª©ng d·ª•ng (C√†i ƒë·∫∑t API Keys)."
            error_msg_log = f"{base_log_prefix} {error_msg_ui}"
            logging.error(error_msg_log)
            self.after(0, lambda msg=error_msg_ui: messagebox.showerror("L·ªói API Key OpenAI", msg, parent=self.master_app if hasattr(self, 'master_app') else self)) # Hi·ªÉn th·ªã popup
            return "ERROR_OPENAI_API_KEY_MISSING" # Tr·∫£ v·ªÅ m√£ l·ªói c·ª• th·ªÉ

        if not HAS_OPENAI or OpenAI is None:
            error_msg_ui = "L·ªói th∆∞ vi·ªán: OpenAI SDK ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t ho·∫∑c import l·ªói.\nVui l√≤ng c√†i ƒë·∫∑t: pip install openai"
            error_msg_log = f"{base_log_prefix} {error_msg_ui.splitlines()[0]}" # Log d√≤ng ƒë·∫ßu
            logging.error(error_msg_log)
            self.after(0, lambda msg=error_msg_ui: messagebox.showerror("L·ªói Th∆∞ Vi·ªán OpenAI", msg, parent=self.master_app if hasattr(self, 'master_app') else self)) # Hi·ªÉn th·ªã popup
            return "ERROR_OPENAI_SDK_MISSING" # Tr·∫£ v·ªÅ m√£ l·ªói c·ª• th·ªÉ
            
        try:
            client = OpenAI(api_key=current_openai_api_key, timeout=60.0)
        except Exception as e_client:
            error_msg_ui = f"L·ªói kh·ªüi t·∫°o OpenAI client: {e_client}"
            error_msg_log = f"{base_log_prefix} {error_msg_ui}"
            logging.error(error_msg_log, exc_info=True)
            self.after(0, lambda msg=error_msg_ui: messagebox.showerror("L·ªói Kh·ªüi T·∫°o OpenAI", f"Kh√¥ng th·ªÉ kh·ªüi t·∫°o OpenAI client:\n{msg}", parent=self.master_app if hasattr(self, 'master_app') else self))
            return "ERROR_OPENAI_CLIENT_INIT" # Tr·∫£ v·ªÅ m√£ l·ªói
            
        retries = 0
        current_delay_s = initial_retry_delay_s

        # L·∫•y gi·ªçng ƒë·ªçc ƒë√£ ch·ªçn t·ª´ self.dub_selected_voice_id_var (ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·ªüi dub_on_voice_selected)
        selected_voice = self.dub_selected_voice_id_var.get()
        if not selected_voice and self.dub_selected_tts_engine_var.get() == "OpenAI TTS":
            # Fallback n·∫øu kh√¥ng c√≥ gi·ªçng n√†o ƒë∆∞·ª£c ch·ªçn cho OpenAI (d√π dub_on_tts_engine_selected n√™n x·ª≠ l√Ω vi·ªác n√†y)
            try:
                default_openai_voice_id = list(self.dub_tts_voice_options["OpenAI TTS"].keys())[0]
                selected_voice = default_openai_voice_id
                logging.warning(f"{base_log_prefix} Kh√¥ng c√≥ gi·ªçng OpenAI ƒë∆∞·ª£c ch·ªçn, s·ª≠ d·ª•ng gi·ªçng m·∫∑c ƒë·ªãnh: '{selected_voice}'.")
            except Exception:
                 logging.error(f"{base_log_prefix} Kh√¥ng c√≥ gi·ªçng OpenAI n√†o ƒë∆∞·ª£c ch·ªçn v√† kh√¥ng th·ªÉ l·∫•y gi·ªçng m·∫∑c ƒë·ªãnh. S·ª≠ d·ª•ng 'nova'.")
                 selected_voice = "nova" # Fallback c·ª©ng
        
        # S·ª≠ d·ª•ng model ƒë√£ c·∫•u h√¨nh trong PiuApp.__init__ (self.dub_openai_tts_model)
        tts_model_to_use = self.dub_openai_tts_model if hasattr(self, 'dub_openai_tts_model') else "tts-1"

        logging.info(f"{base_log_prefix} S·∫Ω s·ª≠ d·ª•ng gi·ªçng: '{selected_voice}', model: '{tts_model_to_use}'.")

        last_error_message_for_ui = "" # L∆∞u l·ªói cu·ªëi c√πng ƒë·ªÉ hi·ªÉn th·ªã n·∫øu t·∫•t c·∫£ retry th·∫•t b·∫°i

        while retries <= max_retries:
            if self.dub_stop_event.is_set():
                logging.info(f"{base_log_prefix} (Th·ª≠ {retries+1}) Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán trong v√≤ng l·∫∑p retry OpenAI.")
                return False
            log_prefix_with_retry = f"{base_log_prefix} (Gi·ªçng:{selected_voice}, Model:{tts_model_to_use}, Th·ª≠ {retries+1})"
            try:
                if retries > 0:
                    logging.info(f"{log_prefix_with_retry} ƒêang th·ª≠ l·∫°i sau {current_delay_s} gi√¢y...")
                    time.sleep(current_delay_s) 
                
                if is_preview and retries == 0: 
                    self.after(0, lambda: self.update_status(f"{log_prefix_with_retry} ƒêang g·ªçi OpenAI TTS API..."))
                
                logging.debug(f"{log_prefix_with_retry} G·ª≠i y√™u c·∫ßu ƒë·∫øn OpenAI TTS API...")
                
                response = client.audio.speech.create(
                    model=tts_model_to_use,
                    voice=selected_voice,
                    input=text_to_speak,
                    response_format="mp3" 
                )
                if self.dub_stop_event.is_set():
                    logging.info(f"{log_prefix_with_retry} Y√™u c·∫ßu d·ª´ng sau khi OpenAI API tr·∫£ v·ªÅ, tr∆∞·ªõc khi ghi file.")
                    return False
                
                with open(output_mp3_path, 'wb') as f:
                    f.write(response.content)
                
                if not os.path.exists(output_mp3_path) or os.path.getsize(output_mp3_path) == 0:
                    error_msg_file = f"{log_prefix_with_retry} L·ªói: File MP3 output kh√¥ng ƒë∆∞·ª£c t·∫°o ho·∫∑c r·ªóng."
                    logging.error(error_msg_file)
                    last_error_message_for_ui = error_msg_file
                    if is_preview: self.after(0, lambda msg=error_msg_file: self.update_status(msg))
                    return False
                self._track_api_call(service_name="openai_tts_chars", units=len(text_to_speak))

                # <<< G·ªåI H√ÄM T·ªêI ∆ØU M·ªöI >>>
                if not is_preview: # Ch·ªâ t·ªëi ∆∞u cho file kh√¥ng ph·∫£i preview, ho·∫∑c t√πy b·∫°n quy·∫øt ƒë·ªãnh
                    logging.info(f"{log_prefix_with_retry} B·∫Øt ƒë·∫ßu t·ªëi ∆∞u kho·∫£ng l·∫∑ng cho file OpenAI TTS: {os.path.basename(output_mp3_path)}")
                    if not self._optimize_trailing_silence_ffmpeg(output_mp3_path, target_pause_ms=150):
                        logging.warning(f"{log_prefix_with_retry} T·ªëi ∆∞u kho·∫£ng l·∫∑ng cho OpenAI TTS c√≥ th·ªÉ ƒë√£ th·∫•t b·∫°i. Ti·∫øp t·ª•c v·ªõi file ch∆∞a t·ªëi ∆∞u.")
                    else:
                        logging.info(f"{log_prefix_with_retry} T·ªëi ∆∞u kho·∫£ng l·∫∑ng cho OpenAI TTS th√†nh c√¥ng.")

                success_msg = f"{log_prefix_with_retry} Th√†nh c√¥ng: ƒê√£ t·∫°o {os.path.basename(output_mp3_path)}"
                logging.info(success_msg)
                if is_preview: 
                    self.after(0, lambda msg=success_msg: self.update_status(msg))
                    if PLAYSOUND_AVAILABLE and playsound:
                        try:
                            logging.debug(f"{log_prefix_with_retry} ƒêang ph√°t preview: {output_mp3_path}")
                            playsound(os.path.abspath(output_mp3_path))
                            self.after(100, lambda: self.update_status(f"{log_prefix_with_retry} ƒê√£ g·ª≠i l·ªánh ph√°t √¢m thanh."))
                        except Exception as e_play:
                            logging.error(f"{log_prefix_with_retry} L·ªói khi d√πng playsound: {e_play}")
                            self.after(0, lambda msg=str(e_play): self.update_status(f"L·ªói ph√°t preview OpenAI: {msg}"))
                    else:
                        logging.warning(f"{log_prefix_with_retry} Th∆∞ vi·ªán 'playsound' kh√¥ng kh·∫£ d·ª•ng.")
                        self.after(0, lambda: self.update_status(f"{log_prefix_with_retry} T·∫°o xong, kh√¥ng th·ªÉ ph√°t (thi·∫øu playsound)."))
                return True # Th√†nh c√¥ng, tho√°t kh·ªèi v√≤ng l·∫∑p v√† h√†m

            except RateLimitError as e_rate: 
                error_text = f"{log_prefix_with_retry} L·ªói RateLimit: {e_rate}."
                logging.warning(error_text)
                last_error_message_for_ui = error_text
                if retries >= max_retries:
                    final_msg = f"{error_text} ƒê√£ th·ª≠ l·∫°i {max_retries} l·∫ßn."
                    if is_preview: 
                        self.after(0, lambda msg=final_msg: self.update_status(msg))
                        self.after(0, lambda msg=final_msg: messagebox.showerror("L·ªói Gi·ªõi H·∫°n OpenAI", msg, parent=self))
                    return False 
                retries += 1
                current_delay_s = min(current_delay_s * 2, 300) # TƒÉng g·∫•p ƒë√¥i, max 5 ph√∫t
                logging.info(f"{log_prefix_with_retry} S·∫Ω th·ª≠ l·∫°i sau {current_delay_s}s.")
            
            except APIStatusError as e_status: 
                 error_text = f"{log_prefix_with_retry} L·ªói API Status (Code: {e_status.status_code}): {e_status.message}"
                 logging.error(error_text)
                 last_error_message_for_ui = error_text
                 if 500 <= e_status.status_code < 600 and retries < max_retries: # L·ªói server, c√≥ th·ªÉ th·ª≠ l·∫°i
                    retries += 1
                    current_delay_s = min(current_delay_s * 2, 300)
                    logging.info(f"{log_prefix_with_retry} L·ªói server, s·∫Ω th·ª≠ l·∫°i sau {current_delay_s}s.")
                    continue # Ti·∫øp t·ª•c v√≤ng l·∫∑p ƒë·ªÉ th·ª≠ l·∫°i
                 break # C√°c l·ªói APIStatusError kh√°c th√¨ kh√¥ng th·ª≠ l·∫°i, tho√°t v√≤ng l·∫∑p
            
            except (AuthenticationError, APIConnectionError, APITimeoutError) as e_non_retry:
                error_type_map = {
                    AuthenticationError: "L·ªói X√°c th·ª±c: API Key kh√¥ng h·ª£p l·ªá ho·∫∑c h·∫øt h·∫°n.",
                    APIConnectionError: "L·ªói K·∫øt n·ªëi: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server OpenAI.",
                    APITimeoutError: "L·ªói Timeout: Y√™u c·∫ßu ƒë·∫øn OpenAI b·ªã qu√° th·ªùi gian ch·ªù."
                }
                error_desc = error_type_map.get(type(e_non_retry), f"L·ªói OpenAI kh√¥ng x√°c ƒë·ªãnh ({type(e_non_retry).__name__})")
                error_text = f"{log_prefix_with_retry} {error_desc}: {str(e_non_retry)}"
                logging.error(error_text)
                last_error_message_for_ui = error_text
                break # Tho√°t v√≤ng l·∫∑p, kh√¥ng th·ª≠ l·∫°i cho c√°c l·ªói n√†y
            
            except Exception as e_general: 
                error_text = f"{log_prefix_with_retry} L·ªói kh√¥ng mong mu·ªën: {type(e_general).__name__} - {str(e_general)}"
                logging.error(error_text, exc_info=True)
                last_error_message_for_ui = error_text
                break # Tho√°t v√≤ng l·∫∑p

        # N·∫øu v√≤ng l·∫∑p k·∫øt th√∫c m√† kh√¥ng return True (t·ª©c l√† t·∫•t c·∫£ c√°c l·∫ßn th·ª≠ ƒë·ªÅu th·∫•t b·∫°i)
        if is_preview: # Ch·ªâ hi·ªÉn th·ªã UI n·∫øu l√† preview
             # ƒê·∫£m b·∫£o last_error_message_for_ui c√≥ gi√° tr·ªã
             if not last_error_message_for_ui: last_error_message_for_ui = f"{base_log_prefix} T·∫°o TTS th·∫•t b·∫°i sau {max_retries + 1} l·∫ßn th·ª≠."
             self.after(0, lambda msg=last_error_message_for_ui: self.update_status(msg))
             self.after(0, lambda msg=last_error_message_for_ui: messagebox.showerror("L·ªói OpenAI TTS (Sau Retry)", msg, parent=self))
        return False


# T·∫°o file √¢m thanh MP3 t·ª´ text ho·∫∑c SSML b·∫±ng Google Cloud TTS API ( Ng√¥n Ng·ªØ ƒê·ªông )
    def dub_speak_with_google(self, text_to_speak_or_ssml, output_mp3_path, is_preview=False, max_retries=2, initial_retry_delay_s=15):
        """T·∫°o file √¢m thanh MP3 t·ª´ text ho·∫∑c SSML b·∫±ng Google Cloud TTS API.
        >>> ƒê√É S·ª¨A L·ªñI: T·ª± ƒë·ªông x√°c ƒë·ªãnh m√£ ng√¥n ng·ªØ t·ª´ ID c·ªßa gi·ªçng ƒë·ªçc. <<<
        """

        with keep_awake("Synthesize TTS (GCloud)"):

            context_is_batch = hasattr(self, 'dub_is_processing') and self.dub_is_processing and not is_preview
            base_log_prefix = f"[Dubbing_Google_Batch(Seg:{os.path.basename(output_mp3_path)})]" if context_is_batch else f"[Dubbing_Google_Preview(File:{os.path.basename(output_mp3_path)})]"
            
            is_ssml_input = text_to_speak_or_ssml.strip().lower().startswith("<speak>") and \
                            text_to_speak_or_ssml.strip().lower().endswith("</speak>")
            log_text_snippet = text_to_speak_or_ssml[:70].replace(os.linesep, ' ') + "..." if len(text_to_speak_or_ssml) > 70 else text_to_speak_or_ssml.replace(os.linesep, ' ')
            
            logging.info(f"{base_log_prefix} Chu·∫©n b·ªã cho {'SSML' if is_ssml_input else 'TEXT'}: '{log_text_snippet}'")

            if self.dub_stop_event.is_set():
                logging.info(f"{base_log_prefix} Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu v·ªõi Google Cloud TTS.")
                return "STOPPED_BY_USER"

            current_google_key_path = self.google_key_path_var.get()
            if not current_google_key_path or not os.path.exists(current_google_key_path):
                error_msg_ui = "L·ªói c·∫•u h√¨nh: ƒê∆∞·ªùng d·∫´n file JSON Key c·ªßa Google Cloud ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p ho·∫∑c kh√¥ng t·ªìn t·∫°i"
                error_msg_log = f"{base_log_prefix} {error_msg_ui}"
                logging.error(error_msg_log)
                self.after(0, lambda msg=error_msg_ui: messagebox.showerror("L·ªói File Key Google Cloud", msg, parent=self.master_app if hasattr(self, 'master_app') else self))
                return "ERROR_GOOGLE_KEY_FILE_MISSING"

            try:
                from google.cloud import texttospeech as google_tts_client
                from google.oauth2 import service_account as google_service_auth
                from google.api_core import exceptions as google_api_exceptions
            except ImportError:
                error_msg_ui = "L·ªói th∆∞ vi·ªán: Google Cloud Text-to-Speech SDK ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t.\nVui l√≤ng c√†i ƒë·∫∑t: pip install google-cloud-texttospeech google-auth"
                error_msg_log = f"{base_log_prefix} {error_msg_ui.splitlines()[0]}"
                logging.error(error_msg_log)
                self.after(0, lambda msg=error_msg_ui: messagebox.showerror("L·ªói Th∆∞ Vi·ªán Google TTS", msg, parent=self.master_app if hasattr(self, 'master_app') else self))
                return "ERROR_GOOGLE_SDK_MISSING"
                
            retries = 0
            current_delay_s = initial_retry_delay_s

            selected_voice_name = self.dub_selected_voice_id_var.get()

            # T·ª± ƒë·ªông tr√≠ch xu·∫•t m√£ ng√¥n ng·ªØ t·ª´ ID gi·ªçng ƒë·ªçc
            language_code_to_use = "vi-VN" # M·∫∑c ƒë·ªãnh an to√†n
            if selected_voice_name:
                try:
                    parts = selected_voice_name.split('-')
                    if len(parts) >= 2:
                        language_code_to_use = f"{parts[0]}-{parts[1]}"
                        logging.info(f"{base_log_prefix} ƒê√£ t·ª± ƒë·ªông x√°c ƒë·ªãnh m√£ ng√¥n ng·ªØ: {language_code_to_use} t·ª´ gi·ªçng ƒë·ªçc '{selected_voice_name}'.")
                except Exception:
                    logging.warning(f"{base_log_prefix} Kh√¥ng th·ªÉ tr√≠ch xu·∫•t m√£ ng√¥n ng·ªØ t·ª´ '{selected_voice_name}', d√πng m·∫∑c ƒë·ªãnh 'vi-VN'.")

            if not selected_voice_name and self.dub_selected_tts_engine_var.get() == "Google Cloud TTS":
                try:
                    default_google_voice_id = list(self.dub_tts_voice_options["Google Cloud TTS"].keys())[0]
                    selected_voice_name = default_google_voice_id
                    logging.warning(f"{base_log_prefix} Kh√¥ng c√≥ gi·ªçng Google Cloud ƒë∆∞·ª£c ch·ªçn, s·ª≠ d·ª•ng gi·ªçng m·∫∑c ƒë·ªãnh: '{selected_voice_name}'.")
                except Exception:
                     logging.error(f"{base_log_prefix} Kh√¥ng c√≥ gi·ªçng Google Cloud ƒë∆∞·ª£c ch·ªçn v√† kh√¥ng th·ªÉ l·∫•y gi·ªçng m·∫∑c ƒë·ªãnh. S·ª≠ d·ª•ng 'vi-VN-Neural2-A'.")
                     selected_voice_name = "vi-VN-Neural2-A"
            
            logging.info(f"{base_log_prefix} S·∫Ω s·ª≠ d·ª•ng gi·ªçng: '{selected_voice_name}', ng√¥n ng·ªØ: '{language_code_to_use}'.")
            last_error_message_for_ui = ""

            while retries <= max_retries:
                if self.dub_stop_event.is_set():
                    logging.info(f"{base_log_prefix} (Th·ª≠ {retries+1}) Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán trong v√≤ng l·∫∑p retry Google Cloud.")
                    return False            

                log_prefix_with_retry = f"{base_log_prefix} (Gi·ªçng:{selected_voice_name}, Th·ª≠ {retries+1})"
                try:
                    if retries > 0:
                        logging.info(f"{log_prefix_with_retry} ƒêang th·ª≠ l·∫°i sau {current_delay_s} gi√¢y...")
                        time.sleep(current_delay_s)

                    gcp_credentials = google_service_auth.Credentials.from_service_account_file(current_google_key_path)
                    client = google_tts_client.TextToSpeechClient(credentials=gcp_credentials)
                    
                    def __normalize_ascii_quotes(text: str) -> str:
                        out = []
                        open_quote = True
                        for ch in text:
                            if ch == '"':
                                out.append('‚Äú' if open_quote else '‚Äù')
                                open_quote = not open_quote
                            else:
                                out.append(ch)
                        return ''.join(out)

                    def __normalize_quotes_in_ssml(ssml: str) -> str:
                        try:
                            import xml.etree.ElementTree as ET
                            root = ET.fromstring(ssml)
                            for node in root.iter():
                                if node.text:
                                    node.text = __normalize_ascii_quotes(node.text)
                                if node.tail:
                                    node.tail = __normalize_ascii_quotes(node.tail)
                            return ET.tostring(root, encoding='unicode', method='xml')
                        except Exception as e:
                            logging.warning(f"{base_log_prefix} Kh√¥ng parse ƒë∆∞·ª£c SSML ƒë·ªÉ normalize ngo·∫∑c k√©p: {e}. G·ª≠i nguy√™n b·∫£n.")
                            return ssml

                    normalize_quotes = True

                    if is_ssml_input:
                        text_for_engine = (
                            __normalize_quotes_in_ssml(text_to_speak_or_ssml) if normalize_quotes
                            else text_to_speak_or_ssml
                        )
                        synthesis_input = google_tts_client.SynthesisInput(ssml=text_for_engine)
                    else:
                        text_for_engine = (
                            __normalize_ascii_quotes(text_to_speak_or_ssml) if normalize_quotes
                            else text_to_speak_or_ssml
                        )
                        synthesis_input = google_tts_client.SynthesisInput(text=text_for_engine)

                    voice_params = google_tts_client.VoiceSelectionParams(
                        language_code=language_code_to_use,
                        name=selected_voice_name
                    )
                    audio_config = google_tts_client.AudioConfig(
                        audio_encoding=google_tts_client.AudioEncoding.MP3
                    )

                    if is_preview and retries == 0: 
                        self.after(0, lambda: self.update_status(f"{log_prefix_with_retry} ƒêang g·ªçi Google Cloud TTS API..."))
                    
                    logging.debug(f"{log_prefix_with_retry} G·ª≠i y√™u c·∫ßu ƒë·∫øn Google Cloud TTS API...")
                    response = client.synthesize_speech(
                        request={"input": synthesis_input, "voice": voice_params, "audio_config": audio_config}
                    )

                    if self.dub_stop_event.is_set():
                        logging.info(f"{log_prefix_with_retry} Y√™u c·∫ßu d·ª´ng sau khi Google API tr·∫£ v·ªÅ, tr∆∞·ªõc khi ghi file.")
                        return False
                    
                    with open(output_mp3_path, 'wb') as out_file:
                        out_file.write(response.audio_content)

                    if not os.path.exists(output_mp3_path) or os.path.getsize(output_mp3_path) == 0:
                        error_msg_file = f"{log_prefix_with_retry} L·ªói: File MP3 output kh√¥ng ƒë∆∞·ª£c t·∫°o ho·∫∑c r·ªóng."
                        logging.error(error_msg_file)
                        last_error_message_for_ui = error_msg_file
                        if is_preview: self.after(0, lambda msg=error_msg_file: self.update_status(msg))
                        return False 
                    self._track_api_call(service_name="google_tts_chars", units=len(text_to_speak_or_ssml))

                    if not is_preview:
                        logging.info(f"{log_prefix_with_retry} B·∫Øt ƒë·∫ßu t·ªëi ∆∞u kho·∫£ng l·∫∑ng cho file Google TTS: {os.path.basename(output_mp3_path)}")
                        if not self._optimize_trailing_silence_ffmpeg(output_mp3_path, target_pause_ms=150):
                            logging.warning(f"{log_prefix_with_retry} T·ªëi ∆∞u kho·∫£ng l·∫∑ng c√≥ th·ªÉ ƒë√£ th·∫•t b·∫°i.")
                        else:
                            logging.info(f"{log_prefix_with_retry} T·ªëi ∆∞u kho·∫£ng l·∫∑ng th√†nh c√¥ng.")
                    
                    success_msg = f"{log_prefix_with_retry} Th√†nh c√¥ng: ƒê√£ t·∫°o {os.path.basename(output_mp3_path)}"
                    logging.info(success_msg)
                    if is_preview: 
                        self.after(0, lambda msg=success_msg: self.update_status(msg))
                        if PLAYSOUND_AVAILABLE and playsound:
                            try:
                                logging.debug(f"{log_prefix_with_retry} ƒêang ph√°t preview: {output_mp3_path}")
                                playsound(os.path.abspath(output_mp3_path))
                                self.after(100, lambda: self.update_status(f"{log_prefix_with_retry} ƒê√£ g·ª≠i l·ªánh ph√°t √¢m thanh."))
                            except Exception as e_play:
                                logging.error(f"{log_prefix_with_retry} L·ªói khi d√πng playsound: {e_play}")
                                self.after(0, lambda msg=str(e_play): self.update_status(f"L·ªói ph√°t preview Google: {msg}"))
                        else:
                            logging.warning(f"{log_prefix_with_retry} Th∆∞ vi·ªán 'playsound' kh√¥ng kh·∫£ d·ª•ng.")
                            self.after(0, lambda: self.update_status(f"{log_prefix_with_retry} T·∫°o xong, kh√¥ng th·ªÉ ph√°t (thi·∫øu playsound)."))
                    return True

                except google_api_exceptions.InvalidArgument as e_invalid_arg: 
                    error_text = f"{log_prefix_with_retry} L·ªói InvalidArgument: {str(e_invalid_arg)}"
                    logging.error(error_text)
                    last_error_message_for_ui = error_text
                    should_show_popup_now_google = False
                    if is_preview:
                        should_show_popup_now_google = True
                    elif hasattr(self, 'dub_is_processing') and self.dub_is_processing:
                        if not self.dub_batch_first_api_error_msg_shown:
                            self.dub_batch_first_api_error_msg_shown = True
                            self.dub_batch_accumulated_api_error_details = error_text
                            should_show_popup_now_google = True
                            self.dub_batch_had_api_key_errors = True
                        else:
                            logging.warning(f"{log_prefix_with_retry} L·ªói API Google ti·∫øp theo (InvalidArgument), popup ƒë√£ b·ªã ch·∫∑n cho batch n√†y: {e_invalid_arg}")
                    
                    if should_show_popup_now_google:
                         self.after(0, lambda msg=error_text: messagebox.showerror("L·ªói Tham S·ªë Google TTS", f"{msg}\nVui l√≤ng ki·ªÉm tra l·∫°i gi·ªçng ƒë·ªçc, m√£ ng√¥n ng·ªØ ho·∫∑c c√∫ ph√°p SSML.", parent=self))
                    
                    if "voice name" in str(e_invalid_arg).lower() or "language_code" in str(e_invalid_arg).lower() or "SSML" in str(e_invalid_arg):
                        if is_preview:
                             self.after(0, lambda msg=error_text: messagebox.showerror("L·ªói Tham S·ªë Google TTS", f"{msg}\nVui l√≤ng ki·ªÉm tra l·∫°i gi·ªçng ƒë·ªçc, m√£ ng√¥n ng·ªØ ho·∫∑c c√∫ ph√°p SSML.", parent=self))
                    break 
                except google_api_exceptions.ResourceExhausted as e_res:
                    error_text = f"{log_prefix_with_retry} L·ªói ResourceExhausted (Quota/RateLimit): {e_res}."
                    logging.warning(error_text)
                    last_error_message_for_ui = error_text
                    should_show_popup_now_google_res = False
                    if is_preview: should_show_popup_now_google_res = True
                    elif hasattr(self, 'dub_is_processing') and self.dub_is_processing:
                        if not self.dub_batch_first_api_error_msg_shown:
                            self.dub_batch_first_api_error_msg_shown = True
                            self.dub_batch_accumulated_api_error_details = error_text
                            should_show_popup_now_google_res = True
                            self.dub_batch_had_api_key_errors = True 
                        else: logging.warning(f"{log_prefix_with_retry} L·ªói API Google ti·∫øp theo (ResourceExhausted), popup b·ªã ch·∫∑n: {e_res}")
                    
                    if should_show_popup_now_google_res:
                         self.after(0, lambda msg=f"{error_text} ƒê√£ th·ª≠ l·∫°i {retries} l·∫ßn.": messagebox.showerror("L·ªói Google TTS (Qu√° t·∫£i/Quota)", msg, parent=self))
                    if retries >= max_retries:
                        final_msg = f"{error_text} ƒê√£ th·ª≠ l·∫°i {max_retries} l·∫ßn."
                        if is_preview: 
                            self.after(0, lambda msg=final_msg: self.update_status(msg))
                            self.after(0, lambda msg=final_msg: messagebox.showerror("L·ªói Google TTS (Qu√° t·∫£i)", msg, parent=self))
                        return False
                    retries += 1
                    current_delay_s = min(current_delay_s * 2, 180) 
                    logging.info(f"{log_prefix_with_retry} S·∫Ω th·ª≠ l·∫°i sau {current_delay_s}s.")
                except (google_api_exceptions.ServiceUnavailable, google_api_exceptions.DeadlineExceeded, google_api_exceptions.InternalServerError) as e_retryable_server:
                    error_text = f"{log_prefix_with_retry} L·ªói Server Google ({type(e_retryable_server).__name__}): {e_retryable_server}."
                    logging.warning(error_text)
                    last_error_message_for_ui = error_text
                    if retries >= max_retries:
                        final_msg = f"{error_text} ƒê√£ th·ª≠ l·∫°i {max_retries} l·∫ßn."
                        if is_preview: 
                            self.after(0, lambda msg=final_msg: self.update_status(msg))
                            self.after(0, lambda msg=final_msg: messagebox.showerror("L·ªói Server Google TTS", msg, parent=self))
                        return False
                    retries += 1
                    current_delay_s = min(current_delay_s * 1.5, 120)
                    logging.info(f"{log_prefix_with_retry} S·∫Ω th·ª≠ l·∫°i sau {current_delay_s}s.")
                except (google_api_exceptions.PermissionDenied, google_api_exceptions.NotFound) as e_non_retry_google:
                    error_map_google = {
                        google_api_exceptions.PermissionDenied: "L·ªói Quy·ªÅn Truy C·∫≠p. Ki·ªÉm tra Service Account JSON key v√† quy·ªÅn API Text-to-Speech.",
                        google_api_exceptions.NotFound: "L·ªói Kh√¥ng T√¨m Th·∫•y. Gi·ªçng ƒë·ªçc ho·∫∑c API endpoint c√≥ th·ªÉ kh√¥ng ƒë√∫ng."
                    }
                    error_desc = error_map_google.get(type(e_non_retry_google), f"L·ªói Google API kh√¥ng x√°c ƒë·ªãnh ({type(e_non_retry_google).__name__})")
                    error_text = f"{log_prefix_with_retry} {error_desc}: {str(e_non_retry_google)}"
                    logging.error(error_text)
                    last_error_message_for_ui = error_text
                    break 
                except FileNotFoundError:
                    error_text = f"{log_prefix_with_retry} L·ªói FileNotFoundError: File JSON Key Google '{current_google_key_path}' kh√¥ng t√¨m th·∫•y."
                    logging.critical(error_text)
                    last_error_message_for_ui = error_text
                    break 
                except Exception as e_general: 
                    error_text = f"{log_prefix_with_retry} L·ªói kh√¥ng mong mu·ªën: {type(e_general).__name__} - {str(e_general)}"
                    logging.error(error_text, exc_info=True)
                    last_error_message_for_ui = error_text
                    break 
            
            if is_preview and 'success_msg' not in locals():
                 if not last_error_message_for_ui: last_error_message_for_ui = f"{base_log_prefix} T·∫°o TTS th·∫•t b·∫°i sau {max_retries + 1} l·∫ßn th·ª≠."
                 self.after(0, lambda msg=last_error_message_for_ui: self.update_status(msg))
                 if "L·ªói Tham S·ªë Google TTS" not in last_error_message_for_ui and \
                    "L·ªói Google TTS (Qu√° t·∫£i)" not in last_error_message_for_ui and \
                    "L·ªói Server Google TTS" not in last_error_message_for_ui:
                     self.after(0, lambda msg=last_error_message_for_ui: messagebox.showerror("L·ªói Google TTS (Sau Retry)", msg, parent=self))
            return False


# H√†m t·∫°o TTS: S·ª≠ d·ª•ng gTTS (Google Translate Text-to-Speech)
    def dub_speak_with_gtts(self, text_to_speak, output_mp3_path, is_preview=False):
        """T·∫°o file √¢m thanh MP3 t·ª´ text b·∫±ng th∆∞ vi·ªán gTTS."""
        context_is_batch = hasattr(self, 'dub_is_processing') and self.dub_is_processing and not is_preview
        base_log_prefix = f"[Dubbing_gTTS_Batch(Seg:{os.path.basename(output_mp3_path)})]" if context_is_batch else f"[Dubbing_gTTS_Preview(File:{os.path.basename(output_mp3_path)})]"
        
        logging.info(f"{base_log_prefix} Chu·∫©n b·ªã cho text: '{text_to_speak[:40].replace(os.linesep, ' ')}...' -> {os.path.basename(output_mp3_path)}")

        text_for_engine = text_to_speak.replace('"', '')

        if self.dub_stop_event.is_set():
            logging.info(f"{base_log_prefix} Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu v·ªõi gTTS.")
            if is_preview: self.after(0, lambda: self.update_status(f"{base_log_prefix} ƒê√£ h·ªßy b·ªüi ng∆∞·ªùi d√πng."))
            return False

        if not text_to_speak.strip():
            error_msg = f"{base_log_prefix} L·ªói: Text r·ªóng, kh√¥ng c√≥ g√¨ ƒë·ªÉ t·ªïng h·ª£p gi·ªçng n√≥i."
            logging.warning(error_msg)
            if is_preview: # Ch·ªâ hi·ªÉn th·ªã UI n·∫øu l√† preview
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                self.after(0, lambda: messagebox.showinfo("Th√¥ng tin", "Kh√¥ng c√≥ n·ªôi dung text ƒë·ªÉ t·∫°o √¢m thanh.", parent=self))
            return False

        try:
            if is_preview:
                 self.after(0, lambda: self.update_status(f"{base_log_prefix} ƒêang g·ªçi API Google Translate (gTTS)..."))

            # lang='vi' cho ti·∫øng Vi·ªát. gTTS kh√¥ng c√≥ nhi·ªÅu t√πy ch·ªçn gi·ªçng cho c√πng m·ªôt ng√¥n ng·ªØ.
            tts_object = gTTS(text=text_to_speak, lang='vi', slow=False)
            tts_object.save(output_mp3_path)

            if not os.path.exists(output_mp3_path) or os.path.getsize(output_mp3_path) == 0:
                error_msg_file = f"{base_log_prefix} L·ªói: File MP3 output kh√¥ng ƒë∆∞·ª£c gTTS t·∫°o ho·∫∑c r·ªóng."
                logging.error(error_msg_file)
                if is_preview: self.after(0, lambda msg=error_msg_file: self.update_status(msg))
                return False
                # <<< G·ªåI H√ÄM T·ªêI ∆ØU M·ªöI >>>
                if not is_preview: # Ch·ªâ t·ªëi ∆∞u cho file kh√¥ng ph·∫£i preview, ho·∫∑c t√πy b·∫°n quy·∫øt ƒë·ªãnh
                    logging.info(f"{log_prefix_with_retry} B·∫Øt ƒë·∫ßu t·ªëi ∆∞u kho·∫£ng l·∫∑ng cho file OpenAI TTS: {os.path.basename(output_mp3_path)}")
                    if not self._optimize_trailing_silence_ffmpeg(output_mp3_path, target_pause_ms=150):
                        logging.warning(f"{log_prefix_with_retry} T·ªëi ∆∞u kho·∫£ng l·∫∑ng cho OpenAI TTS c√≥ th·ªÉ ƒë√£ th·∫•t b·∫°i. Ti·∫øp t·ª•c v·ªõi file ch∆∞a t·ªëi ∆∞u.")
                    else:
                        logging.info(f"{log_prefix_with_retry} T·ªëi ∆∞u kho·∫£ng l·∫∑ng cho OpenAI TTS th√†nh c√¥ng.")

            success_msg = f"{base_log_prefix} Th√†nh c√¥ng: ƒê√£ t·∫°o {os.path.basename(output_mp3_path)}"
            logging.info(success_msg)

            if is_preview:
                self.after(0, lambda msg=success_msg: self.update_status(msg))
                if PLAYSOUND_AVAILABLE and playsound:
                    try:
                        logging.debug(f"{base_log_prefix} ƒêang ph√°t preview: {output_mp3_path}")
                        playsound(os.path.abspath(output_mp3_path))
                        self.after(100, lambda: self.update_status(f"{base_log_prefix} ƒê√£ g·ª≠i l·ªánh ph√°t √¢m thanh."))
                    except Exception as e_play:
                        logging.error(f"{base_log_prefix} L·ªói khi d√πng playsound: {e_play}")
                        self.after(0, lambda msg=str(e_play): self.update_status(f"L·ªói ph√°t preview gTTS: {msg}"))
                else:
                    logging.warning(f"{base_log_prefix} Th∆∞ vi·ªán 'playsound' kh√¥ng kh·∫£ d·ª•ng.")
                    self.after(0, lambda: self.update_status(f"{base_log_prefix} T·∫°o xong, kh√¥ng th·ªÉ ph√°t (thi·∫øu playsound)."))
            return True

        except gTTSError as e_gtts: 
            error_msg = f"{base_log_prefix} L·ªói gTTS: {e_gtts}"
            logging.error(error_msg)
            if is_preview or not (hasattr(self, 'dub_is_processing') and self.dub_is_processing):
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                self.after(0, lambda msg=str(e_gtts): messagebox.showerror("L·ªói gTTS", f"L·ªói t·ª´ gTTS (th∆∞·ªùng do k·∫øt n·ªëi m·∫°ng ho·∫∑c v·∫•n ƒë·ªÅ t·ª´ Google Translate):\n{msg}", parent=self))
            return False
        except ConnectionError as e_conn: # C√≥ th·ªÉ gTTS n√©m l·ªói ConnectionError chung
            error_msg = f"{base_log_prefix} L·ªói K·∫øt n·ªëi (gTTS): {e_conn}. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi Internet."
            logging.error(error_msg)
            if is_preview or not (hasattr(self, 'dub_is_processing') and self.dub_is_processing):
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                self.after(0, lambda msg=str(e_conn): messagebox.showerror("L·ªói K·∫øt N·ªëi gTTS", msg, parent=self))
            return False
        except Exception as e_general:
            error_msg = f"{base_log_prefix} L·ªói kh√¥ng mong mu·ªën v·ªõi gTTS: {type(e_general).__name__} - {str(e_general)}"
            logging.error(error_msg, exc_info=True)
            if is_preview or not (hasattr(self, 'dub_is_processing') and self.dub_is_processing):
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                self.after(0, lambda msg=str(e_general): messagebox.showerror("L·ªói gTTS (Kh√°c)", msg, parent=self))
            return False


# H√†m s·ª≠ d·ª•ng gi·ªçng ƒë·ªçc h·ªá th·ªëng
    def dub_speak_with_system_tts(self, text_to_speak, output_audio_path, is_preview=False):
        """T·∫°o file √¢m thanh t·ª´ text b·∫±ng pyttsx3 (Gi·ªçng ƒë·ªçc H·ªá th·ªëng).
        H√†m n√†y s·∫Ω c·ªë g·∫Øng l∆∞u file d∆∞·ªõi d·∫°ng WAV.
        S·ª≠ d·ª•ng thread.join() v·ªõi timeout ƒë·ªÉ ch·ªù engine.runAndWait().
        """
        context_is_batch = hasattr(self, 'dub_is_processing') and self.dub_is_processing and not is_preview
        base_log_prefix = f"[Dubbing_SystemTTS_Batch(Seg:{os.path.basename(output_audio_path)})]" if context_is_batch else f"[Dubbing_SystemTTS_Preview(File:{os.path.basename(output_audio_path)})]"
        
        logging.info(f"{base_log_prefix} Chu·∫©n b·ªã cho text: '{text_to_speak[:40].replace(os.linesep, ' ')}...' -> {os.path.basename(output_audio_path)}")

        if self.dub_stop_event.is_set():
            logging.info(f"{base_log_prefix} Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu v·ªõi pyttsx3.")
            if is_preview: self.after(0, lambda: self.update_status(f"{base_log_prefix} ƒê√£ h·ªßy b·ªüi ng∆∞·ªùi d√πng."))
            return False

        if not HAS_PYTTSX3 or pyttsx3 is None:
            error_msg = f"{base_log_prefix} L·ªói: Th∆∞ vi·ªán pyttsx3 kh√¥ng kh·∫£ d·ª•ng."
            logging.error(error_msg)
            if is_preview or not context_is_batch:
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                self.after(0, lambda msg=error_msg: messagebox.showerror("L·ªói Th∆∞ Vi·ªán", msg + "\nC√†i ƒë·∫∑t: pip install pyttsx3", parent=self))
            return False

        if not text_to_speak.strip():
            error_msg = f"{base_log_prefix} L·ªói: Text r·ªóng, kh√¥ng th·ªÉ t·∫°o audio."
            logging.warning(error_msg)
            if is_preview: self.after(0, lambda msg=error_msg: self.update_status(msg))
            return False

        output_dir = os.path.dirname(output_audio_path)
        output_basename_no_ext = os.path.splitext(os.path.basename(output_audio_path))[0]
        final_output_wav_path = os.path.join(output_dir, f"{output_basename_no_ext}.wav")

        engine = None
        tts_thread = None # Kh·ªüi t·∫°o bi·∫øn thread
        try:
            if is_preview:
                self.after(0, lambda: self.update_status(f"{base_log_prefix} ƒêang kh·ªüi t·∫°o engine pyttsx3..."))

            engine = pyttsx3.init()
            if engine is None:
                raise RuntimeError("pyttsx3.init() tr·∫£ v·ªÅ None.")

            selected_voice_id_for_system = self.dub_selected_voice_id_var.get()
            if selected_voice_id_for_system and selected_voice_id_for_system != "default_system_voice":
                try:
                    engine.setProperty('voice', selected_voice_id_for_system)
                    logging.info(f"{base_log_prefix} ƒê√£ ƒë·∫∑t gi·ªçng h·ªá th·ªëng th√†nh ID: {selected_voice_id_for_system}")
                except Exception as e_set_voice:
                    logging.warning(f"{base_log_prefix} Kh√¥ng th·ªÉ ƒë·∫∑t gi·ªçng ID '{selected_voice_id_for_system}'. L·ªói: {e_set_voice}")
            else:
                logging.info(f"{base_log_prefix} S·ª≠ d·ª•ng gi·ªçng m·∫∑c ƒë·ªãnh c·ªßa h·ªá th·ªëng.")
            
            # engine.setProperty('rate', 170) # V√≠ d·ª• t·ªëc ƒë·ªô

            engine.save_to_file(text_to_speak, final_output_wav_path)
            logging.info(f"{base_log_prefix} ƒê√£ y√™u c·∫ßu engine l∆∞u v√†o file: {final_output_wav_path}")
            
            # Bi·∫øn ƒë·ªÉ thread con b√°o l·ªói (n·∫øu c√≥)
            thread_exception = None 
            def run_engine_target():
                nonlocal thread_exception
                try:
                    # Kh√¥ng ki·ªÉm tra dub_stop_event ·ªü ƒë√¢y v√¨ runAndWait l√† blocking
                    engine.runAndWait()
                except Exception as e_run:
                    thread_exception = e_run # L∆∞u l·ªói t·ª´ thread con
                    logging.error(f"{base_log_prefix} L·ªói trong engine.runAndWait() (thread): {e_run}")
            
            tts_thread = threading.Thread(target=run_engine_target, daemon=True, name=f"Pyttsx3EngineRunner_{os.path.basename(final_output_wav_path)}")
            tts_thread.start()
            
            tts_thread.join(timeout=30.0) # Ch·ªù t·ªëi ƒëa 30 gi√¢y

            if self.dub_stop_event.is_set():
                logging.info(f"{base_log_prefix} Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán sau khi ch·ªù thread pyttsx3.")
                if tts_thread.is_alive():
                    logging.warning(f"{base_log_prefix} Thread pyttsx3 v·∫´n c√≤n ch·∫°y sau khi join timeout v√† c√≥ y√™u c·∫ßu d·ª´ng. Kh√¥ng th·ªÉ d·ª´ng tr·ª±c ti·∫øp engine.runAndWait().")
                    # Kh√¥ng c√≥ c√°ch n√†o an to√†n ƒë·ªÉ "kill" engine.runAndWait() t·ª´ thread kh√°c.
                return False

            if tts_thread.is_alive(): # N·∫øu thread v·∫´n ch·∫°y sau timeout (v√† kh√¥ng c√≥ y√™u c·∫ßu d·ª´ng)
                logging.error(f"{base_log_prefix} Timeout khi ch·ªù thread pyttsx3.runAndWait() ho√†n th√†nh.")
                return False # B√°o hi·ªáu timeout / l·ªói
            
            if thread_exception: 
                raise thread_exception 

            # Ki·ªÉm tra file output sau khi thread ƒë√£ join (v√† kh√¥ng timeout/kh√¥ng d·ª´ng)
            if not os.path.exists(final_output_wav_path) or os.path.getsize(final_output_wav_path) == 0:
                error_msg_file = f"{base_log_prefix} L·ªói: File WAV output '{os.path.basename(final_output_wav_path)}' kh√¥ng ƒë∆∞·ª£c t·∫°o ho·∫∑c r·ªóng."
                logging.error(error_msg_file)
                if is_preview: self.after(0, lambda msg=error_msg_file: self.update_status(msg))
                return False
                # <<< G·ªåI H√ÄM T·ªêI ∆ØU M·ªöI >>>
                if not is_preview: # Ch·ªâ t·ªëi ∆∞u cho file kh√¥ng ph·∫£i preview, ho·∫∑c t√πy b·∫°n quy·∫øt ƒë·ªãnh
                    logging.info(f"{log_prefix_with_retry} B·∫Øt ƒë·∫ßu t·ªëi ∆∞u kho·∫£ng l·∫∑ng cho file OpenAI TTS: {os.path.basename(output_mp3_path)}")
                    if not self._optimize_trailing_silence_ffmpeg(output_mp3_path, target_pause_ms=150):
                        logging.warning(f"{log_prefix_with_retry} T·ªëi ∆∞u kho·∫£ng l·∫∑ng cho OpenAI TTS c√≥ th·ªÉ ƒë√£ th·∫•t b·∫°i. Ti·∫øp t·ª•c v·ªõi file ch∆∞a t·ªëi ∆∞u.")
                    else:
                        logging.info(f"{log_prefix_with_retry} T·ªëi ∆∞u kho·∫£ng l·∫∑ng cho OpenAI TTS th√†nh c√¥ng.")

            success_msg = f"{base_log_prefix} Th√†nh c√¥ng: ƒê√£ t·∫°o {os.path.basename(final_output_wav_path)}"
            logging.info(success_msg)

            if is_preview:
                self.after(0, lambda msg=success_msg: self.update_status(msg))
                if PLAYSOUND_AVAILABLE and playsound:
                    abs_output_path = os.path.abspath(final_output_wav_path)
                    threading.Thread(target=playsound, args=(abs_output_path,), daemon=True).start()
                    self.after(100, lambda: self.update_status(f"{base_log_prefix} ƒê√£ g·ª≠i l·ªánh ph√°t √¢m thanh."))
            return True

        except RuntimeError as e_runtime: 
            error_msg = f"{base_log_prefix} L·ªói RuntimeError t·ª´ pyttsx3: {e_runtime}"
            logging.error(error_msg)
            if is_preview or not context_is_batch:
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                self.after(0, lambda msg=str(e_runtime): messagebox.showerror("L·ªói pyttsx3", f"L·ªói khi s·ª≠ d·ª•ng gi·ªçng ƒë·ªçc h·ªá th·ªëng:\n{msg}", parent=self))
            return False
        except Exception as e_general: # B·∫Øt l·ªói ƒë∆∞·ª£c n√©m l·∫°i t·ª´ thread_exception ho·∫∑c l·ªói kh√°c
            error_msg = f"{base_log_prefix} L·ªói kh√¥ng mong mu·ªën v·ªõi pyttsx3: {type(e_general).__name__} - {str(e_general)}"
            logging.error(error_msg, exc_info=True)
            if is_preview or not context_is_batch:
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                self.after(0, lambda msg=str(e_general): messagebox.showerror("L·ªói pyttsx3 (Kh√°c)", msg, parent=self))
            return False
        finally:
            if engine:
                try:
                    pass
                except Exception as e_stop:
                    logging.warning(f"{base_log_prefix} L·ªói khi g·ªçi engine.stop() c·ªßa pyttsx3: {e_stop}")



 # --- H√ÄM TR·ª¢ GI√öP M·ªöI ƒê·ªÇ T·ªêI ∆ØU KHO·∫¢NG L·∫∂NG CU·ªêI FILE AUDIO ---
    def _optimize_trailing_silence_ffmpeg(self, audio_file_path, target_pause_ms=150):
        """
        T·ªëi ∆∞u kho·∫£ng l·∫∑ng ·ªü cu·ªëi file audio b·∫±ng FFmpeg (Phi√™n b·∫£n V2 - Ch·ªëng ti·∫øng "p·ªçp").
        1. C·∫Øt b·ªè ho√†n to√†n kho·∫£ng l·∫∑ng ·ªü cu·ªëi hi·ªán c√≥.
        2. √Åp d·ª•ng m·ªôt fade-out C·ª∞C NG·∫ÆN (10ms) ƒë·ªÉ l√†m m∆∞·ª£t ƒëi·ªÉm cu·ªëi c·ªßa √¢m thanh, kh·ª≠ ti·∫øng "p·ªçp".
        3. Th√™m m·ªôt kho·∫£ng l·∫∑ng m·ªõi `target_pause_ms` v√†o cu·ªëi.
        File audio_file_path s·∫Ω b·ªã ghi ƒë√® b·∫±ng m·ªôt file t·∫°m ƒë√£ x·ª≠ l√Ω.

        Args:
            audio_file_path (str): ƒê∆∞·ªùng d·∫´n ƒë·∫øn file audio c·∫ßn x·ª≠ l√Ω.
            target_pause_ms (int): Th·ªùi l∆∞·ª£ng kho·∫£ng l·∫∑ng cu·ªëi c√πng mong mu·ªën (ms).

        Returns:
            bool: True n·∫øu x·ª≠ l√Ω th√†nh c√¥ng, False n·∫øu c√≥ l·ªói.
        """
        if not os.path.exists(audio_file_path) or os.path.getsize(audio_file_path) == 0:
            logging.error(f"[_OptimizeSilenceV2] File audio ƒë·∫ßu v√†o kh√¥ng t·ªìn t·∫°i ho·∫∑c r·ªóng: {audio_file_path}")
            return False

        base_log_prefix = f"[_OptimizeSilenceV2][{os.path.basename(audio_file_path)}]"
        logging.info(f"{base_log_prefix} B·∫Øt ƒë·∫ßu t·ªëi ∆∞u kho·∫£ng l·∫∑ng cu·ªëi (v·ªõi fade-out), m·ª•c ti√™u {target_pause_ms}ms.")

        ffmpeg_executable = find_ffmpeg()
        if not ffmpeg_executable:
            logging.error(f"{base_log_prefix} Kh√¥ng t√¨m th·∫•y FFmpeg. Kh√¥ng th·ªÉ t·ªëi ∆∞u kho·∫£ng l·∫∑ng.")
            return False

        if self.dub_stop_event.is_set():
            logging.info(f"{base_log_prefix} Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán.")
            return False

        original_basename, original_ext = os.path.splitext(os.path.basename(audio_file_path))
        
        # T·∫°o c√°c file t·∫°m trong th∆∞ m·ª•c t·∫°m ch√≠nh c·ªßa ·ª©ng d·ª•ng
        temp_trimmed_path = os.path.join(self.temp_folder, f"{original_basename}_trimmed_{uuid.uuid4().hex[:6]}.wav")
        temp_processed_path = os.path.join(self.temp_folder, f"{original_basename}_processed_{uuid.uuid4().hex[:6]}{original_ext}")
        
        process_trim = None
        process_main = None

        try:
            # --- B∆∞·ªõc 1: C·∫Øt kho·∫£ng l·∫∑ng v√† l·∫•y th·ªùi l∆∞·ª£ng ch√≠nh x√°c ---
            # Ch·∫°y m·ªôt l·ªánh ri√™ng ƒë·ªÉ c·∫Øt v√† l∆∞u ra file WAV t·∫°m th·ªùi.
            # ƒêi·ªÅu n√†y gi√∫p l·∫•y ƒë∆∞·ª£c th·ªùi l∆∞·ª£ng ch√≠nh x√°c c·ªßa ph·∫ßn √¢m thanh c√≤n l·∫°i.
            cmd_trim_only = [
                ffmpeg_executable, "-y", "-i", os.path.abspath(audio_file_path),
                "-af", f"areverse,silenceremove=start_periods=1:start_threshold=-40dB,areverse",
                "-c:a", "pcm_s16le", # Xu·∫•t ra WAV ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√°n ch√≠nh x√°c
                os.path.abspath(temp_trimmed_path)
            ]
            
            try:
                ffmpeg_run_command(
                    cmd_trim_only[1:],
                    process_name=f"{base_log_prefix}_TrimSilence",
                    stop_event=self.dub_stop_event,
                    set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                    clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                    timeout_seconds=90,
                )
            except Exception as e_trim:
                logging.error(f"{base_log_prefix} L·ªói khi c·∫Øt kho·∫£ng l·∫∑ng (b∆∞·ªõc 1): {e_trim}")
                return False

            trimmed_duration_s = get_video_duration_s(temp_trimmed_path)
            if trimmed_duration_s <= 0:
                logging.warning(f"{base_log_prefix} Kh√¥ng l·∫•y ƒë∆∞·ª£c th·ªùi l∆∞·ª£ng sau khi c·∫Øt. S·∫Ω b·ªè qua fade.")
                # N·∫øu kh√¥ng c√≥ duration, ta ch·ªâ th√™m padding m√† kh√¥ng fade
                filter_chain = f"areverse,silenceremove=start_periods=1:start_threshold=-40dB,areverse,apad=pad_dur={target_pause_ms / 1000.0:.3f}"
            else:
                # --- B∆∞·ªõc 2: X√¢y d·ª±ng chu·ªói filter ho√†n ch·ªânh v·ªõi fade-out ---
                fade_out_duration_s = 0.01  # 10 mili gi√¢y l√† ƒë·ªß
                fade_out_start_s = max(0, trimmed_duration_s - fade_out_duration_s)
                
                filter_chain = (
                    f"areverse,silenceremove=start_periods=1:start_threshold=-40dB,areverse," # 1. C·∫Øt l·∫∑ng
                    f"afade=t=out:st={fade_out_start_s:.3f}:d={fade_out_duration_s:.3f},"      # 2. Fade-out m∆∞·ª£t m√†
                    f"apad=pad_dur={target_pause_ms / 1000.0:.3f}"                             # 3. Th√™m l·∫°i kho·∫£ng l·∫∑ng
                )

            # --- B∆∞·ªõc 3: Th·ª±c thi l·ªánh cu·ªëi c√πng ---
            command_final = [ffmpeg_executable, "-y", "-i", os.path.abspath(audio_file_path), "-af", filter_chain]
            
            # Th√™m codec d·ª±a tr√™n ƒë·ªãnh d·∫°ng file g·ªëc ƒë·ªÉ gi·ªØ nguy√™n ƒë·ªãnh d·∫°ng
            if original_ext.lower() == ".mp3":
                command_final.extend(["-c:a", "libmp3lame", "-q:a", str(self.dub_DEFAULT_MP3_QUALITY)])
            elif original_ext.lower() == ".wav":
                command_final.extend(["-c:a", self.dub_DEFAULT_WAV_CODEC, "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE)])
            else:
                command_final.extend(["-c:a", "aac", "-b:a", "192k"]) # Fallback an to√†n

            command_final.append(os.path.abspath(temp_processed_path))
            
            logging.debug(f"{base_log_prefix} L·ªánh FFmpeg cu·ªëi c√πng: {' '.join(command_final)}")

            try:
                ffmpeg_run_command(
                    command_final[1:],
                    process_name=f"{base_log_prefix}_ApplyFadePad",
                    stop_event=self.dub_stop_event,
                    set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                    clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                    timeout_seconds=120,
                )
            except Exception as e_main:
                logging.error(f"{base_log_prefix} L·ªói khi √°p d·ª•ng fade/pad (b∆∞·ªõc 3): {e_main}")
                return False

            if os.path.exists(temp_processed_path):
                # Ghi ƒë√® file g·ªëc b·∫±ng file ƒë√£ x·ª≠ l√Ω th√†nh c√¥ng
                shutil.move(temp_processed_path, audio_file_path)
                logging.info(f"{base_log_prefix} T·ªëi ∆∞u th√†nh c√¥ng.")
                return True
            else:
                logging.error(f"{base_log_prefix} T·ªëi ∆∞u th·∫•t b·∫°i: kh√¥ng t·∫°o ƒë∆∞·ª£c file output t·∫°m.")
                return False

        except Exception as e:
            logging.error(f"{base_log_prefix} L·ªói kh√¥ng mong mu·ªën khi t·ªëi ∆∞u: {e}", exc_info=True)
            return False
        finally:
            # D·ªçn d·∫πp c√°c file t·∫°m
            if 'temp_trimmed_path' in locals() and os.path.exists(temp_trimmed_path):
                try: os.remove(temp_trimmed_path)
                except Exception: pass
            if os.path.exists(temp_processed_path):
                try: os.remove(temp_processed_path)
                except Exception: pass



# H√†m th·ª±c hi·ªán c·∫Øt file audio
    def dub_ffmpeg_cut_audio(self, input_path, output_path, start_ms, end_ms):
        """
        S·ª≠ d·ª•ng FFmpeg ƒë·ªÉ c·∫Øt m·ªôt ƒëo·∫°n audio t·ª´ start_ms ƒë·∫øn end_ms.
        start_ms: Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu c·∫Øt (t√≠nh b·∫±ng mili gi√¢y).
        end_ms: Th·ªùi ƒëi·ªÉm k·∫øt th√∫c c·∫Øt (t√≠nh b·∫±ng mili gi√¢y).
        H√†m n√†y s·∫Ω c·ªë g·∫Øng gi·ªØ nguy√™n codec n·∫øu c√≥ th·ªÉ (copy).
        """
        worker_log_prefix_cutter = f"[{threading.current_thread().name}_FFmpegCut]" # Th√™m prefix cho log
        logging.info(f"{worker_log_prefix_cutter} Y√™u c·∫ßu c·∫Øt audio: '{os.path.basename(input_path)}' t·ª´ {start_ms}ms ƒë·∫øn {end_ms}ms -> '{os.path.basename(output_path)}'")

        ffmpeg_executable = find_ffmpeg()
        if not ffmpeg_executable:
            logging.error(f"{worker_log_prefix_cutter} Kh√¥ng t√¨m th·∫•y FFmpeg ƒë·ªÉ c·∫Øt audio.")
            return False

        if self.dub_stop_event.is_set():
            logging.info(f"{worker_log_prefix_cutter} C·∫Øt audio b·ªã h·ªßy cho '{os.path.basename(input_path)}' do y√™u c·∫ßu d·ª´ng (ƒë·∫ßu h√†m).")
            return False

        if not os.path.exists(input_path):
            logging.error(f"{worker_log_prefix_cutter} File input kh√¥ng t·ªìn t·∫°i: {input_path}")
            return False

        if start_ms < 0:
            logging.warning(f"{worker_log_prefix_cutter} start_ms ({start_ms}) < 0, ƒë·∫∑t l·∫°i th√†nh 0.")
            start_ms = 0
        
        duration_to_cut_ms = end_ms - start_ms
        if duration_to_cut_ms <= 0:
            logging.error(f"{worker_log_prefix_cutter} Th·ªùi l∆∞·ª£ng c·∫Øt kh√¥ng h·ª£p l·ªá ({duration_to_cut_ms}ms). Start: {start_ms}, End: {end_ms}. Kh√¥ng th·ª±c hi·ªán c·∫Øt.")
            # N·∫øu th·ªùi l∆∞·ª£ng kh√¥ng h·ª£p l·ªá, c√≥ th·ªÉ b·∫°n mu·ªën sao ch√©p file g·ªëc ho·∫∑c t·∫°o file r·ªóng t√πy logic
            # Hi·ªán t·∫°i, coi nh∆∞ l·ªói v√† kh√¥ng t·∫°o file output.
            return False

        start_time_seconds_str = f"{start_ms / 1000.0:.3f}"
        duration_seconds_str = f"{duration_to_cut_ms / 1000.0:.3f}"

        command = [
            ffmpeg_executable,
            "-y",  # Ghi ƒë√® file output n·∫øu ƒë√£ t·ªìn t·∫°i
            "-ss", start_time_seconds_str,  # ƒê·∫∑t -ss tr∆∞·ªõc -i ƒë·ªÉ seek nhanh h∆°n v·ªõi m·ªôt s·ªë ƒë·ªãnh d·∫°ng
            "-i", os.path.abspath(input_path),
            "-t", duration_seconds_str,     # Ch·ªâ ƒë·ªãnh th·ªùi l∆∞·ª£ng c·∫ßn c·∫Øt
            # "-c:a", "copy",                 # C·ªë g·∫Øng copy codec audio ƒë·ªÉ tr√°nh re-encode
                                            # Tuy nhi√™n, ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh t∆∞∆°ng th√≠ch v√† ƒë·ªãnh d·∫°ng chu·∫©n trong lu·ªìng x·ª≠ l√Ω,
                                            # c√≥ th·ªÉ n√™n re-encode sang WAV cho c√°c file trung gian.
                                            # Ho·∫∑c d·ª±a v√†o ƒë·ªãnh d·∫°ng output_path.
        ]
        
        # Quy·∫øt ƒë·ªãnh codec d·ª±a tr√™n output_path (∆∞u ti√™n WAV cho file trung gian)
        output_ext_cut = os.path.splitext(output_path)[1].lower()
        if output_ext_cut == ".wav":
            command.extend([
                "-c:a", self.dub_DEFAULT_WAV_CODEC,
                "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE),
                "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS)
            ])
        elif output_ext_cut == ".mp3":
             command.extend([
                "-c:a", "libmp3lame", 
                "-q:a", str(self.dub_DEFAULT_MP3_QUALITY) 
                # Sample rate v√† channels cho MP3 th∆∞·ªùng ƒë∆∞·ª£c gi·ªØ nguy√™n ho·∫∑c FFmpeg t·ª± x·ª≠ l√Ω t·ªët
            ])
        else: # N·∫øu ƒë·ªãnh d·∫°ng output kh√¥ng ph·∫£i wav ho·∫∑c mp3, th·ª≠ copy codec
            logging.warning(f"{worker_log_prefix_cutter} ƒê·ªãnh d·∫°ng output '{output_ext_cut}' kh√¥ng x√°c ƒë·ªãnh r√µ r√†ng cho vi·ªác c·∫Øt. Th·ª≠ copy codec.")
            command.extend(["-c:a", "copy"])


        command.append(os.path.abspath(output_path))
        
        logging.info(f"{worker_log_prefix_cutter} L·ªánh FFmpeg c·∫Øt (service): {' '.join(command[1:])}")
        try:
            ffmpeg_run_command(
                command[1:],
                process_name=f"{worker_log_prefix_cutter}_CutAudio",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=120,
            )
            if not os.path.exists(output_path) or os.path.getsize(output_path) == 0:
                logging.error(f"{worker_log_prefix_cutter} L·ªói c·∫Øt audio: File output '{os.path.basename(output_path)}' kh√¥ng ƒë∆∞·ª£c t·∫°o ho·∫∑c r·ªóng.")
                return False
            logging.info(f"{worker_log_prefix_cutter} C·∫Øt audio th√†nh c√¥ng: {os.path.basename(output_path)}")
            return True
        except Exception as e_general_cut:
            logging.error(f"{worker_log_prefix_cutter} L·ªói khi c·∫Øt audio '{os.path.basename(input_path)}': {e_general_cut}")
            return False


# H√†m FFmpeg: Chu·∫©n h√≥a file √¢m thanh sang ƒë·ªãnh d·∫°ng WAV m·ª•c ti√™u
    def dub_ffmpeg_standardize_to_wav(self, input_path, output_path):
        if self.dub_stop_event.is_set(): # << KI·ªÇM TRA D·ª™NG ƒê·∫¶U H√ÄM >>
            logging.info(f"[DubbingFFmpeg] Chu·∫©n h√≥a WAV b·ªã h·ªßy cho '{os.path.basename(input_path)}' do y√™u c·∫ßu d·ª´ng.")
            return False

        cmd_params = [
            "-y", "-i", os.path.abspath(input_path),
            "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS),
            "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE),
            "-c:a", self.dub_DEFAULT_WAV_CODEC,
            os.path.abspath(output_path)
        ]
        logging.info(f"[DubbingFFmpeg] Chu·∫©n h√≥a WAV (service): {' '.join(cmd_params)}")
        try:
            ffmpeg_run_command(
                cmd_params,
                process_name="DubbingFFmpeg_StandardizeWAV",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=60,
            )
            if not os.path.exists(output_path) or os.path.getsize(output_path) == 0:
                logging.error(f"[DubbingFFmpeg] L·ªói chu·∫©n h√≥a WAV: File output '{os.path.basename(output_path)}' kh√¥ng ƒë∆∞·ª£c t·∫°o ho·∫∑c r·ªóng.")
                return False
            logging.debug(f"[DubbingFFmpeg] Chu·∫©n h√≥a WAV th√†nh c√¥ng: {os.path.basename(output_path)}")
            return True
        except Exception as e_gen:
            logging.error(f"[DubbingFFmpeg] L·ªói khi chu·∫©n h√≥a WAV '{os.path.basename(input_path)}': {e_gen}", exc_info=True)
            return False


# H√†m FFmpeg: √Åp d·ª•ng hi·ªáu ·ª©ng fade-in v√† fade-out cho file WAV
    def dub_ffmpeg_apply_fade(self, input_path, output_path, segment_duration_s,
                              fade_in_s, fade_out_s, fade_delay_s):
        worker_log_prefix_fade = f"[{threading.current_thread().name}_FFmpegApplyFade]" # Th√™m prefix
        logging.info(f"{worker_log_prefix_fade} Y√™u c·∫ßu √°p d·ª•ng fade: Input='{os.path.basename(input_path)}', Output='{os.path.basename(output_path)}', SegDur={segment_duration_s:.3f}s, FadeIn={fade_in_s}s, FadeOut={fade_out_s}s, Delay={fade_delay_s}s")

        ffmpeg_executable = find_ffmpeg()
        if not ffmpeg_executable:
            logging.error(f"{worker_log_prefix_fade} Kh√¥ng t√¨m th·∫•y FFmpeg.")
            return False
        
        if self.dub_stop_event.is_set():
            logging.info(f"{worker_log_prefix_fade} B·ªã h·ªßy cho '{os.path.basename(input_path)}' do y√™u c·∫ßu d·ª´ng.")
            return False

        try:
            f_in_s = float(fade_in_s)
            f_out_s = float(fade_out_s)
            f_delay_s = float(fade_delay_s)
        except ValueError:
            logging.error(f"{worker_log_prefix_fade} Gi√° tr·ªã fade kh√¥ng h·ª£p l·ªá: in='{fade_in_s}', out='{fade_out_s}', delay='{fade_delay_s}'. B·ªè qua fade, sao ch√©p file.")
            if os.path.abspath(input_path) != os.path.abspath(output_path):
                try: shutil.copy2(os.path.abspath(input_path), os.path.abspath(output_path))
                except Exception as e_copy_inv_fade: logging.error(f"L·ªói sao ch√©p (fade invalid): {e_copy_inv_fade}"); return False
            return True # Coi nh∆∞ th√†nh c√¥ng v√¨ kh√¥ng c√≥ g√¨ ƒë·ªÉ l√†m

        # KI·ªÇM TRA M·ªöI: N·∫øu t·∫•t c·∫£ c√°c tham s·ªë fade l√† 0 (ho·∫∑c r·∫•t g·∫ßn 0)
        if abs(f_in_s) < 0.001 and abs(f_out_s) < 0.001 and abs(f_delay_s) < 0.001:
            logging.info(f"{worker_log_prefix_fade} T·∫•t c·∫£ tham s·ªë fade l√† 0 cho '{os.path.basename(input_path)}'. Ch·ªâ sao ch√©p file.")
            if os.path.abspath(input_path) != os.path.abspath(output_path):
                try:
                    shutil.copy2(os.path.abspath(input_path), os.path.abspath(output_path))
                except Exception as e_copy_zero_fade:
                    logging.error(f"{worker_log_prefix_fade} L·ªói sao ch√©p file (khi fade durations l√† 0): {e_copy_zero_fade}")
                    return False
            return True # Th√†nh c√¥ng v√¨ kh√¥ng c·∫ßn √°p d·ª•ng fade

        # Logic c≈© ki·ªÉm tra th·ªùi l∆∞·ª£ng segment (v·∫´n gi·ªØ l·∫°i cho tr∆∞·ªùng h·ª£p fade th·ª±c s·ª± ƒë∆∞·ª£c y√™u c·∫ßu)
        actual_fade_in_start_s = 0.0
        min_duration_for_fade_logic = (f_in_s + f_out_s) + f_delay_s + 0.02 # Th√™m m·ªôt ch√∫t l·ªÅ nh·ªè

        if segment_duration_s <= min_duration_for_fade_logic:
            logging.info(f"{worker_log_prefix_fade} Segment '{os.path.basename(input_path)}' ({segment_duration_s:.3f}s) qu√° ng·∫Øn cho logic fade ƒë∆∞·ª£c y√™u c·∫ßu (c·∫ßn > {min_duration_for_fade_logic:.3f}s). Sao ch√©p file.")
            if os.path.abspath(input_path) != os.path.abspath(output_path):
                try: shutil.copy2(os.path.abspath(input_path), os.path.abspath(output_path))
                except Exception as e_copy_short_fade: logging.error(f"L·ªói sao ch√©p (fade short): {e_copy_short_fade}"); return False
            return True
        
        if segment_duration_s > f_delay_s + f_in_s: # ƒê·∫£m b·∫£o c√≥ ƒë·ªß th·ªùi gian cho delay v√† fade in
            actual_fade_in_start_s = f_delay_s
        
        fade_out_start_time_s = max(0, segment_duration_s - f_out_s)
        
        # Ki·ªÉm tra n·∫øu fade_in v√† fade_out ch·ªìng ch√©o sau khi ƒë√£ t√≠nh delay
        if (actual_fade_in_start_s + f_in_s) >= fade_out_start_time_s and fade_out_start_time_s > actual_fade_in_start_s :
             # N·∫øu ch·ªìng ch√©o, c√≥ th·ªÉ b·ªè qua fade_in ho·∫∑c ƒëi·ªÅu ch·ªânh, v√≠ d·ª•:
             logging.warning(f"{worker_log_prefix_fade} Fade-in ({f_in_s}s sau {actual_fade_in_start_s}s delay) v√† Fade-out ({f_out_s}s t·ª´ {fade_out_start_time_s}s) c√≥ th·ªÉ ch·ªìng ch√©o. B·ªè qua fade-in ƒë·ªÉ ∆∞u ti√™n fade-out.")
             actual_fade_in_start_s = 0.0 # B·ªè qua delay
             f_in_s = 0.0 # B·ªè qua fade_in

        cmd_params = [
            "-y", "-i", os.path.abspath(input_path),
            "-af", f"afade=t=in:ss={actual_fade_in_start_s:.3f}:d={f_in_s:.3f},afade=t=out:st={fade_out_start_time_s:.3f}:d={f_out_s:.3f}",
            "-c:a", self.dub_DEFAULT_WAV_CODEC,
            "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE),
            "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS),
            os.path.abspath(output_path)
        ]
        logging.info(f"{worker_log_prefix_fade} L·ªánh FFmpeg √°p d·ª•ng Fade (service): {' '.join(cmd_params)}")
        try:
            return_code, stdout_data, stderr_data = ffmpeg_run_command(
                cmd_params,
                process_name=f"{worker_log_prefix_fade}ApplyFade",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=60,
            )
            if not os.path.exists(output_path) or os.path.getsize(output_path) == 0:
                 logging.error(f"{worker_log_prefix_fade} L·ªói √°p d·ª•ng Fade: File output r·ªóng.")
                 return False
            return True
        except Exception as e_gen_fade:
            logging.error(f"{worker_log_prefix_fade} L·ªói khi √°p d·ª•ng fade: {e_gen_fade}", exc_info=True)
            return False


# H√†m T·∫°o m·ªôt file WAV ch·ªâ ch·ª©a kho·∫£ng l·∫∑ng v·ªõi th·ªùi l∆∞·ª£ng cho tr∆∞·ªõc.
    def dub_ffmpeg_create_silence_file(self, output_silence_wav_path, duration_ms):
        # D√πng service FFmpeg t·∫≠p trung

        if self.dub_stop_event.is_set():
            logging.info(f"[DubbingFFmpeg] T·∫°o file silence b·ªã h·ªßy (output: {os.path.basename(output_silence_wav_path)}) do y√™u c·∫ßu d·ª´ng.")
            return False
        
        if duration_ms <= 0:
            logging.warning(f"[DubbingFFmpeg] Y√™u c·∫ßu t·∫°o file silence v·ªõi duration <= 0 ({duration_ms}ms). B·ªè qua.")
            # C√≥ th·ªÉ t·∫°o file r·ªóng n·∫øu c·∫ßn, nh∆∞ng th∆∞·ªùng l√† kh√¥ng c·∫ßn thi·∫øt
            try: # T·∫°o file r·ªóng ƒë·ªÉ tr√°nh l·ªói ·ªü b∆∞·ªõc concat n·∫øu logic d·ª±a v√†o s·ª± t·ªìn t·∫°i c·ªßa file
                with open(output_silence_wav_path, 'w') as f_empty: pass
                return True # Coi nh∆∞ th√†nh c√¥ng n·∫øu kh√¥ng c·∫ßn t·∫°o silence
            except Exception: return False


        duration_s_str = f"{duration_ms / 1000.0:.3f}" # Chuy·ªÉn ms sang gi√¢y d·∫°ng chu·ªói xxx.yyy

        cmd_params = [
            "-y", "-f", "lavfi",
            "-i", f"anullsrc=cl=mono:r={self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE}:d={duration_s_str}",
            "-c:a", self.dub_DEFAULT_WAV_CODEC,
            "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE),
            "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS),
            os.path.abspath(output_silence_wav_path)
        ]
        logging.info(f"[DubbingFFmpeg] T·∫°o file silence ({duration_ms}ms) (service): {' '.join(cmd_params)}")
        try:
            ffmpeg_run_command(
                cmd_params,
                process_name="DubbingFFmpeg_CreateSilence",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=40,
            )
            if not os.path.exists(output_silence_wav_path) or os.path.getsize(output_silence_wav_path) == 0:
                 logging.error(f"[DubbingFFmpeg] L·ªói t·∫°o file silence: File output r·ªóng ho·∫∑c kh√¥ng ƒë∆∞·ª£c t·∫°o.")
                 return False
            return True
        except Exception as e_gen:
            logging.error(f"[DubbingFFmpeg] L·ªói khi t·∫°o file silence: {e_gen}", exc_info=True)
            return False


# H√†m Th√™m m·ªôt kho·∫£ng l·∫∑ng v√†o cu·ªëi c·ªßa m·ªôt file audio WAV ƒë√£ c√≥.
    def dub_ffmpeg_pad_audio_with_silence_at_end(self, input_wav_path, output_padded_wav_path, silence_duration_ms_to_add):
        ffmpeg_executable = find_ffmpeg()
        if not ffmpeg_executable:
            logging.error("[DubbingFFmpeg] Kh√¥ng t√¨m th·∫•y FFmpeg ƒë·ªÉ pad audio cu·ªëi.")
            return False
        
        if self.dub_stop_event.is_set():
            logging.info(f"[DubbingFFmpeg] Pad audio cu·ªëi b·ªã h·ªßy cho '{os.path.basename(input_wav_path)}' do y√™u c·∫ßu d·ª´ng.")
            return False

        if silence_duration_ms_to_add <= 0:
            logging.info(f"[DubbingFFmpeg] Th·ªùi l∆∞·ª£ng silence ƒë·ªÉ pad cu·ªëi <= 0 ({silence_duration_ms_to_add}ms). Sao ch√©p file g·ªëc.")
            if os.path.abspath(input_wav_path) != os.path.abspath(output_padded_wav_path):
                try: shutil.copy2(os.path.abspath(input_wav_path), os.path.abspath(output_padded_wav_path))
                except Exception as e_copy_pad: logging.error(f"L·ªói sao ch√©p (pad cu·ªëi): {e_copy_pad}"); return False
            return True

        # 1. T·∫°o file silence t·∫°m th·ªùi
        temp_silence_file_for_pad = os.path.join(self.temp_folder, f"temp_silence_pad_end_{int(time.time())}.wav")
        if not self.dub_ffmpeg_create_silence_file(temp_silence_file_for_pad, silence_duration_ms_to_add):
            logging.error(f"[DubbingFFmpeg] Kh√¥ng th·ªÉ t·∫°o file silence t·∫°m th·ªùi ƒë·ªÉ pad cu·ªëi cho '{os.path.basename(input_wav_path)}'.")
            return False
        
        if self.dub_stop_event.is_set(): # Ki·ªÉm tra l·∫°i sau khi t·∫°o file silence
            if os.path.exists(temp_silence_file_for_pad): os.remove(temp_silence_file_for_pad)
            return False

        # 2. T·∫°o file list ƒë·ªÉ concat input_wav_path v√† file silence
        concat_list_file_for_pad_end = os.path.join(self.temp_folder, f"concat_list_pad_end_{int(time.time())}.txt")
        try:
            with open(concat_list_file_for_pad_end, 'w', encoding='utf-8') as f_list:
                f_list.write(f"file '{os.path.abspath(input_wav_path).replace(os.sep, '/')}'\n")
                f_list.write(f"file '{os.path.abspath(temp_silence_file_for_pad).replace(os.sep, '/')}'\n")
        except Exception as e_write_list:
            logging.error(f"[DubbingFFmpeg] L·ªói t·∫°o file list cho pad cu·ªëi: {e_write_list}")
            if os.path.exists(temp_silence_file_for_pad): os.remove(temp_silence_file_for_pad)
            return False
        
        # 3. Gh√©p (Concatenate)
        success_concat_pad = self.dub_ffmpeg_concatenate_audios(concat_list_file_for_pad_end, output_padded_wav_path)
        
        # 4. D·ªçn d·∫πp file t·∫°m
        if os.path.exists(temp_silence_file_for_pad):
            try: os.remove(temp_silence_file_for_pad)
            except Exception as e_del_sil: logging.warning(f"L·ªói x√≥a file silence t·∫°m (pad cu·ªëi): {e_del_sil}")
        if os.path.exists(concat_list_file_for_pad_end):
            try: os.remove(concat_list_file_for_pad_end)
            except Exception as e_del_list_pad: logging.warning(f"L·ªói x√≥a file list t·∫°m (pad cu·ªëi): {e_del_list_pad}")
            
        if success_concat_pad:
            logging.info(f"[DubbingFFmpeg] Pad cu·ªëi th√†nh c√¥ng cho '{os.path.basename(input_wav_path)}' -> '{os.path.basename(output_padded_wav_path)}'")
        else:
            logging.error(f"[DubbingFFmpeg] L·ªói khi gh√©p audio v·ªõi silence cu·ªëi cho '{os.path.basename(input_wav_path)}'.")
            
        return success_concat_pad


# H√†m FFmpeg: Th√™m kho·∫£ng l·∫∑ng v√†o ƒë·∫ßu file audio WAV
    def dub_ffmpeg_add_leading_silence(self, input_path, output_path, silence_duration_ms):
        # D√πng service FFmpeg t·∫≠p trung

        if self.dub_stop_event.is_set():
            logging.info(f"[DubbingFFmpeg] Th√™m kho·∫£ng l·∫∑ng b·ªã h·ªßy cho '{os.path.basename(input_path)}' do y√™u c·∫ßu d·ª´ng.")
            return False

        if silence_duration_ms <= 0:
            # ... (x·ª≠ l√Ω copy file, kh√¥ng c·∫ßn Popen) ...
            if os.path.abspath(input_path) != os.path.abspath(output_path):
                try: shutil.copy2(os.path.abspath(input_path), os.path.abspath(output_path))
                except Exception as e_copy: logging.error(f"[DubbingFFmpeg] L·ªói sao ch√©p (silence <=0): {e_copy}"); return False
            return True
        
        delay_value_str = str(int(silence_duration_ms))
        cmd_params = [
            "-y", "-i", os.path.abspath(input_path),
            "-af", f"adelay={delay_value_str}|{delay_value_str}",
            "-c:a", self.dub_DEFAULT_WAV_CODEC,
            "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE),
            "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS),
            os.path.abspath(output_path)
        ]
        logging.info(f"[DubbingFFmpeg] Th√™m kho·∫£ng l·∫∑ng ({silence_duration_ms}ms) (service): {' '.join(cmd_params)}")
        try:
            ffmpeg_run_command(
                cmd_params,
                process_name="DubbingFFmpeg_AddLeadingSilence",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=60,
            )
            if not os.path.exists(output_path) or os.path.getsize(output_path) == 0:
                logging.error(f"[DubbingFFmpeg] L·ªói th√™m kho·∫£ng l·∫∑ng: File output r·ªóng.")
                return False
            return True
        except Exception as e_gen:
            logging.error(f"[DubbingFFmpeg] L·ªói khi th√™m kho·∫£ng l·∫∑ng: {e_gen}", exc_info=True)
            return False


# H√†m FFmpeg: Gh√©p n·ªëi c√°c file audio WAV t·ª´ m·ªôt file list
    def dub_ffmpeg_concatenate_audios(self, file_list_path, output_path):
        # D√πng service FFmpeg t·∫≠p trung
        
        if self.dub_stop_event.is_set(): # << KI·ªÇM TRA D·ª™NG >>
            logging.info(f"[DubbingFFmpeg] Gh√©p audio b·ªã h·ªßy (file list: {os.path.basename(file_list_path)}) do y√™u c·∫ßu d·ª´ng.")
            return False

        cmd_params = [
            "-y", "-f", "concat", "-safe", "0",
            "-i", os.path.abspath(file_list_path),
            "-c:a", self.dub_DEFAULT_WAV_CODEC,
            "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE),
            "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS),
            os.path.abspath(output_path)
        ]
        logging.info(f"[DubbingFFmpeg] Gh√©p Audio WAVs (service): {' '.join(cmd_params)}")
        try:
            ffmpeg_run_command(
                cmd_params,
                process_name="DubbingFFmpeg_ConcatWAVs",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=300,
            )
            if not os.path.exists(output_path) or os.path.getsize(output_path) == 0:
                 logging.error(f"[DubbingFFmpeg] L·ªói gh√©p WAV: File output r·ªóng.")
                 return False
            logging.debug(f"[DubbingFFmpeg] Gh√©p WAV th√†nh c√¥ng: {os.path.basename(output_path)}")
            return True
        except Exception as e_gen:
            logging.error(f"[DubbingFFmpeg] L·ªói khi gh√©p WAV: {e_gen}", exc_info=True)
            return False


# H√†m FFmpeg: Chuy·ªÉn ƒë·ªïi WAV sang MP3 v√† chu·∫©n h√≥a ƒë·ªô l·ªõn
    def dub_ffmpeg_convert_wav_to_mp3_normalized(self, input_wav_path, output_mp3_path):
        if self.dub_stop_event.is_set():
            logging.info(f"[DubbingFFmpeg] Chuy·ªÉn MP3 (norm) b·ªã h·ªßy cho '{os.path.basename(input_wav_path)}' do y√™u c·∫ßu d·ª´ng.")
            return False

        loudnorm_filter = "loudnorm=I=-14:LRA=7:TP=-1.5:print_format=summary"
        cmd_params = [
            "-y", "-i", os.path.abspath(input_wav_path),
            "-af", loudnorm_filter, "-c:a", "libmp3lame",
            "-q:a", str(self.dub_DEFAULT_MP3_QUALITY),
            "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE),
            "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS),
            os.path.abspath(output_mp3_path)
        ]
        logging.info(f"[DubbingFFmpeg] Chuy·ªÉn WAV sang MP3 (Normalized) (service): {' '.join(cmd_params)}")
        try:
            ffmpeg_run_command(
                cmd_params,
                process_name="DubbingFFmpeg_ConvertWAV2MP3_Norm",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=300,
            )
            if not os.path.exists(output_mp3_path) or os.path.getsize(output_mp3_path) == 0:
                 logging.error(f"[DubbingFFmpeg] L·ªói chuy·ªÉn MP3 (norm): File output r·ªóng.")
                 return False
            logging.debug(f"[DubbingFFmpeg] Chuy·ªÉn MP3 (normalized) th√†nh c√¥ng: {os.path.basename(output_mp3_path)}")
            return True
        except Exception as e_gen:
            logging.error(f"[DubbingFFmpeg] L·ªói khi chuy·ªÉn MP3 (normalized): {e_gen}", exc_info=True)
            return False



# H√†m FFmpeg: Gh√©p (mux) video g·ªëc v·ªõi track √¢m thanh thuy·∫øt minh v√† t√πy ch·ªçn nh·∫°c n·ªÅn
    def dub_ffmpeg_mux_video_audio(self, video_input_path, dub_audio_path, output_video_path,
                                   action="replace_with_dub_only",
                                   original_audio_mix_level=0.15,
                                   custom_bgm_path=None, 
                                   custom_bgm_level=0.2,
                                   external_audio_path=None):
        """
        (PHI√äN B·∫¢N S·ª¨A L·ªñI LOGIC BGM)
        Gh√©p video, audio thuy·∫øt minh, v√† nh·∫°c n·ªÅn.
        - ƒê·∫£m b·∫£o logic ti·ªÅn x·ª≠ l√Ω nh·∫°c n·ªÅn (fade, concat) ƒë∆∞·ª£c th·ª±c thi ƒë√∫ng.
        - Gi·ªØ nguy√™n logic x·ª≠ l√Ω audio thuy·∫øt minh d√†i/ng·∫Øn h∆°n video.
        """

        with keep_awake("Mux audio/video & branding"):

            worker_log_prefix = f"[{threading.current_thread().name}_MuxFinalVideo_v3.0_BGMFix]"
            logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu. Action: '{action}', Video: '{os.path.basename(video_input_path)}'")

            ffmpeg_executable = find_ffmpeg()
            if not ffmpeg_executable:
                logging.error(f"{worker_log_prefix} Kh√¥ng t√¨m th·∫•y FFmpeg.")
                return False

            if self.dub_stop_event.is_set():
                logging.info(f"{worker_log_prefix} B·ªã h·ªßy do y√™u c·∫ßu d·ª´ng (ƒë·∫ßu h√†m).")
                return False

            if not os.path.exists(video_input_path) or not os.path.exists(dub_audio_path):
                logging.error(f"{worker_log_prefix} File video ('{video_input_path}') ho·∫∑c audio thuy·∫øt minh ('{dub_audio_path}') kh√¥ng t·ªìn t·∫°i.")
                return False

            final_bgm_path_for_mux = None
            temp_files_to_delete = []
            process_to_run = None

            try:
                # === B∆Ø·ªöC 1: L·∫§Y TH·ªúI L∆Ø·ª¢NG V√Ä T√çNH TO√ÅN KHO·∫¢NG L·∫∂NG CHO AUDIO THUY·∫æT MINH ===
                video_duration_s = get_video_duration_s(video_input_path)
                dub_audio_duration_s = (self.dub_get_audio_duration_ms(dub_audio_path) or 0) / 1000.0
                
                if video_duration_s <= 0:
                    logging.error(f"{worker_log_prefix} Kh√¥ng th·ªÉ x√°c ƒë·ªãnh th·ªùi l∆∞·ª£ng video ch√≠nh. Kh√¥ng th·ªÉ ti·∫øp t·ª•c.")
                    return False

                logging.info(f"{worker_log_prefix} Th·ªùi l∆∞·ª£ng Video: {video_duration_s:.3f}s, Th·ªùi l∆∞·ª£ng Audio Thuy·∫øt minh: {dub_audio_duration_s:.3f}s")
                padding_duration_s = 0.0
                if dub_audio_duration_s > 0 and dub_audio_duration_s < video_duration_s:
                    padding_duration_s = video_duration_s - dub_audio_duration_s + 0.1
                    logging.info(f"{worker_log_prefix} Audio thuy·∫øt minh ng·∫Øn h∆°n video. S·∫Ω th√™m {padding_duration_s:.3f}s kho·∫£ng l·∫∑ng.")
                
                # === B∆Ø·ªöC 2: TI·ªÄN X·ª¨ L√ù NH·∫†C N·ªÄN (BGM) N·∫æU C√ì ===
                # Logic n√†y ƒë∆∞·ª£c ƒë∆∞a l√™n tr∆∞·ªõc v√† c·∫•u tr√∫c l·∫°i ƒë·ªÉ r√µ r√†ng h∆°n.
                if self.dub_use_custom_bg_music_var.get():
                    use_bgm_from_folder = self.dub_custom_bg_music_folder_path_var.get()
                    use_bgm_from_single_file = custom_bgm_path and not use_bgm_from_folder

                    if use_bgm_from_folder:
                        logging.info(f"{worker_log_prefix} Ch·∫ø ƒë·ªô nh·∫°c n·ªÅn t·ª´ th∆∞ m·ª•c: {use_bgm_from_folder}")
                        bgm_list = self._prepare_bgm_list_from_folder(use_bgm_from_folder, self.dub_randomize_bg_music_var.get())
                        if bgm_list:
                            temp_concat_path = os.path.join(self.temp_folder, f"bgm_concat_{uuid.uuid4().hex[:6]}.m4a")
                            final_bgm_path_for_mux, temp_files = self._ffmpeg_create_concatenated_bgm(bgm_list, temp_concat_path, video_input_path)
                            temp_files_to_delete.extend(temp_files)
                    
                    elif use_bgm_from_single_file:
                        logging.info(f"{worker_log_prefix} Ch·∫ø ƒë·ªô nh·∫°c n·ªÅn t·ª´ file ƒë∆°n: {os.path.basename(custom_bgm_path)}. B·∫Øt ƒë·∫ßu ti·ªÅn x·ª≠ l√Ω fade.")
                        fade_in = 0.6
                        fade_out = 0.3
                        duration_ms = self.dub_get_audio_duration_ms(custom_bgm_path)
                        
                        if duration_ms and (duration_ms / 1000.0) > (fade_in + fade_out + 0.1):
                            duration_s = duration_ms / 1000.0
                            bgm_base, bgm_ext = os.path.splitext(os.path.basename(custom_bgm_path))
                            temp_faded_path = os.path.join(self.temp_folder, f"faded_bgm_{bgm_base}_{uuid.uuid4().hex[:4]}{bgm_ext}")
                            temp_files_to_delete.append(temp_faded_path)
                            
                            cmd_params_bgm_fade = [
                                "-y",
                                "-i", os.path.abspath(custom_bgm_path),
                                "-af", f"afade=t=in:d={fade_in:.3f},afade=t=out:st={duration_s - fade_out:.3f}:d={fade_out:.3f}",
                                temp_faded_path,
                            ]
                            try:
                                ffmpeg_run_command(
                                    cmd_params_bgm_fade,
                                    process_name=f"{worker_log_prefix}_BGMFade",
                                    stop_event=self.dub_stop_event,
                                    set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                                    clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                                    timeout_seconds=150,
                                )
                                final_bgm_path_for_mux = temp_faded_path
                                logging.info(f"{worker_log_prefix} Ti·ªÅn x·ª≠ l√Ω fade cho BGM th√†nh c√¥ng: {os.path.basename(temp_faded_path)}")
                            except Exception as e_bgmfade:
                                final_bgm_path_for_mux = custom_bgm_path
                                logging.warning(f"{worker_log_prefix} L·ªói ti·ªÅn x·ª≠ l√Ω fade cho BGM. D√πng file g·ªëc. L√Ω do: {e_bgmfade}")
                        else:
                            final_bgm_path_for_mux = custom_bgm_path
                            logging.info(f"{worker_log_prefix} BGM qu√° ng·∫Øn ƒë·ªÉ fade, d√πng file g·ªëc.")

                # === B∆Ø·ªöC 3: X√ÇY D·ª∞NG L·ªÜNH FFmpeg CU·ªêI C√ôNG ===
                command = [ffmpeg_executable, "-y",
                           "-i", os.path.abspath(video_input_path),
                           "-i", os.path.abspath(dub_audio_path)]

                input_map = {"video": "0", "dub": "1"}
                next_input_index = 2
                video_has_original_audio = self.check_for_audio_stream(video_input_path)

                use_looping_bgm = False
                if final_bgm_path_for_mux and os.path.exists(final_bgm_path_for_mux):
                    command.extend(["-stream_loop", "-1", "-i", os.path.abspath(final_bgm_path_for_mux)])
                    input_map["bgm"] = str(next_input_index); next_input_index += 1; use_looping_bgm = True
                
                if external_audio_path and os.path.exists(external_audio_path):
                    command.extend(["-i", os.path.abspath(external_audio_path)])
                    input_map["external"] = str(next_input_index)

                filter_parts, map_ops, audio_codec_ops = self._build_ffmpeg_mux_filter_and_maps(
                    input_map, action, video_has_original_audio, use_looping_bgm,
                    original_audio_mix_level, custom_bgm_level
                )
                
                if padding_duration_s > 0:
                    if filter_parts:
                        dub_stream_input_tag = f"[{input_map['dub']}:a]"
                        # T√¨m v√† thay th·∫ø an to√†n h∆°n
                        found_filter = False
                        for i, part in enumerate(filter_parts):
                            if part.startswith(dub_stream_input_tag):
                                filter_parts[i] = part.replace(dub_stream_input_tag, f"{dub_stream_input_tag}apad=pad_dur={padding_duration_s:.3f},")
                                logging.info(f"{worker_log_prefix} ƒê√£ ch√®n `apad` v√†o filter chain: {filter_parts[i]}")
                                found_filter = True
                                break
                        if not found_filter:
                            logging.warning(f"{worker_log_prefix} Kh√¥ng t√¨m th·∫•y filter chain cho lu·ªìng thuy·∫øt minh ƒë·ªÉ ch√®n 'apad'.")
                    else: # N·∫øu kh√¥ng c√≥ filter n√†o, t·ª± t·∫°o
                        filter_parts.append(f"[{input_map['dub']}:a]apad=pad_dur={padding_duration_s:.3f}[padded_dub]")
                        map_ops = [op.replace(f"[{input_map['dub']}:a]", "[padded_dub]") for op in map_ops] # C·∫ßn s·ª≠a map_ops n·∫øu c√≥

                command.extend(map_ops)
                if filter_parts:
                    command.extend(["-filter_complex", ";".join(filter_parts)])
                
                if video_duration_s > 0:
                     command.extend(["-t", f"{video_duration_s:.3f}"])
                
                command.extend(["-c:v", self.dub_DEFAULT_VIDEO_CODEC])
                command.extend(audio_codec_ops)
                command.append(os.path.abspath(output_video_path))

                # Th·ª±c thi l·ªánh (gi·ªØ nguy√™n)
                logging.info(f"{worker_log_prefix} L·ªánh FFmpeg cu·ªëi c√πng: {' '.join(command)}")
                creation_flags = subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                process_to_run = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=creation_flags)
                self.dub_current_ffmpeg_process = process_to_run
                _, stderr = process_to_run.communicate(timeout=1200)

                if self.dub_stop_event.is_set(): raise InterruptedError("D·ª´ng trong l√∫c gh√©p video cu·ªëi")
                if process_to_run.returncode != 0: raise RuntimeError(f"FFmpeg (mux) th·∫•t b·∫°i. L·ªói: {stderr.decode('utf-8', 'ignore')}")
                if not os.path.exists(output_video_path): raise FileNotFoundError("File video output kh√¥ng ƒë∆∞·ª£c t·∫°o.")
                
                logging.info(f"{worker_log_prefix} Gh√©p video/audio ho√†n t·∫•t: {os.path.basename(output_video_path)}")
                return True
                
            except Exception as e_gen_mux:
                logging.error(f"{worker_log_prefix} L·ªói kh√¥ng mong mu·ªën khi gh√©p video/audio: {e_gen_mux}", exc_info=True)
                if process_to_run and process_to_run.poll() is None: process_to_run.kill()
                return False
            finally:
                if hasattr(self, 'dub_current_ffmpeg_process') and self.dub_current_ffmpeg_process is process_to_run:
                     self.dub_current_ffmpeg_process = None
                
                for temp_file in temp_files_to_delete:
                    if temp_file and os.path.exists(temp_file):
                        try:
                            os.remove(temp_file)
                        except Exception as e_del:
                            logging.warning(f"L·ªói khi x√≥a file t·∫°m BGM '{os.path.basename(temp_file)}': {e_del}")
                        

    # H√ÄM 2: H√ÄM HELPER M·ªöI ƒê·ªÇ X√ÇY D·ª∞NG FILTER_COMPLEX
    def _build_ffmpeg_mux_filter_and_maps(self, input_map, action, video_has_original_audio, use_looping_bgm, original_audio_mix_level, custom_bgm_level):
        """
        (PHI√äN B·∫¢N S·ª¨A L·ªñI BGM) 
        H√†m helper ƒë·ªÉ x√¢y d·ª±ng -filter_complex v√† c√°c l·ªánh -map.
        Track BGM gi·ªù ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a tr∆∞·ªõc, kh√¥ng c·∫ßn loudnorm ·ªü ƒë√¢y n·ªØa.
        """
        filter_parts = []
        map_ops = ["-map", f"{input_map['video']}:v:0?"]
        audio_codec_ops = ["-c:a", self.dub_DEFAULT_AUDIO_CODEC_AAC, "-b:a", self.dub_DEFAULT_AUDIO_BITRATE_AAC]

        DUB_TARGET_LUFS = -11
        ORIGINAL_AUDIO_TARGET_LUFS = -27
        
        # 1. Lu√¥n chu·∫©n h√≥a lu·ªìng thuy·∫øt minh
        dub_stream = f"[{input_map['dub']}:a]"
        normalized_dub_stream = "[dub_norm]"
        filter_parts.append(f"{dub_stream}loudnorm=I={DUB_TARGET_LUFS}:TP=-1.5:LRA=11{normalized_dub_stream}")
        
        final_audio_output_stream = normalized_dub_stream

        # 2. X·ª≠ l√Ω logic tr·ªôn d·ª±a tr√™n "action"
        if action == "audio_ducking":
            ducking_source_input = ""
            if use_looping_bgm:
                ducking_source_input = f"[{input_map['bgm']}:a]"
            elif video_has_original_audio:
                ducking_source_input = f"[{input_map['video']}:a:0?]"

            if ducking_source_input:
                # ### THAY ƒê·ªîI: Kh√¥ng c·∫ßn chu·∫©n h√≥a ngu·ªìn ducking n·ªØa v√¨ BGM ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a ###
                # ### Ch·ªâ c·∫ßn √°p d·ª•ng volume ###
                ducking_source_with_volume = "[duck_source_vol]"
                
                # Quy·∫øt ƒë·ªãnh m·ª©c √¢m l∆∞·ª£ng cho ngu·ªìn ducking
                ducking_volume = custom_bgm_level if use_looping_bgm else original_audio_mix_level
                
                filter_parts.append(f"{ducking_source_input}volume={ducking_volume:.2f}{ducking_source_with_volume}")

                filter_parts.append(f"{normalized_dub_stream}asplit=2[dub_for_sidechain][dub_for_output]")
                filter_parts.append(f"{ducking_source_with_volume}[dub_for_sidechain]sidechaincompress=threshold=0.07:ratio=7[ducked_output]")
                filter_parts.append(f"[ducked_output][dub_for_output]amix=inputs=2[a_out]")
                final_audio_output_stream = "[a_out]"

        elif action == "mix_dub_and_original":
            if video_has_original_audio:
                original_audio_norm = "[original_norm]"
                filter_parts.append(f"[{input_map['video']}:a:0?]loudnorm=I={ORIGINAL_AUDIO_TARGET_LUFS}:TP=-1.5:LRA=11{original_audio_norm}")
                filter_parts.append(f"{original_audio_norm}volume={original_audio_mix_level:.2f}[original_audio_mixed]")
                filter_parts.append(f"[original_audio_mixed]{normalized_dub_stream}amix=inputs=2:duration=shortest[a_out]")
                final_audio_output_stream = "[a_out]"

        else: # M·∫∑c ƒë·ªãnh l√† "replace"
            if use_looping_bgm:
                # ### THAY ƒê·ªîI: B·ªè LOUDNORM cho BGM, ch·ªâ d√πng VOLUME ###
                # BGM ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a tr∆∞·ªõc khi gh√©p, gi·ªù ch·ªâ c·∫ßn ƒë·∫∑t m·ª©c √¢m l∆∞·ª£ng cu·ªëi c√πng
                bgm_mixed = "[bgm_mixed]"
                filter_parts.append(f"[{input_map['bgm']}:a]volume={custom_bgm_level:.2f}{bgm_mixed}")
                
                # Tr·ªôn v·ªõi lu·ªìng thuy·∫øt minh
                filter_parts.append(f"{bgm_mixed}{normalized_dub_stream}amix=inputs=2:duration=first[a_out]")
                final_audio_output_stream = "[a_out]"

        map_ops.extend(["-map", final_audio_output_stream])
        
        return filter_parts, map_ops, audio_codec_ops



# H√†m ti·ªán √≠ch: L·∫•y th·ªùi l∆∞·ª£ng file audio b·∫±ng ffprobe (fallback)
    def dub_get_audio_duration_ms_ffprobe(self, file_path, ffmpeg_executable_path_from_caller):
        """
        L·∫•y th·ªùi l∆∞·ª£ng audio (ms) b·∫±ng ffprobe. Tr·∫£ v·ªÅ None n·∫øu l·ªói.
        H√†m n√†y nh·∫≠n ƒë∆∞·ªùng d·∫´n ffmpeg ƒë√£ ƒë∆∞·ª£c x√°c ƒë·ªãnh t·ª´ h√†m g·ªçi.
        """
        if not ffmpeg_executable_path_from_caller:
            logging.error("[DubbingAudio_FFprobe] ƒê∆∞·ªùng d·∫´n FFmpeg kh√¥ng ƒë∆∞·ª£c cung c·∫•p t·ª´ h√†m g·ªçi.")
            return None
        
        # X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n ffprobe d·ª±a tr√™n ƒë∆∞·ªùng d·∫´n ffmpeg ƒë√£ cung c·∫•p
        ffprobe_exe_name = "ffprobe.exe" if platform.system() == "Windows" else "ffprobe"
        ffprobe_path_candidate = os.path.join(os.path.dirname(ffmpeg_executable_path_from_caller), ffprobe_exe_name)
        final_ffprobe_path = None

        if os.path.exists(ffprobe_path_candidate) and os.access(ffprobe_path_candidate, os.X_OK):
            final_ffprobe_path = ffprobe_path_candidate
            logging.debug(f"[DubbingAudio_FFprobe] S·ª≠ d·ª•ng ffprobe ƒëi k√®m ffmpeg: {final_ffprobe_path}")
        else:
            # N·∫øu kh√¥ng t√¨m th·∫•y c√πng th∆∞ m·ª•c, th·ª≠ t√¨m trong PATH h·ªá th·ªëng
            ffprobe_path_system = shutil.which(ffprobe_exe_name)
            if ffprobe_path_system:
                final_ffprobe_path = ffprobe_path_system
                logging.debug(f"[DubbingAudio_FFprobe] S·ª≠ d·ª•ng ffprobe t·ª´ PATH h·ªá th·ªëng: {final_ffprobe_path}")
            else:
                logging.error(f"[DubbingAudio_FFprobe] Kh√¥ng t√¨m th·∫•y ffprobe t·∫°i '{ffprobe_path_candidate}' "
                              f"(d·ª±a tr√™n ffmpeg: {ffmpeg_executable_path_from_caller}) ho·∫∑c trong PATH h·ªá th·ªëng.")
                return None
        
        command = [
            final_ffprobe_path, 
            "-v", "error", 
            "-show_entries", "format=duration", 
            "-of", "default=noprint_wrappers=1:nokey=1", 
            os.path.abspath(file_path)
        ]
        logging.debug(f"[DubbingAudio_FFprobe] L·ªánh ffprobe duration: {' '.join(command)}")
        try:
            creation_flags = subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            result = subprocess.run(command, capture_output=True, text=True, check=True, timeout=15, creationflags=creation_flags) # TƒÉng timeout nh·∫π
            duration_seconds_str = result.stdout.strip()
            if duration_seconds_str and duration_seconds_str != "N/A":
                duration_ms = int(float(duration_seconds_str) * 1000)
                logging.debug(f"[DubbingAudio_FFprobe] ffprobe duration cho '{os.path.basename(file_path)}': {duration_ms}ms")
                return duration_ms
            else:
                logging.warning(f"[DubbingAudio_FFprobe] ffprobe kh√¥ng tr·∫£ v·ªÅ th·ªùi l∆∞·ª£ng h·ª£p l·ªá cho '{os.path.basename(file_path)}'. "
                                f"Output: '{duration_seconds_str}'")
                return None
        except subprocess.CalledProcessError as e:
            logging.error(f"[DubbingAudio_FFprobe] L·ªói CalledProcessError v·ªõi ffprobe cho '{os.path.basename(file_path)}': {e.stderr}")
            return None
        except subprocess.TimeoutExpired:
            logging.error(f"[DubbingAudio_FFprobe] Timeout (15s) v·ªõi ffprobe cho '{os.path.basename(file_path)}'.")
            return None
        except Exception as e:
            logging.error(f"[DubbingAudio_FFprobe] L·ªói kh√¥ng mong mu·ªën v·ªõi ffprobe cho '{os.path.basename(file_path)}': {e}", exc_info=True)
            return None
        

    # H√†m ti·ªán √≠ch: L·∫•y th·ªùi l∆∞·ª£ng file audio (ms), ∆∞u ti√™n mutagen, fallback ffprobe
    def dub_get_audio_duration_ms(self, file_path):
        """
        L·∫•y th·ªùi l∆∞·ª£ng audio (ms). ∆Øu ti√™n mutagen, fallback ffprobe.
        Tr·∫£ v·ªÅ None n·∫øu kh√¥ng th·ªÉ x√°c ƒë·ªãnh.
        S·ª≠a l·ªói: G·ªçi h√†m find_ffmpeg() to√†n c·ª•c thay v√¨ self.find_ffmpeg().
        """
        if not os.path.exists(file_path) or os.path.getsize(file_path) == 0:
            logging.warning(f"[DubbingAudio] File audio kh√¥ng t·ªìn t·∫°i ho·∫∑c r·ªóng: {file_path}")
            return None
        
        duration_ms = None
        file_ext = os.path.splitext(file_path)[1].lower()
        audio_info = None

        # G·ªçi h√†m find_ffmpeg() to√†n c·ª•c
        ffmpeg_path_for_ffprobe_usage = find_ffmpeg()

        if not ffmpeg_path_for_ffprobe_usage:
            logging.error(f"[DubbingAudio] Kh√¥ng t√¨m th·∫•y FFmpeg khi b·∫Øt ƒë·∫ßu dub_get_audio_duration_ms cho file: {file_path}. "
                          "Kh√¥ng th·ªÉ s·ª≠ d·ª•ng ffprobe l√†m fallback.")

        try:
            if file_ext == ".mp3": audio_info = MP3(file_path)
            elif file_ext == ".wav": audio_info = WAVE(file_path)
            elif file_ext == ".flac": audio_info = FLAC(file_path)
            elif file_ext == ".ogg" or file_ext == ".opus": audio_info = OggOpus(file_path)
            elif file_ext == ".aac" or file_ext == ".m4a": audio_info = AAC(file_path)
            else:
                logging.info(f"[DubbingAudio] ƒê·ªãnh d·∫°ng '{file_ext}' kh√¥ng ƒë∆∞·ª£c mutagen h·ªó tr·ª£ tr·ª±c ti·∫øp. "
                             f"Th·ª≠ ffprobe cho '{os.path.basename(file_path)}'.")
                if ffmpeg_path_for_ffprobe_usage: # Ch·ªâ g·ªçi ffprobe n·∫øu c√≥ ƒë∆∞·ªùng d·∫´n
                    duration_ms = self.dub_get_audio_duration_ms_ffprobe(file_path, ffmpeg_path_for_ffprobe_usage)
                else:
                    logging.warning(f"[DubbingAudio] Kh√¥ng c√≥ FFmpeg, kh√¥ng th·ªÉ d√πng ffprobe cho '{file_ext}'.")
                return duration_ms

            if audio_info and hasattr(audio_info, 'info') and hasattr(audio_info.info, 'length') and audio_info.info.length is not None:
                duration_ms = int(audio_info.info.length * 1000)
                logging.debug(f"[DubbingAudio] Mutagen duration cho '{os.path.basename(file_path)}': {duration_ms}ms")
            else:
                logging.warning(f"[DubbingAudio] Mutagen kh√¥ng l·∫•y ƒë∆∞·ª£c 'audio.info.length' cho '{os.path.basename(file_path)}'. "
                                f"Th·ª≠ ffprobe.")
                if ffmpeg_path_for_ffprobe_usage: # Ch·ªâ g·ªçi ffprobe n·∫øu c√≥ ƒë∆∞·ªùng d·∫´n
                    duration_ms = self.dub_get_audio_duration_ms_ffprobe(file_path, ffmpeg_path_for_ffprobe_usage)
                else:
                    logging.warning(f"[DubbingAudio] Kh√¥ng c√≥ FFmpeg, kh√¥ng th·ªÉ d√πng ffprobe khi mutagen l·ªói.")
        
        except ImportError as ie: 
            logging.warning(f"[DubbingAudio] L·ªói Import Mutagen (c√≥ th·ªÉ thi·∫øu backend) cho '{file_ext}': {ie}. "
                            f"Th·ª≠ ffprobe cho '{os.path.basename(file_path)}'.")
            if ffmpeg_path_for_ffprobe_usage:
                duration_ms = self.dub_get_audio_duration_ms_ffprobe(file_path, ffmpeg_path_for_ffprobe_usage)
            else:
                logging.warning(f"[DubbingAudio] Kh√¥ng c√≥ FFmpeg, kh√¥ng th·ªÉ d√πng ffprobe khi mutagen import l·ªói.")
        except Exception as e:
            logging.error(f"[DubbingAudio] L·ªói khi d√πng mutagen cho '{os.path.basename(file_path)}': {e}. "
                          f"Th·ª≠ ffprobe.", exc_info=True)
            if ffmpeg_path_for_ffprobe_usage:
                duration_ms = self.dub_get_audio_duration_ms_ffprobe(file_path, ffmpeg_path_for_ffprobe_usage)
            else:
                logging.warning(f"[DubbingAudio] Kh√¥ng c√≥ FFmpeg, kh√¥ng th·ªÉ d√πng ffprobe khi mutagen l·ªói chung.")
            
        return duration_ms


 # H√†m FFmpeg: ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô file audio
    def dub_ffmpeg_adjust_audio_speed(self, input_path, output_path, speed_factor):
        ffmpeg_executable = find_ffmpeg()
        if not ffmpeg_executable:
            logging.error("[DubbingFFmpeg] Kh√¥ng t√¨m th·∫•y FFmpeg ƒë·ªÉ ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô audio.")
            return False

        if self.dub_stop_event.is_set(): 
            logging.info(f"[DubbingFFmpeg] ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô b·ªã h·ªßy cho '{os.path.basename(input_path)}' do y√™u c·∫ßu d·ª´ng.")
            return False

        clamped_speed_factor = max(0.5, min(3.0, speed_factor)) 
        if abs(clamped_speed_factor - speed_factor) > 0.001:
             logging.warning(f"[DubbingFFmpeg] Speed factor g·ªëc {speed_factor:.3f} clamp v·ªÅ {clamped_speed_factor:.3f}.")
        
        command = [
            ffmpeg_executable, "-y", "-i", os.path.abspath(input_path),
            "-filter:a", f"atempo={clamped_speed_factor:.3f}"
        ]
        output_ext = os.path.splitext(output_path)[1].lower()
        if output_ext == ".mp3": command.extend(["-c:a", "libmp3lame", "-q:a", str(self.dub_DEFAULT_MP3_QUALITY)])
        elif output_ext == ".wav": command.extend(["-c:a", self.dub_DEFAULT_WAV_CODEC, "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE), "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS)])
        elif output_ext == ".aac": command.extend(["-c:a", self.dub_DEFAULT_AUDIO_CODEC_AAC, "-b:a", self.dub_DEFAULT_AUDIO_BITRATE_AAC])
        else: command.extend(["-c:a", "copy"]) # Fallback
        command.append(os.path.abspath(output_path))
        
        logging.info(f"[DubbingFFmpeg] ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô audio: {' '.join(command)}")
        process_to_run = None
        try:
            creation_flags = subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            process_to_run = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=creation_flags)
            self.dub_current_ffmpeg_process = process_to_run 
            stdout, stderr = process_to_run.communicate(timeout=60)
            return_code = process_to_run.returncode

            if self.dub_stop_event.is_set():
                logging.info(f"[DubbingFFmpeg] ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô cho '{os.path.basename(input_path)}' c√≥ th·ªÉ ƒë√£ b·ªã d·ª´ng.")
                if process_to_run.poll() is None: process_to_run.terminate()
                return False

            if return_code != 0:
                logging.error(f"[DubbingFFmpeg] L·ªói CalledProcessError khi ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô '{os.path.basename(input_path)}'. STDERR: {stderr.decode('utf-8', errors='ignore')[:250]}")
                return False
            if not os.path.exists(output_path) or os.path.getsize(output_path) == 0:
                logging.error(f"[DubbingFFmpeg] L·ªói ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô: File output r·ªóng.")
                return False
            logging.debug(f"[DubbingFFmpeg] ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô th√†nh c√¥ng cho: {os.path.basename(output_path)}")
            return True
        except subprocess.TimeoutExpired:
            logging.error(f"[DubbingFFmpeg] Timeout khi ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô audio '{os.path.basename(input_path)}'.")
            if process_to_run and process_to_run.poll() is None: process_to_run.kill()
            return False
        except Exception as e_gen:
            logging.error(f"[DubbingFFmpeg] L·ªói kh√¥ng mong mu·ªën khi ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô audio: {e_gen}", exc_info=True)
            if process_to_run and process_to_run.poll() is None: process_to_run.kill()
            return False
        finally:
            if self.dub_current_ffmpeg_process is process_to_run:
                self.dub_current_ffmpeg_process = None
                logging.debug(f"[DubbingFFmpeg] ƒê√£ reset dub_current_ffmpeg_process (adjust_speed).")



    # SSML "b·∫£o th·ªß" cho Google TTS (vi-VN)
    def dub_generate_basic_ssml(self,
                                plain_text: str,
                                lang_code: str = 'vi-VN',
                                normalize_quotes: bool = True,
                                use_global_prosody: bool = False,
                                prosody_rate: str = "0.97",
                                prosody_pitch: str = "0st") -> str:
        """
        (PHI√äN B·∫¢N N√ÇNG C·∫§P - CONSERVATIVE)
        T·∫°o SSML "b·∫£o th·ªß" cho Google TTS (vi-VN):
          - Kh√¥ng ch√®n <break> cho ., !, ?, ,
          - Ch·ªâ th√™m <break time="...ms"> cho tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát (ellipsis, g·∫°ch ngang, hai ch·∫•m).
          - D√πng <p>/<s> ƒë·ªÉ ƒë√°nh d·∫•u c·∫•u tr√∫c ƒëo·∫°n/c√¢u.
          - Tu·ª≥ ch·ªçn prosody r·∫•t nh·∫π (rate/pitch) ƒë·ªÉ gi·∫£m c·∫£m gi√°c "g·∫•p".

        Params:
          - normalize_quotes: chuy·ªÉn " ... " th√†nh ‚Äú ‚Ä¶ ‚Äù ƒë·ªÉ gi·∫£m kh·ª±ng tr√™n Neural2.
          - use_global_prosody: b·ªçc to√†n b·ªô b·∫±ng <prosody rate=... pitch=...>.
          - prosody_rate: v√≠ d·ª• "0.97" (nh·∫π), "0.95" (ch·∫≠m h∆°n ch√∫t), "0.99" (g·∫ßn m·∫∑c ƒë·ªãnh).
          - prosody_pitch: v√≠ d·ª• "0st" (gi·ªØ nguy√™n), "0.5st"...

        Tr·∫£ v·ªÅ:
          - Chu·ªói SSML <speak>...</speak>.
        """
        import re
        from xml.sax.saxutils import escape

        if not plain_text or not plain_text.strip():
            return "<speak></speak>"

        text = plain_text.strip()

        # 1) Chu·∫©n ho√° ngo·∫∑c k√©p ASCII -> ‚Äú ‚Äù (tu·ª≥ ch·ªçn)
        if normalize_quotes:
            out, open_q = [], True
            for ch in text:
                if ch == '"':
                    out.append('‚Äú' if open_q else '‚Äù'); open_q = not open_q
                else:
                    out.append(ch)
            text = ''.join(out)

        # 2) T√°ch ƒëo·∫°n theo 2+ newline
        paragraphs = [p.strip() for p in re.split(r'\n\s*\n+', text) if p.strip()]
        if not paragraphs:
            paragraphs = [text]

        # 2.1) Regex d√πng l·∫°i nhi·ªÅu l·∫ßn (t·ªëi ∆∞u nh·∫π)
        re_end_punct = re.compile(r'([.!?‚Ä¶])(\s+|$)')
        re_abbrev_tail = re.compile(r'(?:TS|PGS|GS|ThS|Mr|Mrs|Ms|Dr|Tp|TP|HN|HCM|TP\.HCM|Q\.)\s*$')
        re_ellipsis = re.compile(r'(\.{3,}|‚Ä¶)(?!\s*<break\b)')
        re_dash_inside = re.compile(r'(?<=\w)\s*[‚Äì‚Äî-]\s*(?=\w)')
        # D·∫•u ":" nh∆∞ng KH√îNG ph·∫£i d·∫°ng s·ªë:s·ªë (10:30, 1:3) v√† ch∆∞a c√≥ break ngay sau
        re_colon_safe = re.compile(r'(?<!\d):(?!\d)(?!\s*<break\b)(?=\s+\S)')

        def sent_tokenize_vi(s: str):
            """T√°ch c√¢u ƒë∆°n gi·∫£n, tr√°nh c·∫Øt sau c√°c vi·∫øt t·∫Øt ph·ªï bi·∫øn."""
            parts, start = [], 0
            for m in re_end_punct.finditer(s):
                end = m.end()
                chunk = s[start:end]
                # N·∫øu ƒëu√¥i c√¢u tr√∫ng vi·∫øt t·∫Øt, b·ªè qua l·∫ßn c·∫Øt n√†y
                if re_abbrev_tail.search(s[start:m.start()+1]):
                    continue
                parts.append(chunk.strip())
                start = end
            tail = s[start:].strip()
            if tail:
                parts.append(tail)
            return parts if parts else [s.strip()]

        def lightly_ssml_enhance(txt: str) -> str:
            """
            Ch·ªâ can thi·ªáp t·ªëi thi·ªÉu:
              - Ellipsis: th√™m break ~340ms
              - G·∫°ch ngang gi·ªØa ch·ªØ: break ~200ms
              - D·∫•u hai ch·∫•m (kh√¥ng ph·∫£i s·ªë:s·ªë): break ~160ms
            Kh√¥ng ƒë·ªông v√†o ., !, ?, ,  ‚Üí ƒë·ªÉ engine t·ª± x·ª≠ l√Ω nh·ªãp t·ª± nhi√™n.
            """
            t = escape(txt)
            # 1) Ellipsis
            t = re_ellipsis.sub(r'\1<break time="340ms"/>', t)
            # 2) G·∫°ch ngang n·∫±m gi·ªØa t·ª´ (aside)
            t = re_dash_inside.sub(r'<break time="200ms"/>', t)
            # 3) D·∫•u hai ch·∫•m an to√†n (tr√°nh HH:MM, t·ªâ l·ªá)
            t = re_colon_safe.sub(r':<break time="160ms"/>', t)
            return t

        # 3) D·ª±ng <p>/<s>
        p_nodes = []
        for p in paragraphs:
            sentences = sent_tokenize_vi(p)
            s_nodes = [f"<s>{lightly_ssml_enhance(s)}</s>" for s in sentences]
            p_nodes.append(f"<p>{' '.join(s_nodes)}</p>")

        body = " ".join(p_nodes)

        if use_global_prosody:
            # B·ªçc r·∫•t nh·∫π ƒë·ªÉ gi·∫£m c·∫£m gi√°c "g·∫•p" m√† v·∫´n t·ª± nhi√™n
            body = f'<prosody rate="{prosody_rate}" pitch="{prosody_pitch}">{body}</prosody>'

        return f"<speak>{body}</speak>"



# H√†m h√†nh ƒë·ªông: M·ªü th∆∞ m·ª•c t·∫°m c·ªßa ·ª©ng d·ª•ng PiuApp
    def dub_open_temp_folder(self):
        """M·ªü th∆∞ m·ª•c t·∫°m ch√≠nh c·ªßa Piu (self.temp_folder)."""
        # self.temp_folder ƒë√£ ƒë∆∞·ª£c t·∫°o trong __init__ c·ªßa PiuApp
        if hasattr(self, 'temp_folder') and self.temp_folder and os.path.isdir(self.temp_folder):
            try:
                abs_app_temp_dir = os.path.abspath(self.temp_folder)
                logging.info(f"[Dubbing] Y√™u c·∫ßu m·ªü th∆∞ m·ª•c t·∫°m: {abs_app_temp_dir}")
                
                # S·ª≠ d·ª•ng h√†m open_file_with_default_app ƒë√£ c√≥ c·ªßa PiuApp
                open_file_with_default_app(abs_app_temp_dir)
                self.update_status(f"ƒê√£ y√™u c·∫ßu m·ªü th∆∞ m·ª•c t·∫°m: {os.path.basename(abs_app_temp_dir)}")
            except Exception as e_open_folder:
                logging.error(f"[Dubbing] L·ªói khi m·ªü th∆∞ m·ª•c t·∫°m PiuApp: {e_open_folder}", exc_info=True)
                messagebox.showerror("L·ªói M·ªü Th∆∞ M·ª•c", f"Kh√¥ng th·ªÉ m·ªü th∆∞ m·ª•c t·∫°m.\nƒê∆∞·ªùng d·∫´n: {self.temp_folder}\nL·ªói: {e_open_folder}", parent=self)
                self.update_status(f"L·ªói khi m·ªü th∆∞ m·ª•c t·∫°m: {e_open_folder}")
        elif hasattr(self, 'temp_folder') and self.temp_folder == ".": # Tr∆∞·ªùng h·ª£p fallback c·ªßa PiuApp
             messagebox.showinfo("Th√¥ng tin Th∆∞ M·ª•c T·∫°m", f"Th∆∞ m·ª•c t·∫°m hi·ªán t·∫°i l√† th∆∞ m·ª•c ch·∫°y ch∆∞∆°ng tr√¨nh.\nƒê∆∞·ªùng d·∫´n: {os.path.abspath('.')}", parent=self)
        else:
            messagebox.showerror("L·ªói", "Th∆∞ m·ª•c t·∫°m c·ªßa ·ª©ng d·ª•ng ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p ho·∫∑c kh√¥ng t·ªìn t·∫°i.", parent=self)
            self.update_status("L·ªói: Th∆∞ m·ª•c t·∫°m PiuApp kh√¥ng t·ªìn t·∫°i ho·∫∑c ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p.")


# H√†m h√†nh ƒë·ªông: K√≠ch ho·∫°t t·∫°o v√† l∆∞u audio t·ª´ textbox c·ªßa tab Thuy·∫øt Minh
    def dub_trigger_generate_and_save_audio(self):
        text_to_speak = self.dub_script_textbox.get("1.0", "end-1c").strip()
        if not text_to_speak:
            messagebox.showinfo("Th√¥ng tin", "Kh√¥ng c√≥ vƒÉn b·∫£n n√†o trong √¥ k·ªãch b·∫£n ƒë·ªÉ t·∫°o audio.", parent=self)
            return
        selected_engine = self.dub_selected_tts_engine_var.get()
        
        default_extension = ".mp3"
        if selected_engine == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)":
            default_extension = ".wav"

        file_path_to_save = filedialog.asksaveasfilename(
            title="L∆∞u file audio thuy·∫øt minh",
            defaultextension=default_extension,
            filetypes=[("MP3 Audio", "*.mp3"), ("WAV Audio", "*.wav"), ("All files", "*.*")],
            parent=self
        )

        if not file_path_to_save:
            self.update_status("ƒê√£ h·ªßy l∆∞u file audio thuy·∫øt minh.")
            return

        self.save_current_config()

        # === ƒê·∫∂T C·ªú CHO T√ÅC V·ª§ ƒê∆†N L·∫∫ ===
        self.is_performing_single_task = True
        self.start_time = time.time() # B·∫Øt ƒë·∫ßu ƒë·∫øm gi·ªù cho t√°c v·ª• ƒë∆°n l·∫ª
        logging.info(f"[DubTriggerSave] ƒê·∫∑t is_performing_single_task = True, start_time ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")
        
        # C·∫≠p nh·∫≠t status v√† v√¥ hi·ªáu h√≥a n√∫t
        self.update_status(f"Thuy·∫øt minh ({selected_engine}): Chu·∫©n b·ªã l∆∞u audio...") # Th√¥ng b√°o ban ƒë·∫ßu
        if hasattr(self, 'dub_btn_save_audio_from_text') and self.dub_btn_save_audio_from_text:
            self.dub_btn_save_audio_from_text.configure(state="disabled", text="...") # ƒê·ªïi text ƒë·ªÉ r√µ h∆°n

        # K√≠ch ho·∫°t timer n·∫øu ch∆∞a ch·∫°y
        self.update_time_realtime() 

        thread = threading.Thread(target=self.dub_execute_generate_and_save_thread,
                                 args=(text_to_speak, selected_engine, file_path_to_save),
                                 daemon=True,
                                 name=f"DubSaveAudioThread_{selected_engine}")
        thread.start()



# H√†m lu·ªìng: Th·ª±c thi vi·ªác t·∫°o v√† l∆∞u audio t·ª´ textbox
    def dub_execute_generate_and_save_thread(self, full_text_to_speak_param, selected_engine, final_file_path_to_save): # [cite: 1, 54]
        worker_log_prefix = f"[{threading.current_thread().name}_DubSaveAudioThread_V9_FixNewlineAllStages]" # TƒÉng Version
        base_filename_for_status = os.path.basename(final_file_path_to_save)
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu. Engine: {selected_engine}, Output: {base_filename_for_status}")
        self.after(0, lambda: self.update_status(f"Thuy·∫øt minh ({selected_engine}): ƒêang x·ª≠ l√Ω '{base_filename_for_status[:25]}...'"))

        overall_success_final = False # [cite: 2, 55]
        final_status_message_for_ui = f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫°o '{base_filename_for_status}' v·ªõi {selected_engine}." # [cite: 2, 55]
        
        speak_function_for_chunks = None # [cite: 2, 56]
        if selected_engine == "OpenAI TTS": speak_function_for_chunks = self.dub_speak_with_openai
        elif selected_engine == "Google Cloud TTS": speak_function_for_chunks = self.dub_speak_with_google
        elif selected_engine == "Google Translate (gTTS)": speak_function_for_chunks = self.dub_speak_with_gtts
        elif selected_engine == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)":
            if HAS_PYTTSX3 and callable(getattr(self, 'dub_speak_with_system_tts', None)): # [cite: 3, 57]
                speak_function_for_chunks = self.dub_speak_with_system_tts
            else:
                final_status_message_for_ui = "L·ªói: Ch·ª©c nƒÉng Gi·ªçng ƒë·ªçc H·ªá th·ªëng (pyttsx3) ch∆∞a s·∫µn s√†ng." # [cite: 3, 57]
        
        successful_audio_chunk_paths = [] # [cite: 4, 58]
        temp_chunk_files_to_delete_overall = []  # [cite: 4, 58]

        try: 
            if not speak_function_for_chunks:
                # final_status_message_for_ui ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t n·∫øu l·ªói t·ª´ Gi·ªçng ƒë·ªçc H·ªá th·ªëng
                if not final_status_message_for_ui.startswith("L·ªói:"): 
                    final_status_message_for_ui = f"L·ªói: Kh√¥ng h·ªó tr·ª£ engine TTS '{selected_engine}'."
                raise RuntimeError(final_status_message_for_ui)

            # --- TR√çCH XU·∫§T V√Ä L√ÄM S·∫†CH VƒÇN B·∫¢N THU·∫¶N T√öY BAN ƒê·∫¶U ---
            plain_text_input_for_processing = "" # [cite: 5]
            if "-->" in full_text_to_speak_param and "\n" in full_text_to_speak_param: # [cite: 59]
                logging.info(f"{worker_log_prefix} ƒê·∫ßu v√†o c√≥ v·∫ª l√† SRT. Tr√≠ch xu·∫•t v√† l√†m s·∫°ch text thu·∫ßn t√∫y.")
                try:
                    subs = pysubs2.SSAFile.from_string(full_text_to_speak_param) # [cite: 6]
                    all_text_lines_from_srt = []
                    for event in subs:
                        if event.text and not event.is_comment: # [cite: 60]
                            # ***THAY ƒê·ªîI QUAN TR·ªåNG 1: L√†m s·∫°ch newline ngay khi tr√≠ch xu·∫•t t·ª´ pysubs2***
                            cleaned_event_text = event.text.replace('\\N', ' ').replace('\\n', ' ').replace('\r\n', ' ').replace('\n', ' ')
                            all_text_lines_from_srt.append(cleaned_event_text)
                    
                    plain_text_input_for_processing = ' '.join(line.strip() for line in all_text_lines_from_srt if line.strip()) # [cite: 7]
                    plain_text_input_for_processing = ' '.join(plain_text_input_for_processing.split()).strip() 
                    logging.info(f"{worker_log_prefix} ƒê√£ tr√≠ch xu·∫•t v√† l√†m s·∫°ch text t·ª´ SRT (d√†i {len(plain_text_input_for_processing)} chars): {repr(plain_text_input_for_processing[:100])}")
                except Exception as e_parse_srt_input:
                    logging.warning(f"{worker_log_prefix} L·ªói parse SRT input b·∫±ng pysubs2: {e_parse_srt_input}. D√πng input g·ªëc ƒë√£ l√†m s·∫°ch.") # [cite: 8, 61]
                    # ***THAY ƒê·ªîI QUAN TR·ªåNG 2: L√†m s·∫°ch input g·ªëc n·∫øu parse l·ªói***
                    plain_text_input_for_processing = full_text_to_speak_param.replace('\\N', ' ').replace('\\n', ' ').replace('\r\n', ' ').replace('\n', ' ') # [cite: 9]
                    plain_text_input_for_processing = ' '.join(plain_text_input_for_processing.split()).strip()
            else: # Input l√† plain text
                # ***THAY ƒê·ªîI QUAN TR·ªåNG 3: L√†m s·∫°ch plain text input***
                plain_text_input_for_processing = full_text_to_speak_param.replace('\\N', ' ').replace('\\n', ' ').replace('\r\n', ' ').replace('\n', ' ') # [cite: 10]
                plain_text_input_for_processing = ' '.join(plain_text_input_for_processing.split()).strip()
                logging.info(f"{worker_log_prefix} ƒê·∫ßu v√†o l√† plain text ƒë√£ l√†m s·∫°ch (d√†i {len(plain_text_input_for_processing)} chars): {repr(plain_text_input_for_processing[:100])}") # [cite: 11]

            if not plain_text_input_for_processing: 
                final_status_message_for_ui = "L·ªói: Kh√¥ng c√≥ vƒÉn b·∫£n thu·∫ßn t√∫y ƒë·ªÉ x·ª≠ l√Ω sau khi tr√≠ch xu·∫•t v√† l√†m s·∫°ch." # [cite: 62]
                raise ValueError(final_status_message_for_ui)

            # --- CHIA VƒÇN B·∫¢N ---
            language_hint_for_chunker = 'vi' # [cite: 12, 62]
            chunk_char_limit = 1800  # [cite: 12, 63]
            if selected_engine == "OpenAI TTS": chunk_char_limit = 4000 
            elif selected_engine == "Google Cloud TTS":
                if hasattr(self, 'dub_use_google_ssml_var') and self.dub_use_google_ssml_var.get(): chunk_char_limit = 1800  # [cite: 13]
                else: chunk_char_limit = 2200   # [cite: 13, 64]
            elif selected_engine == "Google Translate (gTTS)": chunk_char_limit = 2500 
            elif selected_engine == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)": chunk_char_limit = 3500 
            
            logging.info(f"{worker_log_prefix} G·ªçi _smart_text_chunker v·ªõi plain_text_input_for_processing (ƒë√£ l√†m s·∫°ch, d√†i {len(plain_text_input_for_processing)} chars). Max size: {chunk_char_limit} chars, Lang: '{language_hint_for_chunker}' cho {selected_engine}") # [cite: 14, 65]
            text_chunks = self._smart_text_chunker(plain_text_input_for_processing, 
                                                   max_chunk_size_chars=chunk_char_limit, 
                                                   language_hint=language_hint_for_chunker) # [cite: 15, 66]

            if text_chunks: # [cite: 16]
                logging.info(f"{worker_log_prefix} _smart_text_chunker ƒë√£ tr·∫£ v·ªÅ {len(text_chunks)} chunk(s). Chi ti·∫øt:") # [cite: 16]
                for idx_chunk, chunk_data in enumerate(text_chunks):
                    logging.info(f"{worker_log_prefix}   Chunk {idx_chunk + 1} (d√†i {len(chunk_data)} chars): {repr(chunk_data)}")
            else:
                logging.warning(f"{worker_log_prefix} _smart_text_chunker kh√¥ng tr·∫£ v·ªÅ chunk n√†o.") # [cite: 17]

            if not text_chunks:
                final_status_message_for_ui = "L·ªói: Kh√¥ng th·ªÉ chia vƒÉn b·∫£n th√†nh c√°c ƒëo·∫°n nh·ªè."
                raise ValueError(final_status_message_for_ui)

            num_chunks_created = len(text_chunks)
            logging.info(f"{worker_log_prefix} VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c _smart_text_chunker chia th√†nh {num_chunks_created} ƒëo·∫°n.") # [cite: 18]
            
            if num_chunks_created > 0:
                self.after(0, lambda eng=selected_engine, num_c=num_chunks_created: 
                          self.update_status(f"Thuy·∫øt minh ({eng}): ƒêang t·∫°o {num_c} ƒëo·∫°n audio...")) # [cite: 68]
            
            # --- D. L·∫∂P QUA T·ª™NG ƒêO·∫†N V√Ä T·∫†O AUDIO T·∫†M ---
            for i, chunk_text_content_from_chunker_loop_var in enumerate(text_chunks): # [cite: 19]
                if self.dub_stop_event.is_set():
                    final_status_message_for_ui = "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng khi t·∫°o ƒëo·∫°n audio." # [cite: 20, 69]
                    raise InterruptedError(final_status_message_for_ui) 

                chunk_log_prefix_loop = f"{worker_log_prefix} Chunk {i+1}/{num_chunks_created}:"
                
                # ***THAY ƒê·ªîI QUAN TR·ªåNG 4: L√†m s·∫°ch k·ªπ h∆°n cho t·ª´ng chunk M·ªòT L·∫¶N N·ªÆA***
                # ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o an to√†n n·∫øu _smart_text_chunker c√≥ th·ªÉ ƒë√£ th√™m l·∫°i \n
                text_content_cleaned_for_tts = chunk_text_content_from_chunker_loop_var 
                original_chunk_repr_for_final_clean = repr(text_content_cleaned_for_tts) # [cite: 21]

                text_content_cleaned_for_tts = text_content_cleaned_for_tts.replace('\\N', ' ').replace('\\n', ' ')
                text_content_cleaned_for_tts = text_content_cleaned_for_tts.replace('\r\n', '\n').replace('\n', ' ')
                text_content_cleaned_for_tts = ' '.join(text_content_cleaned_for_tts.split()).strip()
                
                if original_chunk_repr_for_final_clean != repr(text_content_cleaned_for_tts):
                    logging.info(f"{chunk_log_prefix_loop} ƒê√£ l√†m s·∫°ch (L·∫¶N 2 - AN TO√ÄN) cho CHUNK. G·ªëc: {original_chunk_repr_for_final_clean}, S·∫°ch: {repr(text_content_cleaned_for_tts)}")
                # =======================================================================
                
                if not text_content_cleaned_for_tts: # [cite: 25]
                    logging.warning(f"{chunk_log_prefix_loop} Chunk r·ªóng sau khi l√†m s·∫°ch l·∫ßn 2. B·ªè qua.") # [cite: 26]
                    continue

                logging.info(f"{chunk_log_prefix_loop} B·∫Øt ƒë·∫ßu. Text (d√†i {len(text_content_cleaned_for_tts)} chars): {repr(text_content_cleaned_for_tts[:60])}")
                
                chunk_file_extension = ".mp3" # [cite: 27, 70]
                if selected_engine == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)": chunk_file_extension = ".wav" # [cite: 27]
                temp_chunk_filename_loop = f"dub_tts_chunk_{i}_{uuid.uuid4().hex[:6]}{chunk_file_extension}"
                temp_chunk_filepath_loop = os.path.join(self.temp_folder, temp_chunk_filename_loop)
                temp_chunk_files_to_delete_overall.append(temp_chunk_filepath_loop)

                _text_for_engine_call = text_content_cleaned_for_tts # [cite: 71]
                
                if selected_engine == "Google Cloud TTS" and \
                   hasattr(self, 'dub_use_google_ssml_var') and self.dub_use_google_ssml_var.get() and \
                   not (_text_for_engine_call.strip().lower().startswith("<speak>") and _text_for_engine_call.strip().lower().endswith("</speak>")): # [cite: 28]
                    _text_for_engine_call = self.dub_generate_basic_ssml(_text_for_engine_call) # [cite: 29, 30, 72]
                
                logging.info(f"{chunk_log_prefix_loop} Payload cu·ªëi cho API (d√†i {len(_text_for_engine_call)}): {repr(_text_for_engine_call[:70])}")

                chunk_generation_result = speak_function_for_chunks(
                    _text_for_engine_call, 
                    temp_chunk_filepath_loop, # [cite: 31]
                    is_preview=False # [cite: 73]
                )
                
                if isinstance(chunk_generation_result, str) and "ERROR_" in chunk_generation_result: # [cite: 32]
                    final_status_message_for_ui = f"L·ªói API ({chunk_generation_result}) khi x·ª≠ l√Ω ƒëo·∫°n {i+1}." # [cite: 32]
                    logging.error(f"{chunk_log_prefix_loop} {final_status_message_for_ui}") # [cite: 33]
                    if "API_KEY" in chunk_generation_result.upper() or "SDK_MISSING" in chunk_generation_result or \
                       "AUTHENTICATION" in chunk_generation_result or "GOOGLE_KEY_FILE" in chunk_generation_result.upper():
                        self.dub_batch_had_api_key_errors = True
                    raise RuntimeError(final_status_message_for_ui) # [cite: 34, 75]
                
                if not chunk_generation_result:
                    final_status_message_for_ui = f"L·ªói t·∫°o audio cho ƒëo·∫°n {i+1} (sau retries)." # [cite: 35]
                    logging.error(f"{chunk_log_prefix_loop} {final_status_message_for_ui}") # [cite: 35, 76]
                    raise RuntimeError(final_status_message_for_ui) 
                
                successful_audio_chunk_paths.append(temp_chunk_filepath_loop)
                logging.info(f"{chunk_log_prefix_loop} T·∫°o audio chunk th√†nh c√¥ng: {os.path.basename(temp_chunk_filepath_loop)}")
            
            # --- E. GH√âP FILE HO·∫∂C DI CHUY·ªÇN FILE ---
            if not successful_audio_chunk_paths: # [cite: 36]
                final_status_message_for_ui = "Kh√¥ng c√≥ ƒëo·∫°n audio n√†o ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng." # [cite: 37]
                raise ValueError(final_status_message_for_ui) # [cite: 37, 78]
            
            elif len(successful_audio_chunk_paths) == 1:
                single_chunk_to_save = successful_audio_chunk_paths[0]
                self.after(0, lambda: self.update_status(f"Thuy·∫øt minh ({selected_engine}): Ho√†n t·∫•t, ƒëang l∆∞u file..."))
                logging.info(f"{worker_log_prefix} Ch·ªâ c√≥ 1 chunk. Di chuy·ªÉn: {os.path.basename(single_chunk_to_save)}") # [cite: 38, 79]
                try:
                    final_output_dir_s = os.path.dirname(final_file_path_to_save)
                    if not os.path.exists(final_output_dir_s): os.makedirs(final_output_dir_s, exist_ok=True) # [cite: 38, 80]
                    if os.path.exists(final_file_path_to_save): os.remove(final_file_path_to_save)
                    shutil.move(single_chunk_to_save, final_file_path_to_save)
                    if single_chunk_to_save in temp_chunk_files_to_delete_overall: # [cite: 39]
                        temp_chunk_files_to_delete_overall.remove(single_chunk_to_save)
                    overall_success_final = True # [cite: 39, 81]
                    final_status_message_for_ui = f"ƒê√£ l∆∞u audio: {os.path.basename(final_file_path_to_save)}" # [cite: 81]
                except Exception as e_move:
                    final_status_message_for_ui = f"L·ªói di chuy·ªÉn file audio: {e_move}" # [cite: 40, 82]
                    logging.error(f"{worker_log_prefix} {final_status_message_for_ui}", exc_info=True) # [cite: 40, 82]
            
            elif len(successful_audio_chunk_paths) > 1:
                num_successful_chunks = len(successful_audio_chunk_paths) # [cite: 41]
                logging.info(f"{worker_log_prefix} C√≥ {num_successful_chunks} chunks. B·∫Øt ƒë·∫ßu gh√©p...") # [cite: 42, 83]
                self.after(0, lambda num_s_chunks=num_successful_chunks, eng=selected_engine: 
                           self.update_status(f"Thuy·∫øt minh ({eng}): ƒêang gh√©p {num_s_chunks} ƒëo·∫°n audio..."))
                
                concat_success = self._dub_ffmpeg_concatenate_audio_chunks( # [cite: 43, 84]
                    successful_audio_chunk_paths,
                    final_file_path_to_save
                )
                if concat_success:
                    overall_success_final = True # [cite: 44, 85]
                    final_status_message_for_ui = f"ƒê√£ l∆∞u audio (gh√©p {num_successful_chunks} ƒëo·∫°n): {os.path.basename(final_file_path_to_save)}" # [cite: 44, 85]
                else:
                    final_status_message_for_ui = "L·ªói khi gh√©p c√°c ƒëo·∫°n audio."
            
        except InterruptedError as ie:  # [cite: 45, 86]
            logging.info(f"{worker_log_prefix} X·ª≠ l√Ω b·ªã d·ª´ng: {ie}") # [cite: 86]
            if not final_status_message_for_ui.startswith("ƒê√£ d·ª´ng"): # [cite: 45]
                 final_status_message_for_ui = "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng."
        except (RuntimeError, ValueError) as e_flow: 
            logging.error(f"{worker_log_prefix} L·ªói lu·ªìng: {e_flow}")
            if not final_status_message_for_ui.startswith("L·ªói"):  # [cite: 46, 87]
                 final_status_message_for_ui = f"L·ªói x·ª≠ l√Ω: {str(e_flow)[:120]}" # [cite: 46, 87]
        except Exception as e_general_thread: 
            final_status_message_for_ui = f"L·ªói kh√¥ng mong mu·ªën: {type(e_general_thread).__name__} - {str(e_general_thread)[:100]}"
            logging.critical(f"{worker_log_prefix} {final_status_message_for_ui}", exc_info=True)
        finally:
            if hasattr(self, 'is_performing_single_task'): # [cite: 47, 88]
                self.is_performing_single_task = False
                self.start_time = None  # [cite: 47]
                logging.info(f"{worker_log_prefix} Reset is_performing_single_task = False v√† start_time = None trong finally.") # [cite: 47]

            if 'temp_chunk_files_to_delete_overall' in locals() and temp_chunk_files_to_delete_overall: # [cite: 48, 89]
                logging.info(f"{worker_log_prefix} D·ªçn d·∫πp {len(temp_chunk_files_to_delete_overall)} file chunk t·∫°m...") # [cite: 89]
                for temp_file_path_to_remove_final in temp_chunk_files_to_delete_overall:
                    if os.path.exists(temp_file_path_to_remove_final): # [cite: 48]
                        try:
                            os.remove(temp_file_path_to_remove_final) # [cite: 49, 90]
                            logging.debug(f"{worker_log_prefix}   ƒê√£ x√≥a: {os.path.basename(temp_file_path_to_remove_final)}")
                        except Exception as e_del_final_chunk: # [cite: 49, 91]
                            logging.warning(f"{worker_log_prefix}   L·ªói x√≥a file chunk t·∫°m '{os.path.basename(temp_file_path_to_remove_final)}': {e_del_final_chunk}") # [cite: 49, 91]
            
            if overall_success_final and not self.dub_stop_event.is_set(): # [cite: 50]
                final_msg_for_popup = f"{final_status_message_for_ui}\nƒê√£ l∆∞u t·∫°i:\n{final_file_path_to_save}" # [cite: 50]
                self.after(0, lambda p=final_file_path_to_save, msg=final_msg_for_popup:  # [cite: 50, 92]
                           messagebox.showinfo("Ho√†n th√†nh", msg, parent=self)) # [cite: 50, 92]
                self.after(0, lambda: self.update_status(f"‚úÖ ƒê√£ l∆∞u audio thuy·∫øt minh: {base_filename_for_status[:25]}...")) # [cite: 92]
            elif not self.dub_stop_event.is_set() and not overall_success_final :  # [cite: 51, 93]
                self.after(0, lambda msg=final_status_message_for_ui: # [cite: 51, 93]
                            messagebox.showerror("L·ªói T·∫°o Audio Thuy·∫øt Minh", f"Qu√° tr√¨nh t·∫°o audio g·∫∑p l·ªói:\n{msg}", parent=self)) # [cite: 51, 93]
                self.after(0, lambda: self.update_status(f"‚ùå L·ªói t·∫°o audio: {final_status_message_for_ui[:50]}...")) # [cite: 93]
            elif self.dub_stop_event.is_set():  # [cite: 52, 94]
                 self.after(0, lambda: self.update_status(f"üõë T·∫°o audio '{base_filename_for_status[:25]}...' ƒë√£ d·ª´ng.")) # [cite: 52, 94]
            
            if hasattr(self, 'dub_btn_save_audio_from_text') and self.dub_btn_save_audio_from_text.winfo_exists():
                self.after(0, lambda: self.dub_btn_save_audio_from_text.configure(state="normal", text="üíæ L∆∞u Audio"))
            
            logging.info(f"{worker_log_prefix} K·∫øt th√∫c lu·ªìng. Overall Success: {overall_success_final}, Stop Event: {self.dub_stop_event.is_set()}, Final Message UI: {final_status_message_for_ui}") # [cite: 53, 95]



# --- H√ÄM CHIA VƒÇN B·∫¢N TH√îNG MINH CHO TTS CH·ª®C NƒÇNG L∆ØU AUDIO---
    def _smart_text_chunker(self, text_to_chunk, max_chunk_size_chars=3800, language_hint='vi'):
        """
        Chia vƒÉn b·∫£n th√†nh c√°c ƒëo·∫°n nh·ªè h∆°n, ∆∞u ti√™n ng·∫Øt t·∫°i d·∫•u c√¢u ho·∫∑c ƒëo·∫°n vƒÉn.
        max_chunk_size_chars: Gi·ªõi h·∫°n k√Ω t·ª± g·∫ßn ƒë√∫ng cho m·ªói ƒëo·∫°n.
        language_hint: G·ª£i √Ω ng√¥n ng·ªØ ƒë·ªÉ c√≥ th·ªÉ d√πng sent_tokenize cho ti·∫øng Vi·ªát.
        """
        worker_log_prefix = f"[{threading.current_thread().name}_SmartChunker]"
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu chia vƒÉn b·∫£n (d√†i {len(text_to_chunk)} chars) v·ªõi max_chunk_size={max_chunk_size_chars}, lang_hint='{language_hint}'")
        
        chunks = []
        if not text_to_chunk or not text_to_chunk.strip():
            logging.warning(f"{worker_log_prefix} VƒÉn b·∫£n ƒë·∫ßu v√†o r·ªóng ho·∫∑c ch·ªâ ch·ª©a kho·∫£ng tr·∫Øng.")
            return chunks

        current_position = 0
        text_length = len(text_to_chunk)

        # 1. X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho Ti·∫øng Vi·ªát v·ªõi underthesea
        if language_hint == 'vi' and self.HAS_UNDERTHEESEA_LIB and callable(sent_tokenize): # S·ª≠ d·ª•ng self.HAS_UNDERTHEESEA_LIB
            logging.debug(f"{worker_log_prefix} S·ª≠ d·ª•ng underthesea.sent_tokenize cho ti·∫øng Vi·ªát.")
            try:
                sentences = sent_tokenize(text_to_chunk)
                current_chunk_buffer = ""
                for i, sentence in enumerate(sentences):
                    sentence_stripped = sentence.strip()
                    if not sentence_stripped:
                        continue
                    
                    # N·∫øu th√™m c√¢u n√†y s·∫Ω v∆∞·ª£t qu√° gi·ªõi h·∫°n HO·∫∂C n·∫øu buffer ƒë√£ c√≥ n·ªôi dung v√† c√¢u n√†y l√†m buffer qu√° d√†i
                    if (current_chunk_buffer and len(current_chunk_buffer) + len(sentence_stripped) + 1 > max_chunk_size_chars) or \
                       (not current_chunk_buffer and len(sentence_stripped) > max_chunk_size_chars):
                        
                        if current_chunk_buffer: # Th√™m buffer hi·ªán t·∫°i v√†o chunks n·∫øu c√≥
                            chunks.append(current_chunk_buffer)
                            logging.debug(f"{worker_log_prefix}   ƒê√£ th√™m chunk (sent_tokenize, buffer ƒë·∫ßy): '{current_chunk_buffer[:60].replace(chr(10),' ')}...' ({len(current_chunk_buffer)} chars)")
                            current_chunk_buffer = "" 
                        
                        # N·∫øu c√¢u hi·ªán t·∫°i t·ª± n√≥ ƒë√£ d√†i h∆°n max_chunk_size, ph·∫£i c·∫Øt c·ª©ng c√¢u n√†y
                        if len(sentence_stripped) > max_chunk_size_chars:
                            logging.warning(f"{worker_log_prefix}   C√¢u t·ª´ sent_tokenize qu√° d√†i ({len(sentence_stripped)} chars), s·∫Ω c·∫Øt c·ª©ng: '{sentence_stripped[:60].replace(chr(10),' ')}...'")
                            temp_pos_in_long_sentence = 0
                            while temp_pos_in_long_sentence < len(sentence_stripped):
                                sub_sentence_chunk = sentence_stripped[temp_pos_in_long_sentence : temp_pos_in_long_sentence + max_chunk_size_chars]
                                chunks.append(sub_sentence_chunk)
                                logging.debug(f"{worker_log_prefix}     ƒê√£ th√™m sub-chunk t·ª´ c√¢u d√†i (sent_tokenize): '{sub_sentence_chunk[:60].replace(chr(10),' ')}...' ({len(sub_sentence_chunk)} chars)")
                                temp_pos_in_long_sentence += len(sub_sentence_chunk)
                            continue # Chuy·ªÉn sang c√¢u ti·∫øp theo sau khi ƒë√£ x·ª≠ l√Ω c√¢u d√†i n√†y
                        else: # C√¢u hi·ªán t·∫°i kh√¥ng qu√° d√†i, b·∫Øt ƒë·∫ßu chunk m·ªõi v·ªõi n√≥
                            current_chunk_buffer = sentence_stripped
                    else: # Th√™m c√¢u n√†y v√†o buffer hi·ªán t·∫°i
                        if current_chunk_buffer:
                            current_chunk_buffer += " " + sentence_stripped
                        else:
                            current_chunk_buffer = sentence_stripped
                
                if current_chunk_buffer: # Th√™m buffer cu·ªëi c√πng n·∫øu c√≤n
                    chunks.append(current_chunk_buffer)
                    logging.debug(f"{worker_log_prefix}   ƒê√£ th√™m chunk cu·ªëi (sent_tokenize): '{current_chunk_buffer[:60].replace(chr(10),' ')}...' ({len(current_chunk_buffer)} chars)")
                
                if chunks:
                    logging.info(f"{worker_log_prefix} Chia xong b·∫±ng sent_tokenize, t·∫°o ra {len(chunks)} chunks.")
                    return chunks
                else:
                    logging.warning(f"{worker_log_prefix} sent_tokenize kh√¥ng t·∫°o ƒë∆∞·ª£c chunk n√†o (m·∫∑c d√π text kh√¥ng r·ªóng). Fallback v·ªÅ logic m·∫∑c ƒë·ªãnh.")
            except Exception as e_uts_chunk:
                logging.error(f"{worker_log_prefix} L·ªói khi d√πng sent_tokenize: {e_uts_chunk}. Fallback v·ªÅ logic m·∫∑c ƒë·ªãnh.")
        
        # 2. Logic fallback (ho·∫∑c cho c√°c ng√¥n ng·ªØ kh√°c kh√¥ng ph·∫£i Ti·∫øng Vi·ªát / khi underthesea l·ªói)
        logging.debug(f"{worker_log_prefix} S·ª≠ d·ª•ng logic chia theo d·∫•u c√¢u/ƒëo·∫°n vƒÉn/c·∫Øt c·ª©ng m·∫∑c ƒë·ªãnh.")
        sentence_delimiters = ['.', '?', '!', '„ÄÇ', 'Ôºü', 'ÔºÅ', ';', '‚Ä¶'] # D·∫•u ch·∫•m l·ª≠ng c≈©ng l√† m·ªôt ƒëi·ªÉm ng·∫Øt t·ªët
        paragraph_delimiters = ["\n\n", "\r\n\r\n"] # Ng·∫Øt ƒëo·∫°n (2 l·∫ßn xu·ªëng d√≤ng)
        single_line_break = "\n" # Ng·∫Øt d√≤ng ƒë∆°n

        while current_position < text_length:
            potential_end_position = min(current_position + max_chunk_size_chars, text_length)
            actual_split_point = potential_end_position # M·∫∑c ƒë·ªãnh l√† c·∫Øt c·ª©ng

            # ∆Øu ti√™n t√¨m ƒëi·ªÉm ng·∫Øt t·ª± nhi√™n g·∫ßn nh·∫•t *tr∆∞·ªõc* potential_end_position
            # T√¨m t·ª´ ph·∫£i sang tr√°i trong kho·∫£ng [current_position, potential_end_position]
            
            best_natural_split_point = -1

            # A. T√¨m ng·∫Øt ƒëo·∫°n (hai l·∫ßn xu·ªëng d√≤ng)
            for para_delim in paragraph_delimiters:
                last_para_break = text_to_chunk.rfind(para_delim, current_position, potential_end_position)
                if last_para_break != -1 and last_para_break > current_position : # Ph·∫£i th·ª±c s·ª± n·∫±m trong kho·∫£ng
                    best_natural_split_point = max(best_natural_split_point, last_para_break + len(para_delim))
            
            # B. T√¨m ng·∫Øt c√¢u (n·∫øu kh√¥ng c√≥ ng·∫Øt ƒëo·∫°n ho·∫∑c ng·∫Øt ƒëo·∫°n ·ªü qu√° xa)
            # Ch·ªâ t√¨m d·∫•u c√¢u n·∫øu kh√¥ng c√≥ ng·∫Øt ƒëo·∫°n t·ªët ho·∫∑c ng·∫Øt ƒëo·∫°n ·ªü qu√° g·∫ßn ƒë·∫ßu chunk hi·ªán t·∫°i
            # (v√≠ d·ª•: n·∫øu ng·∫Øt ƒëo·∫°n l√†m chunk qu√° ng·∫Øn, th·ª≠ t√¨m d·∫•u c√¢u xa h∆°n)
            if best_natural_split_point == -1 or best_natural_split_point < current_position + (max_chunk_size_chars // 4): # N·∫øu ng·∫Øt ƒëo·∫°n qu√° g·∫ßn (1/4 chunk)
                search_for_sentence_end_from = max(current_position, potential_end_position - 500) # T√¨m trong 500 k√Ω t·ª± cu·ªëi
                slice_to_search_sentence = text_to_chunk[search_for_sentence_end_from:potential_end_position]
                
                temp_sentence_split_point = -1
                for i_char_slice in range(len(slice_to_search_sentence) - 1, -1, -1):
                    char_in_slice = slice_to_search_sentence[i_char_slice]
                    if char_in_slice in sentence_delimiters:
                        # Ki·ªÉm tra k√Ω t·ª± ti·∫øp theo (n·∫øu c√≥) ƒë·ªÉ tr√°nh c·∫Øt sai v√≠ d·ª• "Mr."
                        idx_after_delimiter_in_slice = i_char_slice + 1
                        if idx_after_delimiter_in_slice < len(slice_to_search_sentence):
                            char_after_delimiter = slice_to_search_sentence[idx_after_delimiter_in_slice]
                            if char_after_delimiter.isspace() or char_after_delimiter in ['"', "'", '‚Äù', '‚Äô', ')', ']']:
                                temp_sentence_split_point = search_for_sentence_end_from + i_char_slice + 1
                                break
                        else: # D·∫•u c√¢u l√† k√Ω t·ª± cu·ªëi c√πng c·ªßa slice
                            temp_sentence_split_point = search_for_sentence_end_from + i_char_slice + 1
                            break
                if temp_sentence_split_point > current_position:
                     best_natural_split_point = max(best_natural_split_point, temp_sentence_split_point)


            # C. T√¨m ng·∫Øt d√≤ng ƒë∆°n (n·∫øu kh√¥ng c√≥ ng·∫Øt ƒëo·∫°n/c√¢u t·ªët)
            if best_natural_split_point == -1 or best_natural_split_point < current_position + (max_chunk_size_chars // 3):
                last_single_break = text_to_chunk.rfind(single_line_break, current_position, potential_end_position)
                if last_single_break != -1 and last_single_break > current_position:
                    best_natural_split_point = max(best_natural_split_point, last_single_break + len(single_line_break))

            if best_natural_split_point != -1 and best_natural_split_point > current_position: # ƒê·∫£m b·∫£o ƒëi·ªÉm ng·∫Øt h·ª£p l·ªá
                actual_split_point = best_natural_split_point
                logging.debug(f"{worker_log_prefix}   T√¨m th·∫•y ƒëi·ªÉm ng·∫Øt t·ª± nhi√™n t·∫°i v·ªã tr√≠ {actual_split_point}.")
            else:
                logging.debug(f"{worker_log_prefix}   Kh√¥ng t√¨m th·∫•y ƒëi·ªÉm ng·∫Øt t·ª± nhi√™n ph√π h·ª£p. S·∫Ω c·∫Øt c·ª©ng t·∫°i {actual_split_point} (potential_end_position).")

            chunk = text_to_chunk[current_position:actual_split_point].strip()
            if chunk: # Ch·ªâ th√™m n·∫øu chunk c√≥ n·ªôi dung
                chunks.append(chunk)
                logging.debug(f"{worker_log_prefix}     ƒê√£ th√™m chunk (logic fallback): '{chunk[:60].replace(chr(10),' ')}...' (D√†i: {len(chunk)} chars)")
            
            current_position = actual_split_point
            # Tr√°nh v√≤ng l·∫∑p v√¥ h·∫°n n·∫øu actual_split_point kh√¥ng ti·∫øn l√™n (v√≠ d·ª• do to√†n k√Ω t·ª± ƒë·∫∑c bi·ªát)
            if current_position >= text_length and not chunk: # N·∫øu ƒë√£ ƒë·∫øn cu·ªëi m√† chunk cu·ªëi r·ªóng
                break
            if current_position == text_length and chunk: # N·∫øu chunk cu·ªëi c√πng v·ª´a ƒë∆∞·ª£c th√™m v√† ch·∫°m ƒë·∫øn cu·ªëi text
                break
            if current_position < text_length and not chunk and actual_split_point == potential_end_position:
                # N·∫øu c·∫Øt c·ª©ng m√† ra chunk r·ªóng, c√≥ th·ªÉ l√† do ƒëo·∫°n cu·ªëi to√†n kho·∫£ng tr·∫Øng
                # ho·∫∑c m√£ l·ªói logic, n√™n tho√°t ƒë·ªÉ tr√°nh l·∫∑p v√¥ h·∫°n
                logging.warning(f"{worker_log_prefix} Ph√°t hi·ªán chunk r·ªóng sau khi c·∫Øt c·ª©ng v√† ch∆∞a h·∫øt text. D·ª´ng chia ƒë·ªÉ tr√°nh l·ªói.")
                break


        # ƒê·∫£m b·∫£o n·∫øu text g·ªëc c√≥ n·ªôi dung m√† chunks l·∫°i r·ªóng th√¨ th√™m to√†n b·ªô text l√†m 1 chunk (fallback cu·ªëi)
        if not chunks and text_to_chunk.strip():
             chunks.append(text_to_chunk.strip())
             logging.warning(f"{worker_log_prefix} Sau t·∫•t c·∫£ c√°c b∆∞·ªõc, kh√¥ng chia ƒë∆∞·ª£c chunk n√†o nh∆∞ng text g·ªëc c√≥ n·ªôi dung. Th√™m to√†n b·ªô text l√†m 1 chunk.")
        
        logging.info(f"{worker_log_prefix} Chia xong (logic fallback/ng√¥n ng·ªØ kh√°c), t·∫°o ra {len(chunks)} chunks.")
        return chunks


# H√†m gh√©p audio cho ch·ª©c nƒÉng t·∫°o audio d√†i
    def _dub_ffmpeg_concatenate_audio_chunks(self, audio_chunk_files, final_output_path):
        """
        Gh√©p m·ªôt danh s√°ch c√°c file audio chunk th√†nh m·ªôt file audio duy nh·∫•t.
        S·ª≠ d·ª•ng FFmpeg concat filter.
        """
        worker_log_prefix = f"[{threading.current_thread().name}_FFmpegConcatChunks_V2]" # Th√™m V2
        logging.info(f"{worker_log_prefix} B·∫Øt ƒë·∫ßu gh√©p {len(audio_chunk_files)} file(s) audio v√†o '{os.path.basename(final_output_path)}'")

        if not audio_chunk_files:
            logging.error(f"{worker_log_prefix} Kh√¥ng c√≥ file audio chunk n√†o ƒë·ªÉ gh√©p.")
            return False

        ffmpeg_executable = find_ffmpeg() # H√†m find_ffmpeg() to√†n c·ª•c c·ªßa b·∫°n
        if not ffmpeg_executable:
            logging.error(f"{worker_log_prefix} Kh√¥ng t√¨m th·∫•y FFmpeg. Kh√¥ng th·ªÉ gh√©p audio chunks.")
            # C√¢n nh·∫Øc self.after(0, lambda: messagebox.showerror(...)) n·∫øu ƒë√¢y l√† l·ªói th∆∞·ªùng g·∫∑p
            return False

        if self.dub_stop_event.is_set(): # Ki·ªÉm tra c·ªù d·ª´ng
            logging.info(f"{worker_log_prefix} Y√™u c·∫ßu d·ª´ng ƒë∆∞·ª£c ph√°t hi·ªán tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu gh√©p chunks.")
            return False

        # T·∫°o c√°c ph·∫ßn c·ªßa l·ªánh FFmpeg
        inputs_cmd_part = []
        filter_complex_audio_streams_part = ""
        
        valid_chunks_for_concat = []
        for i, chunk_path in enumerate(audio_chunk_files):
            if not os.path.exists(chunk_path) or os.path.getsize(chunk_path) == 0:
                logging.warning(f"{worker_log_prefix} File chunk '{os.path.basename(chunk_path)}' kh√¥ng t·ªìn t·∫°i ho·∫∑c r·ªóng. B·ªè qua chunk n√†y.")
                continue
            
            # S·ª≠ d·ª•ng Path().as_posix() cho ƒë∆∞·ªùng d·∫´n an to√†n v·ªõi FFmpeg tr√™n m·ªçi HƒêH
            safe_chunk_path_ffmpeg = Path(os.path.abspath(chunk_path)).as_posix()
            inputs_cmd_part.extend(["-i", safe_chunk_path_ffmpeg])
            filter_complex_audio_streams_part += f"[{len(valid_chunks_for_concat)}:a:0?]" # Index d·ª±a tr√™n s·ªë l∆∞·ª£ng valid_chunks
            valid_chunks_for_concat.append(chunk_path)

        if not valid_chunks_for_concat: # N·∫øu kh√¥ng c√≤n chunk n√†o h·ª£p l·ªá
            logging.error(f"{worker_log_prefix} Kh√¥ng c√≥ file chunk h·ª£p l·ªá n√†o sau khi ki·ªÉm tra. Kh√¥ng th·ªÉ gh√©p.")
            return False
        
        num_valid_chunks_to_concat = len(valid_chunks_for_concat)

        # X√¢y d·ª±ng filter_complex cho concat
        filter_complex_concat_str = f"{filter_complex_audio_streams_part}concat=n={num_valid_chunks_to_concat}:v=0:a=1[a_out]"
        
        command_concat = [ffmpeg_executable, "-y"] # Lu√¥n ghi ƒë√® output
        command_concat.extend(inputs_cmd_part) 
        command_concat.extend([
            "-filter_complex", filter_complex_concat_str,
            "-map", "[a_out]", 
        ])

        output_ext_concat = os.path.splitext(final_output_path)[1].lower()
        if output_ext_concat == ".mp3":
            command_concat.extend(["-c:a", "libmp3lame", "-q:a", str(self.dub_DEFAULT_MP3_QUALITY)])
        elif output_ext_concat == ".wav":
            command_concat.extend(["-c:a", self.dub_DEFAULT_WAV_CODEC, 
                                   "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE), 
                                   "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS)])
        elif output_ext_concat == ".aac":
             command_concat.extend(["-c:a", "aac", "-b:a", self.dub_DEFAULT_AUDIO_BITRATE_AAC])
        else: 
            logging.warning(f"{worker_log_prefix} ƒê·ªãnh d·∫°ng output '{output_ext_concat}' kh√¥ng r√µ codec, th·ª≠ copy (c√≥ th·ªÉ l·ªói).")
            command_concat.extend(["-c:a", "copy"]) 
        
        command_concat.append(os.path.abspath(final_output_path))

        logging.info(f"{worker_log_prefix} L·ªánh FFmpeg gh√©p {num_valid_chunks_to_concat} chunk(s): {' '.join(command_concat)}")
        
        process_concat_run = None
        try:
            creation_flags_concat = subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            process_concat_run = subprocess.Popen(command_concat, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=creation_flags_concat)
            if hasattr(self, 'dub_current_ffmpeg_process'): # Qu·∫£n l√Ω ti·∫øn tr√¨nh
                 self.dub_current_ffmpeg_process = process_concat_run

            _, stderr_concat_bytes = process_concat_run.communicate(timeout=300) 
            return_code_concat = process_concat_run.returncode

            if self.dub_stop_event.is_set():
                logging.info(f"{worker_log_prefix} Gh√©p audio chunks b·ªã h·ªßy trong khi FFmpeg ch·∫°y.")
                if process_concat_run.poll() is None: process_concat_run.terminate()
                return False

            if return_code_concat != 0:
                error_output_concat = stderr_concat_bytes.decode('utf-8', 'ignore') if stderr_concat_bytes else "Kh√¥ng c√≥ stderr."
                logging.error(f"{worker_log_prefix} L·ªói FFmpeg khi gh√©p (Code: {return_code_concat}). STDERR: {error_output_concat[:500]}")
                return False
            
            if not os.path.exists(final_output_path) or os.path.getsize(final_output_path) == 0:
                logging.error(f"{worker_log_prefix} L·ªói gh√©p: File output '{os.path.basename(final_output_path)}' kh√¥ng ƒë∆∞·ª£c t·∫°o ho·∫∑c r·ªóng.")
                return False
                
            logging.info(f"{worker_log_prefix} Gh√©p audio chunks th√†nh c√¥ng: {os.path.basename(final_output_path)}")
            return True

        except subprocess.TimeoutExpired:
            logging.error(f"{worker_log_prefix} Timeout khi gh√©p audio chunks.")
            if process_concat_run and process_concat_run.poll() is None: process_concat_run.kill()
            return False
        except Exception as e_general_concat:
            logging.error(f"{worker_log_prefix} L·ªói kh√¥ng mong mu·ªën khi gh√©p audio chunks: {e_general_concat}", exc_info=True)
            if process_concat_run and process_concat_run.poll() is None: process_concat_run.kill()
            return False
        finally:
            if hasattr(self, 'dub_current_ffmpeg_process') and self.dub_current_ffmpeg_process is process_concat_run:
                 self.dub_current_ffmpeg_process = None
                 logging.debug(f"{worker_log_prefix} ƒê√£ reset dub_current_ffmpeg_process (concat_chunks).")



# H√†m s·ª± ki·ªán: X·ª≠ l√Ω khi t√πy ch·ªçn √¢m thanh n·ªÅn video cho thuy·∫øt minh thay ƒë·ªïi
    def dub_on_background_audio_option_changed(self, selected_option, update_status=True): # Th√™m update_status=True
        """
        (PHI√äN B·∫¢N 6.0 - HO√ÄN CH·ªàNH CU·ªêI C√ôNG)
        Qu·∫£n l√Ω hi·ªÉn th·ªã t·∫•t c·∫£ c√°c control √¢m thanh n·ªÅn, bao g·ªìm c·∫£ √Çm l∆∞·ª£ng.
        """
        logging.info(f"[DubAudioOptionChanged_v6_Final] Selected: {selected_option}")

        # L·∫•y tham chi·∫øu t·ªõi c√°c frame v√† widget quan tr·ªçng t·ª´ dubbing_view_frame
        dubbing_tab = getattr(self, 'dubbing_view_frame', None)
        if not dubbing_tab:
            return
        parent_options_frame = getattr(dubbing_tab, 'dub_audio_output_options_frame', None)
        mix_level_frame = getattr(dubbing_tab, 'dub_mix_level_controls_frame', None)
        custom_bgm_main_frame = getattr(dubbing_tab, 'dub_custom_bg_music_frame', None)
        
        if not all(widget and widget.winfo_exists() for widget in [parent_options_frame, mix_level_frame, custom_bgm_main_frame]):
            logging.error("[DubAudioOptionChanged_v6_Final] M·ªôt trong c√°c frame ch√≠nh ch∆∞a ƒë∆∞·ª£c t·∫°o.")
            return

        # 1. Lu√¥n ·∫©n c√°c frame chi ti·∫øt tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh
        if mix_level_frame.winfo_ismapped():
            mix_level_frame.pack_forget()
        if custom_bgm_main_frame.winfo_ismapped():
            custom_bgm_main_frame.pack_forget()
        
        # 2. Quy·∫øt ƒë·ªãnh hi·ªÉn th·ªã frame n√†o d·ª±a tr√™n l·ª±a ch·ªçn menu ch√≠nh
        background_audio_menu = getattr(dubbing_tab, 'dub_background_audio_menu', None)
        if selected_option == self.dub_background_audio_options[0]: # "Tr·ªôn v·ªõi √¢m thanh g·ªëc..."
            mix_level_frame.pack(pady=(5, 10), padx=10, fill="x", after=background_audio_menu)
            self.dub_use_custom_bg_music_var.set(False)

        elif selected_option == self.dub_background_audio_options[1]: # "Thay th·∫ø √¢m thanh g·ªëc"
            # Hi·ªán khung l·ªõn ch·ª©a t·∫•t c·∫£ c√°c control nh·∫°c n·ªÅn t√πy ch·ªânh
            custom_bgm_main_frame.pack(pady=(5, 10), padx=10, fill="x", expand=True, after=background_audio_menu)
            
            # B√¢y gi·ªù, qu·∫£n l√Ω c√°c control con B√äN TRONG khung l·ªõn ƒë√≥
            use_custom_music_checked = self.dub_use_custom_bg_music_var.get()
            is_processing = hasattr(self, 'dub_is_processing') and self.dub_is_processing
            control_state = ctk.DISABLED if is_processing else ctk.NORMAL
            
            # L·∫•y tham chi·∫øu c√°c widget con t·ª´ dubbing_tab
            checkbox_grid_frame = getattr(dubbing_tab, 'checkbox_and_volume_grid_frame')
            selection_controls_frame = getattr(dubbing_tab, 'dub_music_selection_controls_frame')
            lbl_path = getattr(dubbing_tab, 'dub_lbl_bg_music_path')
            lbl_vol_title = getattr(dubbing_tab, 'dub_lbl_custom_bg_music_volume_title_inline')
            vol_entry_frame = getattr(dubbing_tab, 'custom_bg_vol_entry_frame')

            # Lu√¥n hi·ªÉn th·ªã frame ch·ª©a checkbox "Nh·∫°c n·ªÅn t√πy ch·ªânh"
            if not checkbox_grid_frame.winfo_ismapped():
                checkbox_grid_frame.pack(side="top", anchor="w", padx=0, pady=(5,0), fill="x")
            
            # C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa checkbox ch√≠nh
            getattr(dubbing_tab, 'dub_chk_use_custom_bg_music').configure(state=control_state)

            # Hi·ªán/·∫©n c√°c control ph·ª• thu·ªôc v√†o checkbox
            if use_custom_music_checked:
                # Hi·ªán c√°c control li√™n quan
                if not selection_controls_frame.winfo_ismapped():
                    selection_controls_frame.pack(side="top", pady=(5,5), padx=0, fill="x")
                if not lbl_path.winfo_ismapped():
                    lbl_path.pack(side="top", pady=(0,5), padx=5, anchor="w", fill="x")

                # <<< S·ª¨A L·ªñI: HI·ªÇN TH·ªä C√ÅC WIDGET √ÇM L∆Ø·ª¢NG B·∫∞NG GRID >>>
                lbl_vol_title.grid(row=0, column=1, sticky="w", pady=2, padx=(40, 2))
                vol_entry_frame.grid(row=0, column=2, sticky="w", pady=2, padx=(0, 0))

                # C·∫≠p nh·∫≠t label ƒë∆∞·ªùng d·∫´n
                folder_path = self.dub_custom_bg_music_folder_path_var.get()
                file_path = self.dub_custom_bg_music_path_var.get()
                if folder_path: lbl_path.configure(text=f"Th∆∞ m·ª•c: {folder_path}")
                elif file_path: lbl_path.configure(text=f"File: {os.path.basename(file_path)}")
                else: lbl_path.configure(text="Ch∆∞a ch·ªçn nh·∫°c n·ªÅn")
            else:
                # ·∫®n c√°c control kh√¥ng c·∫ßn thi·∫øt
                if selection_controls_frame.winfo_ismapped(): selection_controls_frame.pack_forget()
                if lbl_path.winfo_ismapped(): lbl_path.pack_forget()
                # <<< S·ª¨A L·ªñI: ·∫®N C√ÅC WIDGET √ÇM L∆Ø·ª¢NG B·∫∞NG GRID_REMOVE >>>
                if lbl_vol_title.winfo_ismapped(): lbl_vol_title.grid_remove()
                if vol_entry_frame.winfo_ismapped(): vol_entry_frame.grid_remove()

            # C·∫≠p nh·∫≠t tr·∫°ng th√°i b·∫≠t/t·∫Øt c·ªßa c√°c control con
            sub_control_state = control_state if use_custom_music_checked else ctk.DISABLED
            getattr(dubbing_tab, 'dub_entry_custom_bg_music_volume').configure(state=sub_control_state)
            getattr(dubbing_tab, 'dub_btn_browse_bg_folder').configure(state=sub_control_state)
            getattr(dubbing_tab, 'dub_btn_browse_bg_music').configure(state=sub_control_state)
            
            is_folder_mode = bool(self.dub_custom_bg_music_folder_path_var.get())
            randomize_state = ctk.NORMAL if use_custom_music_checked and is_folder_mode and not is_processing else ctk.DISABLED
            getattr(dubbing_tab, 'dub_chk_randomize_music').configure(state=randomize_state)
            if not is_folder_mode: self.dub_randomize_bg_music_var.set(False)

        elif selected_option == self.dub_background_audio_options[2]: # "Audio Ducking"
            self.dub_use_custom_bg_music_var.set(False)
        
        if self.initial_ui_setup_complete and update_status: # Th√™m "and update_status"
            self.update_status(f"‚ÑπÔ∏è Thuy·∫øt Minh - X·ª≠ l√Ω √¢m thanh n·ªÅn: {selected_option}")

        

# H√†m ti·ªán √≠ch UI: C·∫≠p nh·∫≠t hi·ªÉn th·ªã % cho slider √¢m l∆∞·ª£ng n·ªÅn (khi tr·ªôn v·ªõi g·ªëc)
    def dub_update_mix_level_label_display(self, value_from_slider):
        """C·∫≠p nh·∫≠t self.dub_lbl_mix_level_display."""
        if hasattr(self, 'dub_lbl_mix_level_display') and self.dub_lbl_mix_level_display: 
            current_val_percent = float(value_from_slider) * 100 
            self.dub_lbl_mix_level_display.configure(text=f"{current_val_percent:.0f}%")

        if hasattr(self, 'initial_ui_setup_complete') and self.initial_ui_setup_complete:
            if hasattr(self, 'dub_background_audio_option_var') and \
               hasattr(self, 'dub_background_audio_options') and \
               self.dub_background_audio_option_var.get() == self.dub_background_audio_options[0]:
                self.update_status(f"‚ÑπÔ∏è Thuy·∫øt Minh - √Çm l∆∞·ª£ng n·ªÅn (g·ªëc) khi tr·ªôn: {float(value_from_slider)*100:.0f}%")
        else:
            if hasattr(self, 'dub_background_audio_option_var') and \
               hasattr(self, 'dub_background_audio_options') and \
               self.dub_background_audio_option_var.get() == self.dub_background_audio_options[0]:
                logging.debug(f"[Dubbing Status Startup] initial_ui_setup_complete=False, b·ªè qua update status ban ƒë·∫ßu cho Mix Level: {float(value_from_slider)*100:.0f}%")
        
        #self.save_current_config() 





# H√†m s·ª± ki·ªán: X·ª≠ l√Ω khi checkbox "S·ª≠ d·ª•ng nh·∫°c n·ªÅn t√πy ch·ªânh" thay ƒë·ªïi
    def dub_on_use_custom_bg_music_changed(self, *args):
        """
        (PHI√äN B·∫¢N S·ª¨A L·ªñI)
        Qu·∫£n l√Ω hi·ªÉn th·ªã c√°c control con B√äN TRONG khung nh·∫°c n·ªÅn t√πy ch·ªânh.
        """
        # Ki·ªÉm tra xem parent ch√≠nh (custom_bgm_main_frame) c√≥ ƒëang hi·ªÉn th·ªã kh√¥ng
        parent_frame = getattr(self, 'dub_custom_bg_music_frame', None)
        if not (parent_frame and parent_frame.winfo_ismapped()):
            return # Kh√¥ng l√†m g√¨ n·∫øu khung cha ƒëang b·ªã ·∫©n

        is_checked = self.dub_use_custom_bg_music_var.get()
        is_dub_processing = hasattr(self, 'dub_is_processing') and self.dub_is_processing
        control_state = ctk.DISABLED if is_dub_processing else ctk.NORMAL

        # L·∫•y tham chi·∫øu widget con
        checkbox_grid_frame = getattr(self, 'checkbox_and_volume_grid_frame')
        selection_controls_frame = getattr(self, 'dub_music_selection_controls_frame')
        lbl_path = getattr(self, 'dub_lbl_bg_music_path')

        # Lu√¥n hi·ªÉn th·ªã frame ch·ª©a checkbox "Nh·∫°c n·ªÅn t√πy ch·ªânh" v√† Volume
        if not checkbox_grid_frame.winfo_ismapped():
            checkbox_grid_frame.pack(side="top", anchor="w", padx=0, pady=(5,0), fill="x")

        if is_checked:
            # Hi·ªán frame ch·ª©a n√∫t ch·ªçn file/th∆∞ m·ª•c v√† label ƒë∆∞·ªùng d·∫´n
            if not selection_controls_frame.winfo_ismapped():
                selection_controls_frame.pack(side="top", pady=(5,5), padx=0, fill="x")
            if not lbl_path.winfo_ismapped():
                lbl_path.pack(side="top", pady=(0,5), padx=5, anchor="w", fill="x")

            # C·∫≠p nh·∫≠t label ƒë∆∞·ªùng d·∫´n
            folder_path = self.dub_custom_bg_music_folder_path_var.get()
            file_path = self.dub_custom_bg_music_path_var.get()
            if folder_path: lbl_path.configure(text=f"Th∆∞ m·ª•c: {folder_path}")
            elif file_path: lbl_path.configure(text=f"File: {os.path.basename(file_path)}")
            else: lbl_path.configure(text="Ch∆∞a ch·ªçn nh·∫°c n·ªÅn")
        else:
            # ·∫®n c√°c control ph·ª•
            if selection_controls_frame.winfo_ismapped(): selection_controls_frame.pack_forget()
            if lbl_path.winfo_ismapped(): lbl_path.pack_forget()

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa c√°c n√∫t/checkbox con b√™n trong
        dubbing_tab = getattr(self, 'dubbing_view_frame', None)
        if dubbing_tab:
            getattr(dubbing_tab, 'dub_lbl_custom_bg_music_volume_title_inline').configure(state=control_state if is_checked else ctk.DISABLED)
            getattr(dubbing_tab, 'dub_entry_custom_bg_music_volume').configure(state=control_state if is_checked else ctk.DISABLED)
            getattr(dubbing_tab, 'dub_btn_browse_bg_folder').configure(state=control_state if is_checked else ctk.DISABLED)
            getattr(dubbing_tab, 'dub_btn_browse_bg_music').configure(state=control_state if is_checked else ctk.DISABLED)

        is_folder_mode = bool(self.dub_custom_bg_music_folder_path_var.get())
        randomize_state = ctk.NORMAL if is_checked and is_folder_mode and not is_dub_processing else ctk.DISABLED
        if dubbing_tab:
            getattr(dubbing_tab, 'dub_chk_randomize_music').configure(state=randomize_state)
        if not is_folder_mode: self.dub_randomize_bg_music_var.set(False)

        # C·∫≠p nh·∫≠t status bar ch√≠nh c·ªßa ·ª©ng d·ª•ng
        if self.initial_ui_setup_complete:
            status_text = "B·∫≠t" if is_checked else "T·∫Øt"
            self.update_status(f"‚ÑπÔ∏è Thuy·∫øt Minh - S·ª≠ d·ª•ng nh·∫°c n·ªÅn t√πy ch·ªânh: {status_text}.")
            if is_checked and not (self.dub_custom_bg_music_path_var.get() or self.dub_custom_bg_music_folder_path_var.get()):
                # T·ª± ƒë·ªông g·ª£i √Ω ch·ªçn n·∫øu ch∆∞a c√≥ g√¨
                self.after(100, self._dub_browse_custom_bg_folder)



# H√†m h√†nh ƒë·ªông: M·ªü h·ªôp tho·∫°i ch·ªçn file nh·∫°c n·ªÅn t√πy ch·ªânh
    def dub_browse_custom_bg_music(self):
        """M·ªü filedialog ƒë·ªÉ ch·ªçn file nh·∫°c n·ªÅn, c·∫≠p nh·∫≠t self.dub_custom_bg_music_path_var."""
        if not hasattr(self, 'dub_custom_bg_music_path_var'):
            logging.error("[Dubbing] dub_custom_bg_music_path_var ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.")
            return

        file_path = filedialog.askopenfilename(
            title="Ch·ªçn file Nh·∫°c n·ªÅn t√πy ch·ªânh",
            filetypes=(("Audio files", "*.mp3 *.wav *.aac *.m4a *.ogg *.flac"), 
                       ("All files", "*.*")),
            parent=self
        )
        if file_path:
            self.dub_custom_bg_music_path_var.set(file_path) # C·∫≠p nh·∫≠t StringVar
            if hasattr(self, 'dub_lbl_bg_music_path') and self.dub_lbl_bg_music_path:
                self.dub_lbl_bg_music_path.configure(text=f"Nh·∫°c n·ªÅn: {os.path.basename(file_path)}")

            if hasattr(self, 'initial_ui_setup_complete') and self.initial_ui_setup_complete:
                self.update_status(f"‚ÑπÔ∏è Thuy·∫øt Minh - ƒê√£ ch·ªçn nh·∫°c n·ªÅn t√πy ch·ªânh: {os.path.basename(file_path)}")
            else:
                logging.debug(f"[Dubbing Status Startup] initial_ui_setup_complete=False, b·ªè qua update status ban ƒë·∫ßu cho Browse Custom BGM: {os.path.basename(file_path)}")

            #self.save_current_config()
        else:
            if hasattr(self, 'initial_ui_setup_complete') and self.initial_ui_setup_complete:
                self.update_status("Thuy·∫øt Minh - ƒê√£ h·ªßy ch·ªçn file nh·∫°c n·ªÅn t√πy ch·ªânh.")
            else:
                logging.debug("[Dubbing Status Startup] initial_ui_setup_complete=False, b·ªè qua update status ban ƒë·∫ßu cho H·ªßy Browse Custom BGM.")


# H√†m ti·ªán √≠ch UI: Hi·ªán/·∫©n c√°c control c·ªßa nh·∫°c n·ªÅn t√πy ch·ªânh
# B√™n trong l·ªõp SubtitleApp

    def dub_update_custom_bg_music_controls_visibility(self, *args):
        """
        (PHI√äN B·∫¢N S·ª¨A L·ªñI)
        C·∫≠p nh·∫≠t tr·∫°ng th√°i v√† kh·∫£ nƒÉng hi·ªÉn th·ªã c·ªßa T·∫§T C·∫¢ c√°c control li√™n quan ƒë·∫øn
        nh·∫°c n·ªÅn t√πy ch·ªânh, bao g·ªìm c·∫£ c√°c n√∫t ch·ªçn th∆∞ m·ª•c/file m·ªõi.
        """
        # L·∫•y t·ª´ dubbing_view_frame
        dubbing_tab = getattr(self, 'dubbing_view_frame', None)
        if not dubbing_tab:
            return
        parent_custom_music_frame = getattr(dubbing_tab, 'dub_custom_bg_music_frame', None)
        
        if not (parent_custom_music_frame and hasattr(parent_custom_music_frame, 'winfo_exists') and parent_custom_music_frame.winfo_exists()):
            logging.debug("[DubVisibility_v8] parent_custom_music_frame kh√¥ng t·ªìn t·∫°i. B·ªè qua.")
            return

        # L·∫•y tham chi·∫øu ƒë·∫øn t·∫•t c·∫£ c√°c widget con c·∫ßn qu·∫£n l√Ω t·ª´ dubbing_tab
        checkbox_grid_frame = getattr(dubbing_tab, 'checkbox_and_volume_grid_frame', None)
        selection_controls_frame = getattr(dubbing_tab, 'dub_music_selection_controls_frame', None)
        lbl_path = getattr(dubbing_tab, 'dub_lbl_bg_music_path', None)
        
        # Ki·ªÉm tra s·ª± t·ªìn t·∫°i c·ªßa c√°c widget ch√≠nh
        if not all(w and w.winfo_exists() for w in [checkbox_grid_frame, selection_controls_frame, lbl_path]):
            logging.warning("[DubVisibility_v8] M·ªôt ho·∫∑c nhi·ªÅu frame/widget con cho nh·∫°c n·ªÅn ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.")
            return

        use_custom_music_is_checked = self.dub_use_custom_bg_music_var.get()
        is_currently_dub_processing = hasattr(self, 'dub_is_processing') and self.dub_is_processing
        
        # ·∫®n/Hi·ªán to√†n b·ªô c·ª•m ƒëi·ªÅu khi·ªÉn nh·∫°c n·ªÅn t√πy ch·ªânh
        if use_custom_music_is_checked:
            # A. Hi·ªÉn th·ªã c√°c frame con
            if not checkbox_grid_frame.winfo_ismapped():
                checkbox_grid_frame.pack(in_=parent_custom_music_frame, side="top", anchor="w", padx=0, pady=(5,0), fill="x")
            if not selection_controls_frame.winfo_ismapped():
                selection_controls_frame.pack(in_=parent_custom_music_frame, side="top", pady=(5,5), padx=10, fill="x", after=checkbox_grid_frame)
            if not lbl_path.winfo_ismapped():
                lbl_path.pack(in_=parent_custom_music_frame, side="top", pady=(0,5), padx=10, anchor="w", fill="x", after=selection_controls_frame)

            # B. C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa t·ª´ng widget con
            control_state = ctk.DISABLED if is_currently_dub_processing else ctk.NORMAL
            
            # C√°c n√∫t ch·ªçn th∆∞ m·ª•c/file
            getattr(dubbing_tab, 'dub_btn_browse_bg_folder').configure(state=control_state)
            getattr(dubbing_tab, 'dub_btn_browse_bg_music').configure(state=control_state)
            
            # Checkbox ng·∫´u nhi√™n
            chk_randomize = getattr(dubbing_tab, 'dub_chk_randomize_music')
            is_folder_mode = bool(self.dub_custom_bg_music_folder_path_var.get())
            randomize_state = ctk.NORMAL if is_folder_mode and not is_currently_dub_processing else ctk.DISABLED
            chk_randomize.configure(state=randomize_state)
            if not is_folder_mode:
                self.dub_randomize_bg_music_var.set(False)

            # C·∫≠p nh·∫≠t label ƒë∆∞·ªùng d·∫´n
            folder_path = self.dub_custom_bg_music_folder_path_var.get()
            file_path = self.dub_custom_bg_music_path_var.get()
            if folder_path:
                lbl_path.configure(text=f"Th∆∞ m·ª•c: {folder_path}")
            elif file_path:
                lbl_path.configure(text=f"File: {os.path.basename(file_path)}")
            else:
                lbl_path.configure(text="Ch∆∞a ch·ªçn nh·∫°c n·ªÅn")
        else:
            # ·∫®n t·∫•t c·∫£ n·∫øu checkbox ch√≠nh kh√¥ng ƒë∆∞·ª£c ch·ªçn
            if checkbox_grid_frame.winfo_ismapped():
                checkbox_grid_frame.pack_forget()
            if selection_controls_frame.winfo_ismapped():
                selection_controls_frame.pack_forget()
            if lbl_path.winfo_ismapped():
                lbl_path.pack_forget()        


# 2 H√†m cho ch·ª©c nƒÉng ch·ªçn nh·∫°c n·ªÅn t√πy ch·ªânh
    def _dub_browse_custom_bg_folder(self):
        """M·ªü dialog cho ng∆∞·ªùi d√πng ch·ªçn m·ªôt th∆∞ m·ª•c ch·ª©a nh·∫°c n·ªÅn."""
        # L·∫•y th∆∞ m·ª•c ƒë√£ ch·ªçn tr∆∞·ªõc ƒë√≥ (n·∫øu c√≥) ƒë·ªÉ l√†m th∆∞ m·ª•c m·∫∑c ƒë·ªãnh
        initial_dir = self.dub_custom_bg_music_folder_path_var.get() or get_default_downloads_folder()
        folder_path = filedialog.askdirectory(
            title="Ch·ªçn Th∆∞ m·ª•c ch·ª©a Nh·∫°c n·ªÅn",
            initialdir=initial_dir,
            parent=self
        )

        if folder_path:
            # L∆∞u ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c v√†o bi·∫øn t∆∞∆°ng ·ª©ng
            self.dub_custom_bg_music_folder_path_var.set(folder_path)
            # Khi ch·ªçn th∆∞ m·ª•c, x√≥a l·ª±a ch·ªçn file ƒë∆°n l·∫ª ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n
            self.dub_custom_bg_music_path_var.set("") 
            logging.info(f"[DubBGM] ƒê√£ ch·ªçn th∆∞ m·ª•c nh·∫°c n·ªÅn: {folder_path}")
            self.update_status(f"‚ÑπÔ∏è Thuy·∫øt Minh - Nh·∫°c n·ªÅn: Th∆∞ m·ª•c {os.path.basename(folder_path)}")
        else:
            logging.info("[DubBGM] Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn th∆∞ m·ª•c nh·∫°c n·ªÅn.")

        # Lu√¥n c·∫≠p nh·∫≠t l·∫°i giao di·ªán sau khi ch·ªçn
        self.dub_update_custom_bg_music_controls_visibility()


    def dub_browse_custom_bg_music(self):
        """
        M·ªü filedialog ƒë·ªÉ ch·ªçn M·ªòT file nh·∫°c n·ªÅn.
        (ƒê√É S·ª¨A: ƒê·ªÉ reset l·ª±a ch·ªçn th∆∞ m·ª•c)
        """
        initial_dir = self.dub_custom_bg_music_path_var.get() or get_default_downloads_folder()
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn File Nh·∫°c n·ªÅn t√πy ch·ªânh",
            filetypes=(("Audio files", "*.mp3 *.wav *.aac *.m4a *.ogg *.flac"), 
                       ("All files", "*.*")),
            initialdir=initial_dir,
            parent=self
        )
        if file_path:
            self.dub_custom_bg_music_path_var.set(file_path)
            # Khi ch·ªçn file ƒë∆°n l·∫ª, x√≥a l·ª±a ch·ªçn th∆∞ m·ª•c
            self.dub_custom_bg_music_folder_path_var.set("") 
            logging.info(f"[DubBGM] ƒê√£ ch·ªçn file nh·∫°c n·ªÅn ƒë∆°n l·∫ª: {file_path}")
            self.update_status(f"‚ÑπÔ∏è Thuy·∫øt Minh - Nh·∫°c n·ªÅn: File {os.path.basename(file_path)}")
        else:
            logging.info("[DubBGM] Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn file nh·∫°c n·ªÅn ƒë∆°n l·∫ª.")

        # Lu√¥n c·∫≠p nh·∫≠t l·∫°i UI sau khi ch·ªçn
        self.dub_update_custom_bg_music_controls_visibility()


# H√ÄM M·ªöI: Qu√©t th∆∞ m·ª•c, l·∫•y danh s√°ch file nh·∫°c, gi·ªõi h·∫°n v√† t√πy ch·ªçn x√°o tr·ªôn
    def _prepare_bgm_list_from_folder(self, folder_path, randomize=False):
        """
        Qu√©t th∆∞ m·ª•c, l·∫•y danh s√°ch file nh·∫°c, gi·ªõi h·∫°n, v√† t√πy ch·ªçn x√°o tr·ªôn.
        Tr·∫£ v·ªÅ danh s√°ch c√°c ƒë∆∞·ªùng d·∫´n file nh·∫°c ho·∫∑c None n·∫øu c√≥ l·ªói.
        """
        if not folder_path or not os.path.isdir(folder_path):
            logging.error(f"[BGM_Prepare] ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c nh·∫°c kh√¥ng h·ª£p l·ªá: {folder_path}")
            return None

        supported_extensions = ('.mp3', '.wav', '.aac', '.m4a', '.ogg', '.flac')
        all_music_files = []
        try:
            for item_name in os.listdir(folder_path):
                # B·ªè qua c√°c file ·∫©n (v√≠ d·ª•: .DS_Store tr√™n macOS)
                if item_name.startswith('.'):
                    continue
                if item_name.lower().endswith(supported_extensions):
                    full_path = os.path.join(folder_path, item_name)
                    if os.path.isfile(full_path):
                        all_music_files.append(full_path)
        except Exception as e:
            logging.error(f"[BGM_Prepare] L·ªói khi ƒë·ªçc th∆∞ m·ª•c nh·∫°c '{folder_path}': {e}", exc_info=True)
            # Th√¥ng b√°o l·ªói n√†y cho ng∆∞·ªùi d√πng tr√™n lu·ªìng ch√≠nh
            self.after(0, lambda: messagebox.showerror("L·ªói ƒê·ªçc Th∆∞ m·ª•c Nh·∫°c", f"Kh√¥ng th·ªÉ ƒë·ªçc file t·ª´ th∆∞ m·ª•c:\n{folder_path}\nL·ªói: {e}", parent=self))
            return None

        if not all_music_files:
            logging.warning(f"[BGM_Prepare] Kh√¥ng t√¨m th·∫•y file nh·∫°c n√†o trong th∆∞ m·ª•c: {folder_path}")
            self.after(0, lambda: messagebox.showinfo("Kh√¥ng c√≥ nh·∫°c", f"Kh√¥ng t√¨m th·∫•y file nh·∫°c n√†o ƒë∆∞·ª£c h·ªó tr·ª£ trong th∆∞ m·ª•c ƒë√£ ch·ªçn.", parent=self))
            return None

        # X√°o tr·ªôn n·∫øu c·∫ßn
        if randomize:
            import random
            random.shuffle(all_music_files)
            logging.info(f"[BGM_Prepare] ƒê√£ x√°o tr·ªôn {len(all_music_files)} file nh·∫°c.")
        else:
            all_music_files.sort() # S·∫Øp x·∫øp theo t√™n ƒë·ªÉ c√≥ th·ª© t·ª± nh·∫•t qu√°n
            logging.info(f"[BGM_Prepare] ƒê√£ s·∫Øp x·∫øp {len(all_music_files)} file nh·∫°c theo t√™n.")

        # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng file
        file_limit = 100
        if len(all_music_files) > file_limit:
            logging.warning(f"[BGM_Prepare] T√¨m th·∫•y {len(all_music_files)} file, v∆∞·ª£t qu√° gi·ªõi h·∫°n {file_limit}. Ch·ªâ x·ª≠ l√Ω {file_limit} file ƒë·∫ßu ti√™n.")
            self.after(0, lambda: messagebox.showinfo("Gi·ªõi h·∫°n File Nh·∫°c", f"Th∆∞ m·ª•c ch·ª©a {len(all_music_files)} file nh·∫°c.\n·ª®ng d·ª•ng s·∫Ω ch·ªâ x·ª≠ l√Ω {file_limit} file ƒë·∫ßu ti√™n trong danh s√°ch (ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp/x√°o tr·ªôn).", parent=self))
            return all_music_files[:file_limit]
        
        return all_music_files

### K·∫æT TH√öC CODE CHO B∆Ø·ªöC 2 ###

### B·∫ÆT ƒê·∫¶U CODE CHO B∆Ø·ªöC 3 ###

# H√ÄM M·ªöI 3A: L·∫•y th·ªùi l∆∞·ª£ng video b·∫±ng ffprobe

# H√ÄM M·ªöI 3C: Gh√©p n·ªëi c√°c file audio th√†nh m·ªôt b·∫£n nh·∫°c n·ªÅn duy nh·∫•t
    def _ffmpeg_create_concatenated_bgm(self, audio_files, final_output_path, main_video_for_timing_path):
        """
        (PHI√äN B·∫¢N N√ÇNG C·∫§P V·ªöI ACROSSFADE)
        Chu·∫©n h√≥a LUFS v√† √°p d·ª•ng fade-in/out cho t·ª´ng file audio, sau ƒë√≥ gh√©p n·ªëi t·∫•t c·∫£
        ch√∫ng l·∫°i b·∫±ng b·ªô l·ªçc 'acrossfade' ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng chuy·ªÉn ti·∫øp m∆∞·ª£t m√†.
        """
        worker_log_prefix = f"[{threading.current_thread().name}_FFmpegConcatBGM_v4_Acrossfade]"
        ffmpeg_executable = find_ffmpeg()
        if not ffmpeg_executable:
            logging.error(f"{worker_log_prefix} Kh√¥ng t√¨m th·∫•y FFmpeg.")
            return None, []

        if not audio_files:
            logging.warning(f"{worker_log_prefix} Danh s√°ch audio r·ªóng, kh√¥ng gh√©p.")
            return None, []

        temp_files_created = []
        
        try:
            video_duration_s = get_video_duration_s(main_video_for_timing_path)
            if video_duration_s <= 0:
                raise ValueError(f"Kh√¥ng th·ªÉ l·∫•y th·ªùi l∆∞·ª£ng c·ªßa video ch√≠nh: {main_video_for_timing_path}")
            
            logging.info(f"{worker_log_prefix} Video ch√≠nh d√†i {video_duration_s:.2f}s. B·∫Øt ƒë·∫ßu x·ª≠ l√Ω v√† gh√©p {len(audio_files)} file BGM v·ªõi acrossfade.")
            
            processed_chunks_for_concat = []
            fade_in_duration_s = 0.5  # Th·ªùi gian fade-in cho b√†i ƒë·∫ßu ti√™n
            fade_out_duration_s = 2.0 # Th·ªùi gian fade-out cho b√†i cu·ªëi c√πng
            crossfade_duration_s = 1.5 # Th·ªùi gian tr·ªôn ch·ªìng l√™n nhau gi·ªØa 2 b√†i h√°t

            # --- B∆∞·ªõc A: Chu·∫©n h√≥a v√† x·ª≠ l√Ω tr∆∞·ªõc t·ª´ng file ---
            for i, file_path in enumerate(audio_files):
                if self.dub_stop_event.is_set(): raise InterruptedError("D·ª´ng trong l√∫c ti·ªÅn x·ª≠ l√Ω BGM")
                
                # 1. Chu·∫©n h√≥a LUFS sang WAV
                norm_wav_path = os.path.join(self.temp_folder, f"norm_chunk_{i}_{uuid.uuid4().hex[:6]}.wav")
                temp_files_created.append(norm_wav_path)
                
                if not self._ffmpeg_normalize_single_audio_to_wav(file_path, norm_wav_path, target_lufs=-23.0):
                    logging.warning(f"{worker_log_prefix} B·ªè qua chunk BGM do l·ªói chu·∫©n h√≥a LUFS: {os.path.basename(file_path)}")
                    continue
                
                # Sau khi chu·∫©n h√≥a, th√™m ngay v√†o danh s√°ch s·∫Ω d√πng ƒë·ªÉ gh√©p
                processed_chunks_for_concat.append(norm_wav_path)

            if not processed_chunks_for_concat:
                 raise ValueError("Kh√¥ng c√≥ chunk BGM n√†o h·ª£p l·ªá sau khi chu·∫©n h√≥a.")
            
            # --- B∆∞·ªõc B: X√¢y d·ª±ng l·ªánh FFmpeg v·ªõi -filter_complex v√† acrossfade ---
            command = [ffmpeg_executable, "-y"]
            filter_chains = []
            
            # Th√™m t·∫•t c·∫£ c√°c file ƒë√£ x·ª≠ l√Ω l√†m input cho FFmpeg
            for chunk_path in processed_chunks_for_concat:
                command.extend(["-i", os.path.abspath(chunk_path)])

            num_chunks = len(processed_chunks_for_concat)
            
            # √Åp d·ª•ng fade-in cho file ƒë·∫ßu ti√™n
            if num_chunks > 0:
                filter_chains.append(f"[0:a]afade=t=in:d={fade_in_duration_s:.3f}[a0]")
            
            # √Åp d·ª•ng acrossfade tu·∫ßn t·ª± cho c√°c file ti·∫øp theo
            # [a0][1:a]acrossfade=...[a1]; [a1][2:a]acrossfade=...[a2]; ...
            last_stream_tag = "a0"
            for i in range(1, num_chunks):
                current_stream_tag = f"[{i}:a]"
                output_stream_tag = f"[a{i}]"
                filter_chains.append(f"[{last_stream_tag}]{current_stream_tag}acrossfade=d={crossfade_duration_s:.3f}:c1=tri:c2=tri{output_stream_tag}")
                last_stream_tag = f"a{i}"
            
            # Sau khi gh√©p n·ªëi, √°p d·ª•ng fade-out cho track cu·ªëi c√πng
            # v√† c·∫Øt theo ƒë√∫ng th·ªùi l∆∞·ª£ng video
            final_processed_stream_tag = f"[{last_stream_tag}]"
            filter_chains.append(f"{final_processed_stream_tag}afade=t=out:d={fade_out_duration_s:.3f}:start_time={video_duration_s - fade_out_duration_s:.3f}[final_audio]")

            command.extend([
                "-filter_complex", ";".join(filter_chains),
                "-map", "[final_audio]",
                "-t", f"{video_duration_s:.3f}",
                "-c:a", "aac", "-b:a", "192k",
                os.path.abspath(final_output_path)
            ])
            
            # --- B∆∞·ªõc C: Th·ª±c thi l·ªánh ---
            logging.info(f"{worker_log_prefix} L·ªánh FFmpeg cu·ªëi c√πng (acrossfade) (service): {' '.join(command[1:])}")
            try:
                ffmpeg_run_command(
                    command[1:],
                    process_name=f"{worker_log_prefix}_Acrossfade",
                    stop_event=self.dub_stop_event,
                    set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                    clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                    timeout_seconds=600,
                )
            except Exception as e:
                raise RuntimeError(f"FFmpeg (gh√©p BGM v·ªõi acrossfade) th·∫•t b·∫°i: {e}")

            if self.dub_stop_event.is_set():
                raise InterruptedError("D·ª´ng trong l√∫c gh√©p BGM v·ªõi acrossfade")
            
            return final_output_path, temp_files_created 

        except Exception as e:
            logging.error(f"{worker_log_prefix} L·ªói khi gh√©p BGM v·ªõi acrossfade: {e}", exc_info=True)
            return None, temp_files_created


# --- H√ÄM M·ªöI:  Chu·∫©n h√≥a m·ªôt file audio duy nh·∫•t sang ƒë·ªãnh d·∫°ng WAV v·ªõi ƒë·ªô l·ªõn m·ª•c ti√™u (LUFS) ---
    def _ffmpeg_normalize_single_audio_to_wav(self, input_path, output_wav_path, target_lufs=-23.0):
        """
        Chu·∫©n h√≥a m·ªôt file audio duy nh·∫•t sang ƒë·ªãnh d·∫°ng WAV v·ªõi ƒë·ªô l·ªõn m·ª•c ti√™u (LUFS).
        H√†m n√†y ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ x·ª≠ l√Ω nh·∫°c n·ªÅn.
        """
        worker_log_prefix = f"[{threading.current_thread().name}_NormalizeSingleBGM]"
        # D√πng service FFmpeg t·∫≠p trung

        if self.dub_stop_event.is_set():
            logging.info(f"{worker_log_prefix} B·ªã h·ªßy do y√™u c·∫ßu d·ª´ng.")
            return False

        loudnorm_filter = f"loudnorm=I={target_lufs}:TP=-1.5:LRA=11:print_format=summary"
        cmd_params = [
            "-y",
            "-i", os.path.abspath(input_path),
            "-af", loudnorm_filter,
            "-c:a", self.dub_DEFAULT_WAV_CODEC,
            "-ar", str(self.dub_TARGET_AUDIO_PROCESSING_SAMPLE_RATE),
            "-ac", str(self.dub_TARGET_AUDIO_PROCESSING_CHANNELS),
            os.path.abspath(output_wav_path)
        ]
        logging.info(f"{worker_log_prefix} Chu·∫©n h√≥a '{os.path.basename(input_path)}' sang WAV (LUFS={target_lufs}) (service)...")
        try:
            ffmpeg_run_command(
                cmd_params,
                process_name=f"{worker_log_prefix}_NormalizeWAV",
                stop_event=self.dub_stop_event,
                set_current_process=lambda p: setattr(self, 'dub_current_ffmpeg_process', p),
                clear_current_process=lambda: setattr(self, 'dub_current_ffmpeg_process', None),
                timeout_seconds=180,
            )
            return True
        except Exception as e:
            logging.error(f"{worker_log_prefix} L·ªói khi chu·∫©n h√≥a audio: {e}", exc_info=True)
            return False

#------------------------------------------------------------------
# H√†m d√πng khi l∆∞u c·∫•u h√¨nh v√† khi c·∫ßn l·∫•y gi√° tr·ªã √¢m l∆∞·ª£ng ƒë·ªÉ x·ª≠ l√Ω
    def get_validated_custom_bg_volume_float(self):
        """
        L·∫•y gi√° tr·ªã √¢m l∆∞·ª£ng nh·∫°c n·ªÅn t√πy ch·ªânh t·ª´ StringVar (d·∫°ng % string),
        x√°c th·ª±c n√≥ (0-100), v√† chuy·ªÉn ƒë·ªïi sang float (0.0-1.0).
        Tr·∫£ v·ªÅ gi√° tr·ªã float h·ª£p l·ªá ho·∫∑c gi√° tr·ªã m·∫∑c ƒë·ªãnh (0.25) n·∫øu l·ªói.
        """
        default_volume_float = 0.25 # Gi√° tr·ªã m·∫∑c ƒë·ªãnh khi c√≥ l·ªói
        try:
            if hasattr(self, 'dub_custom_bg_music_volume_percent_str_var'):
                volume_percent_str = self.dub_custom_bg_music_volume_percent_str_var.get()
                if not volume_percent_str.strip(): # N·∫øu ng∆∞·ªùi d√πng x√≥a r·ªóng
                    logging.warning("Gi√° tr·ªã √¢m l∆∞·ª£ng nh·∫°c n·ªÅn t√πy ch·ªânh b·ªã r·ªóng. S·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh.")
                    # T√πy ch·ªçn: Set l·∫°i StringVar v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh
                    # self.dub_custom_bg_music_volume_percent_str_var.set(str(int(default_volume_float * 100)))
                    return default_volume_float

                volume_percent_int = int(volume_percent_str)
                if 0 <= volume_percent_int <= 100:
                    return float(volume_percent_int / 100.0)
                else:
                    logging.warning(f"Gi√° tr·ªã √¢m l∆∞·ª£ng nh·∫°c n·ªÅn t√πy ch·ªânh '{volume_percent_str}%' n·∫±m ngo√†i kho·∫£ng h·ª£p l·ªá (0-100). S·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh.")
                    # Set l·∫°i StringVar v·ªÅ m·ªôt gi√° tr·ªã h·ª£p l·ªá g·∫ßn nh·∫•t ho·∫∑c m·∫∑c ƒë·ªãnh
                    # self.dub_custom_bg_music_volume_percent_str_var.set(str(max(0, min(100, volume_percent_int))))
                    return default_volume_float
            else:
                logging.error("Kh√¥ng t√¨m th·∫•y bi·∫øn dub_custom_bg_music_volume_percent_str_var.")
                return default_volume_float
        except ValueError: # N·∫øu ng∆∞·ªùi d√πng nh·∫≠p ch·ªØ thay v√¨ s·ªë
            current_val_in_var = self.dub_custom_bg_music_volume_percent_str_var.get() if hasattr(self, 'dub_custom_bg_music_volume_percent_str_var') else "N/A"
            logging.warning(f"Gi√° tr·ªã √¢m l∆∞·ª£ng nh·∫°c n·ªÅn t√πy ch·ªânh '{current_val_in_var}' kh√¥ng ph·∫£i l√† s·ªë nguy√™n h·ª£p l·ªá. S·ª≠ d·ª•ng m·∫∑c ƒë·ªãnh.")
            # Set l·∫°i StringVar v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh
            # if hasattr(self, 'dub_custom_bg_music_volume_percent_str_var'):
            #     self.dub_custom_bg_music_volume_percent_str_var.set(str(int(default_volume_float * 100)))
            return default_volume_float
        except Exception as e:
            logging.error(f"L·ªói kh√¥ng mong mu·ªën khi l·∫•y gi√° tr·ªã √¢m l∆∞·ª£ng t√πy ch·ªânh: {e}")
            return default_volume_float


# H√†m ti·ªán √≠ch: Tr√≠ch xu·∫•t l·ªùi tho·∫°i thu·∫ßn t√∫y t·ª´ m·ªôt kh·ªëi text (c√≥ th·ªÉ ch·ª©a metadata SRT)
    def dub_extract_pure_dialog_from_selection(self, selected_text_block):
        """Tr√≠ch xu·∫•t l·ªùi tho·∫°i thu·∫ßn t√∫y, lo·∫°i b·ªè metadata hi·ªÉn th·ªã trong textbox."""
        if not selected_text_block:
            return ""
        selected_text_block = selected_text_block.strip()
        display_metadata_pattern = r"^--- M·ª•c #\d+ \[[^\]]+\] ---$" # ƒêi·ªÅu ch·ªânh pattern cho kh·ªõp v·ªõi dub_refresh_script_textbox
        timecode_pattern = r"^\d{2}:\d{2}:\d{2}[,.]\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}[,.]\d{3}$"
        index_pattern = r"^\d+$"

        lines = selected_text_block.splitlines()
        is_likely_plain_text_input = True
        if len(lines) > 1 or "-->" in selected_text_block or "--- M·ª•c #" in selected_text_block:
            is_likely_plain_text_input = False

        if is_likely_plain_text_input and len(lines) == 1:
            return selected_text_block

        dialog_lines = []
        for i, line in enumerate(lines):
            stripped_line = line.strip()
            if not stripped_line:
                if dialog_lines and dialog_lines[-1].strip():
                    dialog_lines.append("")
                continue
            if re.match(display_metadata_pattern, stripped_line) or \
               re.match(timecode_pattern, stripped_line):
                continue
            is_likely_srt_index = False
            if re.match(index_pattern, stripped_line):
                if i + 1 < len(lines) and re.match(timecode_pattern, lines[i+1].strip()):
                    is_likely_srt_index = True
                elif i > 0 and not (re.match(display_metadata_pattern, lines[i-1].strip()) or re.match(timecode_pattern, lines[i-1].strip())):
                    pass
                elif i == 0 and (i + 1 >= len(lines) or not re.match(timecode_pattern, lines[i+1].strip())):
                    pass
            if is_likely_srt_index:
                continue
            dialog_lines.append(line)
        return "\n".join(dialog_lines).strip()



# H√†m h√†nh ƒë·ªông: Nghe th·ª≠ d√≤ng/ƒëo·∫°n ƒë∆∞·ª£c ch·ªçn trong textbox k·ªãch b·∫£n c·ªßa tab Thuy·∫øt Minh
    def dub_preview_current_line(self):
        """Nghe th·ª≠ TTS cho text ƒë∆∞·ª£c ch·ªçn ho·∫∑c to√†n b·ªô n·ªôi dung trong self.dub_script_textbox."""
        
        selected_text_from_sel_tag = ""
        text_to_preview = ""
        source_info = "" # ƒê·ªÉ bi·∫øt ngu·ªìn text l√† t·ª´ ƒë√¢u (ch·ªçn, to√†n b·ªô, hay t·ª´ srt_data)

        if hasattr(self, 'dub_script_textbox') and self.dub_script_textbox and self.dub_script_textbox.winfo_exists():
            try:
                selected_text_from_sel_tag = self.dub_script_textbox.get("sel.first", "sel.last")
            except Exception: 
                pass # Kh√¥ng c√≥ g√¨ ƒë∆∞·ª£c ch·ªçn

            if selected_text_from_sel_tag.strip():
                # ∆Øu ti√™n text ƒë∆∞·ª£c ch·ªçn
                text_to_preview = self.dub_extract_pure_dialog_from_selection(selected_text_from_sel_tag)
                source_info = "ƒëo·∫°n ƒë∆∞·ª£c ch·ªçn"
                # Fallback n·∫øu h√†m extract tr·∫£ v·ªÅ r·ªóng nh∆∞ng text g·ªëc c√≥ n·ªôi dung
                if not text_to_preview.strip() and selected_text_from_sel_tag.strip():
                    text_to_preview = selected_text_from_sel_tag.strip() # D√πng text g·ªëc ƒë√£ ch·ªçn
                    source_info = "ƒëo·∫°n ƒë∆∞·ª£c ch·ªçn (th√¥)"
            else:
                # N·∫øu kh√¥ng c√≥ g√¨ ƒë∆∞·ª£c ch·ªçn, l·∫•y to√†n b·ªô n·ªôi dung textbox
                full_textbox_content = self.dub_script_textbox.get("1.0", "end-1c").strip()
                if full_textbox_content:
                    text_to_preview = self.dub_extract_pure_dialog_from_selection(full_textbox_content)
                    source_info = "to√†n b·ªô k·ªãch b·∫£n"
                    if not text_to_preview.strip() and full_textbox_content:
                        text_to_preview = full_textbox_content
                        source_info = "to√†n b·ªô k·ªãch b·∫£n (th√¥)"
                elif hasattr(self, 'dub_srt_data') and self.dub_srt_data:
                    # N·∫øu textbox r·ªóng nh∆∞ng c√≥ self.dub_srt_data (v√≠ d·ª• t·ª´ file SRT ƒë√£ t·∫£i)
                    all_dialog_lines = [item.get("text", "") for item in self.dub_srt_data if item.get("text", "").strip()]
                    if all_dialog_lines:
                        text_to_preview = "\n".join(all_dialog_lines).strip() # N·ªëi t·∫•t c·∫£ c√°c d√≤ng tho·∫°i l·∫°i
                        source_info = "to√†n b·ªô k·ªãch b·∫£n ƒë√£ t·∫£i"
        else:
            logging.warning("[DubPreview] dub_script_textbox ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o cho preview.")
            messagebox.showinfo("Th√¥ng b√°o", "Textbox k·ªãch b·∫£n ch∆∞a s·∫µn s√†ng.", parent=self)
            return
        
        if not text_to_preview.strip():
            messagebox.showinfo("Th√¥ng tin", "Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ nghe th·ª≠.", parent=self)
            # G·ªçi h√†m c·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t n·∫øu c√≥, v√¨ kh√¥ng c√≥ g√¨ ƒë·ªÉ preview
            if hasattr(self, '_update_dub_script_controls_state'):
                 self.after(0, self._update_dub_script_controls_state)
            return

        selected_engine = self.dub_selected_tts_engine_var.get()
        preview_text_for_status = text_to_preview.replace('\n', ' ')[:60] + "..." if len(text_to_preview.replace('\n', ' ')) > 60 else text_to_preview.replace('\n', ' ')
        
        # C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i v·ªõi emoji
        self.update_status(f"üîä Nghe th·ª≠ ({source_info}) v·ªõi {selected_engine}: '{preview_text_for_status}'")

        # Thay ƒë·ªïi text v√† state c·ªßa n√∫t Nghe th·ª≠
        if hasattr(self, 'dub_preview_button') and self.dub_preview_button and self.dub_preview_button.winfo_exists():
            self.dub_preview_button.configure(text="...", state=ctk.DISABLED)
            logging.info(f"[DubPreview] ƒê√£ ƒë·∫∑t n√∫t Nghe th·ª≠: text='...', state='disabled'")
        else:
            logging.warning("[DubPreview] Kh√¥ng t√¨m th·∫•y dub_preview_button ƒë·ªÉ c·∫•u h√¨nh khi b·∫Øt ƒë·∫ßu nghe th·ª≠.")
        
        # ƒê·∫∑t c·ªù v√† qu·∫£n l√Ω timer cho t√°c v·ª• "Nghe th·ª≠"
        self.is_performing_single_task = True 
        logging.debug("[DubPreview] ƒê√£ ƒë·∫∑t is_performing_single_task = True.")
        
        # Ch·ªâ kh·ªüi ƒë·ªông/reset start_time n·∫øu kh√¥ng c√≥ t√°c v·ª• n·ªÅn n√†o kh√°c ƒëang ch·∫°y timer
        # Ho·∫∑c n·∫øu self.start_time ƒëang l√† None (nghƒ©a l√† timer ch∆∞a ch·∫°y cho t√°c v·ª• n√†o)
        any_other_main_task_using_timer = (
            self.is_subbing or self.is_downloading or self.is_loading_model_for_timer or 
            self.dub_is_processing or self.is_creating_slideshow or 
            self.is_gpt_processing_script or self.is_dalle_processing
        )
        if not any_other_main_task_using_timer or self.start_time is None:
            self.start_time = time.time()
            logging.debug(f"[DubPreview] ƒê·∫∑t start_time cho Nghe th·ª≠. C√°c t√°c v·ª• ch√≠nh kh√°c c√≥ ƒëang ch·∫°y timer kh√¥ng: {any_other_main_task_using_timer}")
            # K√≠ch ho·∫°t v√≤ng l·∫∑p update_time_realtime n·∫øu n√≥ ch∆∞a ch·∫°y
            # H√†m update_time_realtime s·∫Ω t·ª± ki·ªÉm tra active_timer_task_exists
            self.after(1000, self.update_time_realtime) 
        else:
            logging.debug(f"[DubPreview] M·ªôt t√°c v·ª• ch√≠nh kh√°c ƒëang s·ª≠ d·ª•ng timer. Kh√¥ng reset start_time cho Nghe th·ª≠.")

        # G·ªçi h√†m _set_dubbing_tab_ui_state ƒë·ªÉ n√≥ nh·∫≠n bi·∫øt is_performing_single_task
        if hasattr(self, '_set_dubbing_tab_ui_state'):
            # ch·∫°y tr·ªÖ m·ªôt nh·ªãp ƒë·ªÉ UI k·ªãp c·∫≠p nh·∫≠t
            self.after(10, lambda: self._set_dubbing_tab_ui_state())

        thread = threading.Thread(target=self.dub_execute_tts_preview_thread,
                                 args=(text_to_preview, selected_engine),
                                 daemon=True, 
                                 name=f"DubTTSPreviewThread_{selected_engine}")
        thread.start()



# H√†m lu·ªìng: Th·ª±c thi vi·ªác t·∫°o v√† ph√°t √¢m thanh preview cho tab Thuy·∫øt Minh
    def dub_execute_tts_preview_thread(self, text_to_preview, selected_engine):
        """Lu·ªìng th·ª±c hi·ªán g·ªçi TTS v√† ph√°t √¢m thanh preview."""
        success = False
        preview_file_path = None 
        context_log = f"[Dubbing_Preview_{selected_engine}]"

        try:
            # X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n file preview v√† h√†m speak t∆∞∆°ng ·ª©ng
            speak_function = None
            # M·∫∑c ƒë·ªãnh preview l√† .mp3 cho c√°c API
            preview_extension = ".mp3" 

            if selected_engine == "OpenAI TTS":
                preview_file_path = self.dub_openai_output_mp3_filename 
                speak_function = self.dub_speak_with_openai
            elif selected_engine == "Google Cloud TTS":
                preview_file_path = self.dub_google_output_mp3_filename
                speak_function = self.dub_speak_with_google
            elif selected_engine == "Google Translate (gTTS)":
                preview_file_path = self.dub_gtts_output_mp3_filename
                speak_function = self.dub_speak_with_gtts

            elif selected_engine == "Gi·ªçng ƒë·ªçc H·ªá th·ªëng (Offline)":
                preview_extension = ".wav"
                # T·∫°o t√™n file preview ri√™ng cho system TTS
                preview_file_path = os.path.join(self.temp_folder, f"dub_system_tts_preview{preview_extension}")
                if HAS_PYTTSX3 and callable(getattr(self, 'dub_speak_with_system_tts', None)):
                    speak_function = self.dub_speak_with_system_tts
                else:
                    logging.error(f"{context_log} pyttsx3 kh√¥ng kh·∫£ d·ª•ng ho·∫∑c h√†m x·ª≠ l√Ω ch∆∞a c√≥.")
                    self.after(0, lambda: self.update_status(f"{context_log} L·ªói: pyttsx3 ch∆∞a s·∫µn s√†ng."))
            
            if not preview_file_path and not speak_function: # N·∫øu kh√¥ng c√≥ engine n√†o kh·ªõp
                error_msg = f"{context_log} L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c file preview ho·∫∑c h√†m speak cho engine '{selected_engine}'."
                logging.error(error_msg)
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                # K√≠ch ho·∫°t l·∫°i n√∫t nghe th·ª≠ trong kh·ªëi finally
                return 

            if preview_file_path and os.path.exists(preview_file_path):
                try:
                    os.remove(preview_file_path)
                except Exception as e_del:
                    logging.warning(f"{context_log} Kh√¥ng th·ªÉ x√≥a file preview c≈© '{os.path.basename(preview_file_path)}': {e_del}")
            
            if speak_function:
                text_for_engine = text_to_preview
                if selected_engine == "Google Cloud TTS" and \
                   hasattr(self, 'dub_use_google_ssml_var') and self.dub_use_google_ssml_var.get() and \
                   not (text_to_preview.strip().lower().startswith("<speak>") and text_to_preview.strip().lower().endswith("</speak>")):
                    text_for_engine = self.dub_generate_basic_ssml(text_to_preview)

                success = speak_function(text_for_engine, preview_file_path, is_preview=True)
            # else: (tr∆∞·ªùng h·ª£p speak_function l√† None ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü tr√™n)
            
            if success:
                pass # C√°c h√†m speak_with_... ƒë√£ x·ª≠ l√Ω playsound v√† update_status khi is_preview=True
            else: 
                current_status = self.status_label.cget("text") if hasattr(self, 'status_label') and self.status_label else ""
                if not current_status.lower().startswith("l·ªói") and not "th·∫•t b·∫°i" in current_status.lower():
                     self.after(0, lambda: self.update_status(f"{context_log} Nghe th·ª≠ th·∫•t b·∫°i ho·∫∑c kh√¥ng c√≥ √¢m thanh."))

        except Exception as e:
            error_msg = f"{context_log} L·ªói nghi√™m tr·ªçng khi nghe th·ª≠: {e}"
            logging.error(error_msg, exc_info=True)
            is_main_dub_processing = hasattr(self, 'dub_is_processing') and self.dub_is_processing
            if not is_main_dub_processing: # Ch·ªâ hi·ªán l·ªói UI n·∫øu kh√¥ng ph·∫£i ƒëang batch
                self.after(0, lambda msg=error_msg: self.update_status(msg))
                self.after(0, lambda msg=error_msg: messagebox.showerror("L·ªói Nghe Th·ª≠ Nghi√™m Tr·ªçng", msg, parent=self))

        finally:
            if hasattr(self, 'is_performing_single_task'):
                self.is_performing_single_task = False
                logging.debug("[DubTTSPreviewThread] ƒê√£ reset is_performing_single_task = False.")
                if not (self.is_subbing or self.is_downloading or self.is_loading_model_for_timer or self.dub_is_processing or self.is_creating_slideshow or self.is_gpt_processing_script or self.is_dalle_processing):
                    self.start_time = None
                    logging.debug("[DubTTSPreviewThread] Timer reset do kh√¥ng c√≤n t√°c v·ª• n√†o kh√°c.")
            
            is_main_dub_processing_final = hasattr(self, 'dub_is_processing') and self.dub_is_processing
            
            # --- KH√îI PH·ª§C N√öT NGHE TH·ª¨ ---
            if not is_main_dub_processing_final:  # Ch·ªâ kh√¥i ph·ª•c n·∫øu kh√¥ng c√≥ batch dubbing n√†o ƒëang ch·∫°y
                btn = getattr(self, 'dub_preview_button', None)
                if btn and btn.winfo_exists():
                    try:
                        try:
                            is_active = self._is_app_fully_activated()
                        except Exception:
                            is_active = False

                        if is_active:
                            # M·ªü l·∫°i: nh√£n chu·∫©n l√† "üîä Nghe th·ª≠ Script" (state s·∫Ω ƒë∆∞·ª£c tinh ch·ªânh ti·∫øp b·ªüi _update_dub_script_controls_state)
                            if hasattr(self, '_btn_unlock'):
                                self.after(0, lambda: self._btn_unlock(btn, enable=True, fallback_text="üîä Nghe th·ª≠ Script"))
                            else:
                                self.after(0, lambda: btn.configure(text="üîä Nghe th·ª≠ Script", state=ctk.NORMAL))
                        else:
                            # Ch∆∞a k√≠ch ho·∫°t ‚Üí kho√° + nh√£n "üîí K√≠ch ho·∫°t"
                            if hasattr(self, '_btn_lock'):
                                self.after(0, lambda: self._btn_lock(btn, lock_text="üîí K√≠ch ho·∫°t"))
                            else:
                                self.after(0, lambda: btn.configure(text="üîí K√≠ch ho·∫°t", state=ctk.DISABLED))

                        logging.info(f"[DubTTSPreviewThread] ƒê√£ kh√¥i ph·ª•c n√∫t Nghe th·ª≠ (active={is_active}).")

                        # ƒê·ªÉ _update_dub_script_controls_state tinh ch·ªânh l·∫°i theo n·ªôi dung textbox
                        if hasattr(self, '_update_dub_script_controls_state'):
                            self.after(10, self._update_dub_script_controls_state)
                    except Exception:
                        pass
            # --- K·∫æT TH√öC KH√îI PH·ª§C N√öT ---
            
            current_status_text_preview_final = ""
            if hasattr(self, 'status_label') and self.status_label and self.status_label.winfo_exists():
                current_status_text_preview_final = self.status_label.cget("text")
            
            is_specific_preview_message_showing = any(prefix in current_status_text_preview_final for prefix in ["‚úÖ [Dubbing_Preview", "üîä [Dubbing_Preview", "‚ö†Ô∏è [Dubbing_Preview", "‚ùå [Dubbing_Preview", "üõë [Dubbing_Preview"])
            
            if not is_specific_preview_message_showing:
                if success and "üîä" in current_status_text_preview_final and "ƒêang ph√°t" in current_status_text_preview_final :
                     self.after(100, lambda: self.update_status("‚ÑπÔ∏è Nghe th·ª≠ k·∫øt th√∫c."))
                elif not success: # success l√† bi·∫øn ƒë∆∞·ª£c ƒë·∫∑t trong kh·ªëi try
                     self.after(100, lambda: self.update_status("‚ö†Ô∏è Nghe th·ª≠ g·∫∑p s·ª± c·ªë ho·∫∑c b·ªã h·ªßy."))


# Trong l·ªõp SubtitleApp
    def dub_select_output_dir(self):
        initial_dir = self.dub_output_path_var.get() or get_default_downloads_folder() # Ho·∫∑c m·ªôt th∆∞ m·ª•c m·∫∑c ƒë·ªãnh kh√°c
        path = filedialog.askdirectory(initialdir=initial_dir, parent=self)
        if path:
            self.dub_output_path_var.set(path)
            # L∆∞u v√†o config n·∫øu c·∫ßn
            self.cfg["dub_output_path"] = path 
            # self.save_current_config() # C√¢n nh·∫Øc vi·ªác g·ªçi h√†m l∆∞u t·ªïng th·ªÉ
            self.update_status(f"Th∆∞ m·ª•c l∆∞u video thuy·∫øt minh: {path}")


# Nh√≥m H√†m x·ª≠ l√Ω ch·ªçn foder ·∫£nh
    def dub_update_image_folder_controls_visibility(self, *args):
        """
        C·∫≠p nh·∫≠t tr·∫°ng th√°i v√† kh·∫£ nƒÉng hi·ªÉn th·ªã c·ªßa c√°c control li√™n quan ƒë·∫øn
        vi·ªác ch·ªçn th∆∞ m·ª•c ·∫£nh cho slideshow, C√ì X√âT ƒê·∫æN TR·∫†NG TH√ÅI B·∫¢N QUY·ªÄN.
        """
        # L·∫•y t·ª´ dubbing_view_frame
        dubbing_tab = getattr(self, 'dubbing_view_frame', None)
        if not dubbing_tab:
            return
        parent_frame = getattr(dubbing_tab, 'dub_slideshow_folder_frame', None)
        chk_box = getattr(dubbing_tab, 'dub_chk_use_image_folder', None)
        btn_browse = getattr(dubbing_tab, 'dub_btn_browse_image_folder', None)
        lbl_path = getattr(dubbing_tab, 'dub_lbl_image_folder_path', None)
        btn_load_video_single = getattr(dubbing_tab, 'dub_load_video_button', None)

        if not all(widget and hasattr(widget, 'winfo_exists') and widget.winfo_exists()
                   for widget in [parent_frame, chk_box, btn_browse, lbl_path, btn_load_video_single]):
            logging.debug("[ImageFolderVisibility] M·ªôt ho·∫∑c nhi·ªÅu widget slideshow folder ch∆∞a s·∫µn s√†ng.")
            return

        # --- KI·ªÇM TRA B·∫¢N QUY·ªÄN ---
        try:
            is_app_really_active = self._is_app_fully_activated()
        except Exception:
            is_app_really_active = False

        unactivated_text_short = "üîí K√≠ch ho·∫°t"  # D√πng chung cho c√°c n√∫t b·ªã kh√≥a
        # (tu·ª≥: gi·ªØ l·∫°i activation_status_check n·∫øu b·∫°n ch·ªâ d√πng ƒë·ªÉ log)
        # activation_status_check = self.cfg.get('activation_status', 'INACTIVE')


        use_folder_mode = self.dub_use_image_folder_var.get()
        is_dub_processing = hasattr(self, 'dub_is_processing') and self.dub_is_processing

        # C·∫≠p nh·∫≠t tr·∫°ng th√°i checkbox ch√≠nh (ph·ª• thu·ªôc processing v√† activation)
        checkbox_main_state = ctk.DISABLED
        if is_app_really_active and not is_dub_processing:
            checkbox_main_state = ctk.NORMAL
        chk_box.configure(state=checkbox_main_state)

        if use_folder_mode:
            # Ch·∫ø ƒë·ªô ch·ªçn th∆∞ m·ª•c ·∫£nh ƒëang B·∫¨T
            if not btn_browse.winfo_ismapped():
                btn_browse.pack(in_=parent_frame, pady=(0,5), padx=10, anchor="w", fill="x", after=chk_box)
            
            # N√∫t "Ch·ªçn th∆∞ m·ª•c ·∫£nh..."
            btn_browse_state_final = ctk.DISABLED
            if is_app_really_active and not is_dub_processing: # Ch·ªâ b·∫≠t n·∫øu active v√† kh√¥ng processing
                btn_browse_state_final = ctk.NORMAL
            btn_browse.configure(state=btn_browse_state_final)


            if not lbl_path.winfo_ismapped():
                lbl_path.pack(in_=parent_frame, pady=(0,10), padx=10, anchor="w", fill="x", after=btn_browse)
            current_folder_path = self.dub_selected_image_folder_path_var.get()
            lbl_path.configure(text=f"Th∆∞ m·ª•c ƒë√£ ch·ªçn: {current_folder_path if current_folder_path else '(Ch∆∞a ch·ªçn)'}")

            # V√¥ hi·ªáu h√≥a n√∫t ch·ªçn video/·∫£nh ƒë∆°n l·∫ª v√† ƒë·∫∑t text ph√π h·ª£p
            btn_load_video_single_text = "D√πng Th∆∞ m·ª•c ·∫¢nh" if is_app_really_active else unactivated_text_short
            btn_load_video_single.configure(state=ctk.DISABLED, text=btn_load_video_single_text)
            
            # N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô th∆∞ m·ª•c, th√¨ l·ª±a ch·ªçn video/·∫£nh ƒë∆°n l·∫ª ph·∫£i b·ªã x√≥a
            if hasattr(self, 'dub_current_video_path_for_queue_temp'): self.dub_current_video_path_for_queue_temp = ""
            if hasattr(self, 'dub_current_video_for_queue_display'): 
                self.dub_current_video_for_queue_display.set("(D√πng th∆∞ m·ª•c ·∫£nh)" if is_app_really_active else "(Ch∆∞a k√≠ch ho·∫°t)")

        else: # Ch·∫ø ƒë·ªô ch·ªçn th∆∞ m·ª•c ·∫£nh ƒëang T·∫ÆT
            if btn_browse.winfo_ismapped():
                btn_browse.pack_forget()
            btn_browse.configure(state=ctk.DISABLED)

            if lbl_path.winfo_ismapped():
                lbl_path.pack_forget()

            # K√≠ch ho·∫°t/V√¥ hi·ªáu h√≥a n√∫t ch·ªçn video/·∫£nh ƒë∆°n l·∫ª d·ª±a tr√™n b·∫£n quy·ªÅn v√† tr·∫°ng th√°i processing
            btn_load_video_single_text_final = "üé¨ Video/·∫¢nh..." if is_app_really_active else unactivated_text_short
            btn_load_video_single_state_final = ctk.DISABLED
            if is_app_really_active and not is_dub_processing:
                btn_load_video_single_state_final = ctk.NORMAL
            
            btn_load_video_single.configure(state=btn_load_video_single_state_final, text=btn_load_video_single_text_final)

        # L∆∞u c·∫•u h√¨nh (ch·ªâ khi kh√¥ng ph·∫£i ƒëang kh√¥i ph·ª•c t·ª´ task config)
        if not (hasattr(self, '_is_restoring_task_config') and self._is_restoring_task_config):
            self.cfg["dub_use_image_folder"] = use_folder_mode
        logging.debug(f"[ImageFolderVisibility] C·∫≠p nh·∫≠t UI. Folder mode: {use_folder_mode}, AppActive: {is_app_really_active}, Processing: {is_dub_processing}")

    def dub_browse_image_folder_for_slideshow(self):
        """M·ªü dialog cho ng∆∞·ªùi d√πng ch·ªçn th∆∞ m·ª•c ch·ª©a ·∫£nh cho slideshow."""
        if not hasattr(self, 'dub_selected_image_folder_path_var'):
            logging.error("[DubBrowseImageFolder] Bi·∫øn dub_selected_image_folder_path_var ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o.")
            return

        initial_dir_slideshow = self.dub_selected_image_folder_path_var.get() or \
                                (self.dub_output_path_var.get() or get_default_downloads_folder())

        folder_path = filedialog.askdirectory(
            title="Ch·ªçn Th∆∞ m·ª•c ch·ª©a ·∫¢nh cho Slideshow",
            initialdir=initial_dir_slideshow,
            parent=self
        )

        if not folder_path:
            logging.info("[DubBrowseImageFolder] Ng∆∞·ªùi d√πng ƒë√£ h·ªßy ch·ªçn th∆∞ m·ª•c.")
            if not self.dub_selected_image_folder_path_var.get() and hasattr(self, 'dub_use_image_folder_var'):
                # self.dub_use_image_folder_var.set(False) # T√πy ch·ªçn: b·ªè check n·∫øu h·ªßy v√† ch∆∞a c√≥ g√¨
                # self.dub_update_image_folder_controls_visibility()
                pass
            return

        self.dub_selected_image_folder_path_var.set(folder_path)
        if hasattr(self, 'dub_lbl_image_folder_path') and self.dub_lbl_image_folder_path.winfo_exists():
             self.dub_lbl_image_folder_path.configure(text=f"Th∆∞ m·ª•c ƒë√£ ch·ªçn: {folder_path}")

        self.cfg["dub_slideshow_image_folder"] = folder_path
        logging.info(f"[DubBrowseImageFolder] ƒê√£ ch·ªçn th∆∞ m·ª•c ·∫£nh: {folder_path}")
        self.update_status(f"Th∆∞ m·ª•c ·∫£nh Slideshow: {os.path.basename(folder_path)}")

        image_extensions_supported = ('.png', '.jpg', '.jpeg', '.bmp', '.webp', '.gif')
        image_paths_from_folder = []
        try:
            for item_name in os.listdir(folder_path):
                item_full_path = os.path.join(folder_path, item_name)
                if os.path.isfile(item_full_path) and item_name.lower().endswith(image_extensions_supported):
                    image_paths_from_folder.append(item_full_path)
            image_paths_from_folder.sort()
        except Exception as e_listdir:
            logging.error(f"[DubBrowseImageFolder] L·ªói khi ƒë·ªçc file t·ª´ th∆∞ m·ª•c '{folder_path}': {e_listdir}", exc_info=True)
            messagebox.showerror("L·ªói ƒê·ªçc Th∆∞ M·ª•c", f"Kh√¥ng th·ªÉ ƒë·ªçc danh s√°ch ·∫£nh t·ª´ th∆∞ m·ª•c ƒë√£ ch·ªçn.\nL·ªói: {e_listdir}", parent=self)
            return

        if not image_paths_from_folder:
            messagebox.showinfo("Kh√¥ng c√≥ ·∫¢nh", "Kh√¥ng t√¨m th·∫•y file ·∫£nh n√†o ƒë∆∞·ª£c h·ªó tr·ª£ trong th∆∞ m·ª•c ƒë√£ ch·ªçn.", parent=self)
            logging.warning(f"[DubBrowseImageFolder] Kh√¥ng t√¨m th·∫•y ·∫£nh trong th∆∞ m·ª•c: {folder_path}")
            return

        logging.info(f"[DubBrowseImageFolder] T√¨m th·∫•y {len(image_paths_from_folder)} ·∫£nh. Ki·ªÉm tra ngu·ªìn timing...")

        # --- Ph·∫ßn 1: Ki·ªÉm tra xem ƒë√£ c√≥ ngu·ªìn timing ch∆∞a TR∆Ø·ªöC KHI g·ªçi popup ---
        can_proceed_without_popup_folder = False
        current_timing_source_for_log_folder = "ch∆∞a x√°c ƒë·ªãnh"

        if hasattr(self, 'dub_audio_path_for_queue_temp') and \
           self.dub_audio_path_for_queue_temp and \
           os.path.exists(self.dub_audio_path_for_queue_temp) and \
           (self.dub_get_audio_duration_ms(self.dub_audio_path_for_queue_temp) or 0) > 0:
            can_proceed_without_popup_folder = True
            current_timing_source_for_log_folder = f"Audio ngo√†i ({os.path.basename(self.dub_audio_path_for_queue_temp)})"
            logging.info(f"[DubBrowseImageFolder-CheckTiming] ƒê√£ c√≥ audio ngo√†i h·ª£p l·ªá: {current_timing_source_for_log_folder}")

        if not can_proceed_without_popup_folder and \
           hasattr(self, 'dub_temp_srt_data_for_queue') and self.dub_temp_srt_data_for_queue:
            current_script_file_path_check_folder = getattr(self, 'dub_current_script_path_for_queue_temp', None)
            if current_script_file_path_check_folder and os.path.exists(current_script_file_path_check_folder) and \
               current_script_file_path_check_folder != "text_input":
                can_proceed_without_popup_folder = True
                current_timing_source_for_log_folder = f"File SRT ({os.path.basename(current_script_file_path_check_folder)})"
                logging.info(f"[DubBrowseImageFolder-CheckTiming] ƒê√£ c√≥ file SRT h·ª£p l·ªá: {current_timing_source_for_log_folder}")

        if not can_proceed_without_popup_folder and \
           hasattr(self, 'dub_script_textbox') and self.dub_script_textbox.winfo_exists():
            textbox_content_check_folder = self.dub_script_textbox.get("1.0", "end-1c").strip()
            if textbox_content_check_folder and not self._is_textbox_content_invalid_for_script(textbox_content_check_folder):
                can_proceed_without_popup_folder = True
                current_timing_source_for_log_folder = "N·ªôi dung Textbox"
                logging.info(f"[DubBrowseImageFolder-CheckTiming] ƒê√£ c√≥ n·ªôi dung textbox h·ª£p l·ªá: {current_timing_source_for_log_folder}")
        # --- K·∫øt th√∫c Ph·∫ßn 1 ---

        # --- Ph·∫ßn 2: Quy·∫øt ƒë·ªãnh g·ªçi popup hay t·∫°o slideshow ---
        if not can_proceed_without_popup_folder:
            logging.info("[DubBrowseImageFolder] Ch∆∞a c√≥ k·ªãch b·∫£n/audio ngo√†i h·ª£p l·ªá. S·∫Ω hi·ªÉn th·ªã popup y√™u c·∫ßu.")
            self.prompt_for_script_for_slideshow(image_paths_from_folder)
            return

        logging.info(f"[DubBrowseImageFolder] ƒê√£ c√≥ ngu·ªìn timing ({current_timing_source_for_log_folder}). B·∫Øt ƒë·∫ßu t·∫°o slideshow tr·ª±c ti·∫øp.")
        self.update_status(f"ƒêang chu·∫©n b·ªã t·∫°o video t·ª´ {len(image_paths_from_folder)} ·∫£nh (Th∆∞ m·ª•c: {os.path.basename(folder_path)}, Timing: {current_timing_source_for_log_folder})...")

        if hasattr(self, 'dub_btn_browse_image_folder') and self.dub_btn_browse_image_folder.winfo_exists():
             self.dub_btn_browse_image_folder.configure(state="disabled")
        if hasattr(self, 'dub_load_video_button') and self.dub_load_video_button.winfo_exists():
            self.dub_load_video_button.configure(state="disabled")
        if hasattr(self, 'dub_btn_add_to_queue') and self.dub_btn_add_to_queue.winfo_exists():
             self.dub_btn_add_to_queue.configure(state="disabled")

        # C·∫≠p nh·∫≠t t√™n hi·ªÉn th·ªã t·∫°m th·ªùi
        self.dub_current_video_for_queue_display.set(f"Th∆∞ m·ª•c: {os.path.basename(folder_path)} ({len(image_paths_from_folder)} ·∫£nh)")
        # self.dub_current_video_path_for_queue_temp s·∫Ω ƒë∆∞·ª£c set b·ªüi _create_video_from_images_thread

        thread = threading.Thread(target=self._create_video_from_images_thread,
                                 args=(image_paths_from_folder,),
                                 daemon=True,
                                 name="CreateSlideshowFromFolderThread")
        thread.start()



# H√†m m·ªü Popup t√πy ch·ªânh font
    def open_subtitle_style_settings_window(self):
        """M·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t Ki·ªÉu Ph·ª• ƒë·ªÅ."""
        if hasattr(self, '_subtitle_style_settings_win') and \
           self._subtitle_style_settings_win and \
           self._subtitle_style_settings_win.winfo_exists():
            self._subtitle_style_settings_win.focus()
            logging.info("C·ª≠a s·ªï c√†i ƒë·∫∑t Ki·ªÉu Ph·ª• ƒë·ªÅ ƒë√£ ƒë∆∞·ª£c m·ªü, ƒëang focus.")
            return

        logging.info("M·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t Ki·ªÉu Ph·ª• ƒë·ªÅ...")
        # Truy·ªÅn c√°c bi·∫øn style ƒë√£ t·∫°o trong __init__ v√†o ƒë√¢y n·∫øu c·∫ßn
        # Nh∆∞ng hi·ªán t·∫°i SubtitleStyleSettingsWindow truy c·∫≠p tr·ª±c ti·∫øp qua self.master_app
        self._subtitle_style_settings_win = SubtitleStyleSettingsWindow(master_app=self)


# H√†m m·ªü Popup Logo/Intro
    def open_branding_settings_window(self):
        """M·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t Logo, Intro, Outro."""
        # Ki·ªÉm tra xem c·ª≠a s·ªï ƒë√£ m·ªü ch∆∞a
        if hasattr(self, '_branding_settings_win') and \
           self._branding_settings_win and \
           self._branding_settings_win.winfo_exists():
            self._branding_settings_win.focus()
            logging.info("C·ª≠a s·ªï c√†i ƒë·∫∑t Branding ƒë√£ ƒë∆∞·ª£c m·ªü, ƒëang focus.")
            return

        logging.info("M·ªü c·ª≠a s·ªï c√†i ƒë·∫∑t Branding...")
        self._branding_settings_win = BrandingSettingsWindow(master_app=self)
        # self._branding_settings_win.wait_window() # N·∫øu mu·ªën ch·∫∑n t∆∞∆°ng t√°c ho√†n to√†n cho ƒë·∫øn khi popup ƒë√≥ng



# CHU·ªñI H√ÄM X·ª¨ L√ù CH√àN LOGO/INTRO.OUTRO

# H√ÄM X·ª¨ L√ù CH√çNH CH·ª®C NƒÇNG CH√àN LOGO, INTRO/OUTRO
    def _apply_branding_elements_worker(self, input_video_path, final_output_path_suggestion, callback_after_branding_with_context):
        ffmpeg_executable = find_ffmpeg()
        if not ffmpeg_executable:
            logging.error("Branding Worker Error: FFmpeg kh√¥ng t√¨m th·∫•y.")
            if callback_after_branding_with_context:
                self.after(0, callback_after_branding_with_context, False, input_video_path, "FFmpeg kh√¥ng t√¨m th·∫•y.")
            return

        with keep_awake(f"Branding: {os.path.basename(input_video_path)}"):
            temp_dir_for_branding = os.path.join(self.temp_folder, f"branding_job_{uuid.uuid4().hex[:6]}")
            os.makedirs(temp_dir_for_branding, exist_ok=True)
            logging.info(f"Branding Worker: Th∆∞ m·ª•c t·∫°m cho branding: {temp_dir_for_branding}")

            video_input_for_current_step = os.path.abspath(input_video_path)
            processed_video_path_after_last_step = video_input_for_current_step
            final_video_path_for_callback = video_input_for_current_step
            
            intermediate_files_to_delete = []

            # --- Helper function cho LOGO (GI·ªÆ NGUY√äN CODE G·ªêC C·ª¶A B·∫†N) ---
            def apply_logo_to_video(input_video_for_logo, output_logo_temp_basename):
                nonlocal intermediate_files_to_delete
                temp_output_video_with_logo_path = os.path.join(temp_dir_for_branding, f"{output_logo_temp_basename}.mkv")
                logging.info(f"Branding Worker (apply_logo_to_video): ƒêang x·ª≠ l√Ω ch√®n Logo v√†o: {os.path.basename(input_video_for_logo)}")
                
                opacity_percent = self.branding_logo_opacity_var.get()
                opacity_float = opacity_percent / 100.0
                size_percentage = self.branding_logo_size_percent_var.get()
                margin_pixels = self.branding_logo_margin_px_var.get()
                logo_position_key = self.branding_logo_position_var.get()
                logo_file_path_for_ffmpeg = self.branding_logo_path_var.get()

                main_video_fps_str_logo, main_video_duration_str_logo, main_video_width_str_logo, main_video_height_str_logo = "30", "60", "1280", "720"
                current_ffprobe_exec_logo = find_ffprobe()
                if current_ffprobe_exec_logo:
                    try:
                        cmd_probe_fps_logo = [current_ffprobe_exec_logo, "-v", "error", "-select_streams", "v:0", "-show_entries", "stream=r_frame_rate", "-of", "default=noprint_wrappers=1:nokey=1", input_video_for_logo]
                        probe_res_fps_logo = subprocess.run(cmd_probe_fps_logo, capture_output=True, text=True, timeout=10, creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0, check=False)
                        if probe_res_fps_logo.returncode == 0 and probe_res_fps_logo.stdout.strip():
                            fps_raw_logo = probe_res_fps_logo.stdout.strip()
                            if '/' in fps_raw_logo: num_s, den_s = fps_raw_logo.split('/'); main_video_fps_str_logo = str(float(num_s) / float(den_s)) if den_s != '0' else "30"
                            elif fps_raw_logo.replace('.', '', 1).isdigit(): main_video_fps_str_logo = fps_raw_logo
                        cmd_probe_dur_logo = [current_ffprobe_exec_logo, "-v", "error", "-show_entries", "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", input_video_for_logo]
                        probe_res_dur_logo = subprocess.run(cmd_probe_dur_logo, capture_output=True, text=True, timeout=10, creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0, check=False)
                        if probe_res_dur_logo.returncode == 0 and probe_res_dur_logo.stdout.strip().lower() != "n/a": main_video_duration_str_logo = probe_res_dur_logo.stdout.strip()
                        cmd_probe_res_dim_logo = [current_ffprobe_exec_logo, "-v", "error", "-select_streams", "v:0", "-show_entries", "stream=width,height", "-of", "csv=s=x:p=0", input_video_for_logo]
                        probe_res_dim_run_logo = subprocess.run(cmd_probe_res_dim_logo, capture_output=True, text=True, timeout=10, creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0, check=False)
                        if probe_res_dim_run_logo.returncode == 0 and probe_res_dim_run_logo.stdout.strip():
                            w_h_logo = probe_res_dim_run_logo.stdout.strip().split('x')
                            main_video_width_str_logo, main_video_height_str_logo = (w_h_logo[0], w_h_logo[1]) if len(w_h_logo) == 2 and w_h_logo[0].isdigit() and w_h_logo[1].isdigit() else ("1280", "720")
                        logging.info(f"Branding Worker (apply_logo) - Video Info: Res={main_video_width_str_logo}x{main_video_height_str_logo}, FPS={main_video_fps_str_logo}, Duration={main_video_duration_str_logo}s")
                    except Exception as e_probe_logo_inner: logging.warning(f"Branding Worker (apply_logo): L·ªói ffprobe: {e_probe_logo_inner}. D√πng m·∫∑c ƒë·ªãnh.")
                else: logging.warning("Branding Worker (apply_logo): ffprobe kh√¥ng t√¨m th·∫•y.")

                main_video_width_for_calc_logo_inner = int(main_video_width_str_logo)
                calculated_logo_width_inner = int(main_video_width_for_calc_logo_inner * (size_percentage / 100.0))
                calculated_logo_width_inner = max(10, calculated_logo_width_inner)

                x_pos_expr_logo_inner = f"{margin_pixels}"
                y_pos_expr_logo_inner = f"{margin_pixels}"
                if logo_position_key == "top_left": x_pos_expr_logo_inner = f"{margin_pixels}"; y_pos_expr_logo_inner = f"{margin_pixels}"
                elif logo_position_key == "top_right": x_pos_expr_logo_inner = f"main_w-overlay_w-{margin_pixels}"; y_pos_expr_logo_inner = f"{margin_pixels}"
                elif logo_position_key == "bottom_left": x_pos_expr_logo_inner = f"{margin_pixels}"; y_pos_expr_logo_inner = f"main_h-overlay_h-{margin_pixels}"
                elif logo_position_key == "bottom_right": x_pos_expr_logo_inner = f"main_w-overlay_w-{margin_pixels}"; y_pos_expr_logo_inner = f"main_h-overlay_h-{margin_pixels}"
                elif logo_position_key == "center": x_pos_expr_logo_inner = "(main_w-overlay_w)/2"; y_pos_expr_logo_inner = "(main_h-overlay_h)/2"

                filter_complex_logo_str_inner = (f"[1:v]colorchannelmixer=aa={opacity_float:.2f},scale={calculated_logo_width_inner}:-1[logo_scaled];[0:v][logo_scaled]overlay=x='{x_pos_expr_logo_inner}':y='{y_pos_expr_logo_inner}':eof_action=pass[video_with_logo_applied];[video_with_logo_applied]scale={main_video_width_str_logo}:{main_video_height_str_logo}:flags=bicubic,format=yuv420p[final_video_output_logo]")
                
                ffmpeg_logo_cmd_full_inner = [ffmpeg_executable, "-y", "-i", input_video_for_logo, "-loop", "1", "-framerate", main_video_fps_str_logo, "-t", main_video_duration_str_logo, "-i", logo_file_path_for_ffmpeg, "-filter_complex", filter_complex_logo_str_inner, "-map", "[final_video_output_logo]", "-map", "0:a?", "-map", "0:s?", "-c:v", "libx264", "-preset", self.cfg.get("ffmpeg_preset", "medium"), "-crf", str(self.cfg.get("ffmpeg_crf", 22)), "-profile:v", "main", "-level", "4.0", "-pix_fmt", "yuv420p", "-movflags", "+faststart"]
                
                if self.check_for_audio_stream(input_video_for_logo):
                    ffmpeg_logo_cmd_full_inner.extend(["-c:a", "aac", "-b:a", "192k"])
                else:
                    logging.info(f"Branding Worker (apply_logo_to_video): Video '{os.path.basename(input_video_for_logo)}' kh√¥ng c√≥ audio, output logo s·∫Ω kh√¥ng c√≥ audio.")

                temp_output_video_with_logo_path = os.path.join(temp_dir_for_branding, f"{output_logo_temp_basename}.mp4")
                ffmpeg_logo_cmd_full_inner.extend(["-c:s", "mov_text", "-shortest", temp_output_video_with_logo_path])
                
                try:
                    cmd_params_logo = ffmpeg_logo_cmd_full_inner[1:]  # b·ªè executable, gi·ªØ tham s·ªë
                    ffmpeg_run_command(
                        cmd_params_logo,
                        process_name=f"Branding_ApplyLogo_{os.path.basename(input_video_for_logo)}",
                        stop_event=self.stop_event if hasattr(self, 'stop_event') else None,
                        set_current_process=lambda p: setattr(self, 'current_process', p),
                        clear_current_process=lambda: setattr(self, 'current_process', None),
                        timeout_seconds=1800,
                    )
                    if not os.path.exists(temp_output_video_with_logo_path) or os.path.getsize(temp_output_video_with_logo_path) < 1024:
                        raise RuntimeError("FFmpeg (ch√®n logo): File output logo kh√¥ng h·ª£p l·ªá.")
                    if os.path.abspath(input_video_for_logo) != os.path.abspath(input_video_path) and input_video_for_logo not in intermediate_files_to_delete:
                        intermediate_files_to_delete.append(input_video_for_logo)
                    return temp_output_video_with_logo_path
                except Exception as e_logo_apply:
                    raise RuntimeError(f"L·ªói khi ch√®n logo: {e_logo_apply}")

            # --- Helper function l·∫•y th·ªùi l∆∞·ª£ng (GI·ªÆ NGUY√äN CODE G·ªêC C·ª¶A B·∫†N) ---
            def get_video_duration_s(video_path_to_probe, ffprobe_exe_path):
                if not ffprobe_exe_path or not os.path.exists(video_path_to_probe):
                    logging.warning(f"get_video_duration_s: ffprobe kh√¥ng c√≥ ho·∫∑c file '{os.path.basename(video_path_to_probe)}' kh√¥ng t·ªìn t·∫°i. Tr·∫£ v·ªÅ 60s.")
                    return 60.0
                try:
                    cmd_probe_duration = [ffprobe_exe_path, "-v", "error", "-show_entries", "format=duration", "-of", "default=noprint_wrappers=1:nokey=1", video_path_to_probe]
                    result_duration = subprocess.run(cmd_probe_duration, capture_output=True, text=True, timeout=10, check=False, creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0)
                    if result_duration.returncode == 0 and result_duration.stdout.strip() and result_duration.stdout.strip().lower() != "n/a":
                        duration = float(result_duration.stdout.strip())
                        logging.debug(f"get_video_duration_s: Th·ªùi l∆∞·ª£ng c·ªßa '{os.path.basename(video_path_to_probe)}' l√† {duration:.3f}s")
                        return duration
                    else:
                        logging.warning(f"get_video_duration_s: ffprobe l·ªói ho·∫∑c kh√¥ng tr·∫£ v·ªÅ duration cho '{os.path.basename(video_path_to_probe)}'. Output: '{result_duration.stdout.strip()}'. Tr·∫£ v·ªÅ 60s.")
                        return 60.0
                except Exception as e_get_dur:
                    logging.warning(f"get_video_duration_s: Exception khi l·∫•y duration cho '{os.path.basename(video_path_to_probe)}': {e_get_dur}. Tr·∫£ v·ªÅ 60s.")
                    return 60.0
            
            try:
                target_width, target_height, target_fps, target_sar = "1280", "720", "30", "1/1"
                current_ffprobe_exec = find_ffprobe()
                if current_ffprobe_exec:
                    try:
                        cmd_probe_geo = [current_ffprobe_exec, "-v", "error", "-select_streams", "v:0", "-show_entries", "stream=width,height,sample_aspect_ratio", "-of", "default=noprint_wrappers=1:nokey=1", video_input_for_current_step]
                        probe_res_geo = subprocess.run(cmd_probe_geo, capture_output=True, text=True, timeout=10, creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0, check=False)
                        if probe_res_geo.returncode == 0 and probe_res_geo.stdout.strip():
                            lines = probe_res_geo.stdout.strip().split('\n')
                            if len(lines) >= 1 and lines[0].strip() and lines[0].strip() != "N/A": target_width = lines[0].strip()
                            if len(lines) >= 2 and lines[1].strip() and lines[1].strip() != "N/A": target_height = lines[1].strip()
                            if len(lines) >= 3 and lines[2].strip() and lines[2].strip() != "N/A" and lines[2].strip() != "0:1": target_sar = lines[2].strip()
                        cmd_probe_fps = [current_ffprobe_exec, "-v", "error", "-select_streams", "v:0", "-show_entries", "stream=r_frame_rate", "-of", "default=noprint_wrappers=1:nokey=1", video_input_for_current_step]
                        probe_res_fps = subprocess.run(cmd_probe_fps, capture_output=True, text=True, timeout=10, creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0, check=False)
                        if probe_res_fps.returncode == 0 and probe_res_fps.stdout.strip():
                            fps_raw = probe_res_fps.stdout.strip()
                            if '/' in fps_raw:
                                num_str, den_str = fps_raw.split('/')
                                if den_str != '0' and num_str.replace('.', '', 1).isdigit() and den_str.replace('.', '', 1).isdigit():
                                    try: target_fps = str(float(num_str) / float(den_str))
                                    except ValueError: logging.warning(f"L·ªói chuy·ªÉn ƒë·ªïi FPS: {fps_raw}")
                            elif fps_raw.replace('.', '', 1).isdigit():
                                target_fps = fps_raw
                        logging.info(f"Branding Worker - Video ch√≠nh target: Res={target_width}x{target_height}, FPS={target_fps}, SAR={target_sar}")
                    except Exception as e_probe_main_worker:
                        logging.warning(f"Branding Worker: L·ªói ffprobe video ch√≠nh: {e_probe_main_worker}. D√πng m·∫∑c ƒë·ªãnh.")
                else:
                    logging.warning("Branding Worker: ffprobe kh√¥ng t√¨m th·∫•y, d√πng th√¥ng s·ªë m·∫∑c ƒë·ªãnh.")

                ### B·∫ÆT ƒê·∫¶U LOGIC M·ªöI: KI·ªÇM TRA V√Ä T·∫†O VIDEO T·∫†M TH·ªúI ###
                
                # --- X·ª≠ l√Ω Intro ---
                intro_path_for_concat = None
                if self.branding_intro_from_image_enabled_var.get():
                    image_path = self.branding_intro_image_path_var.get()
                    duration_str = self.branding_intro_image_duration_var.get()
                    try:
                        duration_s = float(duration_str)
                        if image_path and os.path.exists(image_path) and duration_s > 0:
                            temp_intro_video_path = os.path.join(temp_dir_for_branding, "temp_intro_from_image.mp4")
                            logging.info(f"Branding: ƒêang t·∫°o Intro video t·ª´ ·∫£nh '{os.path.basename(image_path)}' (Th·ªùi l∆∞·ª£ng: {duration_s}s)...")
                            self.update_status(f"üé® Branding: ƒêang t·∫°o Intro t·ª´ ·∫£nh...")
                            
                            success = self._ffmpeg_create_slideshow(
                                image_paths=[image_path],
                                output_video_path=temp_intro_video_path,
                                resolution=f"{target_width}x{target_height}",
                                fps=float(target_fps),
                                image_durations_list_seconds=[duration_s]
                            )
                            if success:
                                intro_path_for_concat = temp_intro_video_path
                                intermediate_files_to_delete.append(temp_intro_video_path)
                            else:
                                logging.warning("Kh√¥ng th·ªÉ t·∫°o Intro video t·ª´ ·∫£nh. S·∫Ω b·ªè qua Intro.")
                    except (ValueError, TypeError):
                        logging.warning(f"Th·ªùi l∆∞·ª£ng Intro t·ª´ ·∫£nh kh√¥ng h·ª£p l·ªá: '{duration_str}'. B·ªè qua Intro.")
                
                # ### S·ª¨A ƒê·ªîI: D√ôNG ELIF ƒê·ªÇ ∆ØU TI√äN ·∫¢NH ###
                elif self.branding_intro_enabled_var.get():
                    intro_path_for_concat = self.branding_intro_path_var.get()
                    if not (intro_path_for_concat and os.path.exists(intro_path_for_concat)):
                        intro_path_for_concat = None

                # --- X·ª≠ l√Ω Outro (t∆∞∆°ng t·ª± Intro) ---
                outro_path_for_concat = None
                if self.branding_outro_from_image_enabled_var.get():
                    image_path = self.branding_outro_image_path_var.get()
                    duration_str = self.branding_outro_image_duration_var.get()
                    try:
                        duration_s = float(duration_str)
                        if image_path and os.path.exists(image_path) and duration_s > 0:
                            temp_outro_video_path = os.path.join(temp_dir_for_branding, "temp_outro_from_image.mp4")
                            logging.info(f"Branding: ƒêang t·∫°o Outro video t·ª´ ·∫£nh '{os.path.basename(image_path)}' (Th·ªùi l∆∞·ª£ng: {duration_s}s)...")
                            self.update_status(f"üé® Branding: ƒêang t·∫°o Outro t·ª´ ·∫£nh...")

                            success = self._ffmpeg_create_slideshow(
                                image_paths=[image_path],
                                output_video_path=temp_outro_video_path,
                                resolution=f"{target_width}x{target_height}",
                                fps=float(target_fps),
                                image_durations_list_seconds=[duration_s]
                            )
                            if success:
                                outro_path_for_concat = temp_outro_video_path
                                intermediate_files_to_delete.append(temp_outro_video_path)
                            else:
                                logging.warning("Kh√¥ng th·ªÉ t·∫°o Outro video t·ª´ ·∫£nh. S·∫Ω b·ªè qua Outro.")
                    except (ValueError, TypeError):
                        logging.warning(f"Th·ªùi l∆∞·ª£ng Outro t·ª´ ·∫£nh kh√¥ng h·ª£p l·ªá: '{duration_str}'. B·ªè qua Outro.")

                # ### S·ª¨A ƒê·ªîI: D√ôNG ELIF ƒê·ªÇ ∆ØU TI√äN ·∫¢NH ###
                elif self.branding_outro_enabled_var.get():
                    outro_path_for_concat = self.branding_outro_path_var.get()
                    if not (outro_path_for_concat and os.path.exists(outro_path_for_concat)):
                        outro_path_for_concat = None
                
                ### K·∫æT TH√öC LOGIC M·ªöI ###

                video_main_content_for_concat_list = video_input_for_current_step
                
                logo_is_enabled_check = self.branding_logo_enabled_var.get()
                logo_file_path_check = self.branding_logo_path_var.get()
                if logo_is_enabled_check and logo_file_path_check and os.path.exists(logo_file_path_check):
                    self.update_status(f"üé® Branding: ƒêang ch√®n Logo v√†o video...")
                    video_main_content_for_concat_list = apply_logo_to_video(video_input_for_current_step, "main_with_logo_temp")
                    if not video_main_content_for_concat_list:
                        raise RuntimeError("Kh√¥ng th·ªÉ √°p d·ª•ng logo v√†o video ch√≠nh.")
                
                ### QUAN TR·ªåNG: D√ôNG C√ÅC BI·∫æN PATH M·ªöI ƒê·ªÇ X√ÇY D·ª∞NG DANH S√ÅCH ###
                videos_to_concat_paths = []
                
                if intro_path_for_concat and os.path.exists(intro_path_for_concat):
                    videos_to_concat_paths.append(os.path.abspath(intro_path_for_concat))

                if self.stop_event.is_set():
                    raise InterruptedError("D·ª´ng sau khi chu·∫©n b·ªã intro (Branding)")
                
                videos_to_concat_paths.append(os.path.abspath(video_main_content_for_concat_list))

                if self.stop_event.is_set():
                    raise InterruptedError("D·ª´ng sau khi chu·∫©n b·ªã n·ªôi dung ch√≠nh (Branding)")
                
                if outro_path_for_concat and os.path.exists(outro_path_for_concat):
                    videos_to_concat_paths.append(os.path.abspath(outro_path_for_concat))

                # --- Ph·∫ßn logic concat c·ªßa b·∫°n gi·ªØ nguy√™n, n√≥ s·∫Ω l√†m vi·ªác v·ªõi `videos_to_concat_paths` ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ---
                if len(videos_to_concat_paths) > 1:
                    logging.info(f"Branding Worker: Chu·∫©n b·ªã concat {len(videos_to_concat_paths)} video.")
                    self.update_status(f"üé® Branding: ƒêang gh√©p {len(videos_to_concat_paths)} ph·∫ßn...")

                    concat_inputs_cmd_list = []
                    filter_complex_video_parts_list = []
                    filter_complex_audio_parts_list = []
                    
                    video_streams_to_concat_str = ""
                    audio_streams_to_concat_str = ""
                    actual_audio_inputs_for_concat_count = 0

                    main_content_input_index_for_map = -1
                    try:
                        abs_video_main_content_path = os.path.abspath(video_main_content_for_concat_list)
                        abs_videos_to_concat_paths = [os.path.abspath(p) for p in videos_to_concat_paths]
                        if abs_video_main_content_path in abs_videos_to_concat_paths:
                            main_content_input_index_for_map = abs_videos_to_concat_paths.index(abs_video_main_content_path)
                            logging.info(f"Branding Worker - N·ªôi dung ch√≠nh l√† input th·ª©: {main_content_input_index_for_map}")
                        else:
                            logging.warning(f"Branding Worker - Kh√¥ng t√¨m th·∫•y video ch√≠nh trong inputs. Ph·ª• ƒë·ªÅ c√≥ th·ªÉ b·ªã m·∫•t.")
                    except Exception as e_find_idx:
                        logging.error(f"Branding Worker - L·ªói t√¨m index video ch√≠nh: {e_find_idx}")

                    FADE_DURATION = float(self.cfg.get("branding_video_fade_duration", 0.5))

                    for i, vid_path_item_concat in enumerate(videos_to_concat_paths):
                        concat_inputs_cmd_list.extend(["-i", vid_path_item_concat])
                        segment_duration = get_video_duration_s(vid_path_item_concat, current_ffprobe_exec)
                        
                        video_filters_for_segment = [f"scale={target_width}:{target_height}:force_original_aspect_ratio=decrease:flags=bicubic", f"pad={target_width}:{target_height}:(ow-iw)/2:(oh-ih)/2:color=black", f"setsar={target_sar}", f"fps={target_fps}"]
                        
                        if self.check_for_audio_stream(vid_path_item_concat):
                            current_audio_filters = ["aresample=async=1:osr=48000", "aformat=channel_layouts=stereo"]
                            if i > 0 and FADE_DURATION > 0:
                                video_filters_for_segment.append(f"fade=type=in:duration={FADE_DURATION:.3f}:start_time=0")
                                current_audio_filters.append(f"afade=type=in:duration={FADE_DURATION:.3f}:start_time=0")
                            if i < len(videos_to_concat_paths) - 1 and FADE_DURATION > 0 and segment_duration > FADE_DURATION:
                                fade_out_start_time = segment_duration - FADE_DURATION
                                video_filters_for_segment.append(f"fade=type=out:duration={FADE_DURATION:.3f}:start_time={fade_out_start_time:.3f}")
                                current_audio_filters.append(f"afade=type=out:duration={FADE_DURATION:.3f}:start_time={fade_out_start_time:.3f}")
                            
                            filter_complex_audio_parts_list.append(f"[{i}:a]{','.join(current_audio_filters)}[a{actual_audio_inputs_for_concat_count}]")
                            audio_streams_to_concat_str += f"[a{actual_audio_inputs_for_concat_count}]"
                            actual_audio_inputs_for_concat_count += 1
                        else:
                            logging.info(f"Branding Worker: Video '{os.path.basename(vid_path_item_concat)}' (input #{i}) kh√¥ng c√≥ audio.")
                        
                        filter_complex_video_parts_list.append(f"[{i}:v]{','.join(video_filters_for_segment)}[v{i}]")
                        video_streams_to_concat_str += f"[v{i}]"
                    
                    final_filter_complex_parts = filter_complex_video_parts_list + filter_complex_audio_parts_list
                    final_filter_complex_parts.append(f"{video_streams_to_concat_str}concat=n={len(videos_to_concat_paths)}:v=1:a=0[cv]")
                    
                    mapping_ops_final = ["-map", "[cv]"]
                    audio_codec_options_final = []

                    if actual_audio_inputs_for_concat_count > 0:
                        final_filter_complex_parts.append(f"{audio_streams_to_concat_str}concat=n={actual_audio_inputs_for_concat_count}:v=0:a=1[ca]")
                        mapping_ops_final.extend(["-map", "[ca]"])
                        audio_codec_options_final.extend(["-c:a", "aac", "-b:a", "192k"])
                    else:
                        logging.info("Branding Worker: Kh√¥ng c√≥ lu·ªìng audio n√†o trong c√°c video input ƒë·ªÉ concat. Video output s·∫Ω kh√¥ng c√≥ audio.")

                    final_concat_filter_cmd_str = ";".join(final_filter_complex_parts)
                    
                    if main_content_input_index_for_map != -1:
                        mapping_ops_final.extend(["-map", f"{main_content_input_index_for_map}:s:0?"])
                        logging.info(f"Branding Worker - ƒê√£ th√™m map cho ph·ª• ƒë·ªÅ t·ª´ input {main_content_input_index_for_map}:s:0?")

                    ffmpeg_concat_filter_final_cmd = [ffmpeg_executable, "-y"] + concat_inputs_cmd_list + ["-filter_complex", final_concat_filter_cmd_str] + mapping_ops_final + ["-c:v", "libx264", "-preset", self.cfg.get("ffmpeg_preset", "fast"), "-crf", str(self.cfg.get("ffmpeg_crf", 23)), "-profile:v", "main", "-level", "4.0", "-pix_fmt", "yuv420p", "-movflags", "+faststart"] + audio_codec_options_final + ["-c:s", "copy", "-vsync", "cfr", "-r", target_fps, os.path.abspath(final_output_path_suggestion)]
                    logging.info(f"Branding Worker - Concat Filter Command (V4 - improved audio handling): {' '.join(ffmpeg_concat_filter_final_cmd)}")
                    
                    process_concat_final_run = None
                    try:
                        process_concat_final_run = None
                        cmd_params_concat_final = ffmpeg_concat_filter_final_cmd[1:]
                        ffmpeg_run_command(
                            cmd_params_concat_final,
                            process_name="Branding_FinalConcat",
                            stop_event=self.stop_event if hasattr(self, 'stop_event') else None,
                            set_current_process=lambda p: setattr(self, 'current_process', p),
                            clear_current_process=lambda: setattr(self, 'current_process', None),
                            timeout_seconds=3600,
                        )
                        if not os.path.exists(final_output_path_suggestion) or os.path.getsize(final_output_path_suggestion) < 1024: raise RuntimeError("FFmpeg (concat filter cu·ªëi): File output kh√¥ng h·ª£p l·ªá ho·∫∑c qu√° nh·ªè.")
                        processed_video_path_after_last_step = final_output_path_suggestion
                        logging.info(f"Branding Worker - Concat Filter cu·ªëi th√†nh c√¥ng: {final_output_path_suggestion}")
                    except InterruptedError: raise
                    except Exception as e_cf_final_run_step:
                        logging.error(f"Branding Worker: L·ªói trong b∆∞·ªõc concat filter cu·ªëi: {e_cf_final_run_step}", exc_info=True)
                        raise RuntimeError(f"L·ªói concat filter cu·ªëi: {e_cf_final_run_step}")
                    finally:
                        if hasattr(self, 'current_process'): self.current_process = None
                
                elif len(videos_to_concat_paths) == 1:
                    processed_video_path_after_last_step = videos_to_concat_paths[0]
                    logging.info("Branding Worker: Ch·ªâ c√≥ m·ªôt video, kh√¥ng c·∫ßn concat th√™m.")
                else:
                    logging.warning("Branding Worker: Kh√¥ng c√≥ video n√†o ƒë·ªÉ output. D√πng video input g·ªëc.")
                    processed_video_path_after_last_step = video_input_for_current_step

                final_video_path_for_callback = processed_video_path_after_last_step
                
                if os.path.abspath(processed_video_path_after_last_step) != os.path.abspath(final_output_path_suggestion) and processed_video_path_after_last_step != os.path.abspath(input_video_path):
                    logging.info(f"Branding Worker: Di chuy·ªÉn file k·∫øt qu·∫£ '{os.path.basename(processed_video_path_after_last_step)}' ƒë·∫øn '{final_output_path_suggestion}'")
                    shutil.move(processed_video_path_after_last_step, final_output_path_suggestion)
                    if processed_video_path_after_last_step in intermediate_files_to_delete:
                        intermediate_files_to_delete.remove(processed_video_path_after_last_step)
                    final_video_path_for_callback = final_output_path_suggestion
                elif processed_video_path_after_last_step == os.path.abspath(input_video_path) and os.path.abspath(input_video_path) != os.path.abspath(final_output_path_suggestion) and not (self.branding_intro_enabled_var.get() or self.branding_logo_enabled_var.get() or self.branding_outro_enabled_var.get() or self.branding_intro_from_image_enabled_var.get() or self.branding_outro_from_image_enabled_var.get()):
                     logging.info(f"Branding Worker: Kh√¥ng branding, sao ch√©p video g·ªëc '{input_video_path}' sang '{final_output_path_suggestion}'")
                     shutil.copy2(input_video_path, final_output_path_suggestion)
                     final_video_path_for_callback = final_output_path_suggestion

                logging.info(f"Branding Worker: ƒê∆∞·ªùng d·∫´n video cu·ªëi cho callback: {final_video_path_for_callback}")
                if callback_after_branding_with_context:
                    self.after(0, callback_after_branding_with_context, True, final_video_path_for_callback, None)

            except InterruptedError as ie_main_branding_worker:
                logging.warning(f"Branding Worker: Qu√° tr√¨nh b·ªã d·ª´ng: {ie_main_branding_worker}")
                if callback_after_branding_with_context:
                    self.after(0, callback_after_branding_with_context, False, input_video_path, "ƒê√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
            except Exception as e_main_branding_worker_final:
                logging.error(f"Branding Worker: L·ªói chung: {e_main_branding_worker_final}", exc_info=True)
                if callback_after_branding_with_context:
                    self.after(0, callback_after_branding_with_context, False, input_video_path, f"L·ªói branding: {str(e_main_branding_worker_final)[:150]}")
            finally:
                if 'video_main_content_for_concat_list' in locals() and video_main_content_for_concat_list and os.path.abspath(video_main_content_for_concat_list) != os.path.abspath(input_video_path) and (not final_video_path_for_callback or os.path.abspath(video_main_content_for_concat_list) != os.path.abspath(final_video_path_for_callback)) and video_main_content_for_concat_list not in intermediate_files_to_delete:
                    intermediate_files_to_delete.append(video_main_content_for_concat_list)
                
                logging.debug(f"Branding Worker: D·ªçn d·∫πp files: {intermediate_files_to_delete}")
                for temp_file_to_clean in intermediate_files_to_delete:
                    if temp_file_to_clean and os.path.exists(temp_file_to_clean) and os.path.abspath(temp_file_to_clean) != os.path.abspath(input_video_path) and (not final_video_path_for_callback or os.path.abspath(temp_file_to_clean) != os.path.abspath(final_video_path_for_callback)):
                        try:
                            os.remove(temp_file_to_clean)
                            logging.info(f"Branding Worker: ƒê√£ x√≥a file t·∫°m: {os.path.basename(temp_file_to_clean)}")
                        except Exception as e_del_intermediate_final:
                            logging.warning(f"Branding Worker: L·ªói x√≥a file t·∫°m '{os.path.basename(temp_file_to_clean)}': {e_del_intermediate_final}")
                try:
                    if os.path.exists(temp_dir_for_branding):
                        shutil.rmtree(temp_dir_for_branding)
                        logging.info(f"Branding Worker: ƒê√£ x√≥a th∆∞ m·ª•c t·∫°m branding: {temp_dir_for_branding}")
                except Exception as e_rm_main_temp_dir_final:
                    logging.warning(f"Branding Worker: L·ªói x√≥a th∆∞ m·ª•c t·∫°m branding '{temp_dir_for_branding}': {e_rm_main_temp_dir_final}")

                if hasattr(self, 'current_process') and self.current_process:
                    self.current_process = None


# H√†m n√†y s·∫Ω kh·ªüi t·∫°o v√† b·∫Øt ƒë·∫ßu lu·ªìng branding.
    def _start_branding_thread(self, video_path_from_previous_step, callback_after_branding, original_context_data=None):
        """
        B·∫Øt ƒë·∫ßu qu√° tr√¨nh branding trong m·ªôt lu·ªìng m·ªõi.
        `callback_after_branding` s·∫Ω ƒë∆∞·ª£c g·ªçi v·ªõi (success, final_video_path, error_message, original_context_data).
        `original_context_data` ƒë∆∞·ª£c truy·ªÅn th·∫≥ng cho callback cu·ªëi c√πng.
        """
        output_directory_for_branded_video = ""
        # === B∆Ø·ªöC 1: ∆Øu ti√™n ƒë∆∞·ªùng d·∫´n override t·ª´ context ===
        if original_context_data and isinstance(original_context_data, dict) and original_context_data.get("output_dir_override"):
            output_directory_for_branded_video = original_context_data.get("output_dir_override")
            logging.info(f"[BrandingStartThread] ƒê√£ s·ª≠ d·ª•ng th∆∞ m·ª•c output ƒë∆∞·ª£c ghi ƒë√® t·ª´ context: {output_directory_for_branded_video}")
        # === B∆Ø·ªöC 2: Fallback v·ªÅ logic c≈© n·∫øu kh√¥ng c√≥ override ===
        else:
            current_view_for_output = self.current_view
            if current_view_for_output == "‚ô™ Thuy·∫øt Minh" and self.dub_output_path_var.get() and os.path.isdir(self.dub_output_path_var.get()):
                output_directory_for_branded_video = self.dub_output_path_var.get()
            elif current_view_for_output == "‚â° T·∫°o Ph·ª• ƒê·ªÅ" and self.output_path_var.get() and os.path.isdir(self.output_path_var.get()):
                output_directory_for_branded_video = self.output_path_var.get()
            
            if not output_directory_for_branded_video:
                parent_dir_of_input = os.path.dirname(video_path_from_previous_step)
                if parent_dir_of_input and os.path.isdir(parent_dir_of_input):
                    output_directory_for_branded_video = parent_dir_of_input
                else:
                    output_directory_for_branded_video = self.cfg.get("output_path", get_default_downloads_folder())

        base_name_of_input = os.path.splitext(os.path.basename(video_path_from_previous_step))[0]
        suffixes_to_clean = ["_hardsub_manual", "_softsub_manual", "_hardsub", "_softsub", "_PiuDub", "_dalle_show", "_merged", "_slideshow"]
        for suffix in suffixes_to_clean:
            if base_name_of_input.endswith(suffix):
                base_name_of_input = base_name_of_input[:-len(suffix)]

        safe_branded_base_name = create_safe_filename(base_name_of_input, remove_accents=False, max_length=150)
        if not safe_branded_base_name: safe_branded_base_name = f"branded_output_{uuid.uuid4().hex[:4]}"

        # M·∫∑c ƒë·ªãnh output l√† MP4 cho hardsub ho·∫∑c c√°c tr∆∞·ªùng h·ª£p kh√¥ng y√™u c·∫ßu gi·ªØ softsub ƒë·∫∑c bi·ªát
        output_extension = ".mp4"
        logging.info(f"[BrandingStartThread] output_extension m·∫∑c ƒë·ªãnh ƒë∆∞·ª£c ƒë·∫∑t th√†nh: {output_extension}")

        # Ki·ªÉm tra ng·ªØ c·∫£nh t·ª´ original_context_data
        if original_context_data and isinstance(original_context_data, dict):
            is_softsub_branding = original_context_data.get("is_softsub_input_for_branding", False)
            merge_mode_context = original_context_data.get("merge_mode_used", "") # L·∫•y c·∫£ merge_mode ƒë·ªÉ log n·∫øu c·∫ßn

            if is_softsub_branding:
                # N·∫øu ƒë√¢y l√† tr∆∞·ªùng h·ª£p branding cho video ƒë√£ softsub, ∆∞u ti√™n MKV
                output_extension = ".mkv"
                logging.info(f"[BrandingStartThread] Ph√°t hi·ªán ng·ªØ c·∫£nh softsub (is_softsub_input_for_branding=True, merge_mode='{merge_mode_context}'). ƒê·ªïi output_extension th√†nh: {output_extension}")
            else:
                logging.info(f"[BrandingStartThread] Kh√¥ng ph·∫£i ng·ªØ c·∫£nh softsub (is_softsub_input_for_branding=False, merge_mode='{merge_mode_context}'). Gi·ªØ output_extension l√†: {output_extension}")
        else:
            logging.info(f"[BrandingStartThread] Kh√¥ng c√≥ original_context_data ho·∫∑c kh√¥ng ph·∫£i dict. Gi·ªØ output_extension m·∫∑c ƒë·ªãnh l√†: {output_extension}")


        final_branded_video_path_suggestion = os.path.join(output_directory_for_branded_video, f"{safe_branded_base_name}{output_extension}") # <<< S·ª¨A ƒê·ªÇ D√ôNG output_extension

        logging.info(f"Branding: Chu·∫©n b·ªã b·∫Øt ƒë·∫ßu lu·ªìng. Video Input: '{video_path_from_previous_step}', "
                     f"Output G·ª£i √Ω ({output_extension}): '{final_branded_video_path_suggestion}'") # C·∫≠p nh·∫≠t log

        self.update_status(f"üé® ƒêang ch√®n Logo cho: {os.path.basename(video_path_from_previous_step)}...")
        # C√≥ th·ªÉ v√¥ hi·ªáu h√≥a c√°c n√∫t ch√≠nh ·ªü ƒë√¢y n·∫øu c·∫ßn
        # V√≠ d·ª•: self.sub_button.configure(state="disabled")

        branding_thread = threading.Thread(
            target=self._apply_branding_elements_worker,
            args=(video_path_from_previous_step, final_branded_video_path_suggestion,
                  lambda success, final_path, err_msg: callback_after_branding(success, final_path, err_msg, original_context_data)
                 ),
            daemon=True,
            name="BrandingApplierThread"
        )
        branding_thread.start()


# H√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi sau khi lu·ªìng branding ho√†n t·∫•t (th√†nh c√¥ng ho·∫∑c th·∫•t b·∫°i).
    def _handle_branding_completion(self, success, final_video_path, error_message, original_context_data):
        source_view_info = original_context_data.get("source_view", "Kh√¥ng r√µ")
        log_prefix_cb = f"[BrandingCallback_{source_view_info}]"
        
        logging.info(f"{log_prefix_cb} K·∫øt qu·∫£: Success={success}, Path='{final_video_path}', Error='{error_message}'")
        logging.debug(f"{log_prefix_cb} Original Context Data: {original_context_data}")

        specific_callback_after_branding_for_dub_chain = None
        if isinstance(original_context_data, dict): 
            specific_callback_after_branding_for_dub_chain = original_context_data.get("specific_callback_after_branding_for_this_context")
        
        logging.debug(f"{log_prefix_cb} Gi√° tr·ªã c·ªßa specific_callback_after_branding_for_dub_chain: {specific_callback_after_branding_for_dub_chain} (C√≥ th·ªÉ g·ªçi ƒë∆∞·ª£c kh√¥ng: {callable(specific_callback_after_branding_for_dub_chain)})")

        callback_to_continue_sub_queue = original_context_data.get("callback_after_all_processing_for_this_file") if isinstance(original_context_data, dict) else None

        if source_view_info == "subtitle_auto_processing_with_brand_then_done":
            logging.info(f"{log_prefix_cb} Branding cho lu·ªìng Auto-Sub (ch·ªâ Sub, c√≥ Brand) ho√†n t·∫•t.")
            
            # <<< S·ª¨A L·ªñI ·ªû ƒê√ÇY >>>
            if success and final_video_path:
                # L·∫•y l·∫°i task object ƒë√£ ƒë∆∞·ª£c truy·ªÅn qua context
                task_object = original_context_data.get("task_object") # L·∫•y ƒë√∫ng key "task_object"
                if task_object:
                    # C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n cu·ªëi c√πng trong task object l√† video ƒë√£ branding
                    task_object['final_video_path'] = final_video_path
                    # G·ªçi h√†m th√™m v√†o h√†ng ch·ªù upload v·ªõi task object ƒë√£ ho√†n ch·ªânh
                    self._add_completed_video_to_upload_queue(task_object)
                    logging.info(f"{log_prefix_cb} ƒê√£ th√™m video ƒë√£ branding v√†o h√†ng ch·ªù upload.")
                else:
                    logging.error(f"{log_prefix_cb} L·ªói: Kh√¥ng t√¨m th·∫•y 'task_object' trong context ƒë·ªÉ th√™m v√†o h√†ng ch·ªù upload.")
            else:
                logging.warning(f"{log_prefix_cb} Branding th·∫•t b·∫°i ho·∫∑c kh√¥ng c√≥ video output. Kh√¥ng th√™m v√†o h√†ng ch·ªù upload.")
            # <<< K·∫æT TH√öC S·ª¨A L·ªñI >>>

            # Sau khi ƒë√£ x·ª≠ l√Ω xong vi·ªác th√™m v√†o h√†ng ch·ªù upload, g·ªçi callback ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo
            if callback_to_continue_sub_queue and callable(callback_to_continue_sub_queue):
                logging.info(f"{log_prefix_cb} G·ªçi callback g·ªëc c·ªßa task sub: {callback_to_continue_sub_queue.__name__} ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo ho·∫∑c ho√†n t·∫•t l√¥.")
                self.after(10, callback_to_continue_sub_queue)
            else:
                logging.error(f"{log_prefix_cb} L·ªói nghi√™m tr·ªçng: Kh√¥ng t√¨m th·∫•y callback h·ª£p l·ªá trong context ({callback_to_continue_sub_queue}) ƒë·ªÉ x·ª≠ l√Ω file sub ti·∫øp theo. H√†ng ch·ªù sub c√≥ th·ªÉ b·ªã k·∫πt.")
                self.is_subbing = False 
                if not (self.is_downloading or self.dub_is_processing or self.is_creating_slideshow or self.is_gpt_processing_script or self.is_dalle_processing or self.is_loading_model_for_timer):
                    self.start_time = None
                if hasattr(self, 'reset_ui_after_pause_or_stop'): self.reset_ui_after_pause_or_stop() 
                if hasattr(self, '_check_completion_and_shutdown'): self._check_completion_and_shutdown()

        elif source_view_info == "subtitle_auto_processing": 
            logging.info(f"{log_prefix_cb} Branding cho lu·ªìng Auto-Sub (ch·ªù Dub - '{source_view_info}') ho√†n t·∫•t.")
            video_to_use_for_dub_chain = None
            if success and final_video_path and os.path.exists(final_video_path):
                video_to_use_for_dub_chain = final_video_path
                self.update_status(f"‚úÖ Branding xong (Sub -> Dub): {os.path.basename(final_video_path)}")
            else:
                video_before_branding = original_context_data.get("video_before_branding") if isinstance(original_context_data, dict) else None
                if video_before_branding and os.path.exists(video_before_branding):
                    video_to_use_for_dub_chain = video_before_branding
                    logging.warning(f"{log_prefix_cb} Branding l·ªói/kh√¥ng output (Sub -> Dub). D√πng video TR∆Ø·ªöC brand cho dub chain: {os.path.basename(video_to_use_for_dub_chain)}")
                    self.update_status(f"‚ö†Ô∏è L·ªói Branding (Sub -> Dub). D√πng video ch∆∞a brand: {os.path.basename(video_to_use_for_dub_chain)}")
                else:
                    logging.error(f"{log_prefix_cb} Branding l·ªói V√Ä kh√¥ng t√¨m th·∫•y video tr∆∞·ªõc branding (Sub -> Dub). Kh√¥ng th·ªÉ ti·∫øp t·ª•c dub chain cho file n√†y.")
                    self.update_status(f"‚ùå L·ªói n·∫∑ng khi branding (Sub -> Dub), kh√¥ng c√≥ video ƒë·ªÉ dub.")

            srt_for_dub_chain = original_context_data.get("srt_file_generated_for_sub_task") if isinstance(original_context_data, dict) else None
            original_input_video_for_task = original_context_data.get("original_input_file_of_sub_task") if isinstance(original_context_data, dict) else None
            pending_dub_flag_from_context = original_context_data.get("pending_auto_dub_after_this_batch_flag", False) if isinstance(original_context_data, dict) else False # S·ª≠a l·∫°i
            logging.debug(f"{log_prefix_cb} Ki·ªÉm tra pending_dub_flag_from_context (Sub -> Dub): {pending_dub_flag_from_context}")

            if pending_dub_flag_from_context:
                if video_to_use_for_dub_chain and srt_for_dub_chain and os.path.exists(srt_for_dub_chain) and os.path.exists(video_to_use_for_dub_chain):
                    self.files_for_chained_dubbing.append({
                        'video_to_dub': video_to_use_for_dub_chain,
                        'script_content_type': 'srt_file',
                        'script_data': srt_for_dub_chain,
                        'script_display_name_override': os.path.basename(srt_for_dub_chain),
                        'original_downloaded_video': original_input_video_for_task 
                    })
                    logging.info(f"{log_prefix_cb}   (Auto-Sub + Brand -> Dub) ƒê√£ c·∫≠p nh·∫≠t KQ cho chain Dub: Video='{os.path.basename(video_to_use_for_dub_chain)}', SRT='{os.path.basename(srt_for_dub_chain)}'")
                else:
                    logging.warning(f"{log_prefix_cb}   (Auto-Sub + Brand -> Dub) Thi·∫øu video ('{video_to_use_for_dub_chain}') ho·∫∑c SRT ('{srt_for_dub_chain}') sau branding/l·ªói. Kh√¥ng th√™m v√†o chain dub.")
            else:
                logging.info(f"{log_prefix_cb}  (Auto-Sub + Brand -> Dub) Kh√¥ng c√≥ y√™u c·∫ßu dub sau sub (pending_dub_flag_from_context=False).")
            
            if callback_to_continue_sub_queue and callable(callback_to_continue_sub_queue):
                logging.info(f"{log_prefix_cb} G·ªçi callback g·ªëc c·ªßa task sub (Sub -> Dub): {callback_to_continue_sub_queue.__name__} ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo ho·∫∑c ho√†n t·∫•t l√¥.")
                self.after(10, callback_to_continue_sub_queue)
            else:
                logging.error(f"{log_prefix_cb} L·ªói nghi√™m tr·ªçng (Sub -> Dub): Kh√¥ng t√¨m th·∫•y callback h·ª£p l·ªá trong context ({callback_to_continue_sub_queue}) ƒë·ªÉ x·ª≠ l√Ω file sub ti·∫øp theo. H√†ng ch·ªù sub c√≥ th·ªÉ b·ªã k·∫πt.")
                self.is_subbing = False
                if not (self.is_downloading or self.dub_is_processing or self.is_creating_slideshow or self.is_gpt_processing_script or self.is_dalle_processing or self.is_loading_model_for_timer): # Th√™m c√°c c·ªù ki·ªÉm tra kh√°c
                    self.start_time = None
                if hasattr(self, 'reset_ui_after_pause_or_stop'): self.reset_ui_after_pause_or_stop()
                if hasattr(self, '_check_completion_and_shutdown'): self._check_completion_and_shutdown()

        elif source_view_info == "subtitle_manual_merge_and_dub":
            logging.info(f"{log_prefix_cb} Branding cho lu·ªìng Manual Sub & Dub ho√†n t·∫•t. Chuy·ªÉn giao cho _handle_manual_merge_completion.")

            callback_for_manual_merge = original_context_data.get("callback_after_all_processing_for_this_file") if isinstance(original_context_data, dict) else None
            if callback_for_manual_merge and callable(callback_for_manual_merge):
                logging.debug(f"{log_prefix_cb} G·ªçi l·∫°i callback cho manual merge: {callback_for_manual_merge.__name__}")
                self.after(0, callback_for_manual_merge, success, final_video_path, error_message, original_context_data)
            else:
                 logging.error(f"{log_prefix_cb} Thi·∫øu callback cho manual merge sau branding.")
                 self.is_subbing = False
                 if not (self.is_downloading or self.dub_is_processing or self.is_creating_slideshow or self.is_gpt_processing_script or self.is_dalle_processing or self.is_loading_model_for_timer): # Th√™m c√°c c·ªù ki·ªÉm tra kh√°c
                    self.start_time = None
                 if hasattr(self, 'reset_ui_after_pause_or_stop'): self.reset_ui_after_pause_or_stop()
                 if hasattr(self, '_check_completion_and_shutdown'): self._check_completion_and_shutdown()
        
        # === KH·ªêI ELIF CHO CH·∫æ ƒê·ªò GH√âP TH·ª¶ C√îNG ===
        elif source_view_info == "subtitle_manual_batch":
            task_id = original_context_data.get("task_id")
            logging.info(f"{log_prefix_cb} Branding cho t√°c v·ª• th·ªß c√¥ng (ID: {task_id}) ho√†n t·∫•t.")
            
            # L·∫•y l·∫°i task_data g·ªëc
            task_data = next((t for t in self.manual_sub_queue if t.get('id') == task_id), None)
            
            if task_data:
                # C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n file cu·ªëi c√πng trong task
                if success and final_video_path:
                    task_data['result_path'] = final_video_path
                    task_data['branded_path'] = final_video_path # Th√™m key m·ªõi ƒë·ªÉ r√µ r√†ng
                else: # N·∫øu branding l·ªói, gi·ªØ l·∫°i ƒë∆∞·ªùng d·∫´n tr∆∞·ªõc ƒë√≥
                    task_data['result_path'] = original_context_data.get("video_before_branding")

                # <<< TH√äM LOGIC KI·ªÇM TRA UPLOAD M·ªöI V√ÄO ƒê√ÇY >>>
                # Ch·ªâ th√™m v√†o h√†ng ch·ªù upload n·∫øu branding th√†nh c√¥ng v√† ng∆∞·ªùi d√πng mu·ªën
                if success and self.auto_upload_to_youtube_var.get():
                    logging.info(f"{log_prefix_cb} T√°c v·ª• th·ªß c√¥ng + branding th√†nh c√¥ng. T·ª± ƒë·ªông th√™m v√†o h√†ng ch·ªù upload.")
                    self._add_completed_video_to_upload_queue(task_data)
                # <<< K·∫æT TH√öC LOGIC UPLOAD M·ªöI >>>

            # Logic c≈©: X√≥a t√°c v·ª• hi·ªán t·∫°i v√† g·ªçi t√°c v·ª• ti·∫øp theo (v·∫´n gi·ªØ)
            if self.manual_sub_queue and self.manual_sub_queue[0].get('id') == task_id:
                self.manual_sub_queue.pop(0)
                logging.info(f"{log_prefix_cb} ƒê√£ x√≥a t√°c v·ª• ƒë√£ branding xong (ID: {task_id}).")
            else:
                logging.warning(f"{log_prefix_cb} Kh√¥ng t√¨m th·∫•y t√°c v·ª• ƒë√£ branding ƒë·ªÉ x√≥a kh·ªèi ƒë·∫ßu h√†ng ch·ªù.")

            self.after(50, self._process_next_manual_sub_task)

        # KH·ªêI ELIF CHO CH·∫æ ƒê·ªò AUDIO>VIDEO
        elif source_view_info == "audio_to_video_final_brand":
            task_object = original_context_data.get("task_object", {})
            logging.info(f"{log_prefix_cb} Branding cho chu·ªói Audio-to-Video ho√†n t·∫•t.")
            
            # C·∫≠p nh·∫≠t task object v·ªõi k·∫øt qu·∫£ cu·ªëi c√πng t·ª´ branding
            if success and final_video_path:
                task_object['final_video_path'] = final_video_path # C·∫≠p nh·∫≠t l·∫°i ƒë∆∞·ªùng d·∫´n cu·ªëi c√πng
                
                # X√≥a file trung gian (video ƒë√£ c√≥ ti·∫øng nh∆∞ng ch∆∞a branding)
                video_before_branding = original_context_data.get("video_before_branding")
                if video_before_branding and os.path.exists(video_before_branding):
                    try:
                        os.remove(video_before_branding)
                        logging.info(f"{log_prefix_cb} ƒê√£ x√≥a file trung gian (ch∆∞a branding): {os.path.basename(video_before_branding)}")
                    except Exception as e_del:
                        logging.warning(f"{log_prefix_cb} L·ªói x√≥a file trung gian: {e_del}")
            
            # Th√™m v√†o h√†ng ch·ªù upload (b·∫•t k·ªÉ branding th√†nh c√¥ng hay kh√¥ng, d√πng video t·ªët nh·∫•t c√≥ ƒë∆∞·ª£c)
            self._add_completed_video_to_upload_queue(task_object)

            # G·ªçi callback g·ªëc ƒë·ªÉ x·ª≠ l√Ω file ti·∫øp theo trong h√†ng ch·ªù ch√≠nh
            if hasattr(self, '_process_next_subtitle_file'):
                self.after(50, self._process_next_subtitle_file)

        # Thay ƒë·ªïi c√°c kh·ªëi if sau th√†nh elif ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh lo·∫°i tr·ª´
        elif source_view_info == "dubbing_final_brand": 
            logging.info(f"{log_prefix_cb} Branding cho t√°c v·ª• dub (trong chu·ªói S&D ho·∫∑c Dub-Only) ho√†n t·∫•t (context: {source_view_info}).")

            # N·∫øu branding th√†nh c√¥ng, ƒë√¢y ch√≠nh l√† video cu·ªëi c√πng
            if success and final_video_path:
                logging.info(f"[BrandingCompletion] Branding cho video dub th√†nh c√¥ng. G·ªçi h√†m th√™m v√†o h√†ng ch·ªù upload.")
                self._add_completed_video_to_upload_queue(final_video_path)

            video_dubbed_only_path = original_context_data.get("video_before_branding")

            if success and final_video_path and os.path.exists(final_video_path):
                logging.info(f"{log_prefix_cb} Branding th√†nh c√¥ng, video cu·ªëi c√πng: {final_video_path}")
                if video_dubbed_only_path and os.path.exists(video_dubbed_only_path) and \
                   os.path.abspath(video_dubbed_only_path) != os.path.abspath(final_video_path):
                    try:
                        os.remove(video_dubbed_only_path)
                        logging.info(f"{log_prefix_cb} ƒê√£ x√≥a file video ch·ªâ c√≥ thuy·∫øt minh (trung gian): {video_dubbed_only_path}")
                    except Exception as e_del_dub_only:
                        logging.warning(f"{log_prefix_cb} L·ªói khi x√≥a file video ch·ªâ c√≥ thuy·∫øt minh (trung gian) '{video_dubbed_only_path}': {e_del_dub_only}")
                elif video_dubbed_only_path and os.path.abspath(video_dubbed_only_path) == os.path.abspath(final_video_path):
                    logging.info(f"{log_prefix_cb} Video tr∆∞·ªõc v√† sau branding l√† c√πng m·ªôt file, kh√¥ng x√≥a: {video_dubbed_only_path}")
                elif not video_dubbed_only_path: # S·ª≠a l·∫°i elif cho ƒë√∫ng
                    logging.warning(f"{log_prefix_cb} Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng d·∫´n 'video_before_branding' trong context ƒë·ªÉ x√≥a file thuy·∫øt minh trung gian.")
            
            else: 
                logging.warning(f"{log_prefix_cb} Branding kh√¥ng th√†nh c√¥ng ho·∫∑c kh√¥ng c√≥ video output. S·∫Ω KH√îNG x√≥a file video ch·ªâ c√≥ thuy·∫øt minh (n·∫øu c√≥): {video_dubbed_only_path}")

            if specific_callback_after_branding_for_dub_chain and callable(specific_callback_after_branding_for_dub_chain):
                logging.debug(f"{log_prefix_cb} G·ªçi callback c·ª• th·ªÉ: {specific_callback_after_branding_for_dub_chain.__name__}")
                self.after(0, specific_callback_after_branding_for_dub_chain,
                           success,
                           final_video_path, 
                           error_message,
                           original_context_data
                )
            else:
                logging.error(f"{log_prefix_cb} L·ªñI: Callback cho 'dubbing_final_brand' KH√îNG T√åM TH·∫§Y ho·∫∑c KH√îNG G·ªåI ƒê∆Ø·ª¢C. H√†ng ch·ªù dubbing c√≥ th·ªÉ b·ªã k·∫πt!")
                self.dub_is_processing = False 
                if hasattr(self, 'dub_on_batch_finished'): self.dub_on_batch_finished(stopped=True) 
                if hasattr(self, 'reset_dubbing_ui_after_batch_or_stop'): self.reset_dubbing_ui_after_batch_or_stop(True)
                if hasattr(self, '_check_completion_and_shutdown'): self._check_completion_and_shutdown()
            
            return 
        
        elif source_view_info == "dubbing_batch_item": 
            task_id_dubbed = original_context_data.get("task_id_of_dub_item") if isinstance(original_context_data, dict) else None
            original_video_dubbed = original_context_data.get("video_before_branding") if isinstance(original_context_data, dict) else None
            logging.info(f"{log_prefix_cb} Branding cho t√°c v·ª• Dubbing (context c≈© 'dubbing_batch_item') ID '{task_id_dubbed}' ho√†n t·∫•t. Video cu·ªëi: {os.path.basename(final_video_path if final_video_path else original_video_dubbed or 'N/A')}")

            if not self.dub_is_processing: 
                if hasattr(self, '_update_dub_start_batch_button_state'): self._update_dub_start_batch_button_state() 
                if hasattr(self, 'reset_dubbing_ui_after_batch_or_stop'): self.reset_dubbing_ui_after_batch_or_stop(stopped_by_user=False) 
        
        # --- Ph·∫ßn is_part_of_a_continuing_chain v√† c√°c logic cu·ªëi h√†m gi·ªØ nguy√™n ---
        is_part_of_a_continuing_chain = (
            (source_view_info == "subtitle_auto_processing" and callback_to_continue_sub_queue) or
            (source_view_info == "subtitle_manual_merge_and_dub" and hasattr(self, 'manual_sub_then_dub_active') and self.manual_sub_then_dub_active) or
            (source_view_info == "dubbing_final_brand" and hasattr(self, 'dub_is_processing') and self.dub_is_processing)
        )

        if not is_part_of_a_continuing_chain:
            logging.info(f"{log_prefix_cb} Branding l√† b∆∞·ªõc cu·ªëi v√† kh√¥ng c√≥ chu·ªói n√†o kh√°c ƒëang ch·ªù (is_part_of_a_continuing_chain=False). Reset c√°c c·ªù chung.")
            self.is_subbing = False # ƒê·∫£m b·∫£o reset n·∫øu kh√¥ng ph·∫£i l√† chu·ªói S&D
            self.is_creating_slideshow = False 
            self.is_dalle_processing = False   
            
            if not (self.is_downloading or self.is_loading_model_for_timer or self.dub_is_processing or self.is_gpt_processing_script): # Th√™m is_gpt_processing_script
                self.start_time = None
                     
            # Ki·ªÉm tra k·ªπ h∆°n tr∆∞·ªõc khi reset UI tab Sub
            if source_view_info not in ["subtitle_auto_processing", 
                                         "subtitle_manual_merge_and_dub", 
                                         "dubbing_final_brand", # ƒê√£ c√≥ return ·ªü tr√™n, nh∆∞ng ƒë·ªÉ ƒë√¢y cho an to√†n
                                         "subtitle_auto_processing_with_brand_then_done", # ƒê√£ c√≥ return
                                         "subtitle_manual_merge_only_with_branding"]: # ƒê√£ c√≥ return
                if hasattr(self, '_set_subtitle_tab_ui_state'): self._set_subtitle_tab_ui_state(False)
                if hasattr(self, 'reset_dubbing_ui_after_batch_or_stop'): self.reset_dubbing_ui_after_batch_or_stop(False) # Reset UI Dub n·∫øu kh√¥ng ph·∫£i l√† dub chain
        else:
            logging.info(f"{log_prefix_cb} Branding l√† m·ªôt ph·∫ßn c·ªßa chu·ªói ƒëang ti·∫øp t·ª•c. C√°c c·ªù s·∫Ω ƒë∆∞·ª£c qu·∫£n l√Ω b·ªüi c√°c b∆∞·ªõc sau.")

        if hasattr(self, '_check_completion_and_shutdown'): self.after(500, self._check_completion_and_shutdown)


# =====================================================================================================================================
# L·ªöP C·ª¨A S·ªî C√ÄI ƒê·∫∂T LOGO/INTRO/OUTRO
# =====================================================================================================================================

# BrandingSettingsWindow class - MOVED TO ui/popups/branding_settings.py

# =====================================================================================================================================
# L·ªöP C·ª¨A S·ªî C√ÄI ƒê·∫∂T KI·ªÇU PH·ª§ ƒê·ªÄ
# =====================================================================================================================================

# SubtitleStyleSettingsWindow class - MOVED TO ui/popups/subtitle_style_settings.py

# =====================================================================================================================================
# L·ªöP C·ª¨A S·ªî C√ÄI ƒê·∫∂T T·∫†O ·∫¢NH IMAGEN (M·ªöI)
# =====================================================================================================================================
# ImagenSettingsWindow class removed - moved to ui/popups/imagen_settings.py

# =======================================================================================================================================================================

# DalleSettingsWindow class removed - moved to ui/popups/dalle_settings.py

# MetadataManagerWindow class removed - moved to ui/popups/metadata_manager.py

# =====================================================================================================================================
# L·ªöP C·ª¨A S·ªî C√ÄI ƒê·∫∂T T·∫†O ·∫¢NH IMAGEN (M·ªöI)
# =====================================================================================================================================
# ImagenSettingsWindow class removed - moved to ui/popups/imagen_settings.py

# =======================================================================================================================================================================

# DalleSettingsWindow class removed - moved to ui/popups/dalle_settings.py

# MetadataManagerWindow class removed - moved to ui/popups/metadata_manager.py 

        google_select_button = ctk.CTkButton(google_frame, text="Ch·ªçn File JSON...", width=120, command=self._select_google_key_file)
        # ƒê·∫∑t n√∫t ch·ªçn file v√†o c·ªôt 2, h√†ng 1
        google_select_button.grid(row=1, column=2, padx=(0, 10), pady=(2, 5), sticky="e") 

        # --- H√†ng 2: Nh√£n tr·∫°ng th√°i v√† N√∫t Ki·ªÉm tra ---
        self.google_status_label = ctk.CTkLabel(google_frame, text="", font=("Segoe UI", 10), text_color="gray", justify=ctk.LEFT) 
        # ƒê·∫∑t status v√†o c·ªôt 0, h√†ng 2, cƒÉn tr√°i
        self.google_status_label.grid(row=2, column=0, columnspan=2, padx=(10, 5), pady=(0, 10), sticky="w")

        self.google_test_button = ctk.CTkButton(google_frame, text="Ki·ªÉm tra File Key", width=120, command=self._test_google_key) 
        # ƒê·∫∑t n√∫t ki·ªÉm tra v√†o c·ªôt 2, h√†ng 2
        self.google_test_button.grid(row=2, column=2, padx=(0, 10), pady=(0, 10), sticky="e") 

        # C·∫≠p nh·∫≠t text ban ƒë·∫ßu cho label ƒë∆∞·ªùng d·∫´n Google
        initial_google_path = self.google_key_path_var.get()
        self.google_path_label.configure(text=initial_google_path if initial_google_path else "(Ch∆∞a ch·ªçn file)")
        if hasattr(self.google_key_path_var, 'trace_add'): 
             self.google_key_path_var.trace_add("write", self._update_google_label)

        # --- Ph·∫ßn Gemini API Key --- (Th√™m kh·ªëi code n√†y v√†o)
        gemini_frame = ctk.CTkFrame(main_frame)
        gemini_frame.pack(fill="x", pady=(10, 5)) # Th√™m pady tr√™n ƒë·ªÉ c√≥ kho·∫£ng c√°ch

        gemini_frame.grid_columnconfigure(1, weight=1)

        ctk.CTkLabel(gemini_frame, text="Gemini API Key:", anchor="w").grid(row=0, column=0, padx=(10, 5), pady=(5,0), sticky="w")

        self.gemini_entry = ctk.CTkEntry(gemini_frame, textvariable=self.gemini_key_var, show="*")
        self.gemini_entry.grid(row=1, column=0, columnspan=2, padx=(10, 5), pady=(2,5), sticky="ew")
        self.gemini_entry.bind("<Button-3>", textbox_right_click_menu)

        # N√∫t ki·ªÉm tra s·∫Ω ƒë∆∞·ª£c th√™m logic sau
        self.gemini_test_button = ctk.CTkButton(gemini_frame, text="Ki·ªÉm tra", width=120, command=self._test_gemini_key) 
        self.gemini_test_button.grid(row=1, column=2, padx=(0, 10), pady=(2,5), sticky="e")

        self.gemini_status_label = ctk.CTkLabel(gemini_frame, text="", font=("Segoe UI", 10), text_color="gray")
        self.gemini_status_label.grid(row=2, column=0, columnspan=3, padx=(10, 5), pady=(0, 10), sticky="w")

        # --- Ph·∫ßn OpenAI API Key ---
        openai_frame = ctk.CTkFrame(main_frame) 
        openai_frame.pack(fill="x", pady=(0, 15)) 

        # C·∫•u h√¨nh c·ªôt: C·ªôt 0 (Label ch√≠nh/Status), C·ªôt 1 (Entry - gi√£n), C·ªôt 2 (N√∫t Test)
        openai_frame.grid_columnconfigure(0, weight=0, minsize=120) 
        openai_frame.grid_columnconfigure(1, weight=1)             
        openai_frame.grid_columnconfigure(2, weight=0, minsize=130) 

        # --- H√†ng 0: Ch·ªâ c√≥ Label ch√≠nh ---
        ctk.CTkLabel(openai_frame, text="OpenAI API Key:", anchor="w").grid(row=0, column=0, padx=(10, 5), pady=(5,0), sticky="w")

        # --- H√†ng 1: √î nh·∫≠p Key v√† N√∫t Ki·ªÉm tra ---
        self.openai_entry = ctk.CTkEntry(openai_frame, textvariable=self.openai_key_var, show="*") 
        self.openai_entry.grid(row=1, column=0, columnspan=2, padx=(10, 5), pady=(2,5), sticky="ew") # Chi·∫øm c·ªôt 0 v√† 1
        self.openai_entry.bind("<Button-3>", textbox_right_click_menu)
        
        self.openai_test_button = ctk.CTkButton(openai_frame, text="Ki·ªÉm tra", width=120, command=self._test_openai_key) 
        self.openai_test_button.grid(row=1, column=2, padx=(0, 10), pady=(2,5), sticky="e") # ·ªû c·ªôt 2 c√πng h√†ng

        # --- H√†ng 2: Ch·ªâ c√≥ Nh√£n tr·∫°ng th√°i ---
        self.openai_status_label = ctk.CTkLabel(openai_frame, text="", font=("Segoe UI", 10), text_color="gray", justify=ctk.LEFT)
        # ƒê·∫∑t status v√†o c·ªôt 0, h√†ng 2, cƒÉn tr√°i
        self.openai_status_label.grid(row=2, column=0, columnspan=3, padx=(10, 5), pady=(0, 10), sticky="w") 

 
        # --- Khung N√∫t L∆∞u / H·ªßy --- 
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(side="bottom", fill="x", pady=(15, 0)) 

        cancel_button = ctk.CTkButton(button_frame, text="H·ªßy", width=100, command=self.destroy)
        cancel_button.pack(side="right", padx=(10, 0))

        save_button = ctk.CTkButton(button_frame, text="L∆∞u C√†i ƒê·∫∑t", width=120, command=self._save_settings, fg_color="#1f6aa5")
        save_button.pack(side="right")


# X·ª≠ l√Ω s·ª± ki·ªán nh·∫•n n√∫t "Ki·ªÉm tra" cho OpenAI API Key.
    def _test_openai_key(self):
        """ B·∫Øt ƒë·∫ßu ki·ªÉm tra OpenAI API Key trong m·ªôt lu·ªìng ri√™ng. """
        current_key = self.openai_key_var.get().strip()
        if not current_key:
            self.openai_status_label.configure(text="Vui l√≤ng nh·∫≠p API Key.", text_color="orange")
            return

        # V√¥ hi·ªáu h√≥a n√∫t ki·ªÉm tra v√† hi·ªÉn th·ªã tr·∫°ng th√°i "ƒêang ki·ªÉm tra..."
        self.openai_test_button.configure(state=ctk.DISABLED, text="...")
        self.openai_status_label.configure(text="ƒêang ki·ªÉm tra OpenAI Key...", text_color="gray")
        self.update_idletasks() # C·∫≠p nh·∫≠t giao di·ªán ngay

        # Ch·∫°y ki·ªÉm tra trong thread
        thread = threading.Thread(target=self._perform_openai_key_check, args=(current_key,), daemon=True, name="OpenAIKeyCheckThread")
        thread.start()


# Th·ª±c hi·ªán ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa OpenAI API Key (ch·∫°y trong lu·ªìng).
    def _perform_openai_key_check(self, api_key_to_test):
        """ 
        Th·ª±c hi·ªán ki·ªÉm tra OpenAI API Key (ch·∫°y trong thread) - B·∫¢N N√ÇNG C·∫§P
        B·∫±ng c√°ch th·ª≠ m·ªôt y√™u c·∫ßu chat completion nh·ªè.
        """
        logging.info(f"[API Check] B·∫Øt ƒë·∫ßu ki·ªÉm tra OpenAI Key (b·∫£n n√¢ng c·∫•p): ...{api_key_to_test[-4:]}")
        status_message = "L·ªói kh√¥ng x√°c ƒë·ªãnh."
        status_color = "red"
        
        try:
            from openai import OpenAI, RateLimitError, AuthenticationError, APIConnectionError, APIStatusError, APITimeoutError
            HAS_OPENAI_LIBS_FOR_CHECK = True
        except ImportError:
            logging.error("[API Check] Thi·∫øu th∆∞ vi·ªán OpenAI ƒë·ªÉ ki·ªÉm tra key.")
            status_message = "L·ªói: Thi·∫øu th∆∞ vi·ªán OpenAI."
            status_color = "red"
            HAS_OPENAI_LIBS_FOR_CHECK = False

        if HAS_OPENAI_LIBS_FOR_CHECK:
            try:
                test_client = OpenAI(api_key=api_key_to_test, timeout=15.0) 
                
                # --- THAY ƒê·ªîI CH√çNH N·∫∞M ·ªû ƒê√ÇY ---
                # Thay v√¨ g·ªçi client.models.list(), ta th·ª≠ m·ªôt y√™u c·∫ßu chat nh·ªè
                # ƒë·ªÉ ƒë·∫£m b·∫£o key kh√¥ng ch·ªâ h·ª£p l·ªá m√† c√≤n c√≥ quy·ªÅn s·ª≠ d·ª•ng model.
                logging.debug("[API Check] ƒêang g·ªçi client.chat.completions.create() ƒë·ªÉ ki·ªÉm tra...")
                test_client.chat.completions.create(
                    model="gpt-3.5-turbo",  # D√πng model r·∫ª v√† nhanh ƒë·ªÉ test
                    messages=[{"role": "user", "content": "test"}],
                    max_tokens=1,          # Gi·ªõi h·∫°n output t·ªëi ƒëa ƒë·ªÉ ti·∫øt ki·ªám
                    temperature=0          # Kh√¥ng c·∫ßn s√°ng t·∫°o
                )
                # --- K·∫æT TH√öC THAY ƒê·ªîI ---

                logging.info(f"[API Check] Ki·ªÉm tra OpenAI Key th√†nh c√¥ng (ƒë√£ th·ª≠ Chat Completion).")
                status_message = "Key h·ª£p l·ªá! (K·∫øt n·ªëi th√†nh c√¥ng)"
                status_color = ("#0B8457", "lightgreen") # Xanh ƒë·∫≠m cho n·ªÅn s√°ng, xanh t∆∞∆°i cho n·ªÅn t·ªëi

            except AuthenticationError as e:
                logging.warning(f"[API Check] L·ªói x√°c th·ª±c OpenAI: {e}")
                status_message = "L·ªói: Key kh√¥ng ƒë√∫ng ho·∫∑c h·∫øt h·∫°n."
                status_color = "orange"
            except RateLimitError as e:
                logging.warning(f"[API Check] L·ªói gi·ªõi h·∫°n y√™u c·∫ßu OpenAI: {e}")
                status_message = "L·ªói: V∆∞·ª£t qu√° gi·ªõi h·∫°n request."
                status_color = "orange"
            except (APIConnectionError, APITimeoutError) as e:
                logging.error(f"[API Check] L·ªói k·∫øt n·ªëi/timeout OpenAI: {e}")
                status_message = "L·ªói: Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c OpenAI."
                status_color = "red"
            except APIStatusError as e: 
                logging.error(f"[API Check] L·ªói tr·∫°ng th√°i API OpenAI: {e.status_code} - {e.response}")
                # Ki·ªÉm tra l·ªói c·ª• th·ªÉ do kh√¥ng c√≥ quy·ªÅn truy c·∫≠p model
                if "does not exist or you do not have access to it" in str(e).lower():
                    status_message = f"L·ªói: Key ƒë√∫ng, nh∆∞ng kh√¥ng c√≥ quy·ªÅn truy c·∫≠p model."
                    status_color = "orange"
                else:
                    status_message = f"L·ªói API OpenAI: {e.status_code}"
                    status_color = "red"
            except Exception as e: 
                logging.error(f"[API Check] L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra OpenAI Key: {e}", exc_info=True)
                status_message = "L·ªói kh√¥ng x√°c ƒë·ªãnh."
                status_color = "red"

        def _update_ui():
            try:
                if self and self.winfo_exists(): 
                    self.openai_status_label.configure(text=status_message, text_color=status_color)
                    self.openai_test_button.configure(state=ctk.NORMAL, text="Ki·ªÉm tra") 
            except Exception as e_ui:
                logging.error(f"L·ªói c·∫≠p nh·∫≠t UI sau khi ki·ªÉm tra OpenAI Key: {e_ui}")

        if hasattr(self, 'master_app') and self.master_app and hasattr(self.master_app, 'after'):
             self.master_app.after(0, _update_ui)
        elif hasattr(self, 'after'):
             self.after(0, _update_ui)


# H√ÄM M·ªöI: B·∫Øt ƒë·∫ßu ki·ªÉm tra Gemini Key trong lu·ªìng n·ªÅn
    def _test_gemini_key(self):
        """ B·∫Øt ƒë·∫ßu ki·ªÉm tra Gemini API Key trong m·ªôt lu·ªìng ri√™ng. """
        current_key = self.gemini_key_var.get().strip()
        if not current_key:
            self.gemini_status_label.configure(text="Vui l√≤ng nh·∫≠p API Key.", text_color="orange")
            return

        self.gemini_test_button.configure(state=ctk.DISABLED, text="...")
        self.gemini_status_label.configure(text="ƒêang ki·ªÉm tra Gemini Key...", text_color="gray")
        self.update_idletasks()

        thread = threading.Thread(target=self._perform_gemini_key_check, args=(current_key,), daemon=True, name="GeminiKeyCheckThread")
        thread.start()

# H√ÄM M·ªöI: Th·ª±c hi·ªán ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa Gemini API Key (ch·∫°y trong lu·ªìng)
    def _perform_gemini_key_check(self, api_key_to_test):
        """ 
        Th·ª±c hi·ªán ki·ªÉm tra Gemini API Key (ch·∫°y trong thread).
        PHI√äN B·∫¢N N√ÇNG C·∫§P: Th·ª≠ m·ªôt l·ªánh generate_content nh·ªè ƒë·ªÉ ki·ªÉm tra s√¢u h∆°n.
        """
        logging.info(f"[API Check] B·∫Øt ƒë·∫ßu ki·ªÉm tra Gemini Key (b·∫£n n√¢ng c·∫•p): ...{api_key_to_test[-4:]}")
        status_message = "L·ªói kh√¥ng x√°c ƒë·ªãnh."
        status_color = "red"

        try:
            import google.generativeai as genai
            from google.api_core import exceptions as google_api_exceptions

            genai.configure(api_key=api_key_to_test)

            logging.debug("[API Check] ƒêang th·ª≠ ki·ªÉm tra API key b·∫±ng list_models()...")
            
            # Th·ª≠ list_models() ƒë·ªÉ ki·ªÉm tra API key (c√°ch n√†y ·ªïn ƒë·ªãnh h∆°n v√† kh√¥ng c·∫ßn model name c·ª• th·ªÉ)
            models = genai.list_models()
            
            # Ki·ªÉm tra xem c√≥ model n√†o kh·∫£ d·ª•ng kh√¥ng
            model_names = [m.name for m in models]
            logging.debug(f"[API Check] S·ªë l∆∞·ª£ng models c√≥ s·∫µn: {len(model_names)}")
            
            # N·∫øu list_models() th√†nh c√¥ng v√† c√≥ models, API key ƒë√£ h·ª£p l·ªá
            if not model_names:
                raise Exception("Kh√¥ng t√¨m th·∫•y model n√†o kh·∫£ d·ª•ng.")
            
            # Th·ª≠ test generate_content v·ªõi m·ªôt model n·∫øu c√≥ th·ªÉ (kh√¥ng b·∫Øt bu·ªôc)
            tested_generate = False
            for preferred_model in ['gemini-1.5-pro', 'gemini-1.5-flash', 'gemini-pro', 'gemini-1.5-pro-latest']:
                try:
                    # T√¨m model name ƒë·∫ßy ƒë·ªß t·ª´ danh s√°ch
                    full_model_name = None
                    for m_name in model_names:
                        if preferred_model in m_name.lower():
                            full_model_name = m_name
                            break
                    
                    if full_model_name:
                        # L·∫•y short name t·ª´ full name (v√≠ d·ª•: models/gemini-1.5-pro -> gemini-1.5-pro)
                        short_name = full_model_name.split('/')[-1] if '/' in full_model_name else full_model_name
                        logging.debug(f"[API Check] ƒêang th·ª≠ test generate_content v·ªõi model: {short_name}")
                        model = genai.GenerativeModel(short_name)
                        model.generate_content(
                            "test", 
                            generation_config=genai.types.GenerationConfig(max_output_tokens=1, temperature=0.0)
                        )
                        tested_generate = True
                        logging.debug(f"[API Check] Test generate_content th√†nh c√¥ng v·ªõi {short_name}")
                        break
                except Exception as test_e:
                    # B·ªè qua l·ªói khi test model n√†y, th·ª≠ model ti·∫øp theo
                    logging.debug(f"[API Check] Kh√¥ng th·ªÉ test v·ªõi {preferred_model}: {test_e}")
                    continue
            
            if not tested_generate:
                logging.debug("[API Check] Kh√¥ng test ƒë∆∞·ª£c generate_content, nh∆∞ng list_models() th√†nh c√¥ng n√™n API key v·∫´n h·ª£p l·ªá.")

            # N·∫øu list_models() th√†nh c√¥ng (ƒë√£ ƒë·∫øn ƒë√¢y), key v√† m√¥i tr∆∞·ªùng ƒë·ªÅu ·ªïn.
            status_message = "‚úÖ Key h·ª£p l·ªá! (K·∫øt n·ªëi th√†nh c√¥ng)"
            status_color = ("#0B8457", "lightgreen") # Xanh ƒë·∫≠m cho n·ªÅn s√°ng, xanh t∆∞∆°i cho n·ªÅn t·ªëi
            logging.info(f"[API Check] Ki·ªÉm tra Gemini Key th√†nh c√¥ng. T√¨m th·∫•y {len(model_names)} model(s) kh·∫£ d·ª•ng.")

        except google_api_exceptions.PermissionDenied as e:
            logging.warning(f"[API Check] L·ªói x√°c th·ª±c Gemini: {e}")
            status_message = "L·ªói: Key kh√¥ng ƒë√∫ng ho·∫∑c kh√¥ng c√≥ quy·ªÅn."
            status_color = "orange"
        except google_api_exceptions.GoogleAPICallError as e:
            # L·ªói n√†y c√≥ th·ªÉ do m·∫°ng ho·∫∑c c√°c v·∫•n ƒë·ªÅ k·∫øt n·ªëi kh√°c
            error_str = str(e)
            if "404" in error_str or "not found" in error_str.lower():
                logging.warning(f"[API Check] L·ªói model kh√¥ng t√¨m th·∫•y: {e}")
                status_message = "L·ªói: Model kh√¥ng kh·∫£ d·ª•ng, nh∆∞ng API key c√≥ th·ªÉ h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i."
            else:
                logging.error(f"[API Check] L·ªói g·ªçi API Google (c√≥ th·ªÉ do m·∫°ng): {e}")
                status_message = "L·ªói: Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c t·ªõi Google."
            status_color = "red"
        except Exception as e:
            # B·∫Øt t·∫•t c·∫£ c√°c l·ªói kh√°c, bao g·ªìm c·∫£ "Illegal header value" n·∫øu n√≥ x·∫£y ra ·ªü ƒë√¢y
            logging.error(f"[API Check] L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra Gemini Key: {e}", exc_info=True)
            # Ki·ªÉm tra xem c√≥ ph·∫£i l·ªói header kh√¥ng ƒë·ªÉ ƒë∆∞a ra th√¥ng b√°o c·ª• th·ªÉ
            if "illegal header value" in str(e).lower():
                status_message = "L·ªói: Key c√≥ v·∫ª ƒë√∫ng nh∆∞ng m√¥i tr∆∞·ªùng kh√¥ng h·ª£p l·ªá (l·ªói header)."
            else:
                status_message = f"L·ªói kh√¥ng x√°c ƒë·ªãnh: {type(e).__name__}"
            status_color = "red"

        def _update_ui():
            if self and self.winfo_exists():
                self.gemini_status_label.configure(text=status_message, text_color=status_color)
                self.gemini_test_button.configure(state=ctk.NORMAL, text="Ki·ªÉm tra")

        if hasattr(self.master_app, 'after'):
             self.master_app.after(0, _update_ui)



# X·ª≠ l√Ω s·ª± ki·ªán nh·∫•n n√∫t "Ki·ªÉm tra File Key" cho Google Cloud.
    def _test_google_key(self):
        """ B·∫Øt ƒë·∫ßu ki·ªÉm tra file Google Cloud Key trong m·ªôt lu·ªìng ri√™ng. """
        current_path = self.google_key_path_var.get().strip()
        if not current_path:
            self.google_status_label.configure(text="Vui l√≤ng ch·ªçn file key JSON.", text_color="orange")
            return
        if not os.path.exists(current_path):
            self.google_status_label.configure(text="L·ªói: File key kh√¥ng t·ªìn t·∫°i.", text_color="red")
            return
        if not current_path.lower().endswith(".json"):
             self.google_status_label.configure(text="L·ªói: File ph·∫£i l√† ƒë·ªãnh d·∫°ng .json.", text_color="red")
             return

        # V√¥ hi·ªáu h√≥a n√∫t ki·ªÉm tra v√† hi·ªÉn th·ªã tr·∫°ng th√°i "ƒêang ki·ªÉm tra..."
        self.google_test_button.configure(state=ctk.DISABLED, text="...")
        self.google_status_label.configure(text="ƒêang ki·ªÉm tra Google Key File...", text_color="gray")
        self.update_idletasks() # C·∫≠p nh·∫≠t giao di·ªán ngay

        # Ch·∫°y ki·ªÉm tra trong thread
        thread = threading.Thread(target=self._perform_google_key_check, args=(current_path,), daemon=True, name="GoogleKeyCheckThread")
        thread.start()


# Th·ª±c hi·ªán ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa file JSON Key Google Cloud (ch·∫°y trong lu·ªìng).
    def _perform_google_key_check(self, key_file_path):
        """ Th·ª±c hi·ªán ki·ªÉm tra file Google Cloud Key (ch·∫°y trong thread). """
        logging.info(f"[API Check] B·∫Øt ƒë·∫ßu ki·ªÉm tra Google Key File: {key_file_path}")
        status_message = "L·ªói kh√¥ng x√°c ƒë·ªãnh."
        status_color = "red"
        
        if not HAS_GOOGLE_CLOUD_TRANSLATE or service_account is None or google_translate is None:
            logging.error("[API Check] Thi·∫øu th∆∞ vi·ªán Google Cloud ho·∫∑c Translate ƒë·ªÉ ki·ªÉm tra key.")
            status_message = "L·ªói: Thi·∫øu th∆∞ vi·ªán Google Cloud."
            status_color = "red"
        else:
            try:
                logging.debug(f"[API Check] ƒêang t·∫£i credentials t·ª´: {key_file_path}")
                credentials = service_account.Credentials.from_service_account_file(key_file_path)
                logging.debug(f"[API Check] T·∫£i credentials th√†nh c√¥ng. Project ID: {credentials.project_id}")

                logging.debug(f"[API Check] ƒêang kh·ªüi t·∫°o Google Translate Client...")
                test_client = google_translate.Client(credentials=credentials)
                
                try:
                    logging.debug(f"[API Check] ƒêang th·ª≠ d·ªãch 'test' sang 'en'...")
                    test_client.translate("test", target_language="en") 
                    logging.info(f"[API Check] Ki·ªÉm tra Google Key File th√†nh c√¥ng (ƒë√£ th·ª≠ d·ªãch).")
                    status_message = "File key h·ª£p l·ªá! (ƒê√£ th·ª≠ d·ªãch)"
                    # S·ª¨A ·ªû ƒê√ÇY: D√πng c·∫∑p m√†u thay v√¨ "lightgreen"
                    status_color = ("#0B8457", "lightgreen") # Xanh ƒë·∫≠m cho n·ªÅn s√°ng, xanh t∆∞∆°i cho n·ªÅn t·ªëi
                except HttpError as http_err: 
                     error_content = getattr(http_err, 'content', b'').decode('utf-8', 'replace')
                     logging.warning(f"[API Check] L·ªói HttpError khi th·ª≠ d·ªãch: {http_err.resp.status} - {error_content}")
                     status_message = f"L·ªói API Google ({http_err.resp.status}). C√≥ th·ªÉ API ch∆∞a b·∫≠t?"
                     status_color = "orange"
                     try:
                         error_json = json.loads(error_content)
                         error_detail = error_json.get('error', {}).get('message', '')
                         if error_detail: status_message += f"\nChi ti·∫øt: {error_detail[:100]}..."
                     except: pass
                except Exception as trans_err:
                    logging.warning(f"[API Check] L·ªói khi th·ª≠ d·ªãch v·ªõi Google Key: {trans_err}", exc_info=True)
                    status_message = "File key ƒë√∫ng, nh∆∞ng l·ªói khi th·ª≠ d·ªãch."
                    status_color = "orange"

            except FileNotFoundError:
                logging.error(f"[API Check] L·ªói kh√¥ng t√¨m th·∫•y file key: {key_file_path}")
                status_message = "L·ªói: File key kh√¥ng t·ªìn t·∫°i."
                status_color = "red"
            except ValueError as ve: 
                logging.error(f"[API Check] L·ªói ƒë·ªãnh d·∫°ng file Google Key JSON: {ve}")
                status_message = "L·ªói: ƒê·ªãnh d·∫°ng file key kh√¥ng h·ª£p l·ªá."
                status_color = "red"
            except Exception as e:
                logging.error(f"[API Check] L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra Google Key: {e}", exc_info=True)
                status_message = "L·ªói kh√¥ng x√°c ƒë·ªãnh khi ki·ªÉm tra."
                status_color = "red"

        def _update_ui_google():
            try:
                if self and self.winfo_exists(): 
                    self.google_status_label.configure(text=status_message, text_color=status_color)
                    self.google_test_button.configure(state=ctk.NORMAL, text="Ki·ªÉm tra File Key") 
            except Exception as e_ui:
                logging.error(f"L·ªói c·∫≠p nh·∫≠t UI sau khi ki·ªÉm tra Google Key: {e_ui}")

        if hasattr(self, 'master_app') and self.master_app and hasattr(self.master_app, 'after'):
             self.master_app.after(0, _update_ui_google)
        elif hasattr(self, 'after'): 
             self.after(0, _update_ui_google)


# H√†m h√†nh ƒë·ªông (API Settings): Ch·ªçn file JSON key c·ªßa Google Cloud
    def _select_google_key_file(self):
        """ M·ªü dialog ch·ªçn file JSON key c·ªßa Google """
        initial_dir = os.path.dirname(self.google_key_path_var.get()) if self.google_key_path_var.get() else "/"
        filepath = filedialog.askopenfilename(
            title="Ch·ªçn file JSON Key c·ªßa Google Service Account",
            initialdir=initial_dir,
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            parent=self # ƒê·∫£m b·∫£o dialog m·ªü tr√™n c·ª≠a s·ªï n√†y
        )
        if filepath and os.path.exists(filepath) and filepath.lower().endswith(".json"):
            self.google_key_path_var.set(filepath)
            logging.info(f"ƒê√£ ch·ªçn file Google Key: {filepath}")
        elif filepath:
            messagebox.showerror("File kh√¥ng h·ª£p l·ªá", "Vui l√≤ng ch·ªçn m·ªôt file .json h·ª£p l·ªá.", parent=self)


     # Callback c·∫≠p nh·∫≠t label hi·ªÉn th·ªã ƒë∆∞·ªùng d·∫´n file Google Key khi bi·∫øn thay ƒë·ªïi.
    def _update_google_label(self, *args):
        """ C·∫≠p nh·∫≠t label hi·ªÉn th·ªã ƒë∆∞·ªùng d·∫´n file Google Key """
        path = self.google_key_path_var.get()
        if self.google_path_label and self.google_path_label.winfo_exists():
             self.google_path_label.configure(text=path if path else "(Ch∆∞a ch·ªçn file)")


# L∆∞u c√°c c√†i ƒë·∫∑t API (b·∫±ng c√°ch g·ªçi h√†m l∆∞u c·ªßa app ch√≠nh) v√† ƒë√≥ng c·ª≠a s·ªï.
    def _save_settings(self):
        """L∆∞u c·∫•u h√¨nh API + l√†m t∆∞∆°i UI ngay, KH√îNG ghi ƒë√® gi√° tr·ªã ng∆∞·ªùi d√πng v·ª´a nh·∫≠p."""
        logging.info("L∆∞u c√†i ƒë·∫∑t API Keys...")
        try:
            if not (self.master_app and callable(getattr(self.master_app, 'save_current_config', None))):
                logging.error("Kh√¥ng th·ªÉ g·ªçi save_current_config t·ª´ c·ª≠a s·ªï c√†i ƒë·∫∑t.")
                return

            # 1) ƒê·∫®Y GI√Å TR·ªä T·ª™ POPUP -> MAIN APP (n·∫øu popup gi·ªØ StringVar ri√™ng)
            try:
                if hasattr(self, 'openai_key_var') and hasattr(self.master_app, 'openai_key_var'):
                    self.master_app.openai_key_var.set(self.openai_key_var.get().strip())
                if hasattr(self, 'gemini_key_var') and hasattr(self.master_app, 'gemini_key_var'):
                    self.master_app.gemini_key_var.set(self.gemini_key_var.get().strip())
                if hasattr(self, 'google_key_path_var') and hasattr(self.master_app, 'google_key_path_var'):
                    self.master_app.google_key_path_var.set(self.google_key_path_var.get().strip())
            except Exception as e_sync:
                logging.debug(f"Sync popup->main StringVar l·ªói (b·ªè qua): {e_sync}")

            # 2) L∆ØU CONFIG
            self.master_app.save_current_config()
            logging.info("ƒê√£ g·ªçi save_current_config t·ª´ c·ª≠a s·ªï ch√≠nh.")

            # 3) TH√îNG B√ÅO + (tu·ª≥ ch·ªçn) re-check license
            if hasattr(self.master_app, 'update_status'):
                self.master_app.after(10, lambda: self.master_app.update_status("‚úÖ C√°c c√†i ƒë·∫∑t API ƒë√£ ƒë∆∞·ª£c l∆∞u."))
            if hasattr(self.master_app, 'check_activation_status'):
                logging.info("APISettings: Y√™u c·∫ßu ki·ªÉm tra l·∫°i b·∫£n quy·ªÅn sau khi l∆∞u API keys.")
                self.master_app.after(3000, self.master_app.check_activation_status)

            # 4) REFRESH UI C√ÅC TAB NGAY (kh·ªèi c·∫ßn ƒë·ªïi tab)
            for fn_name in ("_set_dubbing_tab_ui_state",
                            "_update_dub_script_controls_state",
                            "_set_subtitle_tab_ui_state"):   # üëà th√™m d√≤ng n√†y cho tab Sub
                try:
                    fn = getattr(self.master_app, fn_name, None)
                    if callable(fn):
                        self.master_app.after(0, fn)
                except Exception as e_ref:
                    logging.debug(f"Refresh '{fn_name}' after save failed: {e_ref}")

        except Exception as e:
            logging.error(f"L·ªói khi g·ªçi save_current_config: {e}")
            return
# =====================================================================================================================================
# L·ªöP C·ª¨A S·ªî C√ÄI ƒê·∫∂T T·∫†O ·∫¢NH IMAGEN (M·ªöI)
# =====================================================================================================================================
# ImagenSettingsWindow class removed - moved to ui/popups/imagen_settings.py

# =======================================================================================================================================================================

# DalleSettingsWindow class removed - moved to ui/popups/dalle_settings.py

# MetadataManagerWindow class removed - moved to ui/popups/metadata_manager.py



# ==========================
# SECTION 5: Kh·ªëi Th·ª±c thi Ch√≠nh
# ==========================

if __name__ == "__main__":

    # K√≠ch ho·∫°t DPI Per-Monitor v2 (∆∞u ti√™n), fallback n·∫øu m√°y kh√¥ng h·ªó tr·ª£
    try:
        if sys.platform == "win32":
            ctypes.windll.user32.SetProcessDpiAwarenessContext(ctypes.c_void_p(-4)) # Per-Monitor v2
            logging.info("DPI awareness ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh: Per-Monitor Awareness v2.")
    except AttributeError:
        # Fallback cho c√°c phi√™n b·∫£n Windows c≈© h∆°n
        try:
            ctypes.windll.shcore.SetProcessDpiAwareness(2) # PER_MONITOR_DPI_AWARE
            logging.info("DPI awareness ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh: Per-Monitor Awareness (Fallback).")
        except Exception as e:
            logging.warning(f"Kh√¥ng th·ªÉ k√≠ch ho·∫°t DPI Awareness: {e}")

    # S·ª≠ d·ª•ng h·∫±ng s·ªë APP_NAME ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü ph·∫ßn ƒë·∫ßu file Piu.py c·ªßa b·∫°n
    logging.info(f"--- B·∫Øt ƒë·∫ßu ·ª®ng d·ª•ng {APP_NAME} ---") # V√≠ d·ª•: APP_NAME l√† "Piu"

    # Ki·ªÉm tra c√°c th∆∞ vi·ªán thi·∫øt y·∫øu
    # ƒê·∫£m b·∫£o c√°c bi·∫øn nh∆∞ HAS_WHISPER, PYWIN32_AVAILABLE, PSUTIL_AVAILABLE (n·∫øu d√πng cho macOS)
    # ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü global scope (th∆∞·ªùng l√† sau kh·ªëi import)

    if sys.platform == "win32" and not PYWIN32_AVAILABLE:
        logging.warning("PYWIN32 kh√¥ng kh·∫£ d·ª•ng, ch·ª©c nƒÉng single-instance tr√™n Windows s·∫Ω b·ªã ·∫£nh h∆∞·ªüng.")
        # C√¢n nh·∫Øc hi·ªÉn th·ªã messagebox ·ªü ƒë√¢y n·∫øu b·∫°n coi ƒë√¢y l√† l·ªói nghi√™m tr·ªçng
        # V√≠ d·ª•:
        # try:
        #     import tkinter as tk_err_init
        #     from tkinter import messagebox as mb_err_init
        #     err_root = tk_err_init.Tk()
        #     err_root.withdraw()
        #     mb_err_init.showerror("L·ªói Th∆∞ Vi·ªán", "pywin32 c·∫ßn thi·∫øt cho Windows nh∆∞ng kh√¥ng t√¨m th·∫•y.\nCh·ª©c nƒÉng instance duy nh·∫•t c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông.")
        #     err_root.destroy()
        # except: pass


    if not HAS_WHISPER: # Gi·∫£ s·ª≠ HAS_WHISPER ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a to√†n c·ª•c
        # T·∫°o root t·∫°m th·ªùi ƒë·ªÉ messagebox c√≥ parent n·∫øu app ch√≠nh ch∆∞a kh·ªüi t·∫°o
        try:
            import tkinter as tk_temp_err
            from tkinter import messagebox as mb_temp_err
            temp_err_root = tk_temp_err.Tk()
            temp_err_root.withdraw()
            mb_temp_err.showerror("Thi·∫øu Th∆∞ vi·ªán Quan tr·ªçng", 
                                  "Th∆∞ vi·ªán 'whisper' c·∫ßn thi·∫øt nh∆∞ng kh√¥ng t√¨m th·∫•y.\n"
                                  "Vui l√≤ng c√†i ƒë·∫∑t: pip install -U openai-whisper\n\n"
                                  "·ª®ng d·ª•ng s·∫Ω tho√°t.", parent=temp_err_root)
            temp_err_root.destroy()
        except: # Fallback n·∫øu kh√¥ng th·ªÉ hi·ªán messagebox
            print("L·ªñI NGHI√äM TR·ªåNG: Thi·∫øu th∆∞ vi·ªán 'whisper'. Vui l√≤ng c√†i ƒë·∫∑t: pip install -U openai-whisper")
        sys.exit(1)

    app_instance = None
    try:
        app_instance = SubtitleApp()
        
        # L√™n l·ªãch _run_startup_tasks_sequentially ƒë·ªÉ ch·∫°y SAU KHI v√≤ng l·∫∑p ch√≠nh b·∫Øt ƒë·∫ßu.
        # ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o v√≤ng l·∫∑p s·ª± ki·ªán Tkinter ƒëang ho·∫°t ƒë·ªông khi c√°c lu·ªìng c·ªë g·∫Øng g·ªçi .after().
        app_instance.after(500, app_instance._run_startup_tasks_sequentially) 
        
        app_instance.mainloop() # D√≤ng n√†y PH·∫¢I ƒë∆∞·ª£c g·ªçi tr√™n lu·ªìng ch√≠nh v√† b·∫Øt ƒë·∫ßu v√≤ng l·∫∑p s·ª± ki·ªán GUI.

    except SingleInstanceException as sie:
            # B·∫Øt exception t√πy ch·ªânh m√† ch√∫ng ta ƒë√£ n√©m t·ª´ __init__
            # Ph∆∞∆°ng th·ª©c _activate_existing_window() ƒë√£ ƒë∆∞·ª£c g·ªçi b√™n trong __init__
            # ƒë·ªÉ c·ªë g·∫Øng ƒë∆∞a c·ª≠a s·ªï c·ªßa instance c≈© ra ph√≠a tr∆∞·ªõc.
            # Instance m·ªõi n√†y s·∫Ω tho√°t m√† kh√¥ng hi·ªÉn th·ªã th√™m popup n√†o.
            logging.warning(f"ƒê√£ b·∫Øt ƒë∆∞·ª£c SingleInstanceException: {sie}. Instance m·ªõi n√†y s·∫Ω tho√°t.")
            
            # Kh√¥ng hi·ªÉn th·ªã messagebox ·ªü ƒë√¢y n·ªØa theo y√™u c·∫ßu.
            # D√≤ng log ·ªü tr√™n ƒë√£ ƒë·ªß cho vi·ªác g·ª° l·ªói.
                
            sys.exit(0) # Tho√°t instance m·ªõi n√†y m·ªôt c√°ch b√¨nh th∆∞·ªùng

    except Exception as e_main_loop: # Gi·ªØ l·∫°i kh·ªëi b·∫Øt l·ªói chung c·ªßa b·∫°n
        logging.critical("L·ªói nghi√™m tr·ªçng kh√¥ng x·ª≠ l√Ω ƒë∆∞·ª£c trong v√≤ng l·∫∑p ·ª©ng d·ª•ng ch√≠nh!", exc_info=True)
        try:
            parent_win_for_error = None
            if app_instance and hasattr(app_instance, 'winfo_exists') and app_instance.winfo_exists():
                parent_win_for_error = app_instance
            else: # N·∫øu app_instance kh√¥ng h·ª£p l·ªá, t·∫°o root t·∫°m
                try:
                    import tkinter as tk_err_fallback
                    parent_win_for_error = tk_err_fallback.Tk()
                    parent_win_for_error.withdraw() # ·∫®n n√≥ ƒëi
                except Exception:
                    parent_win_for_error = None # Kh√¥ng th·ªÉ t·∫°o parent

            messagebox.showerror("L·ªói Nghi√™m tr·ªçng", 
                                 f"ƒê√£ x·∫£y ra l·ªói nghi√™m tr·ªçng kh√¥ng mong mu·ªën:\n{e_main_loop}\n\n·ª®ng d·ª•ng s·∫Ω ƒë√≥ng.", 
                                 parent=parent_win_for_error)
            
            if parent_win_for_error and not (app_instance and hasattr(app_instance, 'winfo_exists') and app_instance.winfo_exists()):
                # N·∫øu parent l√† root t·∫°m, h·ªßy n√≥ sau khi messagebox ƒë√≥ng
                try: parent_win_for_error.destroy()
                except: pass

        except Exception:
            pass # B·ªè qua n·∫øu kh√¥ng th·ªÉ hi·ªÉn th·ªã messagebox (v√≠ d·ª•: GUI ch∆∞a bao gi·ªù kh·ªüi t·∫°o)
    
    finally:

        if app_instance: # Ch·ªâ th·ª±c hi·ªán n·∫øu app_instance ƒë√£ ƒë∆∞·ª£c t·∫°o
            # Cho Windows: Gi·∫£i ph√≥ng Mutex
            if sys.platform == "win32" and PYWIN32_AVAILABLE and \
               hasattr(app_instance, 'mutex') and app_instance.mutex: # Ki·ªÉm tra k·ªπ c√°c thu·ªôc t√≠nh
                try:
                    # Ki·ªÉm tra xem c√≥ ph·∫£i self.mutex trong _perform_full_quit ƒë√£ gi·∫£i ph√≥ng ch∆∞a
                    # B·∫±ng c√°ch ki·ªÉm tra app_instance.mutex m·ªôt l·∫ßn n·ªØa.
                    # N·∫øu _perform_full_quit ƒë√£ ch·∫°y, app_instance.mutex s·∫Ω l√† None.
                    if app_instance.mutex: # Ch·ªâ gi·∫£i ph√≥ng n·∫øu n√≥ ch∆∞a ƒë∆∞·ª£c ƒë·∫∑t th√†nh None
                        logging.debug(f"Kh·ªëi finally (main): Chu·∫©n b·ªã gi·∫£i ph√≥ng Mutex handle: {app_instance.mutex}")
                        win32api.CloseHandle(app_instance.mutex)
                        app_instance.mutex = None 
                        logging.info("Mutex (Windows) ƒë√£ ƒë∆∞·ª£c gi·∫£i ph√≥ng trong kh·ªëi finally c·ªßa main (n·∫øu ch∆∞a ƒë∆∞·ª£c gi·∫£i ph√≥ng tr∆∞·ªõc ƒë√≥).")
                    else:
                        logging.debug("Kh·ªëi finally (main): Mutex (Windows) c√≥ v·∫ª ƒë√£ ƒë∆∞·ª£c gi·∫£i ph√≥ng ·ªü n∆°i kh√°c (v√≠ d·ª•: _perform_full_quit).")
                except Exception as e_final_mutex_release:
                    logging.error(f"L·ªói khi gi·∫£i ph√≥ng Mutex (Windows) trong kh·ªëi finally c·ªßa main: {e_final_mutex_release}")
            
            # (Ph·∫ßn cho macOS lock file c√≥ th·ªÉ ƒë·ªÉ tr·ªëng ho·∫∑c comment l·∫°i n·∫øu b·∫°n ch∆∞a l√†m)
            # elif sys.platform == "darwin" and hasattr(app_instance, 'lock_file_path') and \
            #      app_instance.lock_file_path and os.path.exists(app_instance.lock_file_path):
            #     try:
            #         # (Code x√≥a lock file cho macOS nh∆∞ ƒë√£ th·∫£o lu·∫≠n tr∆∞·ªõc)
            #     except Exception as e_final_lock_remove:
            #         logging.error(f"L·ªói khi x√≥a lock file (macOS) trong kh·ªëi finally: {e_final_lock_remove}")

        logging.info(f"--- ·ª®ng d·ª•ng {APP_NAME} ƒê√£ ƒë√≥ng (t·ª´ kh·ªëi main finally) ---")